/* automatically generated by rust-bindgen 0.69.4 */

// Generated at 2024-04-08 04:20:22.090053500 +02:00
use cty;
pub use windows::Win32::Foundation::NTSTATUS as NTSTATUS;
pub use nt_string::unicode_string::NtUnicodeString as _UNICODE_STRING;
pub use windows::Win32::Foundation::BOOLEAN as BOOLEAN;
pub use nt_string::unicode_string::NtUnicodeString as UNICODE_STRING;
pub use windows::Win32::Foundation::BOOL as BOOL;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
   storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
   #[inline]
   pub const fn new(storage: Storage) -> Self {
      Self { storage }
   }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
   Storage: AsRef<[u8]> + AsMut<[u8]>,
{
   #[inline]
   pub fn get_bit(&self, index: usize) -> bool {
      debug_assert!(index / 8 < self.storage.as_ref().len());
      let byte_index = index / 8;
      let byte = self.storage.as_ref()[byte_index];
      let bit_index = if cfg!(target_endian = "big") {
         7 - (index % 8)
      } else {
         index % 8
      };
      let mask = 1 << bit_index;
      byte & mask == mask
   }
   #[inline]
   pub fn set_bit(&mut self, index: usize, val: bool) {
      debug_assert!(index / 8 < self.storage.as_ref().len());
      let byte_index = index / 8;
      let byte = &mut self.storage.as_mut()[byte_index];
      let bit_index = if cfg!(target_endian = "big") {
         7 - (index % 8)
      } else {
         index % 8
      };
      let mask = 1 << bit_index;
      if val {
         *byte |= mask;
      } else {
         *byte &= !mask;
      }
   }
   #[inline]
   pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
      debug_assert!(bit_width <= 64);
      debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
      debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
      let mut val = 0;
      for i in 0..(bit_width as usize) {
         if self.get_bit(i + bit_offset) {
            let index = if cfg!(target_endian = "big") {
               bit_width as usize - 1 - i
            } else {
               i
            };
            val |= 1 << index;
         }
      }
      val
   }
   #[inline]
   pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
      debug_assert!(bit_width <= 64);
      debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
      debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
      for i in 0..(bit_width as usize) {
         let mask = 1 << i;
         let val_bit_is_set = val & mask == mask;
         let index = if cfg!(target_endian = "big") {
            bit_width as usize - 1 - i
         } else {
            i
         };
         self.set_bit(index + bit_offset, val_bit_is_set);
      }
   }
}
pub const NT_CUSTOMER_SHIFT: u32 = 29;
pub const NT_FACILITY_MASK: u32 = 4095;
pub const NT_FACILITY_SHIFT: u32 = 16;
pub const RTL_BALANCED_NODE_RESERVED_PARENT_MASK: u32 = 3;
pub const OBJ_PROTECT_CLOSE: u32 = 1;
pub const OBJ_INHERIT: u32 = 2;
pub const OBJ_AUDIT_OBJECT_CLOSE: u32 = 4;
pub const OBJ_NO_RIGHTS_UPGRADE: u32 = 8;
pub const OBJ_PERMANENT: u32 = 16;
pub const OBJ_EXCLUSIVE: u32 = 32;
pub const OBJ_CASE_INSENSITIVE: u32 = 64;
pub const OBJ_OPENIF: u32 = 128;
pub const OBJ_OPENLINK: u32 = 256;
pub const OBJ_KERNEL_HANDLE: u32 = 512;
pub const OBJ_FORCE_ACCESS_CHECK: u32 = 1024;
pub const OBJ_IGNORE_IMPERSONATED_DEVICEMAP: u32 = 2048;
pub const OBJ_DONT_REPARSE: u32 = 4096;
pub const OBJ_VALID_ATTRIBUTES: u32 = 8178;
pub const MAXIMUM_LEADBYTES: u32 = 12;
pub const LOW_PRIORITY: u32 = 0;
pub const LOW_REALTIME_PRIORITY: u32 = 16;
pub const HIGH_PRIORITY: u32 = 31;
pub const MAXIMUM_PRIORITY: u32 = 32;
pub const LDRP_PACKAGED_BINARY: u32 = 1;
pub const LDRP_MARKED_FOR_REMOVAL: u32 = 2;
pub const LDRP_IMAGE_DLL: u32 = 4;
pub const LDRP_LOAD_NOTIFICATIONS_SENT: u32 = 8;
pub const LDRP_TELEMETRY_ENTRY_PROCESSED: u32 = 16;
pub const LDRP_PROCESS_STATIC_IMPORT: u32 = 32;
pub const LDRP_IN_LEGACY_LISTS: u32 = 64;
pub const LDRP_IN_INDEXES: u32 = 128;
pub const LDRP_SHIM_DLL: u32 = 256;
pub const LDRP_IN_EXCEPTION_TABLE: u32 = 512;
pub const LDRP_LOAD_IN_PROGRESS: u32 = 4096;
pub const LDRP_LOAD_CONFIG_PROCESSED: u32 = 8192;
pub const LDRP_ENTRY_PROCESSED: u32 = 16384;
pub const LDRP_PROTECT_DELAY_LOAD: u32 = 32768;
pub const LDRP_DONT_CALL_FOR_THREADS: u32 = 262144;
pub const LDRP_PROCESS_ATTACH_CALLED: u32 = 524288;
pub const LDRP_PROCESS_ATTACH_FAILED: u32 = 1048576;
pub const LDRP_COR_DEFERRED_VALIDATE: u32 = 2097152;
pub const LDRP_COR_IMAGE: u32 = 4194304;
pub const LDRP_DONT_RELOCATE: u32 = 8388608;
pub const LDRP_COR_IL_ONLY: u32 = 16777216;
pub const LDRP_CHPE_IMAGE: u32 = 33554432;
pub const LDRP_CHPE_EMULATOR_IMAGE: u32 = 67108864;
pub const LDRP_REDIRECTED: u32 = 268435456;
pub const LDRP_COMPAT_DATABASE_PROCESSED: u32 = 2147483648;
pub const LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT: u32 = 1;
pub const LDR_GET_DLL_HANDLE_EX_PIN: u32 = 2;
pub const LDR_ADDREF_DLL_PIN: u32 = 1;
pub const LDR_GET_PROCEDURE_ADDRESS_DONT_RECORD_FORWARDER: u32 = 1;
pub const LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS: u32 = 1;
pub const LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY: u32 = 2;
pub const LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID: u32 = 0;
pub const LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED: u32 = 1;
pub const LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED: u32 = 2;
pub const LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS: u32 = 1;
pub const LDR_DLL_NOTIFICATION_REASON_LOADED: u32 = 1;
pub const LDR_DLL_NOTIFICATION_REASON_UNLOADED: u32 = 2;
pub const RESOURCE_TYPE_LEVEL: u32 = 0;
pub const RESOURCE_NAME_LEVEL: u32 = 1;
pub const RESOURCE_LANGUAGE_LEVEL: u32 = 2;
pub const RESOURCE_DATA_LEVEL: u32 = 3;
pub const ENCLAVE_STATE_CREATED: u32 = 0;
pub const ENCLAVE_STATE_INITIALIZED: u32 = 1;
pub const ENCLAVE_STATE_INITIALIZED_VBS: u32 = 2;
pub const EFI_VARIABLE_NON_VOLATILE: u32 = 1;
pub const EFI_VARIABLE_BOOTSERVICE_ACCESS: u32 = 2;
pub const EFI_VARIABLE_RUNTIME_ACCESS: u32 = 4;
pub const EFI_VARIABLE_HARDWARE_ERROR_RECORD: u32 = 8;
pub const EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS: u32 = 16;
pub const EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS: u32 = 32;
pub const EFI_VARIABLE_APPEND_WRITE: u32 = 64;
pub const EFI_VARIABLE_ENHANCED_AUTHENTICATED_ACCESS: u32 = 128;
pub const EVENT_QUERY_STATE: u32 = 1;
pub const EVENT_PAIR_ALL_ACCESS: u32 = 2031616;
pub const SEMAPHORE_QUERY_STATE: u32 = 1;
pub const PROFILE_CONTROL: u32 = 1;
pub const PROFILE_ALL_ACCESS: u32 = 983041;
pub const KEYEDEVENT_WAIT: u32 = 1;
pub const KEYEDEVENT_WAKE: u32 = 2;
pub const KEYEDEVENT_ALL_ACCESS: u32 = 983043;
pub const WORKER_FACTORY_RELEASE_WORKER: u32 = 1;
pub const WORKER_FACTORY_WAIT: u32 = 2;
pub const WORKER_FACTORY_SET_INFORMATION: u32 = 4;
pub const WORKER_FACTORY_QUERY_INFORMATION: u32 = 8;
pub const WORKER_FACTORY_READY_WORKER: u32 = 16;
pub const WORKER_FACTORY_SHUTDOWN: u32 = 32;
pub const WORKER_FACTORY_ALL_ACCESS: u32 = 983103;
pub const MM_WORKING_SET_MAX_HARD_ENABLE: u32 = 1;
pub const MM_WORKING_SET_MAX_HARD_DISABLE: u32 = 2;
pub const MM_WORKING_SET_MIN_HARD_ENABLE: u32 = 4;
pub const MM_WORKING_SET_MIN_HARD_DISABLE: u32 = 8;
pub const EVENT_TRACE_FLAG_EXT_ITEMS: u32 = 2164195328;
pub const EVENT_TRACE_FLAG_EXT_LEN_NEW_STRUCT: u32 = 255;
pub const ETW_MINIMUM_CACHED_STACK_LENGTH: u32 = 4;
pub const ETW_SW_ARRAY_SIZE: u32 = 256;
pub const ETW_STACK_SW_ARRAY_SIZE: u32 = 192;
pub const ETW_MAX_STACKWALK_FILTER: u32 = 256;
pub const ETW_MAX_TAG_FILTER: u32 = 4;
pub const ETW_MAX_POOLTAG_FILTER: u32 = 4;
pub const ETW_EXT_ENABLE_FLAGS: u32 = 1;
pub const ETW_EXT_PIDS: u32 = 2;
pub const ETW_EXT_STACKWALK_FILTER: u32 = 3;
pub const ETW_EXT_POOLTAG_FILTER: u32 = 4;
pub const ETW_EXT_STACK_CACHING: u32 = 5;
pub const TRACE_HEADER_EVENT_TRACE: u32 = 1073741824;
pub const TRACE_HEADER_ENUM_MASK: u32 = 16711680;
pub const PERF_MASK_INDEX: u32 = 3758096384;
pub const PERF_MASK_GROUP: i64 = -3758096385;
pub const PERF_NUM_MASKS: u32 = 8;
pub const PERF_PROCESS: u32 = 1;
pub const PERF_THREAD: u32 = 2;
pub const PERF_PROC_THREAD: u32 = 3;
pub const PERF_LOADER: u32 = 4;
pub const PERF_PERF_COUNTER: u32 = 8;
pub const PERF_FILENAME: u32 = 512;
pub const PERF_DISK_IO: u32 = 768;
pub const PERF_DISK_IO_INIT: u32 = 1024;
pub const PERF_ALL_FAULTS: u32 = 4096;
pub const PERF_HARD_FAULTS: u32 = 8192;
pub const PERF_VAMAP: u32 = 32768;
pub const PERF_NETWORK: u32 = 65536;
pub const PERF_REGISTRY: u32 = 131072;
pub const PERF_DBGPRINT: u32 = 262144;
pub const PERF_JOB: u32 = 524288;
pub const PERF_ALPC: u32 = 1048576;
pub const PERF_SPLIT_IO: u32 = 2097152;
pub const PERF_DEBUG_EVENTS: u32 = 4194304;
pub const PERF_FILE_IO: u32 = 33554432;
pub const PERF_FILE_IO_INIT: u32 = 67108864;
pub const PERF_NO_SYSCONFIG: u32 = 268435456;
pub const PERF_MEMORY: u32 = 536870913;
pub const PERF_PROFILE: u32 = 536870914;
pub const PERF_CONTEXT_SWITCH: u32 = 536870916;
pub const PERF_FOOTPRINT: u32 = 536870920;
pub const PERF_DRIVERS: u32 = 536870928;
pub const PERF_REFSET: u32 = 536870944;
pub const PERF_POOL: u32 = 536870976;
pub const PERF_POOLTRACE: u32 = 536870977;
pub const PERF_DPC: u32 = 536871040;
pub const PERF_COMPACT_CSWITCH: u32 = 536871168;
pub const PERF_DISPATCHER: u32 = 536871424;
pub const PERF_PMC_PROFILE: u32 = 536871936;
pub const PERF_PROFILING: u32 = 536871938;
pub const PERF_PROCESS_INSWAP: u32 = 536872960;
pub const PERF_AFFINITY: u32 = 536875008;
pub const PERF_PRIORITY: u32 = 536879104;
pub const PERF_INTERRUPT: u32 = 536887296;
pub const PERF_VIRTUAL_ALLOC: u32 = 536903680;
pub const PERF_SPINLOCK: u32 = 536936448;
pub const PERF_SYNC_OBJECTS: u32 = 537001984;
pub const PERF_DPC_QUEUE: u32 = 537133056;
pub const PERF_MEMINFO: u32 = 537395200;
pub const PERF_CONTMEM_GEN: u32 = 537919488;
pub const PERF_SPINLOCK_CNTRS: u32 = 538968064;
pub const PERF_SPININSTR: u32 = 539033600;
pub const PERF_SESSION: u32 = 541065216;
pub const PERF_PFSECTION: u32 = 541065216;
pub const PERF_MEMINFO_WS: u32 = 545259520;
pub const PERF_KERNEL_QUEUE: u32 = 553648128;
pub const PERF_INTERRUPT_STEER: u32 = 570425344;
pub const PERF_SHOULD_YIELD: u32 = 603979776;
pub const PERF_WS: u32 = 671088640;
pub const PERF_ANTI_STARVATION: u32 = 1073741825;
pub const PERF_PROCESS_FREEZE: u32 = 1073741826;
pub const PERF_PFN_LIST: u32 = 1073741828;
pub const PERF_WS_DETAIL: u32 = 1073741832;
pub const PERF_WS_ENTRY: u32 = 1073741840;
pub const PERF_HEAP: u32 = 1073741856;
pub const PERF_SYSCALL: u32 = 1073741888;
pub const PERF_UMS: u32 = 1073741952;
pub const PERF_BACKTRACE: u32 = 1073742080;
pub const PERF_VULCAN: u32 = 1073742336;
pub const PERF_OBJECTS: u32 = 1073742848;
pub const PERF_EVENTS: u32 = 1073743872;
pub const PERF_FULLTRACE: u32 = 1073745920;
pub const PERF_DFSS: u32 = 1073750016;
pub const PERF_PREFETCH: u32 = 1073758208;
pub const PERF_PROCESSOR_IDLE: u32 = 1073774592;
pub const PERF_CPU_CONFIG: u32 = 1073807360;
pub const PERF_TIMER: u32 = 1073872896;
pub const PERF_CLOCK_INTERRUPT: u32 = 1074003968;
pub const PERF_LOAD_BALANCER: u32 = 1074266112;
pub const PERF_CLOCK_TIMER: u32 = 1074790400;
pub const PERF_IDLE_SELECTION: u32 = 1075838976;
pub const PERF_IPI: u32 = 1077936128;
pub const PERF_IO_TIMER: u32 = 1082130432;
pub const PERF_REG_HIVE: u32 = 1090519040;
pub const PERF_REG_NOTIF: u32 = 1107296256;
pub const PERF_PPM_EXIT_LATENCY: u32 = 1140850688;
pub const PERF_WORKER_THREAD: u32 = 1207959552;
pub const PERF_OPTICAL_IO: u32 = 2147483649;
pub const PERF_OPTICAL_IO_INIT: u32 = 2147483650;
pub const PERF_DLL_INFO: u32 = 2147483656;
pub const PERF_DLL_FLUSH_WS: u32 = 2147483664;
pub const PERF_OB_HANDLE: u32 = 2147483712;
pub const PERF_OB_OBJECT: u32 = 2147483776;
pub const PERF_WAKE_DROP: u32 = 2147484160;
pub const PERF_WAKE_EVENT: u32 = 2147484672;
pub const PERF_DEBUGGER: u32 = 2147485696;
pub const PERF_PROC_ATTACH: u32 = 2147487744;
pub const PERF_WAKE_COUNTER: u32 = 2147491840;
pub const PERF_POWER: u32 = 2147516416;
pub const PERF_SOFT_TRIM: u32 = 2147549184;
pub const PERF_CC: u32 = 2147614720;
pub const PERF_FLT_IO_INIT: u32 = 2148007936;
pub const PERF_FLT_IO: u32 = 2148532224;
pub const PERF_FLT_FASTIO: u32 = 2149580800;
pub const PERF_FLT_IO_FAILURE: u32 = 2151677952;
pub const PERF_HV_PROFILE: u32 = 2155872256;
pub const PERF_WDF_DPC: u32 = 2164260864;
pub const PERF_WDF_INTERRUPT: u32 = 2181038080;
pub const PERF_CACHE_FLUSH: u32 = 2214592512;
pub const PERF_HIBER_RUNDOWN: u32 = 2684354561;
pub const PERF_SYSCFG_SYSTEM: u32 = 3221225473;
pub const PERF_SYSCFG_GRAPHICS: u32 = 3221225474;
pub const PERF_SYSCFG_STORAGE: u32 = 3221225476;
pub const PERF_SYSCFG_NETWORK: u32 = 3221225480;
pub const PERF_SYSCFG_SERVICES: u32 = 3221225488;
pub const PERF_SYSCFG_PNP: u32 = 3221225504;
pub const PERF_SYSCFG_OPTICAL: u32 = 3221225536;
pub const PERF_SYSCFG_ALL: u32 = 3758096383;
pub const PERF_CLUSTER_OFF: u32 = 3758096385;
pub const PERF_MEMORY_CONTROL: u32 = 3758096386;
pub const EVENT_TRACE_GROUP_HEADER: u32 = 0;
pub const EVENT_TRACE_GROUP_IO: u32 = 256;
pub const EVENT_TRACE_GROUP_MEMORY: u32 = 512;
pub const EVENT_TRACE_GROUP_PROCESS: u32 = 768;
pub const EVENT_TRACE_GROUP_FILE: u32 = 1024;
pub const EVENT_TRACE_GROUP_THREAD: u32 = 1280;
pub const EVENT_TRACE_GROUP_TCPIP: u32 = 1536;
pub const EVENT_TRACE_GROUP_JOB: u32 = 1792;
pub const EVENT_TRACE_GROUP_UDPIP: u32 = 2048;
pub const EVENT_TRACE_GROUP_REGISTRY: u32 = 2304;
pub const EVENT_TRACE_GROUP_DBGPRINT: u32 = 2560;
pub const EVENT_TRACE_GROUP_CONFIG: u32 = 2816;
pub const EVENT_TRACE_GROUP_SPARE1: u32 = 3072;
pub const EVENT_TRACE_GROUP_WNF: u32 = 3328;
pub const EVENT_TRACE_GROUP_POOL: u32 = 3584;
pub const EVENT_TRACE_GROUP_PERFINFO: u32 = 3840;
pub const EVENT_TRACE_GROUP_HEAP: u32 = 4096;
pub const EVENT_TRACE_GROUP_OBJECT: u32 = 4352;
pub const EVENT_TRACE_GROUP_POWER: u32 = 4608;
pub const EVENT_TRACE_GROUP_MODBOUND: u32 = 4864;
pub const EVENT_TRACE_GROUP_IMAGE: u32 = 5120;
pub const EVENT_TRACE_GROUP_DPC: u32 = 5376;
pub const EVENT_TRACE_GROUP_CC: u32 = 5632;
pub const EVENT_TRACE_GROUP_CRITSEC: u32 = 5888;
pub const EVENT_TRACE_GROUP_STACKWALK: u32 = 6144;
pub const EVENT_TRACE_GROUP_UMS: u32 = 6400;
pub const EVENT_TRACE_GROUP_ALPC: u32 = 6656;
pub const EVENT_TRACE_GROUP_SPLITIO: u32 = 6912;
pub const EVENT_TRACE_GROUP_THREAD_POOL: u32 = 7168;
pub const EVENT_TRACE_GROUP_HYPERVISOR: u32 = 7424;
pub const EVENT_TRACE_GROUP_HYPERVISORX: u32 = 7680;
pub const WMI_LOG_TYPE_HEADER: u32 = 0;
pub const WMI_LOG_TYPE_HEADER_EXTENSION: u32 = 5;
pub const WMI_LOG_TYPE_RUNDOWN_COMPLETE: u32 = 8;
pub const WMI_LOG_TYPE_GROUP_MASKS_END: u32 = 32;
pub const WMI_LOG_TYPE_RUNDOWN_BEGIN: u32 = 48;
pub const WMI_LOG_TYPE_RUNDOWN_END: u32 = 49;
pub const WMI_LOG_TYPE_DBGID_RSDS: u32 = 64;
pub const WMI_LOG_TYPE_DBGID_NB10: u32 = 65;
pub const WMI_LOG_TYPE_BUILD_LAB: u32 = 66;
pub const WMI_LOG_TYPE_BINARY_PATH: u32 = 67;
pub const WMI_LOG_TYPE_CONFIG_CPU: u32 = 2826;
pub const WMI_LOG_TYPE_CONFIG_PHYSICALDISK: u32 = 2827;
pub const WMI_LOG_TYPE_CONFIG_LOGICALDISK: u32 = 2828;
pub const WMI_LOG_TYPE_CONFIG_OPTICALMEDIA: u32 = 2834;
pub const WMI_LOG_TYPE_CONFIG_NIC: u32 = 2829;
pub const WMI_LOG_TYPE_CONFIG_VIDEO: u32 = 2830;
pub const WMI_LOG_TYPE_CONFIG_SERVICES: u32 = 2831;
pub const WMI_LOG_TYPE_CONFIG_POWER: u32 = 2832;
pub const WMI_LOG_TYPE_CONFIG_IRQ: u32 = 2837;
pub const WMI_LOG_TYPE_CONFIG_PNP: u32 = 2838;
pub const WMI_LOG_TYPE_CONFIG_IDECHANNEL: u32 = 2839;
pub const WMI_LOG_TYPE_CONFIG_NUMANODE: u32 = 2840;
pub const WMI_LOG_TYPE_CONFIG_PLATFORM: u32 = 2841;
pub const WMI_LOG_TYPE_CONFIG_PROCESSORGROUP: u32 = 2842;
pub const WMI_LOG_TYPE_CONFIG_PROCESSORNUMBER: u32 = 2843;
pub const WMI_LOG_TYPE_CONFIG_DPI: u32 = 2844;
pub const WMI_LOG_TYPE_CONFIG_CODEINTEGRITY: u32 = 2845;
pub const WMI_LOG_TYPE_CONFIG_MACHINEID: u32 = 2846;
pub const PERFINFO_LOG_TYPE_FILENAME: u32 = 1024;
pub const PERFINFO_LOG_TYPE_FILENAME_CREATE: u32 = 1056;
pub const PERFINFO_LOG_TYPE_FILENAME_SAME: u32 = 1057;
pub const PERFINFO_LOG_TYPE_FILENAME_NULL: u32 = 1058;
pub const PERFINFO_LOG_TYPE_FILENAME_DELETE: u32 = 1059;
pub const PERFINFO_LOG_TYPE_FILENAME_RUNDOWN: u32 = 1060;
pub const PERFINFO_LOG_TYPE_MAPFILE: u32 = 1061;
pub const PERFINFO_LOG_TYPE_UNMAPFILE: u32 = 1062;
pub const PERFINFO_LOG_TYPE_MAPFILE_DC_START: u32 = 1063;
pub const PERFINFO_LOG_TYPE_MAPFILE_DC_END: u32 = 1064;
pub const PERFINFO_LOG_TYPE_FILE_IO_CREATE: u32 = 1088;
pub const PERFINFO_LOG_TYPE_FILE_IO_CLEANUP: u32 = 1089;
pub const PERFINFO_LOG_TYPE_FILE_IO_CLOSE: u32 = 1090;
pub const PERFINFO_LOG_TYPE_FILE_IO_READ: u32 = 1091;
pub const PERFINFO_LOG_TYPE_FILE_IO_WRITE: u32 = 1092;
pub const PERFINFO_LOG_TYPE_FILE_IO_SET_INFORMATION: u32 = 1093;
pub const PERFINFO_LOG_TYPE_FILE_IO_DELETE: u32 = 1094;
pub const PERFINFO_LOG_TYPE_FILE_IO_RENAME: u32 = 1095;
pub const PERFINFO_LOG_TYPE_FILE_IO_DIRENUM: u32 = 1096;
pub const PERFINFO_LOG_TYPE_FILE_IO_FLUSH: u32 = 1097;
pub const PERFINFO_LOG_TYPE_FILE_IO_QUERY_INFORMATION: u32 = 1098;
pub const PERFINFO_LOG_TYPE_FILE_IO_FS_CONTROL: u32 = 1099;
pub const PERFINFO_LOG_TYPE_FILE_IO_OPERATION_END: u32 = 1100;
pub const PERFINFO_LOG_TYPE_FILE_IO_DIRNOTIFY: u32 = 1101;
pub const PERFINFO_LOG_TYPE_FILE_IO_CREATE_NEW: u32 = 1102;
pub const PERFINFO_LOG_TYPE_FILE_IO_DELETE_PATH: u32 = 1103;
pub const PERFINFO_LOG_TYPE_FILE_IO_RENAME_PATH: u32 = 1104;
pub const PERFINFO_LOG_TYPE_FILE_IO_SETLINK_PATH: u32 = 1105;
pub const PERFINFO_LOG_TYPE_FILE_IO_SETLINK: u32 = 1106;
pub const PERFINFO_LOG_TYPE_FLT_PREOP_INIT: u32 = 1120;
pub const PERFINFO_LOG_TYPE_FLT_POSTOP_INIT: u32 = 1121;
pub const PERFINFO_LOG_TYPE_FLT_PREOP_COMPLETION: u32 = 1122;
pub const PERFINFO_LOG_TYPE_FLT_POSTOP_COMPLETION: u32 = 1123;
pub const PERFINFO_LOG_TYPE_FLT_PREOP_FAILURE: u32 = 1124;
pub const PERFINFO_LOG_TYPE_FLT_POSTOP_FAILURE: u32 = 1125;
pub const WMI_LOG_TYPE_JOB_CREATE: u32 = 1824;
pub const WMI_LOG_TYPE_JOB_TERMINATE: u32 = 1825;
pub const WMI_LOG_TYPE_JOB_OPEN: u32 = 1826;
pub const WMI_LOG_TYPE_JOB_ASSIGN_PROCESS: u32 = 1827;
pub const WMI_LOG_TYPE_JOB_REMOVE_PROCESS: u32 = 1828;
pub const WMI_LOG_TYPE_JOB_SET: u32 = 1829;
pub const WMI_LOG_TYPE_JOB_QUERY: u32 = 1830;
pub const WMI_LOG_TYPE_JOB_SET_FAILED: u32 = 1831;
pub const WMI_LOG_TYPE_JOB_QUERY_FAILED: u32 = 1832;
pub const WMI_LOG_TYPE_JOB_SET_NOTIFICATION: u32 = 1833;
pub const WMI_LOG_TYPE_JOB_SEND_NOTIFICATION: u32 = 1834;
pub const WMI_LOG_TYPE_JOB_QUERY_VIOLATION: u32 = 1835;
pub const WMI_LOG_TYPE_JOB_SET_CPU_RATE: u32 = 1836;
pub const WMI_LOG_TYPE_JOB_SET_NET_RATE: u32 = 1837;
pub const WMI_LOG_TYPE_PROCESS_CREATE: u32 = 769;
pub const WMI_LOG_TYPE_PROCESS_DELETE: u32 = 770;
pub const WMI_LOG_TYPE_PROCESS_DC_START: u32 = 771;
pub const WMI_LOG_TYPE_PROCESS_DC_END: u32 = 772;
pub const WMI_LOG_TYPE_PROCESS_LOAD_IMAGE: u32 = 778;
pub const WMI_LOG_TYPE_PROCESS_TERMINATE: u32 = 779;
pub const PERFINFO_LOG_TYPE_PROCESS_PERFCTR_END: u32 = 800;
pub const PERFINFO_LOG_TYPE_PROCESS_PERFCTR_RD: u32 = 801;
pub const PERFINFO_LOG_TYPE_INSWAPPROCESS: u32 = 803;
pub const PERFINFO_LOG_TYPE_PROCESS_FREEZE: u32 = 804;
pub const PERFINFO_LOG_TYPE_PROCESS_THAW: u32 = 805;
pub const PERFINFO_LOG_TYPE_BOOT_PHASE_START: u32 = 806;
pub const PERFINFO_LOG_TYPE_ZOMBIE_PROCESS: u32 = 807;
pub const PERFINFO_LOG_TYPE_PROCESS_SET_AFFINITY: u32 = 808;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_USER: u32 = 816;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_EXECUTION: u32 = 817;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_KERNEL: u32 = 818;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_INSTRUMENTATION: u32 = 819;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_PRESERVE_PROCESS: u32 = 820;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_USER: u32 = 832;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_EXECUTION: u32 = 833;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_KERNEL: u32 = 834;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_INSTRUMENTATION: u32 = 835;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_PRESERVE_PROCESS: u32 = 836;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_USER: u32 = 848;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_EXECUTION: u32 = 849;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_KERNEL: u32 = 850;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_INSTRUMENTATION: u32 = 851;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_PRESERVE_PROCESS: u32 = 852;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_USER: u32 = 864;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_EXECUTION: u32 = 865;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_KERNEL: u32 = 866;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_INSTRUMENTATION: u32 = 867;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_PRESERVE_PROCESS: u32 = 868;
pub const PERFINFO_LOG_TYPE_DEBUG_EVENT: u32 = 880;
pub const WMI_LOG_TYPE_IMAGE_LOAD: u32 = 5121;
pub const WMI_LOG_TYPE_IMAGE_UNLOAD: u32 = 5122;
pub const WMI_LOG_TYPE_IMAGE_DC_START: u32 = 5123;
pub const WMI_LOG_TYPE_IMAGE_DC_END: u32 = 5124;
pub const WMI_LOG_TYPE_IMAGE_RELOCATION: u32 = 5152;
pub const WMI_LOG_TYPE_IMAGE_KERNEL_BASE: u32 = 5153;
pub const WMI_LOG_TYPE_IMAGE_HYPERCALL_PAGE: u32 = 5154;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_ATTEMPT: u32 = 5248;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_SUCCESS: u32 = 5249;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_FAIL: u32 = 5250;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_WAIT: u32 = 5251;
pub const PERFINFO_LOG_TYPE_LDR_PROC_INIT_DONE: u32 = 5252;
pub const PERFINFO_LOG_TYPE_LDR_CREATE_SECTION: u32 = 5253;
pub const PERFINFO_LOG_TYPE_LDR_SECTION_CREATED: u32 = 5254;
pub const PERFINFO_LOG_TYPE_LDR_MAP_VIEW: u32 = 5255;
pub const PERFINFO_LOG_TYPE_LDR_RELOCATE_IMAGE: u32 = 5264;
pub const PERFINFO_LOG_TYPE_LDR_IMAGE_RELOCATED: u32 = 5265;
pub const PERFINFO_LOG_TYPE_LDR_HANDLE_OLD_DESCRIPTORS: u32 = 5266;
pub const PERFINFO_LOG_TYPE_LDR_OLD_DESCRIPTORS_HANDLED: u32 = 5267;
pub const PERFINFO_LOG_TYPE_LDR_HANDLE_NEW_DESCRIPTORS: u32 = 5268;
pub const PERFINFO_LOG_TYPE_LDR_NEW_DESCRIPTORS_HANDLED: u32 = 5269;
pub const PERFINFO_LOG_TYPE_LDR_DLLMAIN_EXIT: u32 = 5270;
pub const PERFINFO_LOG_TYPE_LDR_FIND_DLL: u32 = 5280;
pub const PERFINFO_LOG_TYPE_LDR_VIEW_MAPPED: u32 = 5281;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_RELEASE: u32 = 5282;
pub const PERFINFO_LOG_TYPE_LDR_DLLMAIN_ENTER: u32 = 5283;
pub const PERFINFO_LOG_TYPE_LDR_ERROR: u32 = 5284;
pub const PERFINFO_LOG_TYPE_LDR_VIEW_MAPPING: u32 = 5285;
pub const PERFINFO_LOG_TYPE_LDR_SNAPPING: u32 = 5286;
pub const PERFINFO_LOG_TYPE_LDR_SNAPPED: u32 = 5287;
pub const PERFINFO_LOG_TYPE_LDR_LOADING: u32 = 5288;
pub const PERFINFO_LOG_TYPE_LDR_LOADED: u32 = 5289;
pub const PERFINFO_LOG_TYPE_LDR_FOUND_KNOWN_DLL: u32 = 5290;
pub const PERFINFO_LOG_TYPE_LDR_ABNORMAL: u32 = 5291;
pub const PERFINFO_LOG_TYPE_LDR_PLACEHOLDER: u32 = 5292;
pub const PERFINFO_LOG_TYPE_LDR_RDY_TO_INIT: u32 = 5293;
pub const PERFINFO_LOG_TYPE_LDR_RDY_TO_RUN: u32 = 5294;
pub const PERFINFO_LOG_TYPE_LDR_NEW_DLL_LOAD: u32 = 5296;
pub const PERFINFO_LOG_TYPE_LDR_NEW_DLL_AS_DATA: u32 = 5297;
pub const PERFINFO_LOG_TYPE_LDR_EXTERNAL_PATH: u32 = 5312;
pub const PERFINFO_LOG_TYPE_LDR_GENERATED_PATH: u32 = 5313;
pub const PERFINFO_LOG_TYPE_LDR_APISET_RESOLVING: u32 = 5328;
pub const PERFINFO_LOG_TYPE_LDR_APISET_HOSTED: u32 = 5329;
pub const PERFINFO_LOG_TYPE_LDR_APISET_UNHOSTED: u32 = 5330;
pub const PERFINFO_LOG_TYPE_LDR_APISET_UNRESOLVED: u32 = 5331;
pub const PERFINFO_LOG_TYPE_LDR_SEARCH_SECURITY: u32 = 5332;
pub const PERFINFO_LOG_TYPE_LDR_SEARCH_PATH_SECURITY: u32 = 5333;
pub const WMI_LOG_TYPE_THREAD_CREATE: u32 = 1281;
pub const WMI_LOG_TYPE_THREAD_DELETE: u32 = 1282;
pub const WMI_LOG_TYPE_THREAD_DC_START: u32 = 1283;
pub const WMI_LOG_TYPE_THREAD_DC_END: u32 = 1284;
pub const PERFINFO_LOG_TYPE_CONTEXTSWAP: u32 = 1316;
pub const PERFINFO_LOG_TYPE_CONTEXTSWAP_BATCH: u32 = 1317;
pub const PERFINFO_LOG_TYPE_SPINLOCK: u32 = 1321;
pub const PERFINFO_LOG_TYPE_QUEUE: u32 = 1322;
pub const PERFINFO_LOG_TYPE_RESOURCE: u32 = 1323;
pub const PERFINFO_LOG_TYPE_PUSHLOCK: u32 = 1324;
pub const PERFINFO_LOG_TYPE_WAIT_SINGLE: u32 = 1325;
pub const PERFINFO_LOG_TYPE_WAIT_MULTIPLE: u32 = 1326;
pub const PERFINFO_LOG_TYPE_DELAY_EXECUTION: u32 = 1327;
pub const PERFINFO_LOG_TYPE_THREAD_SET_PRIORITY: u32 = 1328;
pub const PERFINFO_LOT_TYPE_THREAD_SET_BASE_PRIORITY: u32 = 1329;
pub const PERFINFO_LOG_TYPE_THREAD_SET_BASE_PRIORITY: u32 = 1329;
pub const PERFINFO_LOG_TYPE_READY_THREAD: u32 = 1330;
pub const PERFINFO_LOG_TYPE_THREAD_SET_PAGE_PRIORITY: u32 = 1331;
pub const PERFINFO_LOG_TYPE_THREAD_SET_IO_PRIORITY: u32 = 1332;
pub const PERFINFO_LOG_TYPE_THREAD_SET_AFFINITY: u32 = 1333;
pub const PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM: u32 = 1337;
pub const PERFINFO_LOG_TYPE_DFSS_START_NEW_INTERVAL: u32 = 1338;
pub const PERFINFO_LOG_TYPE_DFSS_PROCESS_IDLE_ONLY_QUEUE: u32 = 1339;
pub const PERFINFO_LOG_TYPE_ANTI_STARVATION_BOOST: u32 = 1340;
pub const PERFINFO_LOG_TYPE_THREAD_MIGRATION: u32 = 1341;
pub const PERFINFO_LOG_TYPE_KQUEUE_ENQUEUE: u32 = 1342;
pub const PERFINFO_LOG_TYPE_KQUEUE_DEQUEUE: u32 = 1343;
pub const PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM_START: u32 = 1344;
pub const PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM_END: u32 = 1345;
pub const PERFINFO_LOG_TYPE_AUTO_BOOST_SET_FLOOR: u32 = 1346;
pub const PERFINFO_LOG_TYPE_AUTO_BOOST_CLEAR_FLOOR: u32 = 1347;
pub const PERFINFO_LOG_TYPE_AUTO_BOOST_NO_ENTRIES: u32 = 1348;
pub const PERFINFO_LOG_TYPE_THREAD_SUBPROCESSTAG_CHANGED: u32 = 1349;
pub const WMI_LOG_TYPE_TCPIP_SEND: u32 = 1546;
pub const WMI_LOG_TYPE_TCPIP_RECEIVE: u32 = 1547;
pub const WMI_LOG_TYPE_TCPIP_CONNECT: u32 = 1548;
pub const WMI_LOG_TYPE_TCPIP_DISCONNECT: u32 = 1549;
pub const WMI_LOG_TYPE_TCPIP_RETRANSMIT: u32 = 1550;
pub const WMI_LOG_TYPE_TCPIP_ACCEPT: u32 = 1551;
pub const WMI_LOG_TYPE_TCPIP_RECONNECT: u32 = 1552;
pub const WMI_LOG_TYPE_TCPIP_FAIL: u32 = 1553;
pub const WMI_LOG_TYPE_TCPIP_TCPCOPY: u32 = 1554;
pub const WMI_LOG_TYPE_TCPIP_ARPCOPY: u32 = 1555;
pub const WMI_LOG_TYPE_TCPIP_FULLACK: u32 = 1556;
pub const WMI_LOG_TYPE_TCPIP_PARTACK: u32 = 1557;
pub const WMI_LOG_TYPE_TCPIP_DUPACK: u32 = 1558;
pub const WMI_LOG_TYPE_UDP_SEND: u32 = 2058;
pub const WMI_LOG_TYPE_UDP_RECEIVE: u32 = 2059;
pub const WMI_LOG_TYPE_UDP_FAIL: u32 = 2065;
pub const WMI_LOG_TYPE_TCPIP_SEND_IPV6: u32 = 1562;
pub const WMI_LOG_TYPE_TCPIP_RECEIVE_IPV6: u32 = 1563;
pub const WMI_LOG_TYPE_TCPIP_CONNECT_IPV6: u32 = 1564;
pub const WMI_LOG_TYPE_TCPIP_DISCONNECT_IPV6: u32 = 1565;
pub const WMI_LOG_TYPE_TCPIP_RETRANSMIT_IPV6: u32 = 1566;
pub const WMI_LOG_TYPE_TCPIP_ACCEPT_IPV6: u32 = 1567;
pub const WMI_LOG_TYPE_TCPIP_RECONNECT_IPV6: u32 = 1568;
pub const WMI_LOG_TYPE_TCPIP_FAIL_IPV6: u32 = 1569;
pub const WMI_LOG_TYPE_TCPIP_TCPCOPY_IPV6: u32 = 1570;
pub const WMI_LOG_TYPE_TCPIP_ARPCOPY_IPV6: u32 = 1571;
pub const WMI_LOG_TYPE_TCPIP_FULLACK_IPV6: u32 = 1572;
pub const WMI_LOG_TYPE_TCPIP_PARTACK_IPV6: u32 = 1573;
pub const WMI_LOG_TYPE_TCPIP_DUPACK_IPV6: u32 = 1574;
pub const WMI_LOG_TYPE_UDP_SEND_IPV6: u32 = 2074;
pub const WMI_LOG_TYPE_UDP_RECEIVE_IPV6: u32 = 2075;
pub const WMI_LOG_TYPE_IO_READ: u32 = 266;
pub const WMI_LOG_TYPE_IO_WRITE: u32 = 267;
pub const WMI_LOG_TYPE_IO_READ_INIT: u32 = 268;
pub const WMI_LOG_TYPE_IO_WRITE_INIT: u32 = 269;
pub const WMI_LOG_TYPE_IO_FLUSH: u32 = 270;
pub const WMI_LOG_TYPE_IO_FLUSH_INIT: u32 = 271;
pub const WMI_LOG_TYPE_IO_REDIRECTED_INIT: u32 = 272;
pub const PERFINFO_LOG_TYPE_DRIVER_INIT: u32 = 288;
pub const PERFINFO_LOG_TYPE_DRIVER_INIT_COMPLETE: u32 = 289;
pub const PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_CALL: u32 = 290;
pub const PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_RETURN: u32 = 291;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETIONROUTINE_CALL: u32 = 292;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETIONROUTINE_RETURN: u32 = 293;
pub const PERFINFO_LOG_TYPE_DRIVER_ADD_DEVICE_CALL: u32 = 294;
pub const PERFINFO_LOG_TYPE_DRIVER_ADD_DEVICE_RETURN: u32 = 295;
pub const PERFINFO_LOG_TYPE_DRIVER_STARTIO_CALL: u32 = 296;
pub const PERFINFO_LOG_TYPE_DRIVER_STARTIO_RETURN: u32 = 297;
pub const PERFINFO_LOG_TYPE_PREFETCH_ACTION: u32 = 304;
pub const PERFINFO_LOG_TYPE_PREFETCH_REQUEST: u32 = 305;
pub const PERFINFO_LOG_TYPE_PREFETCH_READLIST: u32 = 306;
pub const PERFINFO_LOG_TYPE_PREFETCH_READ: u32 = 307;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST: u32 = 308;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST_RETURN: u32 = 309;
pub const PERFINFO_LOG_TYPE_BOOT_PREFETCH_INFORMATION: u32 = 310;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_READ: u32 = 311;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_WRITE: u32 = 312;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_FLUSH: u32 = 313;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_READ_INIT: u32 = 314;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_WRITE_INIT: u32 = 315;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_FLUSH_INIT: u32 = 316;
pub const WMI_LOG_TYPE_PAGE_FAULT_TRANSITION: u32 = 522;
pub const WMI_LOG_TYPE_PAGE_FAULT_DEMAND_ZERO: u32 = 523;
pub const WMI_LOG_TYPE_PAGE_FAULT_COPY_ON_WRITE: u32 = 524;
pub const WMI_LOG_TYPE_PAGE_FAULT_GUARD_PAGE: u32 = 525;
pub const WMI_LOG_TYPE_PAGE_FAULT_HARD_PAGE_FAULT: u32 = 526;
pub const WMI_LOG_TYPE_PAGE_FAULT_ACCESS_VIOLATION: u32 = 527;
pub const PERFINFO_LOG_TYPE_HARDFAULT: u32 = 544;
pub const PERFINFO_LOG_TYPE_REMOVEPAGEBYCOLOR: u32 = 545;
pub const PERFINFO_LOG_TYPE_REMOVEPAGEFROMLIST: u32 = 546;
pub const PERFINFO_LOG_TYPE_PAGEINMEMORY: u32 = 547;
pub const PERFINFO_LOG_TYPE_INSERTINFREELIST: u32 = 548;
pub const PERFINFO_LOG_TYPE_INSERTINMODIFIEDLIST: u32 = 549;
pub const PERFINFO_LOG_TYPE_INSERTINLIST: u32 = 550;
pub const PERFINFO_LOG_TYPE_INSERTATFRONT: u32 = 552;
pub const PERFINFO_LOG_TYPE_UNLINKFROMSTANDBY: u32 = 553;
pub const PERFINFO_LOG_TYPE_UNLINKFFREEORZERO: u32 = 554;
pub const PERFINFO_LOG_TYPE_WORKINGSETMANAGER: u32 = 555;
pub const PERFINFO_LOG_TYPE_TRIMPROCESS: u32 = 556;
pub const PERFINFO_LOG_TYPE_ZEROSHARECOUNT: u32 = 558;
pub const PERFINFO_LOG_TYPE_WSINFOPROCESS: u32 = 572;
pub const PERFINFO_LOG_TYPE_FAULTADDR_WITH_IP: u32 = 581;
pub const PERFINFO_LOG_TYPE_TRIMSESSION: u32 = 582;
pub const PERFINFO_LOG_TYPE_MEMORYSNAPLITE: u32 = 583;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_RUNDOWN: u32 = 584;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_CREATE: u32 = 585;
pub const PERFINFO_LOG_TYPE_WSINFOSESSION: u32 = 586;
pub const PERFINFO_LOG_TYPE_CREATE_SESSION: u32 = 587;
pub const PERFINFO_LOG_TYPE_SESSION_RUNDOWN_DC_END: u32 = 588;
pub const PERFINFO_LOG_TYPE_SESSION_RUNDOWN_DC_START: u32 = 589;
pub const PERFINFO_LOG_TYPE_SESSION_DELETE: u32 = 590;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_DELETE: u32 = 591;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ALLOC: u32 = 610;
pub const PERFINFO_LOG_TYPE_VIRTUAL_FREE: u32 = 611;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_RUNDOWN: u32 = 612;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_CREATE: u32 = 613;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_RESERVE: u32 = 614;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_RELEASE: u32 = 615;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_DESTROY: u32 = 616;
pub const PERFINFO_LOG_TYPE_PAGEFILE_BACK: u32 = 617;
pub const PERFINFO_LOG_TYPE_MEMINFO: u32 = 624;
pub const PERFINFO_LOG_TYPE_CONTMEM_GENERATE: u32 = 625;
pub const PERFINFO_LOG_TYPE_FILE_STORE_FAULT: u32 = 626;
pub const PERFINFO_LOG_TYPE_INMEMORY_STORE_FAULT: u32 = 627;
pub const PERFINFO_LOG_TYPE_COMPRESSED_PAGE: u32 = 628;
pub const PERFINFO_LOG_TYPE_PAGEINMEMORY_ACTIVE: u32 = 629;
pub const PERFINFO_LOG_TYPE_PAGE_ACCESS: u32 = 630;
pub const PERFINFO_LOG_TYPE_PAGE_RELEASE: u32 = 631;
pub const PERFINFO_LOG_TYPE_PAGE_RANGE_ACCESS: u32 = 632;
pub const PERFINFO_LOG_TYPE_PAGE_RANGE_RELEASE: u32 = 633;
pub const PERFINFO_LOG_TYPE_PAGE_COMBINE: u32 = 634;
pub const PERFINFO_LOG_TYPE_KERNEL_MEMUSAGE: u32 = 635;
pub const PERFINFO_LOG_TYPE_MM_STATS: u32 = 636;
pub const PERFINFO_LOG_TYPE_MEMINFOEX_WS: u32 = 637;
pub const PERFINFO_LOG_TYPE_MEMINFOEX_SESSIONWS: u32 = 638;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ROTATE: u32 = 639;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ALLOC_DC_START: u32 = 640;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ALLOC_DC_END: u32 = 641;
pub const PERFINFO_LOG_TYPE_PAGE_ACCESS_EX: u32 = 642;
pub const PERFINFO_LOG_TYPE_REMOVEFROMWS: u32 = 643;
pub const PERFINFO_LOG_TYPE_WSSHAREABLE_RUNDOWN: u32 = 644;
pub const PERFINFO_LOG_TYPE_INMEMORYACTIVE_RUNDOWN: u32 = 645;
pub const PERFINFO_LOG_TYPE_MEM_RESET_INFO: u32 = 646;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_OBJECT_CREATE: u32 = 647;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_OBJECT_DELETE: u32 = 648;
pub const WMI_LOG_TYPE_REG_RUNDOWNBEGIN: u32 = 2328;
pub const WMI_LOG_TYPE_REG_RUNDOWNEND: u32 = 2329;
pub const PERFINFO_LOG_TYPE_CMCELLREFERRED: u32 = 2336;
pub const PERFINFO_LOG_TYPE_REG_SET_VALUE: u32 = 2337;
pub const PERFINFO_LOG_TYPE_REG_COUNTERS: u32 = 2338;
pub const PERFINFO_LOG_TYPE_REG_CONFIG: u32 = 2339;
pub const PERFINFO_LOG_TYPE_REG_HIVE_INITIALIZE: u32 = 2340;
pub const PERFINFO_LOG_TYPE_REG_HIVE_DESTROY: u32 = 2341;
pub const PERFINFO_LOG_TYPE_REG_HIVE_LINK: u32 = 2342;
pub const PERFINFO_LOG_TYPE_REG_HIVE_RUNDOWN_DC_END: u32 = 2343;
pub const PERFINFO_LOG_TYPE_REG_HIVE_DIRTY: u32 = 2344;
pub const PERFINFO_LOG_TYPE_REG_NOTIF_REGISTER: u32 = 2352;
pub const PERFINFO_LOG_TYPE_REG_NOTIF_DELIVER: u32 = 2353;
pub const PERFINFO_LOG_TYPE_RUNDOWN_CHECKPOINT: u32 = 3872;
pub const PERFINFO_LOG_TYPE_MARK: u32 = 3874;
pub const PERFINFO_LOG_TYPE_ASYNCMARK: u32 = 3876;
pub const PERFINFO_LOG_TYPE_IMAGENAME: u32 = 3878;
pub const PERFINFO_LOG_TYPE_DELAYS_CC_CAN_I_WRITE: u32 = 3879;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE: u32 = 3886;
pub const PERFINFO_LOG_TYPE_PMC_INTERRUPT: u32 = 3887;
pub const PERFINFO_LOG_TYPE_PMC_CONFIG: u32 = 3888;
pub const PERFINFO_LOG_TYPE_MSI_INTERRUPT: u32 = 3890;
pub const PERFINFO_LOG_TYPE_SYSCALL_ENTER: u32 = 3891;
pub const PERFINFO_LOG_TYPE_SYSCALL_EXIT: u32 = 3892;
pub const PERFINFO_LOG_TYPE_BACKTRACE: u32 = 3893;
pub const PERFINFO_LOG_TYPE_BACKTRACE_USERSTACK: u32 = 3894;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_CACHE: u32 = 3895;
pub const PERFINFO_LOG_TYPE_EXCEPTION_STACK: u32 = 3896;
pub const PERFINFO_LOG_TYPE_BRANCH_TRACE: u32 = 3897;
pub const PERFINFO_LOG_TYPE_DEBUGGER_ENABLED: u32 = 3898;
pub const PERFINFO_LOG_TYPE_DEBUGGER_EXIT: u32 = 3899;
pub const PERFINFO_LOG_TYPE_BRANCH_TRACE_DEBUG: u32 = 3904;
pub const PERFINFO_LOG_TYPE_BRANCH_ADDRESS_DEBUG: u32 = 3905;
pub const PERFINFO_LOG_TYPE_THREADED_DPC: u32 = 3906;
pub const PERFINFO_LOG_TYPE_INTERRUPT: u32 = 3907;
pub const PERFINFO_LOG_TYPE_DPC: u32 = 3908;
pub const PERFINFO_LOG_TYPE_TIMERDPC: u32 = 3909;
pub const PERFINFO_LOG_TYPE_IOTIMER_EXPIRATION: u32 = 3910;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_NMI: u32 = 3911;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_SET_INTERVAL: u32 = 3912;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_DC_START: u32 = 3913;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_DC_END: u32 = 3914;
pub const PERFINFO_LOG_TYPE_SPINLOCK_DC_START: u32 = 3915;
pub const PERFINFO_LOG_TYPE_SPINLOCK_DC_END: u32 = 3916;
pub const PERFINFO_LOG_TYPE_ERESOURCE_DC_START: u32 = 3917;
pub const PERFINFO_LOG_TYPE_ERESOURCE_DC_END: u32 = 3918;
pub const PERFINFO_LOG_TYPE_CLOCK_INTERRUPT: u32 = 3919;
pub const PERFINFO_LOG_TYPE_TIMER_EXPIRATION_START: u32 = 3920;
pub const PERFINFO_LOG_TYPE_TIMER_EXPIRATION: u32 = 3921;
pub const PERFINFO_LOG_TYPE_TIMER_SET_PERIODIC: u32 = 3922;
pub const PERFINFO_LOG_TYPE_TIMER_SET_ONE_SHOT: u32 = 3923;
pub const PERFINFO_LOG_TYPE_TIMER_SET_THREAD: u32 = 3924;
pub const PERFINFO_LOG_TYPE_TIMER_CANCEL: u32 = 3925;
pub const PERFINFO_LOG_TYPE_TIME_ADJUSTMENT: u32 = 3926;
pub const PERFINFO_LOG_TYPE_CLOCK_MODE_SWITCH: u32 = 3927;
pub const PERFINFO_LOG_TYPE_CLOCK_TIME_UPDATE: u32 = 3928;
pub const PERFINFO_LOG_TYPE_CLOCK_DYNAMIC_TICK_VETO: u32 = 3929;
pub const PERFINFO_LOG_TYPE_CLOCK_CONFIGURATION: u32 = 3930;
pub const PERFINFO_LOG_TYPE_IPI: u32 = 3931;
pub const PERFINFO_LOG_TYPE_UNEXPECTED_INTERRUPT: u32 = 3932;
pub const PERFINFO_LOG_TYPE_IOTIMER_START: u32 = 3933;
pub const PERFINFO_LOG_TYPE_IOTIMER_STOP: u32 = 3934;
pub const PERFINFO_LOG_TYPE_PASSIVE_INTERRUPT: u32 = 3935;
pub const PERFINFO_LOG_TYPE_WDF_INTERRUPT: u32 = 3936;
pub const PERFINFO_LOG_TYPE_WDF_PASSIVE_INTERRUPT: u32 = 3937;
pub const PERFINFO_LOG_TYPE_WDF_DPC: u32 = 3938;
pub const PERFINFO_LOG_TYPE_CPU_CACHE_FLUSH: u32 = 3939;
pub const PERFINFO_LOG_TYPE_DPC_ENQUEUE: u32 = 3940;
pub const PERFINFO_LOG_TYPE_DPC_EXECUTION: u32 = 3941;
pub const PERFINFO_LOG_TYPE_INTERRUPT_STEERING: u32 = 3942;
pub const PERFINFO_LOG_TYPE_WDF_WORK_ITEM: u32 = 3943;
pub const PERFINFO_LOG_TYPE_KTIMER2_SET: u32 = 3944;
pub const PERFINFO_LOG_TYPE_KTIMER2_EXPIRATION: u32 = 3945;
pub const PERFINFO_LOG_TYPE_KTIMER2_CANCEL: u32 = 3946;
pub const PERFINFO_LOG_TYPE_KTIMER2_DISABLE: u32 = 3947;
pub const PERFINFO_LOG_TYPE_KTIMER2_FINALIZATION: u32 = 3948;
pub const PERFINFO_LOG_TYPE_SHOULD_YIELD_PROCESSOR: u32 = 3949;
pub const PERFINFO_LOG_TYPE_FUNCTION_CALL: u32 = 3968;
pub const PERFINFO_LOG_TYPE_FUNCTION_RETURN: u32 = 3969;
pub const PERFINFO_LOG_TYPE_FUNCTION_ENTER: u32 = 3970;
pub const PERFINFO_LOG_TYPE_FUNCTION_EXIT: u32 = 3971;
pub const PERFINFO_LOG_TYPE_TAILCALL: u32 = 3972;
pub const PERFINFO_LOG_TYPE_TRAP: u32 = 3973;
pub const PERFINFO_LOG_TYPE_SPINLOCK_ACQUIRE: u32 = 3974;
pub const PERFINFO_LOG_TYPE_SPINLOCK_RELEASE: u32 = 3975;
pub const PERFINFO_LOG_TYPE_CAP_COMMENT: u32 = 3976;
pub const PERFINFO_LOG_TYPE_CAP_RUNDOWN: u32 = 3977;
pub const PERFINFO_LOG_TYPE_DEBUG_PRINT: u32 = 2592;
pub const PERFINFO_LOG_TYPE_WNF_SUBSCRIBE: u32 = 3360;
pub const PERFINFO_LOG_TYPE_WNF_UNSUBSCRIBE: u32 = 3361;
pub const PERFINFO_LOG_TYPE_WNF_CALLBACK: u32 = 3362;
pub const PERFINFO_LOG_TYPE_WNF_PUBLISH: u32 = 3363;
pub const PERFINFO_LOG_TYPE_WNF_NAME_SUB_RUNDOWN: u32 = 3364;
pub const PERFINFO_LOG_TYPE_ALLOCATEPOOL: u32 = 3616;
pub const PERFINFO_LOG_TYPE_ALLOCATEPOOL_SESSION: u32 = 3617;
pub const PERFINFO_LOG_TYPE_FREEPOOL: u32 = 3618;
pub const PERFINFO_LOG_TYPE_FREEPOOL_SESSION: u32 = 3619;
pub const PERFINFO_LOG_TYPE_ADDPOOLPAGE: u32 = 3620;
pub const PERFINFO_LOG_TYPE_ADDPOOLPAGE_SESSION: u32 = 3621;
pub const PERFINFO_LOG_TYPE_BIGPOOLPAGE: u32 = 3622;
pub const PERFINFO_LOG_TYPE_BIGPOOLPAGE_SESSION: u32 = 3623;
pub const PERFINFO_LOG_TYPE_POOLSNAP_DC_START: u32 = 3624;
pub const PERFINFO_LOG_TYPE_POOLSNAP_DC_END: u32 = 3625;
pub const PERFINFO_LOG_TYPE_BIGPOOLSNAP_DC_START: u32 = 3626;
pub const PERFINFO_LOG_TYPE_BIGPOOLSNAP_DC_END: u32 = 3627;
pub const PERFINFO_LOG_TYPE_POOLSNAP_SESSION_DC_START: u32 = 3628;
pub const PERFINFO_LOG_TYPE_POOLSNAP_SESSION_DC_END: u32 = 3629;
pub const PERFINFO_LOG_TYPE_SESSIONBIGPOOLSNAP_DC_START: u32 = 3630;
pub const PERFINFO_LOG_TYPE_SESSIONBIGPOOLSNAP_DC_END: u32 = 3631;
pub const PERFINFO_LOG_TYPE_HEAP_CREATE: u32 = 4128;
pub const PERFINFO_LOG_TYPE_HEAP_ALLOC: u32 = 4129;
pub const PERFINFO_LOG_TYPE_HEAP_REALLOC: u32 = 4130;
pub const PERFINFO_LOG_TYPE_HEAP_DESTROY: u32 = 4131;
pub const PERFINFO_LOG_TYPE_HEAP_FREE: u32 = 4132;
pub const PERFINFO_LOG_TYPE_HEAP_EXTEND: u32 = 4133;
pub const PERFINFO_LOG_TYPE_HEAP_SNAPSHOT: u32 = 4134;
pub const PERFINFO_LOG_TYPE_HEAP_CREATE_SNAPSHOT: u32 = 4135;
pub const PERFINFO_LOG_TYPE_HEAP_DESTROY_SNAPSHOT: u32 = 4136;
pub const PERFINFO_LOG_TYPE_HEAP_EXTEND_SNAPSHOT: u32 = 4137;
pub const PERFINFO_LOG_TYPE_HEAP_CONTRACT: u32 = 4138;
pub const PERFINFO_LOG_TYPE_HEAP_LOCK: u32 = 4139;
pub const PERFINFO_LOG_TYPE_HEAP_UNLOCK: u32 = 4140;
pub const PERFINFO_LOG_TYPE_HEAP_VALIDATE: u32 = 4141;
pub const PERFINFO_LOG_TYPE_HEAP_WALK: u32 = 4142;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ALLOC: u32 = 4143;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_FREE: u32 = 4144;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ALLOC_CACHE: u32 = 4145;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_FREE_CACHE: u32 = 4146;
pub const PERFINFO_LOG_TYPE_HEAP_COMMIT: u32 = 4147;
pub const PERFINFO_LOG_TYPE_HEAP_DECOMMIT: u32 = 4148;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_INIT: u32 = 4149;
pub const PERFINFO_LOG_TYPE_HEAP_AFFINITY_ENABLE: u32 = 4150;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ACTIVATED: u32 = 4152;
pub const PERFINFO_LOG_TYPE_HEAP_AFFINITY_ASSIGN: u32 = 4153;
pub const PERFINFO_LOG_TYPE_HEAP_REUSE_THRESHOLD_ACTIVATED: u32 = 4154;
pub const PERFINFO_LOG_TYPE_CRITSEC_ENTER: u32 = 5920;
pub const PERFINFO_LOG_TYPE_CRITSEC_LEAVE: u32 = 5921;
pub const PERFINFO_LOG_TYPE_CRITSEC_COLLISION: u32 = 5922;
pub const PERFINFO_LOG_TYPE_CRITSEC_INITIALIZE: u32 = 5923;
pub const PERFINFO_LOG_TYPE_STACKWALK: u32 = 6176;
pub const PERFINFO_LOG_TYPE_STACKTRACE_CREATE: u32 = 6178;
pub const PERFINFO_LOG_TYPE_STACKTRACE_DELETE: u32 = 6179;
pub const PERFINFO_LOG_TYPE_STACKTRACE_RUNDOWN: u32 = 6180;
pub const PERFINFO_LOG_TYPE_STACKTRACE_KEY_KERNEL: u32 = 6181;
pub const PERFINFO_LOG_TYPE_STACKTRACE_KEY_USER: u32 = 6182;
pub const WMI_LOG_TYPE_ALPC_SEND_MESSAGE: u32 = 6689;
pub const WMI_LOG_TYPE_ALPC_RECEIVE_MESSAGE: u32 = 6690;
pub const WMI_LOG_TYPE_ALPC_WAIT_FOR_REPLY: u32 = 6691;
pub const WMI_LOG_TYPE_ALPC_WAIT_FOR_NEW_MESSAGE: u32 = 6692;
pub const WMI_LOG_TYPE_ALPC_UNWAIT: u32 = 6693;
pub const WMI_LOG_TYPE_ALPC_CONNECT_REQUEST: u32 = 6694;
pub const WMI_LOG_TYPE_ALPC_CONNECT_SUCCESS: u32 = 6695;
pub const WMI_LOG_TYPE_ALPC_CONNECT_FAIL: u32 = 6696;
pub const WMI_LOG_TYPE_ALPC_CLOSE_PORT: u32 = 6697;
pub const PERFINFO_LOG_TYPE_CREATE_HANDLE: u32 = 4384;
pub const PERFINFO_LOG_TYPE_CLOSE_HANDLE: u32 = 4385;
pub const PERFINFO_LOG_TYPE_DUPLICATE_HANDLE: u32 = 4386;
pub const PERFINFO_LOG_TYPE_OBJECT_TYPE_DC_START: u32 = 4388;
pub const PERFINFO_LOG_TYPE_OBJECT_TYPE_DC_END: u32 = 4389;
pub const PERFINFO_LOG_TYPE_OBJECT_HANDLE_DC_START: u32 = 4390;
pub const PERFINFO_LOG_TYPE_OBJECT_HANDLE_DC_END: u32 = 4391;
pub const PERFINFO_LOG_TYPE_CREATE_OBJECT: u32 = 4400;
pub const PERFINFO_LOG_TYPE_DELETE_OBJECT: u32 = 4401;
pub const PERFINFO_LOG_TYPE_REFERENCE_OBJECT: u32 = 4402;
pub const PERFINFO_LOG_TYPE_DEREFERENCE_OBJECT: u32 = 4403;
pub const PERFINFO_LOG_TYPE_BATTERY_LIFE_INFO: u32 = 4640;
pub const PERFINFO_LOG_TYPE_IDLE_STATE_CHANGE: u32 = 4641;
pub const PERFINFO_LOG_TYPE_SET_POWER_ACTION: u32 = 4642;
pub const PERFINFO_LOG_TYPE_SET_POWER_ACTION_RET: u32 = 4643;
pub const PERFINFO_LOG_TYPE_SET_DEVICES_STATE: u32 = 4644;
pub const PERFINFO_LOG_TYPE_SET_DEVICES_STATE_RET: u32 = 4645;
pub const PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE: u32 = 4646;
pub const PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE_COMPLETE: u32 = 4647;
pub const PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT: u32 = 4648;
pub const PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT_RET: u32 = 4649;
pub const PERFINFO_LOG_TYPE_PO_PRESLEEP: u32 = 4656;
pub const PERFINFO_LOG_TYPE_PO_POSTSLEEP: u32 = 4657;
pub const PERFINFO_LOG_TYPE_PO_CALIBRATED_PERFCOUNTER: u32 = 4658;
pub const PERFINFO_LOG_TYPE_PPM_PERF_STATE_CHANGE: u32 = 4659;
pub const PERFINFO_LOG_TYPE_PPM_THROTTLE_STATE_CHANGE: u32 = 4660;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_STATE_CHANGE: u32 = 4661;
pub const PERFINFO_LOG_TYPE_PPM_THERMAL_CONSTRAINT: u32 = 4662;
pub const PERFINFO_LOG_TYPE_PO_SIGNAL_RESUME_UI: u32 = 4663;
pub const PERFINFO_LOG_TYPE_PO_SIGNAL_VIDEO_ON: u32 = 4664;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_STATE_ENTER: u32 = 4665;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_STATE_EXIT: u32 = 4666;
pub const PERFINFO_LOG_TYPE_PPM_PLATFORM_IDLE_STATE_ENTER: u32 = 4667;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_EXIT_LATENCY: u32 = 4668;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_PROCESSOR_SELECTION: u32 = 4669;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_PLATFORM_SELECTION: u32 = 4670;
pub const PERFINFO_LOG_TYPE_PPM_COORDINATED_IDLE_ENTER: u32 = 4671;
pub const PERFINFO_LOG_TYPE_PPM_COORDINATED_IDLE_EXIT: u32 = 4672;
pub const PERFINFO_LOG_TYPE_COWHEADER: u32 = 4888;
pub const PERFINFO_LOG_TYPE_COWBLOB: u32 = 4889;
pub const PERFINFO_LOG_TYPE_COWBLOB_CLOSED: u32 = 4890;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_ENT: u32 = 4896;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_JUMP: u32 = 4897;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_RET: u32 = 4898;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_CALL: u32 = 4899;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_CALLRET: u32 = 4900;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_INT2E: u32 = 4901;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_INT2B: u32 = 4902;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_FULLTRACE: u32 = 4903;
pub const PERFINFO_LOG_TYPE_MMCSS_START: u32 = 32;
pub const PERFINFO_LOG_TYPE_MMCSS_STOP: u32 = 33;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_EVENT: u32 = 34;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_WAKEUP: u32 = 35;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_SLEEP: u32 = 36;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_SLEEP_RESP: u32 = 37;
pub const PERFINFO_LOG_TYPE_SPLITIO_VOLMGR: u32 = 6944;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_ENQUEUE: u32 = 7200;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_DEQUEUE: u32 = 7201;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_START: u32 = 7202;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_STOP: u32 = 7203;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_CANCEL: u32 = 7204;
pub const PERFINFO_LOG_TYPE_TP_POOL_CREATE: u32 = 7205;
pub const PERFINFO_LOG_TYPE_TP_POOL_CLOSE: u32 = 7206;
pub const PERFINFO_LOG_TYPE_TP_POOL_TH_MIN_SET: u32 = 7207;
pub const PERFINFO_LOG_TYPE_TP_POOL_TH_MAX_SET: u32 = 7208;
pub const PERFINFO_LOG_TYPE_TP_WORKER_NUMANODE_SWITCH: u32 = 7209;
pub const PERFINFO_LOG_TYPE_TP_TIMER_SET: u32 = 7210;
pub const PERFINFO_LOG_TYPE_TP_TIMER_CANCELLED: u32 = 7211;
pub const PERFINFO_LOG_TYPE_TP_TIMER_SET_NTTIMER: u32 = 7212;
pub const PERFINFO_LOG_TYPE_TP_TIMER_CANCEL_NTTIMER: u32 = 7213;
pub const PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION_BEGIN: u32 = 7214;
pub const PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION_END: u32 = 7215;
pub const PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION: u32 = 7216;
pub const PERFINFO_LOG_TYPE_UMS_DIRECTED_SWITCH_START: u32 = 6432;
pub const PERFINFO_LOG_TYPE_UMS_DIRECTED_SWITCH_END: u32 = 6433;
pub const PERFINFO_LOG_TYPE_UMS_PARK: u32 = 6434;
pub const PERFINFO_LOG_TYPE_UMS_DISASSOCIATE: u32 = 6435;
pub const PERFINFO_LOG_TYPE_UMS_CONTEXT_SWITCH: u32 = 6436;
pub const PERFINFO_LOG_TYPE_CC_WORKITEM_ENQUEUE: u32 = 5632;
pub const PERFINFO_LOG_TYPE_CC_WORKITEM_DEQUEUE: u32 = 5633;
pub const PERFINFO_LOG_TYPE_CC_WORKITEM_COMPLETE: u32 = 5634;
pub const PERFINFO_LOG_TYPE_CC_READ_AHEAD: u32 = 5635;
pub const PERFINFO_LOG_TYPE_CC_WRITE_BEHIND: u32 = 5636;
pub const PERFINFO_LOG_TYPE_CC_LAZY_WRITE_SCAN: u32 = 5637;
pub const PERFINFO_LOG_TYPE_CC_CAN_I_WRITE_FAIL: u32 = 5638;
pub const PERFINFO_LOG_TYPE_CC_FLUSH_CACHE: u32 = 5641;
pub const PERFINFO_LOG_TYPE_CC_FLUSH_SECTION: u32 = 5642;
pub const PERFINFO_LOG_TYPE_CC_READ_AHEAD_PREFETCH: u32 = 5643;
pub const PERFINFO_LOG_TYPE_CC_SCHEDULE_READ_AHEAD: u32 = 5644;
pub const PERFINFO_LOG_TYPE_CC_LOGGED_STREAM_INFO: u32 = 5645;
pub const PERFINFO_LOG_TYPE_CC_EXTRA_WRITEBEHIND_THREAD: u32 = 5646;
pub const ETW_MAX_PROFILING_SOURCES: u32 = 4;
pub const ETW_MAX_PMC_EVENTS: u32 = 4;
pub const ETW_MAX_PMC_COUNTERS: u32 = 4;
pub const MAXIMUM_NODE_COUNT: u32 = 64;
pub const CODEINTEGRITY_OPTION_ENABLED: u32 = 1;
pub const CODEINTEGRITY_OPTION_TESTSIGN: u32 = 2;
pub const CODEINTEGRITY_OPTION_UMCI_ENABLED: u32 = 4;
pub const CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED: u32 = 8;
pub const CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED: u32 = 16;
pub const CODEINTEGRITY_OPTION_TEST_BUILD: u32 = 32;
pub const CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD: u32 = 64;
pub const CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED: u32 = 128;
pub const CODEINTEGRITY_OPTION_FLIGHT_BUILD: u32 = 256;
pub const CODEINTEGRITY_OPTION_FLIGHTING_ENABLED: u32 = 512;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED: u32 = 1024;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED: u32 = 2048;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED: u32 = 4096;
pub const CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED: u32 = 8192;
pub const CODEINTEGRITY_OPTION_WHQL_ENFORCEMENT_ENABLED: u32 = 16384;
pub const CODEINTEGRITY_OPTION_WHQL_AUDITMODE_ENABLED: u32 = 32768;
pub const SYSTEM_STORE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_STATS_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_STORE_CREATE_INFORMATION_VERSION: u32 = 6;
pub const SYSTEM_STORE_DELETE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_LIST_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_CACHE_LIST_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_CACHE_CREATE_INFORMATION_VERSION: u32 = 3;
pub const SYSTEM_CACHE_DELETE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_CACHE_STORE_CREATE_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_CACHE_STORE_DELETE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_CACHE_STATS_INFORMATION_VERSION: u32 = 3;
pub const SYSTEM_STORE_REGISTRATION_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_STORE_RESIZE_INFORMATION_VERSION: u32 = 6;
pub const SYSTEM_CACHE_STORE_RESIZE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_CONFIG_INFORMATION_VERSION: u32 = 4;
pub const SYSTEM_STORE_HIGH_MEM_PRIORITY_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_TRIM_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_COMPRESSION_INFORMATION_VERSION: u32 = 3;
pub const MEMORY_COMBINE_FLAGS_COMMON_PAGES_ONLY: u32 = 4;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED: u32 = 1;
pub const CODEINTEGRITYPOLICY_OPTION_AUDIT: u32 = 2;
pub const CODEINTEGRITYPOLICY_OPTION_REQUIRE_WHQL: u32 = 4;
pub const CODEINTEGRITYPOLICY_OPTION_DISABLED_FLIGHTSIGNING: u32 = 8;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_UMCI: u32 = 16;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_UPDATE_POLICY_NOREBOOT: u32 = 32;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_SECURE_SETTING_POLICY: u32 = 64;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_UNSIGNED_SYSTEMINTEGRITY_POLICY: u32 = 128;
pub const CODEINTEGRITYPOLICY_OPTION_DYNAMIC_CODE_POLICY_ENABLED: u32 = 256;
pub const CODEINTEGRITYPOLICY_OPTION_RELOAD_POLICY_NO_REBOOT: u32 = 268435456;
pub const CODEINTEGRITYPOLICY_OPTION_CONDITIONAL_LOCKDOWN: u32 = 536870912;
pub const CODEINTEGRITYPOLICY_OPTION_NOLOCKDOWN: u32 = 1073741824;
pub const CODEINTEGRITYPOLICY_OPTION_LOCKDOWN: u32 = 2147483648;
pub const CODEINTEGRITYPOLICY_HVCIOPTION_ENABLED: u32 = 1;
pub const CODEINTEGRITYPOLICY_HVCIOPTION_STRICT: u32 = 2;
pub const CODEINTEGRITYPOLICY_HVCIOPTION_DEBUG: u32 = 4;
pub const SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_VERSION: u32 = 1;
pub const SYSDBG_LIVEDUMP_CONTROL_VERSION_1: u32 = 1;
pub const SYSDBG_LIVEDUMP_CONTROL_VERSION_2: u32 = 2;
pub const SYSDBG_LIVEDUMP_CONTROL_VERSION: u32 = 2;
pub const HARDERROR_OVERRIDE_ERRORMODE: u32 = 268435456;
pub const PROCESSOR_FEATURE_MAX: u32 = 64;
pub const MAX_WOW64_SHARED_ENTRIES: u32 = 16;
pub const NX_SUPPORT_POLICY_ALWAYSOFF: u32 = 0;
pub const NX_SUPPORT_POLICY_ALWAYSON: u32 = 1;
pub const NX_SUPPORT_POLICY_OPTIN: u32 = 2;
pub const NX_SUPPORT_POLICY_OPTOUT: u32 = 3;
pub const SEH_VALIDATION_POLICY_ON: u32 = 0;
pub const SEH_VALIDATION_POLICY_OFF: u32 = 1;
pub const SEH_VALIDATION_POLICY_TELEMETRY: u32 = 2;
pub const SEH_VALIDATION_POLICY_DEFER: u32 = 3;
pub const SHARED_GLOBAL_FLAGS_ERROR_PORT_V: u32 = 0;
pub const SHARED_GLOBAL_FLAGS_ERROR_PORT: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED_V: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED: u32 = 2;
pub const SHARED_GLOBAL_FLAGS_VIRT_ENABLED_V: u32 = 2;
pub const SHARED_GLOBAL_FLAGS_VIRT_ENABLED: u32 = 4;
pub const SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED_V: u32 = 3;
pub const SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED: u32 = 8;
pub const SHARED_GLOBAL_FLAGS_LKG_ENABLED_V: u32 = 4;
pub const SHARED_GLOBAL_FLAGS_LKG_ENABLED: u32 = 16;
pub const SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED_V: u32 = 5;
pub const SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED: u32 = 32;
pub const SHARED_GLOBAL_FLAGS_CONSOLE_BROKER_ENABLED_V: u32 = 6;
pub const SHARED_GLOBAL_FLAGS_CONSOLE_BROKER_ENABLED: u32 = 64;
pub const SHARED_GLOBAL_FLAGS_SECURE_BOOT_ENABLED_V: u32 = 7;
pub const SHARED_GLOBAL_FLAGS_SECURE_BOOT_ENABLED: u32 = 128;
pub const SHARED_GLOBAL_FLAGS_MULTI_SESSION_SKU_V: u32 = 8;
pub const SHARED_GLOBAL_FLAGS_MULTI_SESSION_SKU: u32 = 256;
pub const SHARED_GLOBAL_FLAGS_MULTIUSERS_IN_SESSION_SKU_V: u32 = 9;
pub const SHARED_GLOBAL_FLAGS_MULTIUSERS_IN_SESSION_SKU: u32 = 512;
pub const SHARED_GLOBAL_FLAGS_STATE_SEPARATION_ENABLED_V: u32 = 10;
pub const SHARED_GLOBAL_FLAGS_STATE_SEPARATION_ENABLED: u32 = 1024;
pub const SHARED_GLOBAL_FLAGS_SET_GLOBAL_DATA_FLAG: u32 = 1073741824;
pub const SHARED_GLOBAL_FLAGS_CLEAR_GLOBAL_DATA_FLAG: u32 = 2147483648;
pub const SYSTEM_CALL_SYSCALL: u32 = 0;
pub const SYSTEM_CALL_INT_2E: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_ENABLED: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_HV_PAGE: u32 = 2;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_DISABLE_32BIT: u32 = 4;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_MFENCE: u32 = 16;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_LFENCE: u32 = 32;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_A73_ERRATA: u32 = 64;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_RDTSCP: u32 = 128;
pub const FLG_STOP_ON_EXCEPTION: u32 = 1;
pub const FLG_SHOW_LDR_SNAPS: u32 = 2;
pub const FLG_DEBUG_INITIAL_COMMAND: u32 = 4;
pub const FLG_STOP_ON_HUNG_GUI: u32 = 8;
pub const FLG_HEAP_ENABLE_TAIL_CHECK: u32 = 16;
pub const FLG_HEAP_ENABLE_FREE_CHECK: u32 = 32;
pub const FLG_HEAP_VALIDATE_PARAMETERS: u32 = 64;
pub const FLG_HEAP_VALIDATE_ALL: u32 = 128;
pub const FLG_APPLICATION_VERIFIER: u32 = 256;
pub const FLG_MONITOR_SILENT_PROCESS_EXIT: u32 = 512;
pub const FLG_POOL_ENABLE_TAGGING: u32 = 1024;
pub const FLG_HEAP_ENABLE_TAGGING: u32 = 2048;
pub const FLG_USER_STACK_TRACE_DB: u32 = 4096;
pub const FLG_KERNEL_STACK_TRACE_DB: u32 = 8192;
pub const FLG_MAINTAIN_OBJECT_TYPELIST: u32 = 16384;
pub const FLG_HEAP_ENABLE_TAG_BY_DLL: u32 = 32768;
pub const FLG_DISABLE_STACK_EXTENSION: u32 = 65536;
pub const FLG_ENABLE_CSRDEBUG: u32 = 131072;
pub const FLG_ENABLE_KDEBUG_SYMBOL_LOAD: u32 = 262144;
pub const FLG_DISABLE_PAGE_KERNEL_STACKS: u32 = 524288;
pub const FLG_ENABLE_SYSTEM_CRIT_BREAKS: u32 = 1048576;
pub const FLG_HEAP_DISABLE_COALESCING: u32 = 2097152;
pub const FLG_ENABLE_CLOSE_EXCEPTIONS: u32 = 4194304;
pub const FLG_ENABLE_EXCEPTION_LOGGING: u32 = 8388608;
pub const FLG_ENABLE_HANDLE_TYPE_TAGGING: u32 = 16777216;
pub const FLG_HEAP_PAGE_ALLOCS: u32 = 33554432;
pub const FLG_DEBUG_INITIAL_COMMAND_EX: u32 = 67108864;
pub const FLG_DISABLE_DBGPRINT: u32 = 134217728;
pub const FLG_CRITSEC_EVENT_CREATION: u32 = 268435456;
pub const FLG_STOP_ON_UNHANDLED_EXCEPTION: u32 = 536870912;
pub const FLG_ENABLE_HANDLE_EXCEPTIONS: u32 = 1073741824;
pub const FLG_DISABLE_PROTDLLS: u32 = 2147483648;
pub const FLG_VALID_BITS: u32 = 4294966783;
pub const FLG_BOOTONLY_VALID_BITS: u32 = 67788804;
pub const FLG_KERNELMODE_VALID_BITS: u32 = 1237582859;
pub const BCD_OBJECT_DESCRIPTION_VERSION: u32 = 1;
pub const BCD_ELEMENT_DESCRIPTION_VERSION: u32 = 1;
pub const PAGE_ENCLAVE_NO_CHANGE: u32 = 536870912;
pub const MEM_DOS_LIM: u32 = 1073741824;
pub const SEC_BASED: u32 = 2097152;
pub const SEC_NO_CHANGE: u32 = 4194304;
pub const SEC_GLOBAL: u32 = 536870912;
pub const MMPFNLIST_ZERO: u32 = 0;
pub const MMPFNLIST_FREE: u32 = 1;
pub const MMPFNLIST_STANDBY: u32 = 2;
pub const MMPFNLIST_MODIFIED: u32 = 3;
pub const MMPFNLIST_MODIFIEDNOWRITE: u32 = 4;
pub const MMPFNLIST_BAD: u32 = 5;
pub const MMPFNLIST_ACTIVE: u32 = 6;
pub const MMPFNLIST_TRANSITION: u32 = 7;
pub const MMPFNUSE_PROCESSPRIVATE: u32 = 0;
pub const MMPFNUSE_FILE: u32 = 1;
pub const MMPFNUSE_PAGEFILEMAPPED: u32 = 2;
pub const MMPFNUSE_PAGETABLE: u32 = 3;
pub const MMPFNUSE_PAGEDPOOL: u32 = 4;
pub const MMPFNUSE_NONPAGEDPOOL: u32 = 5;
pub const MMPFNUSE_SYSTEMPTE: u32 = 6;
pub const MMPFNUSE_SESSIONPRIVATE: u32 = 7;
pub const MMPFNUSE_METAFILE: u32 = 8;
pub const MMPFNUSE_AWEPAGE: u32 = 9;
pub const MMPFNUSE_DRIVERLOCKPAGE: u32 = 10;
pub const MMPFNUSE_KERNELSTACK: u32 = 11;
pub const MEM_EXECUTE_OPTION_ENABLE: u32 = 1;
pub const MEM_EXECUTE_OPTION_DISABLE: u32 = 2;
pub const MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION: u32 = 4;
pub const MEM_EXECUTE_OPTION_PERMANENT: u32 = 8;
pub const MEM_EXECUTE_OPTION_EXECUTE_DISPATCH_ENABLE: u32 = 16;
pub const MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE: u32 = 32;
pub const MEM_EXECUTE_OPTION_DISABLE_EXCEPTION_CHAIN_VALIDATION: u32 = 64;
pub const MEM_EXECUTE_OPTION_VALID_FLAGS: u32 = 127;
pub const MAP_PROCESS: u32 = 1;
pub const MAP_SYSTEM: u32 = 2;
pub const TERMINATE_ENCLAVE_VALID_FLAGS: u32 = 5;
pub const TERMINATE_ENCLAVE_FLAG_NO_WAIT: u32 = 1;
pub const TERMINATE_ENCLAVE_FLAG_WAIT_ERROR: u32 = 4;
pub const ENCLAVE_CALL_VALID_FLAGS: u32 = 1;
pub const ENCLAVE_CALL_FLAG_NO_WAIT: u32 = 1;
pub const OBJECT_TYPE_CREATE: u32 = 1;
pub const OBJECT_TYPE_ALL_ACCESS: u32 = 983041;
pub const DIRECTORY_QUERY: u32 = 1;
pub const DIRECTORY_TRAVERSE: u32 = 2;
pub const DIRECTORY_CREATE_OBJECT: u32 = 4;
pub const DIRECTORY_CREATE_SUBDIRECTORY: u32 = 8;
pub const DIRECTORY_ALL_ACCESS: u32 = 983055;
pub const SYMBOLIC_LINK_QUERY: u32 = 1;
pub const SYMBOLIC_LINK_SET: u32 = 2;
pub const SYMBOLIC_LINK_ALL_ACCESS: u32 = 983041;
pub const SYMBOLIC_LINK_ALL_ACCESS_EX: u32 = 1048575;
pub const DUPLICATE_SAME_ATTRIBUTES: u32 = 4;
pub const OBJECT_BOUNDARY_DESCRIPTOR_VERSION: u32 = 1;
pub const PROCESS_SET_PORT: u32 = 2048;
pub const THREAD_ALERT: u32 = 4;
pub const GDI_HANDLE_BUFFER_SIZE32: u32 = 34;
pub const GDI_HANDLE_BUFFER_SIZE64: u32 = 60;
pub const GDI_HANDLE_BUFFER_SIZE: u32 = 60;
pub const TLS_EXPANSION_SLOTS: u32 = 1024;
pub const ACTIVATION_CONTEXT_DATA_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_FLAG_NO_INHERIT: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT: u32 = 2;
pub const ACTIVATION_CONTEXT_SECTION_FORMAT_UNKNOWN: u32 = 0;
pub const ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE: u32 = 1;
pub const ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE: u32 = 2;
pub const ACTIVATION_CONTEXT_STRING_SECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE: u32 = 1;
pub const ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER: u32 = 2;
pub const ACTIVATION_CONTEXT_GUID_SECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_POLICY_APPLIED: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ASSEMBLY_POLICY_APPLIED: u32 = 4;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_POLICY_APPLIED: u32 = 8;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_PRIVATE_ASSEMBLY: u32 = 16;
pub const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND: u32 = 4;
pub const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SYSTEM_DEFAULT_REDIRECTED_SYSTEM32_DLL: u32 =
   8;
pub const ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_INVALID: u32 = 0;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_APARTMENT: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_FREE: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE: u32 = 3;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH: u32 = 4;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_NEUTRAL: u32 = 5;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_FLAG_OFFSET: u32 = 8;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_HAS_DEFAULT: u32 = 256;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_HAS_ICON: u32 = 512;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_HAS_CONTENT: u32 = 1024;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_HAS_THUMBNAIL: u32 = 2048;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_HAS_DOCPRINT: u32 = 4096;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_OTHER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_CLR_CLASS: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_NUM_METHODS_VALID: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_BASE_INTERFACE_VALID: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_CLR_SURROGATE_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS_FORMAT_LONGHORN: u32 = 1;
pub const SXS_WINDOWS_SETTINGS_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2005/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2011_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2011/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2013_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2013/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2014_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2014/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2016_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2016/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2017_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2017/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2019_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2019/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2020_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2020/WindowsSettings\0";
pub const ASSEMBLY_STORAGE_MAP_ASSEMBLY_ARRAY_IS_HEAP_ALLOCATED: u32 = 1;
pub const ACTIVATION_CONTEXT_NOTIFICATION_DESTROY: u32 = 1;
pub const ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY: u32 = 2;
pub const ACTIVATION_CONTEXT_NOTIFICATION_USED: u32 = 3;
pub const RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION: u32 = 1;
pub const RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE: u32 = 2;
pub const RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST: u32 = 4;
pub const RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED: u32 = 8;
pub const RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED: u32 = 16;
pub const ACTIVATION_CONTEXT_STACK_FLAG_QUERIES_DISABLED: u32 = 1;
pub const KACF_OLDGETSHORTPATHNAME: u32 = 1;
pub const KACF_VERSIONLIE_NOT_USED: u32 = 2;
pub const KACF_GETDISKFREESPACE: u32 = 8;
pub const KACF_FTMFROMCURRENTAPT: u32 = 32;
pub const KACF_DISALLOWORBINDINGCHANGES: u32 = 64;
pub const KACF_OLE32VALIDATEPTRS: u32 = 128;
pub const KACF_DISABLECICERO: u32 = 256;
pub const KACF_OLE32ENABLEASYNCDOCFILE: u32 = 512;
pub const KACF_OLE32ENABLELEGACYEXCEPTIONHANDLING: u32 = 1024;
pub const KACF_RPCDISABLENDRCLIENTHARDENING: u32 = 2048;
pub const KACF_RPCDISABLENDRMAYBENULL_SIZEIS: u32 = 4096;
pub const KACF_DISABLEALLDDEHACK_NOT_USED: u32 = 8192;
pub const KACF_RPCDISABLENDR61_RANGE: u32 = 16384;
pub const KACF_RPC32ENABLELEGACYEXCEPTIONHANDLING: u32 = 32768;
pub const KACF_OLE32DOCFILEUSELEGACYNTFSFLAGS: u32 = 65536;
pub const KACF_RPCDISABLENDRCONSTIIDCHECK: u32 = 131072;
pub const KACF_USERDISABLEFORWARDERPATCH: u32 = 262144;
pub const KACF_OLE32DISABLENEW_WMPAINT_DISPATCH: u32 = 1048576;
pub const KACF_ADDRESTRICTEDSIDINCOINITIALIZESECURITY: u32 = 2097152;
pub const KACF_ALLOCDEBUGINFOFORCRITSECTIONS: u32 = 4194304;
pub const KACF_OLEAUT32ENABLEUNSAFELOADTYPELIBRELATIVE: u32 = 8388608;
pub const KACF_ALLOWMAXIMIZEDWINDOWGAMMA: u32 = 16777216;
pub const KACF_DONOTADDTOCACHE: u32 = 2147483648;
pub const GDI_BATCH_BUFFER_SIZE: u32 = 310;
pub const STATIC_UNICODE_BUFFER_LENGTH: u32 = 261;
pub const WIN32_CLIENT_INFO_LENGTH: u32 = 62;
pub const PROCESS_EXCEPTION_PORT_ALL_STATE_BITS: u32 = 3;
pub const PROCESS_PRIORITY_CLASS_UNKNOWN: u32 = 0;
pub const PROCESS_PRIORITY_CLASS_IDLE: u32 = 1;
pub const PROCESS_PRIORITY_CLASS_NORMAL: u32 = 2;
pub const PROCESS_PRIORITY_CLASS_HIGH: u32 = 3;
pub const PROCESS_PRIORITY_CLASS_REALTIME: u32 = 4;
pub const PROCESS_PRIORITY_CLASS_BELOW_NORMAL: u32 = 5;
pub const PROCESS_PRIORITY_CLASS_ABOVE_NORMAL: u32 = 6;
pub const PROCESS_LUID_DOSDEVICES_ONLY: u32 = 1;
pub const PROCESS_HANDLE_EXCEPTIONS_ENABLED: u32 = 1;
pub const PROCESS_HANDLE_RAISE_EXCEPTION_ON_INVALID_HANDLE_CLOSE_DISABLED: u32 = 0;
pub const PROCESS_HANDLE_RAISE_EXCEPTION_ON_INVALID_HANDLE_CLOSE_ENABLED: u32 = 1;
pub const PROCESS_HANDLE_TRACING_MAX_SLOTS: u32 = 131072;
pub const PROCESS_HANDLE_TRACING_MAX_STACKS: u32 = 16;
pub const PROCESS_HANDLE_TRACE_TYPE_OPEN: u32 = 1;
pub const PROCESS_HANDLE_TRACE_TYPE_CLOSE: u32 = 2;
pub const PROCESS_HANDLE_TRACE_TYPE_BADREF: u32 = 3;
pub const PS_PROTECTED_SIGNER_MASK: u32 = 255;
pub const PS_PROTECTED_AUDIT_MASK: u32 = 8;
pub const PS_PROTECTED_TYPE_MASK: u32 = 7;
pub const POWER_THROTTLING_PROCESS_CURRENT_VERSION: u32 = 1;
pub const POWER_THROTTLING_PROCESS_EXECUTION_SPEED: u32 = 1;
pub const POWER_THROTTLING_PROCESS_DELAYTIMERS: u32 = 2;
pub const POWER_THROTTLING_PROCESS_IGNORE_TIMER_RESOLUTION: u32 = 4;
pub const POWER_THROTTLING_PROCESS_VALID_FLAGS: u32 = 7;
pub const WIN32K_SYSCALL_FILTER_STATE_ENABLE: u32 = 1;
pub const WIN32K_SYSCALL_FILTER_STATE_AUDIT: u32 = 2;
pub const POWER_THROTTLING_THREAD_CURRENT_VERSION: u32 = 1;
pub const POWER_THROTTLING_THREAD_EXECUTION_SPEED: u32 = 1;
pub const POWER_THROTTLING_THREAD_VALID_FLAGS: u32 = 1;
pub const PROCESS_READWRITEVM_LOGGING_ENABLE_READVM: u32 = 1;
pub const PROCESS_READWRITEVM_LOGGING_ENABLE_WRITEVM: u32 = 2;
pub const PROCESS_READWRITEVM_LOGGING_ENABLE_READVM_V: u32 = 1;
pub const PROCESS_READWRITEVM_LOGGING_ENABLE_WRITEVM_V: u32 = 2;
pub const PROCESS_CREATE_FLAGS_BREAKAWAY: u32 = 1;
pub const PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT: u32 = 2;
pub const PROCESS_CREATE_FLAGS_INHERIT_HANDLES: u32 = 4;
pub const PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE: u32 = 8;
pub const PROCESS_CREATE_FLAGS_LARGE_PAGES: u32 = 16;
pub const PROCESS_CREATE_FLAGS_LARGE_PAGE_SYSTEM_DLL: u32 = 32;
pub const PROCESS_CREATE_FLAGS_PROTECTED_PROCESS: u32 = 64;
pub const PROCESS_CREATE_FLAGS_CREATE_SESSION: u32 = 128;
pub const PROCESS_CREATE_FLAGS_INHERIT_FROM_PARENT: u32 = 256;
pub const PROCESS_CREATE_FLAGS_SUSPENDED: u32 = 512;
pub const PROCESS_CREATE_FLAGS_FORCE_BREAKAWAY: u32 = 1024;
pub const PROCESS_CREATE_FLAGS_MINIMAL_PROCESS: u32 = 2048;
pub const PROCESS_CREATE_FLAGS_RELEASE_SECTION: u32 = 4096;
pub const PROCESS_CREATE_FLAGS_CLONE_MINIMAL: u32 = 8192;
pub const PROCESS_CREATE_FLAGS_CLONE_MINIMAL_REDUCED_COMMIT: u32 = 16384;
pub const PROCESS_CREATE_FLAGS_AUXILIARY_PROCESS: u32 = 32768;
pub const PROCESS_CREATE_FLAGS_CREATE_STORE: u32 = 131072;
pub const PROCESS_CREATE_FLAGS_USE_PROTECTED_ENVIRONMENT: u32 = 262144;
pub const PROCESS_GET_NEXT_FLAGS_PREVIOUS_PROCESS: u32 = 1;
pub const STATECHANGE_SET_ATTRIBUTES: u32 = 1;
pub const QUEUE_USER_APC_FLAGS_NONE: u32 = 0;
pub const QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC: u32 = 1;
pub const QUEUE_USER_APC_CALLBACK_DATA_CONTEXT: u32 = 65536;
pub const ProcThreadAttributeParentProcess: u32 = 0;
pub const ProcThreadAttributeExtendedFlags: u32 = 1;
pub const ProcThreadAttributeHandleList: u32 = 2;
pub const ProcThreadAttributeGroupAffinity: u32 = 3;
pub const ProcThreadAttributePreferredNode: u32 = 4;
pub const ProcThreadAttributeIdealProcessor: u32 = 5;
pub const ProcThreadAttributeUmsThread: u32 = 6;
pub const ProcThreadAttributeMitigationPolicy: u32 = 7;
pub const ProcThreadAttributePackageFullName: u32 = 8;
pub const ProcThreadAttributeSecurityCapabilities: u32 = 9;
pub const ProcThreadAttributeConsoleReference: u32 = 10;
pub const ProcThreadAttributeProtectionLevel: u32 = 11;
pub const ProcThreadAttributeOsMaxVersionTested: u32 = 12;
pub const ProcThreadAttributeJobList: u32 = 13;
pub const ProcThreadAttributeChildProcessPolicy: u32 = 14;
pub const ProcThreadAttributeAllApplicationPackagesPolicy: u32 = 15;
pub const ProcThreadAttributeWin32kFilter: u32 = 16;
pub const ProcThreadAttributeSafeOpenPromptOriginClaim: u32 = 17;
pub const ProcThreadAttributeDesktopAppPolicy: u32 = 18;
pub const ProcThreadAttributeBnoIsolation: u32 = 19;
pub const ProcThreadAttributePseudoConsole: u32 = 22;
pub const ProcThreadAttributeIsolationManifest: u32 = 23;
pub const ProcThreadAttributeMitigationAuditPolicy: u32 = 24;
pub const ProcThreadAttributeMachineType: u32 = 25;
pub const ProcThreadAttributeComponentFilter: u32 = 26;
pub const ProcThreadAttributeEnableOptionalXStateFeatures: u32 = 27;
pub const ProcThreadAttributeCreateStore: u32 = 28;
pub const ProcThreadAttributeTrustedApp: u32 = 29;
pub const EXTENDED_PROCESS_CREATION_FLAG_ELEVATION_HANDLED: u32 = 1;
pub const EXTENDED_PROCESS_CREATION_FLAG_FORCELUA: u32 = 2;
pub const EXTENDED_PROCESS_CREATION_FLAG_FORCE_BREAKAWAY: u32 = 4;
pub const PS_ATTRIBUTE_NUMBER_MASK: u32 = 65535;
pub const PS_ATTRIBUTE_THREAD: u32 = 65536;
pub const PS_ATTRIBUTE_INPUT: u32 = 131072;
pub const PS_ATTRIBUTE_ADDITIVE: u32 = 262144;
pub const PS_STD_INPUT_HANDLE: u32 = 1;
pub const PS_STD_OUTPUT_HANDLE: u32 = 2;
pub const PS_STD_ERROR_HANDLE: u32 = 4;
pub const THREAD_CREATE_FLAGS_NONE: u32 = 0;
pub const THREAD_CREATE_FLAGS_CREATE_SUSPENDED: u32 = 1;
pub const THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH: u32 = 2;
pub const THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER: u32 = 4;
pub const THREAD_CREATE_FLAGS_LOADER_WORKER: u32 = 16;
pub const THREAD_CREATE_FLAGS_SKIP_LOADER_INIT: u32 = 32;
pub const THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE: u32 = 64;
pub const JobObjectBasicAccountingInformation: u32 = 1;
pub const JobObjectBasicLimitInformation: u32 = 2;
pub const JobObjectBasicProcessIdList: u32 = 3;
pub const JobObjectBasicUIRestrictions: u32 = 4;
pub const JobObjectSecurityLimitInformation: u32 = 5;
pub const JobObjectEndOfJobTimeInformation: u32 = 6;
pub const JobObjectAssociateCompletionPortInformation: u32 = 7;
pub const JobObjectBasicAndIoAccountingInformation: u32 = 8;
pub const JobObjectExtendedLimitInformation: u32 = 9;
pub const JobObjectJobSetInformation: u32 = 10;
pub const JobObjectGroupInformation: u32 = 11;
pub const JobObjectNotificationLimitInformation: u32 = 12;
pub const JobObjectLimitViolationInformation: u32 = 13;
pub const JobObjectGroupInformationEx: u32 = 14;
pub const JobObjectCpuRateControlInformation: u32 = 15;
pub const JobObjectCompletionFilter: u32 = 16;
pub const JobObjectCompletionCounter: u32 = 17;
pub const JobObjectFreezeInformation: u32 = 18;
pub const JobObjectExtendedAccountingInformation: u32 = 19;
pub const JobObjectWakeInformation: u32 = 20;
pub const JobObjectBackgroundInformation: u32 = 21;
pub const JobObjectSchedulingRankBiasInformation: u32 = 22;
pub const JobObjectTimerVirtualizationInformation: u32 = 23;
pub const JobObjectCycleTimeNotification: u32 = 24;
pub const JobObjectClearEvent: u32 = 25;
pub const JobObjectInterferenceInformation: u32 = 26;
pub const JobObjectClearPeakJobMemoryUsed: u32 = 27;
pub const JobObjectMemoryUsageInformation: u32 = 28;
pub const JobObjectSharedCommit: u32 = 29;
pub const JobObjectContainerId: u32 = 30;
pub const JobObjectIoRateControlInformation: u32 = 31;
pub const JobObjectNetRateControlInformation: u32 = 32;
pub const JobObjectNotificationLimitInformation2: u32 = 33;
pub const JobObjectLimitViolationInformation2: u32 = 34;
pub const JobObjectCreateSilo: u32 = 35;
pub const JobObjectSiloBasicInformation: u32 = 36;
pub const JobObjectSiloRootDirectory: u32 = 37;
pub const JobObjectServerSiloBasicInformation: u32 = 38;
pub const JobObjectServerSiloUserSharedData: u32 = 39;
pub const JobObjectServerSiloInitialize: u32 = 40;
pub const JobObjectServerSiloRunningState: u32 = 41;
pub const JobObjectIoAttribution: u32 = 42;
pub const JobObjectMemoryPartitionInformation: u32 = 43;
pub const JobObjectContainerTelemetryId: u32 = 44;
pub const JobObjectSiloSystemRoot: u32 = 45;
pub const JobObjectEnergyTrackingState: u32 = 46;
pub const JobObjectThreadImpersonationInformation: u32 = 47;
pub const JobObjectIoPriorityLimit: u32 = 48;
pub const JobObjectPagePriorityLimit: u32 = 49;
pub const MaxJobObjectInfoClass: u32 = 50;
pub const JOB_OBJECT_LIMIT_SILO_READY: u32 = 4194304;
pub const SILO_OBJECT_ROOT_DIRECTORY_SHADOW_ROOT: u32 = 1;
pub const SILO_OBJECT_ROOT_DIRECTORY_INITIALIZE: u32 = 2;
pub const SILO_OBJECT_ROOT_DIRECTORY_SHADOW_DOS_DEVICES: u32 = 4;
pub const MEMORY_BULK_INFORMATION_FLAG_BASIC: u32 = 1;
pub const DBG_STATUS_CONTROL_C: u32 = 1;
pub const DBG_STATUS_SYSRQ: u32 = 2;
pub const DBG_STATUS_BUGCHECK_FIRST: u32 = 3;
pub const DBG_STATUS_BUGCHECK_SECOND: u32 = 4;
pub const DBG_STATUS_FATAL: u32 = 5;
pub const DBG_STATUS_DEBUG_CONTROL: u32 = 6;
pub const DBG_STATUS_WORKER: u32 = 7;
pub const DEBUG_READ_EVENT: u32 = 1;
pub const DEBUG_PROCESS_ASSIGN: u32 = 2;
pub const DEBUG_SET_INFORMATION: u32 = 4;
pub const DEBUG_QUERY_INFORMATION: u32 = 8;
pub const DEBUG_ALL_ACCESS: u32 = 2031631;
pub const DEBUG_KILL_ON_CLOSE: u32 = 1;
pub const FILE_SUPERSEDE: u32 = 0;
pub const FILE_OPEN: u32 = 1;
pub const FILE_CREATE: u32 = 2;
pub const FILE_OPEN_IF: u32 = 3;
pub const FILE_OVERWRITE: u32 = 4;
pub const FILE_OVERWRITE_IF: u32 = 5;
pub const FILE_MAXIMUM_DISPOSITION: u32 = 5;
pub const FILE_DIRECTORY_FILE: u32 = 1;
pub const FILE_WRITE_THROUGH: u32 = 2;
pub const FILE_SEQUENTIAL_ONLY: u32 = 4;
pub const FILE_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FILE_SYNCHRONOUS_IO_ALERT: u32 = 16;
pub const FILE_SYNCHRONOUS_IO_NONALERT: u32 = 32;
pub const FILE_NON_DIRECTORY_FILE: u32 = 64;
pub const FILE_CREATE_TREE_CONNECTION: u32 = 128;
pub const TREE_CONNECT_NO_CLIENT_BUFFERING: u32 = 8;
pub const TREE_CONNECT_WRITE_THROUGH: u32 = 2;
pub const FILE_COMPLETE_IF_OPLOCKED: u32 = 256;
pub const FILE_NO_EA_KNOWLEDGE: u32 = 512;
pub const FILE_OPEN_REMOTE_INSTANCE: u32 = 1024;
pub const FILE_RANDOM_ACCESS: u32 = 2048;
pub const FILE_DELETE_ON_CLOSE: u32 = 4096;
pub const FILE_OPEN_BY_FILE_ID: u32 = 8192;
pub const FILE_OPEN_FOR_BACKUP_INTENT: u32 = 16384;
pub const FILE_NO_COMPRESSION: u32 = 32768;
pub const FILE_OPEN_REQUIRING_OPLOCK: u32 = 65536;
pub const FILE_DISALLOW_EXCLUSIVE: u32 = 131072;
pub const FILE_SESSION_AWARE: u32 = 262144;
pub const FILE_RESERVE_OPFILTER: u32 = 1048576;
pub const FILE_OPEN_REPARSE_POINT: u32 = 2097152;
pub const FILE_OPEN_NO_RECALL: u32 = 4194304;
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: u32 = 8388608;
pub const FILE_CONTAINS_EXTENDED_CREATE_INFORMATION: u32 = 268435456;
pub const FILE_VALID_EXTENDED_OPTION_FLAGS: u32 = 268435456;
pub const EX_CREATE_FLAG_FILE_SOURCE_OPEN_FOR_COPY: u32 = 1;
pub const EX_CREATE_FLAG_FILE_DEST_OPEN_FOR_COPY: u32 = 2;
pub const FILE_VALID_OPTION_FLAGS: u32 = 16777215;
pub const FILE_VALID_PIPE_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_SET_FLAGS: u32 = 54;
pub const FILE_COPY_STRUCTURED_STORAGE: u32 = 65;
pub const FILE_STRUCTURED_STORAGE: u32 = 1089;
pub const FILE_SUPERSEDED: u32 = 0;
pub const FILE_OPENED: u32 = 1;
pub const FILE_CREATED: u32 = 2;
pub const FILE_OVERWRITTEN: u32 = 3;
pub const FILE_EXISTS: u32 = 4;
pub const FILE_DOES_NOT_EXIST: u32 = 5;
pub const FILE_WRITE_TO_END_OF_FILE: u32 = 4294967295;
pub const FILE_USE_FILE_POINTER_POSITION: u32 = 4294967294;
pub const FILE_BYTE_ALIGNMENT: u32 = 0;
pub const FILE_WORD_ALIGNMENT: u32 = 1;
pub const FILE_LONG_ALIGNMENT: u32 = 3;
pub const FILE_QUAD_ALIGNMENT: u32 = 7;
pub const FILE_OCTA_ALIGNMENT: u32 = 15;
pub const FILE_32_BYTE_ALIGNMENT: u32 = 31;
pub const FILE_64_BYTE_ALIGNMENT: u32 = 63;
pub const FILE_128_BYTE_ALIGNMENT: u32 = 127;
pub const FILE_256_BYTE_ALIGNMENT: u32 = 255;
pub const FILE_512_BYTE_ALIGNMENT: u32 = 511;
pub const DOS_MAX_COMPONENT_LENGTH: u32 = 255;
pub const DOS_MAX_PATH_LENGTH: u32 = 260;
pub const MAXIMUM_FILENAME_LENGTH: u32 = 256;
pub const FILE_NEED_EA: u32 = 128;
pub const FILE_EA_TYPE_BINARY: u32 = 65534;
pub const FILE_EA_TYPE_ASCII: u32 = 65533;
pub const FILE_EA_TYPE_BITMAP: u32 = 65531;
pub const FILE_EA_TYPE_METAFILE: u32 = 65530;
pub const FILE_EA_TYPE_ICON: u32 = 65529;
pub const FILE_EA_TYPE_EA: u32 = 65518;
pub const FILE_EA_TYPE_MVMT: u32 = 65503;
pub const FILE_EA_TYPE_MVST: u32 = 65502;
pub const FILE_EA_TYPE_ASN1: u32 = 65501;
pub const FILE_EA_TYPE_FAMILY_IDS: u32 = 65281;
pub const FILE_REMOVABLE_MEDIA: u32 = 1;
pub const FILE_READ_ONLY_DEVICE: u32 = 2;
pub const FILE_FLOPPY_DISKETTE: u32 = 4;
pub const FILE_WRITE_ONCE_MEDIA: u32 = 8;
pub const FILE_REMOTE_DEVICE: u32 = 16;
pub const FILE_DEVICE_IS_MOUNTED: u32 = 32;
pub const FILE_VIRTUAL_VOLUME: u32 = 64;
pub const FILE_AUTOGENERATED_DEVICE_NAME: u32 = 128;
pub const FILE_DEVICE_SECURE_OPEN: u32 = 256;
pub const FILE_CHARACTERISTIC_PNP_DEVICE: u32 = 2048;
pub const FILE_CHARACTERISTIC_TS_DEVICE: u32 = 4096;
pub const FILE_CHARACTERISTIC_WEBDAV_DEVICE: u32 = 8192;
pub const FILE_CHARACTERISTIC_CSV: u32 = 65536;
pub const FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL: u32 = 131072;
pub const FILE_PORTABLE_DEVICE: u32 = 262144;
pub const FILE_REMOTE_DEVICE_VSMB: u32 = 524288;
pub const FILE_DEVICE_REQUIRE_SECURITY_CHECK: u32 = 1048576;
pub const FILE_PIPE_BYTE_STREAM_TYPE: u32 = 0;
pub const FILE_PIPE_MESSAGE_TYPE: u32 = 1;
pub const FILE_PIPE_ACCEPT_REMOTE_CLIENTS: u32 = 0;
pub const FILE_PIPE_REJECT_REMOTE_CLIENTS: u32 = 2;
pub const FILE_PIPE_TYPE_VALID_MASK: u32 = 3;
pub const FILE_PIPE_QUEUE_OPERATION: u32 = 0;
pub const FILE_PIPE_COMPLETE_OPERATION: u32 = 1;
pub const FILE_PIPE_BYTE_STREAM_MODE: u32 = 0;
pub const FILE_PIPE_MESSAGE_MODE: u32 = 1;
pub const FILE_PIPE_INBOUND: u32 = 0;
pub const FILE_PIPE_OUTBOUND: u32 = 1;
pub const FILE_PIPE_FULL_DUPLEX: u32 = 2;
pub const FILE_PIPE_DISCONNECTED_STATE: u32 = 1;
pub const FILE_PIPE_LISTENING_STATE: u32 = 2;
pub const FILE_PIPE_CONNECTED_STATE: u32 = 3;
pub const FILE_PIPE_CLOSING_STATE: u32 = 4;
pub const FILE_PIPE_CLIENT_END: u32 = 0;
pub const FILE_PIPE_SERVER_END: u32 = 1;
pub const FILE_PIPE_UNLIMITED_INSTANCES: u32 = 4294967295;
pub const MAILSLOT_SIZE_AUTO: u32 = 0;
pub const FLAGS_END_OF_FILE_INFO_EX_EXTEND_PAGING: u32 = 1;
pub const FLAGS_END_OF_FILE_INFO_EX_NO_EXTRA_PAGING_EXTEND: u32 = 2;
pub const FLAGS_END_OF_FILE_INFO_EX_TIME_CONSTRAINED: u32 = 4;
pub const FLAGS_DELAY_REASONS_LOG_FILE_FULL: u32 = 1;
pub const FLAGS_DELAY_REASONS_BITMAP_SCANNED: u32 = 2;
pub const FILE_LINK_REPLACE_IF_EXISTS: u32 = 1;
pub const FILE_LINK_POSIX_SEMANTICS: u32 = 2;
pub const FILE_LINK_SUPPRESS_STORAGE_RESERVE_INHERITANCE: u32 = 8;
pub const FILE_LINK_NO_INCREASE_AVAILABLE_SPACE: u32 = 16;
pub const FILE_LINK_NO_DECREASE_AVAILABLE_SPACE: u32 = 32;
pub const FILE_LINK_PRESERVE_AVAILABLE_SPACE: u32 = 48;
pub const FILE_LINK_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const FILE_LINK_FORCE_RESIZE_TARGET_SR: u32 = 128;
pub const FILE_LINK_FORCE_RESIZE_SOURCE_SR: u32 = 256;
pub const FILE_LINK_FORCE_RESIZE_SR: u32 = 384;
pub const FILE_RENAME_REPLACE_IF_EXISTS: u32 = 1;
pub const FILE_RENAME_POSIX_SEMANTICS: u32 = 2;
pub const FILE_RENAME_SUPPRESS_PIN_STATE_INHERITANCE: u32 = 4;
pub const FILE_RENAME_SUPPRESS_STORAGE_RESERVE_INHERITANCE: u32 = 8;
pub const FILE_RENAME_NO_INCREASE_AVAILABLE_SPACE: u32 = 16;
pub const FILE_RENAME_NO_DECREASE_AVAILABLE_SPACE: u32 = 32;
pub const FILE_RENAME_PRESERVE_AVAILABLE_SPACE: u32 = 48;
pub const FILE_RENAME_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const FILE_RENAME_FORCE_RESIZE_TARGET_SR: u32 = 128;
pub const FILE_RENAME_FORCE_RESIZE_SOURCE_SR: u32 = 256;
pub const FILE_RENAME_FORCE_RESIZE_SR: u32 = 384;
pub const FILE_SKIP_SET_USER_EVENT_ON_FAST_IO: u32 = 4;
pub const CHECKSUM_ENFORCEMENT_OFF: u32 = 1;
pub const LX_FILE_METADATA_HAS_UID: u32 = 1;
pub const LX_FILE_METADATA_HAS_GID: u32 = 2;
pub const LX_FILE_METADATA_HAS_MODE: u32 = 4;
pub const LX_FILE_METADATA_HAS_DEVICE_ID: u32 = 8;
pub const LX_FILE_CASE_SENSITIVE_DIR: u32 = 16;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_WRITELOCKED: u32 = 1;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_TO_TX: u32 = 2;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_OUTSIDE_TX: u32 = 4;
pub const FILE_VC_QUOTA_NONE: u32 = 0;
pub const FILE_VC_QUOTA_TRACK: u32 = 1;
pub const FILE_VC_QUOTA_ENFORCE: u32 = 2;
pub const FILE_VC_QUOTA_MASK: u32 = 3;
pub const FILE_VC_CONTENT_INDEX_DISABLED: u32 = 8;
pub const FILE_VC_LOG_QUOTA_THRESHOLD: u32 = 16;
pub const FILE_VC_LOG_QUOTA_LIMIT: u32 = 32;
pub const FILE_VC_LOG_VOLUME_THRESHOLD: u32 = 64;
pub const FILE_VC_LOG_VOLUME_LIMIT: u32 = 128;
pub const FILE_VC_QUOTAS_INCOMPLETE: u32 = 256;
pub const FILE_VC_QUOTAS_REBUILDING: u32 = 512;
pub const FILE_VC_VALID_MASK: u32 = 1023;
pub const SSINFO_FLAGS_ALIGNED_DEVICE: u32 = 1;
pub const SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE: u32 = 2;
pub const SSINFO_FLAGS_NO_SEEK_PENALTY: u32 = 4;
pub const SSINFO_FLAGS_TRIM_ENABLED: u32 = 8;
pub const SSINFO_FLAGS_BYTE_ADDRESSABLE: u32 = 16;
pub const SSINFO_OFFSET_UNKNOWN: u32 = 4294967295;
pub const FILE_QUERY_RESTART_SCAN: u32 = 1;
pub const FILE_QUERY_RETURN_SINGLE_ENTRY: u32 = 2;
pub const FILE_QUERY_INDEX_SPECIFIED: u32 = 4;
pub const FILE_QUERY_RETURN_ON_DISK_ENTRIES_ONLY: u32 = 8;
pub const FILE_QUERY_NO_CURSOR_UPDATE: u32 = 16;
pub const IO_COMPLETION_QUERY_STATE: u32 = 1;
pub const SYMLINK_FLAG_RELATIVE: u32 = 1;
pub const SYMLINK_DIRECTORY: u32 = 2147483648;
pub const SYMLINK_FILE: u32 = 1073741824;
pub const REPARSE_DATA_EX_FLAG_GIVEN_TAG_OR_NONE: u32 = 1;
pub const DEVICE_NAMED_PIPE: &[u8; 19] = b"\\Device\\NamedPipe\\\0";
pub const FILE_PIPE_READ_DATA: u32 = 0;
pub const FILE_PIPE_WRITE_SPACE: u32 = 1;
pub const FILE_PIPE_COMPUTER_NAME_LENGTH: u32 = 15;
pub const FILE_PIPE_SYMLINK_FLAG_GLOBAL: u32 = 1;
pub const FILE_PIPE_SYMLINK_FLAG_RELATIVE: u32 = 2;
pub const FILE_PIPE_SYMLINK_VALID_FLAGS: u32 = 3;
pub const MAILSLOT_CLASS_FIRSTCLASS: u32 = 1;
pub const MAILSLOT_CLASS_SECONDCLASS: u32 = 2;
pub const MOUNTMGR_DEVICE_NAME: &[u8; 26] = b"\\Device\\MountPointManager\0";
pub const MOUNTMGRCONTROLTYPE: u32 = 109;
pub const MOUNTDEVCONTROLTYPE: u32 = 77;
pub const IRP_MJ_CREATE: u32 = 0;
pub const IRP_MJ_CREATE_NAMED_PIPE: u32 = 1;
pub const IRP_MJ_CLOSE: u32 = 2;
pub const IRP_MJ_READ: u32 = 3;
pub const IRP_MJ_WRITE: u32 = 4;
pub const IRP_MJ_QUERY_INFORMATION: u32 = 5;
pub const IRP_MJ_SET_INFORMATION: u32 = 6;
pub const IRP_MJ_QUERY_EA: u32 = 7;
pub const IRP_MJ_SET_EA: u32 = 8;
pub const IRP_MJ_FLUSH_BUFFERS: u32 = 9;
pub const IRP_MJ_QUERY_VOLUME_INFORMATION: u32 = 10;
pub const IRP_MJ_SET_VOLUME_INFORMATION: u32 = 11;
pub const IRP_MJ_DIRECTORY_CONTROL: u32 = 12;
pub const IRP_MJ_FILE_SYSTEM_CONTROL: u32 = 13;
pub const IRP_MJ_DEVICE_CONTROL: u32 = 14;
pub const IRP_MJ_INTERNAL_DEVICE_CONTROL: u32 = 15;
pub const IRP_MJ_SHUTDOWN: u32 = 16;
pub const IRP_MJ_LOCK_CONTROL: u32 = 17;
pub const IRP_MJ_CLEANUP: u32 = 18;
pub const IRP_MJ_CREATE_MAILSLOT: u32 = 19;
pub const IRP_MJ_QUERY_SECURITY: u32 = 20;
pub const IRP_MJ_SET_SECURITY: u32 = 21;
pub const IRP_MJ_POWER: u32 = 22;
pub const IRP_MJ_SYSTEM_CONTROL: u32 = 23;
pub const IRP_MJ_DEVICE_CHANGE: u32 = 24;
pub const IRP_MJ_QUERY_QUOTA: u32 = 25;
pub const IRP_MJ_SET_QUOTA: u32 = 26;
pub const IRP_MJ_PNP: u32 = 27;
pub const IRP_MJ_PNP_POWER: u32 = 27;
pub const IRP_MJ_MAXIMUM_FUNCTION: u32 = 27;
pub const FLT_INTERNAL_OPERATION_COUNT: u32 = 22;
pub const IRP_MN_SCSI_CLASS: u32 = 1;
pub const IRP_MN_START_DEVICE: u32 = 0;
pub const IRP_MN_QUERY_REMOVE_DEVICE: u32 = 1;
pub const IRP_MN_REMOVE_DEVICE: u32 = 2;
pub const IRP_MN_CANCEL_REMOVE_DEVICE: u32 = 3;
pub const IRP_MN_STOP_DEVICE: u32 = 4;
pub const IRP_MN_QUERY_STOP_DEVICE: u32 = 5;
pub const IRP_MN_CANCEL_STOP_DEVICE: u32 = 6;
pub const IRP_MN_QUERY_DEVICE_RELATIONS: u32 = 7;
pub const IRP_MN_QUERY_INTERFACE: u32 = 8;
pub const IRP_MN_QUERY_CAPABILITIES: u32 = 9;
pub const IRP_MN_QUERY_RESOURCES: u32 = 10;
pub const IRP_MN_QUERY_RESOURCE_REQUIREMENTS: u32 = 11;
pub const IRP_MN_QUERY_DEVICE_TEXT: u32 = 12;
pub const IRP_MN_FILTER_RESOURCE_REQUIREMENTS: u32 = 13;
pub const IRP_MN_READ_CONFIG: u32 = 15;
pub const IRP_MN_WRITE_CONFIG: u32 = 16;
pub const IRP_MN_EJECT: u32 = 17;
pub const IRP_MN_SET_LOCK: u32 = 18;
pub const IRP_MN_QUERY_ID: u32 = 19;
pub const IRP_MN_QUERY_PNP_DEVICE_STATE: u32 = 20;
pub const IRP_MN_QUERY_BUS_INFORMATION: u32 = 21;
pub const IRP_MN_DEVICE_USAGE_NOTIFICATION: u32 = 22;
pub const IRP_MN_SURPRISE_REMOVAL: u32 = 23;
pub const IRP_MN_DEVICE_ENUMERATED: u32 = 25;
pub const IRP_MN_WAIT_WAKE: u32 = 0;
pub const IRP_MN_POWER_SEQUENCE: u32 = 1;
pub const IRP_MN_SET_POWER: u32 = 2;
pub const IRP_MN_QUERY_POWER: u32 = 3;
pub const IRP_MN_QUERY_ALL_DATA: u32 = 0;
pub const IRP_MN_QUERY_SINGLE_INSTANCE: u32 = 1;
pub const IRP_MN_CHANGE_SINGLE_INSTANCE: u32 = 2;
pub const IRP_MN_CHANGE_SINGLE_ITEM: u32 = 3;
pub const IRP_MN_ENABLE_EVENTS: u32 = 4;
pub const IRP_MN_DISABLE_EVENTS: u32 = 5;
pub const IRP_MN_ENABLE_COLLECTION: u32 = 6;
pub const IRP_MN_DISABLE_COLLECTION: u32 = 7;
pub const IRP_MN_REGINFO: u32 = 8;
pub const IRP_MN_EXECUTE_METHOD: u32 = 9;
pub const IRP_MN_REGINFO_EX: u32 = 11;
pub const FLTFL_CALLBACK_DATA_REISSUE_MASK: u32 = 65535;
pub const FLTFL_CALLBACK_DATA_IRP_OPERATION: u32 = 1;
pub const FLTFL_CALLBACK_DATA_FAST_IO_OPERATION: u32 = 2;
pub const FLTFL_CALLBACK_DATA_FS_FILTER_OPERATION: u32 = 4;
pub const FLTFL_CALLBACK_DATA_SYSTEM_BUFFER: u32 = 8;
pub const FLTFL_CALLBACK_DATA_GENERATED_IO: u32 = 65536;
pub const FLTFL_CALLBACK_DATA_REISSUED_IO: u32 = 131072;
pub const FLTFL_CALLBACK_DATA_DRAINING_IO: u32 = 262144;
pub const FLTFL_CALLBACK_DATA_POST_OPERATION: u32 = 524288;
pub const FLTFL_CALLBACK_DATA_NEW_SYSTEM_BUFFER: u32 = 1048576;
pub const FLTFL_CALLBACK_DATA_DIRTY: u32 = 2147483648;
pub const IRP_NOCACHE: u32 = 1;
pub const IRP_PAGING_IO: u32 = 2;
pub const IRP_MOUNT_COMPLETION: u32 = 2;
pub const IRP_SYNCHRONOUS_API: u32 = 4;
pub const IRP_ASSOCIATED_IRP: u32 = 8;
pub const IRP_BUFFERED_IO: u32 = 16;
pub const IRP_DEALLOCATE_BUFFER: u32 = 32;
pub const IRP_INPUT_OPERATION: u32 = 64;
pub const IRP_SYNCHRONOUS_PAGING_IO: u32 = 64;
pub const IRP_CREATE_OPERATION: u32 = 128;
pub const IRP_READ_OPERATION: u32 = 256;
pub const IRP_WRITE_OPERATION: u32 = 512;
pub const IRP_CLOSE_OPERATION: u32 = 1024;
pub const IRP_DEFER_IO_COMPLETION: u32 = 2048;
pub const IRP_OB_QUERY_NAME: u32 = 4096;
pub const IRP_HOLD_DEVICE_QUEUE: u32 = 8192;
pub const IRP_UM_DRIVER_INITIATED_IO: u32 = 4194304;
pub const FO_FILE_OPEN: u32 = 1;
pub const FO_SYNCHRONOUS_IO: u32 = 2;
pub const FO_ALERTABLE_IO: u32 = 4;
pub const FO_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FO_WRITE_THROUGH: u32 = 16;
pub const FO_SEQUENTIAL_ONLY: u32 = 32;
pub const FO_CACHE_SUPPORTED: u32 = 64;
pub const FO_NAMED_PIPE: u32 = 128;
pub const FO_STREAM_FILE: u32 = 256;
pub const FO_MAILSLOT: u32 = 512;
pub const FO_GENERATE_AUDIT_ON_CLOSE: u32 = 1024;
pub const FO_QUEUE_IRP_TO_THREAD: u32 = 1024;
pub const FO_DIRECT_DEVICE_OPEN: u32 = 2048;
pub const FO_FILE_MODIFIED: u32 = 4096;
pub const FO_FILE_SIZE_CHANGED: u32 = 8192;
pub const FO_CLEANUP_COMPLETE: u32 = 16384;
pub const FO_TEMPORARY_FILE: u32 = 32768;
pub const FO_DELETE_ON_CLOSE: u32 = 65536;
pub const FO_OPENED_CASE_SENSITIVE: u32 = 131072;
pub const FO_HANDLE_CREATED: u32 = 262144;
pub const FO_FILE_FAST_IO_READ: u32 = 524288;
pub const FO_RANDOM_ACCESS: u32 = 1048576;
pub const FO_FILE_OPEN_CANCELLED: u32 = 2097152;
pub const FO_VOLUME_OPEN: u32 = 4194304;
pub const FO_BYPASS_IO_ENABLED: u32 = 8388608;
pub const FO_REMOTE_ORIGIN: u32 = 16777216;
pub const FO_DISALLOW_EXCLUSIVE: u32 = 33554432;
pub const FO_SKIP_COMPLETION_PORT: u32 = 33554432;
pub const FO_SKIP_SET_EVENT: u32 = 67108864;
pub const FO_SKIP_SET_FAST_IO: u32 = 134217728;
pub const FO_INDIRECT_WAIT_OBJECT: u32 = 268435456;
pub const FO_SECTION_MINSTORE_TREATMENT: u32 = 536870912;
pub const SL_PENDING_RETURNED: u32 = 1;
pub const SL_ERROR_RETURNED: u32 = 2;
pub const SL_INVOKE_ON_CANCEL: u32 = 32;
pub const SL_INVOKE_ON_SUCCESS: u32 = 64;
pub const SL_INVOKE_ON_ERROR: u32 = 128;
pub const SL_FORCE_ACCESS_CHECK: u32 = 1;
pub const SL_OPEN_PAGING_FILE: u32 = 2;
pub const SL_OPEN_TARGET_DIRECTORY: u32 = 4;
pub const SL_STOP_ON_SYMLINK: u32 = 8;
pub const SL_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const SL_CASE_SENSITIVE: u32 = 128;
pub const SL_KEY_SPECIFIED: u32 = 1;
pub const SL_OVERRIDE_VERIFY_VOLUME: u32 = 2;
pub const SL_WRITE_THROUGH: u32 = 4;
pub const SL_FT_SEQUENTIAL_WRITE: u32 = 8;
pub const SL_FORCE_DIRECT_WRITE: u32 = 16;
pub const SL_REALTIME_STREAM: u32 = 32;
pub const SL_PERSISTENT_MEMORY_FIXED_MAPPING: u32 = 32;
pub const SL_BYPASS_IO: u32 = 64;
pub const SL_FORCE_ASYNCHRONOUS: u32 = 1;
pub const SL_READ_ACCESS_GRANTED: u32 = 1;
pub const SL_WRITE_ACCESS_GRANTED: u32 = 4;
pub const SL_FAIL_IMMEDIATELY: u32 = 1;
pub const SL_EXCLUSIVE_LOCK: u32 = 2;
pub const SL_RESTART_SCAN: u32 = 1;
pub const SL_RETURN_SINGLE_ENTRY: u32 = 2;
pub const SL_INDEX_SPECIFIED: u32 = 4;
pub const SL_RETURN_ON_DISK_ENTRIES_ONLY: u32 = 8;
pub const SL_NO_CURSOR_UPDATE: u32 = 16;
pub const SL_QUERY_DIRECTORY_MASK: u32 = 27;
pub const SL_WATCH_TREE: u32 = 1;
pub const SL_ALLOW_RAW_MOUNT: u32 = 1;
pub const SL_BYPASS_ACCESS_CHECK: u32 = 1;
pub const SL_INFO_FORCE_ACCESS_CHECK: u32 = 1;
pub const SL_INFO_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const DO_VERIFY_VOLUME: u32 = 2;
pub const DO_BUFFERED_IO: u32 = 4;
pub const DO_EXCLUSIVE: u32 = 8;
pub const DO_DIRECT_IO: u32 = 16;
pub const DO_MAP_IO_BUFFER: u32 = 32;
pub const DO_DEVICE_INITIALIZING: u32 = 128;
pub const DO_SHUTDOWN_REGISTERED: u32 = 2048;
pub const DO_BUS_ENUMERATED_DEVICE: u32 = 4096;
pub const DO_POWER_PAGABLE: u32 = 8192;
pub const DO_POWER_INRUSH: u32 = 16384;
pub const DO_DEVICE_TO_BE_RESET: u32 = 67108864;
pub const DO_DAX_VOLUME: u32 = 268435456;
pub const KSEC_DEVICE_NAME: &[u8; 15] = b"\\Device\\KSecDD\0";
pub const OPLOCK_KEY_VERSION_WIN7: u32 = 1;
pub const OPLOCK_KEY_VERSION_WIN8: u32 = 2;
pub const OPLOCK_KEY_FLAG_PARENT_KEY: u32 = 1;
pub const OPLOCK_KEY_FLAG_TARGET_KEY: u32 = 2;
pub const PORT_CONNECT: u32 = 1;
pub const PORT_ALL_ACCESS: u32 = 2031617;
pub const LPC_REQUEST: u32 = 1;
pub const LPC_REPLY: u32 = 2;
pub const LPC_DATAGRAM: u32 = 3;
pub const LPC_LOST_REPLY: u32 = 4;
pub const LPC_PORT_CLOSED: u32 = 5;
pub const LPC_CLIENT_DIED: u32 = 6;
pub const LPC_EXCEPTION: u32 = 7;
pub const LPC_DEBUG_EVENT: u32 = 8;
pub const LPC_ERROR_EVENT: u32 = 9;
pub const LPC_CONNECTION_REQUEST: u32 = 10;
pub const LPC_CONTINUATION_REQUIRED: u32 = 8192;
pub const PORT_VALID_OBJECT_ATTRIBUTES: u32 = 64;
pub const PORT_MAXIMUM_MESSAGE_LENGTH: u32 = 512;
pub const ALPC_PORFLG_LPC_MODE: u32 = 4096;
pub const ALPC_PORFLG_ALLOW_IMPERSONATION: u32 = 65536;
pub const ALPC_PORFLG_ALLOW_LPC_REQUESTS: u32 = 131072;
pub const ALPC_PORFLG_WAITABLE_PORT: u32 = 262144;
pub const ALPC_PORFLG_ALLOW_DUP_OBJECT: u32 = 524288;
pub const ALPC_PORFLG_SYSTEM_PROCESS: u32 = 1048576;
pub const ALPC_PORFLG_WAKE_POLICY1: u32 = 2097152;
pub const ALPC_PORFLG_WAKE_POLICY2: u32 = 4194304;
pub const ALPC_PORFLG_WAKE_POLICY3: u32 = 8388608;
pub const ALPC_PORFLG_DIRECT_MESSAGE: u32 = 16777216;
pub const ALPC_PORFLG_ALLOW_MULTIHANDLE_ATTRIBUTE: u32 = 33554432;
pub const ALPC_PORFLG_OBJECT_TYPE_FILE: u32 = 1;
pub const ALPC_PORFLG_OBJECT_TYPE_INVALID: u32 = 2;
pub const ALPC_PORFLG_OBJECT_TYPE_THREAD: u32 = 4;
pub const ALPC_PORFLG_OBJECT_TYPE_SEMAPHORE: u32 = 8;
pub const ALPC_PORFLG_OBJECT_TYPE_EVENT: u32 = 16;
pub const ALPC_PORFLG_OBJECT_TYPE_PROCESS: u32 = 32;
pub const ALPC_PORFLG_OBJECT_TYPE_MUTEX: u32 = 64;
pub const ALPC_PORFLG_OBJECT_TYPE_SECTION: u32 = 128;
pub const ALPC_PORFLG_OBJECT_TYPE_REGKEY: u32 = 256;
pub const ALPC_PORFLG_OBJECT_TYPE_TOKEN: u32 = 512;
pub const ALPC_PORFLG_OBJECT_TYPE_COMPOSITION: u32 = 1024;
pub const ALPC_PORFLG_OBJECT_TYPE_JOB: u32 = 2048;
pub const ALPC_PORFLG_OBJECT_TYPE_ALL: u32 = 4093;
pub const ALPC_MESSAGE_SECURITY_ATTRIBUTE: u32 = 2147483648;
pub const ALPC_MESSAGE_VIEW_ATTRIBUTE: u32 = 1073741824;
pub const ALPC_MESSAGE_CONTEXT_ATTRIBUTE: u32 = 536870912;
pub const ALPC_MESSAGE_HANDLE_ATTRIBUTE: u32 = 268435456;
pub const ALPC_COMPLETION_LIST_BUFFER_GRANULARITY_MASK: u32 = 63;
pub const ALPC_HANDLEFLG_DUPLICATE_SAME_ACCESS: u32 = 65536;
pub const ALPC_HANDLEFLG_DUPLICATE_SAME_ATTRIBUTES: u32 = 131072;
pub const ALPC_HANDLEFLG_DUPLICATE_INHERIT: u32 = 524288;
pub const ALPC_SECFLG_CREATE_HANDLE: u32 = 131072;
pub const ALPC_SECFLG_NOSECTIONHANDLE: u32 = 262144;
pub const ALPC_VIEWFLG_NOT_SECURE: u32 = 262144;
pub const ALPC_CREATEPORTSECTIONFLG_SECURE: u32 = 262144;
pub const ALPC_MSGFLG_REPLY_MESSAGE: u32 = 1;
pub const ALPC_MSGFLG_LPC_MODE: u32 = 2;
pub const ALPC_MSGFLG_RELEASE_MESSAGE: u32 = 65536;
pub const ALPC_MSGFLG_SYNC_REQUEST: u32 = 131072;
pub const ALPC_MSGFLG_TRACK_PORT_REFERENCES: u32 = 262144;
pub const ALPC_MSGFLG_WAIT_USER_MODE: u32 = 1048576;
pub const ALPC_MSGFLG_WAIT_ALERTABLE: u32 = 2097152;
pub const ALPC_MSGFLG_WOW64_CALL: u32 = 2147483648;
pub const ALPC_CANCELFLG_TRY_CANCEL: u32 = 1;
pub const ALPC_CANCELFLG_NO_CONTEXT_CHECK: u32 = 8;
pub const ALPC_CANCELFLGP_FLUSH: u32 = 65536;
pub const ALPC_IMPERSONATEFLG_ANONYMOUS: u32 = 1;
pub const ALPC_IMPERSONATEFLG_REQUIRE_IMPERSONATE: u32 = 2;
pub const ALPC_ATTRFLG_ALLOCATEDATTR: u32 = 536870912;
pub const ALPC_ATTRFLG_VALIDATTR: u32 = 1073741824;
pub const ALPC_ATTRFLG_KEEPRUNNINGATTR: u32 = 1610612736;
pub const PF_BOOT_CONTROL_VERSION: u32 = 1;
pub const PREFETCHER_INFORMATION_VERSION: u32 = 23;
pub const PF_PFN_PRIO_REQUEST_VERSION: u32 = 1;
pub const PF_PFN_PRIO_REQUEST_QUERY_MEMORY_LIST: u32 = 1;
pub const PF_PFN_PRIO_REQUEST_VALID_FLAGS: u32 = 1;
pub const PF_PRIVSOURCE_QUERY_REQUEST_VERSION: u32 = 8;
pub const PF_PRIVSOURCE_QUERY_REQUEST_FLAGS_QUERYWSPAGES: u32 = 1;
pub const PF_PRIVSOURCE_QUERY_REQUEST_FLAGS_QUERYCOMPRESSEDPAGES: u32 = 2;
pub const PF_PRIVSOURCE_QUERY_REQUEST_FLAGS_QUERYSKIPPAGES: u32 = 4;
pub const PF_SCENARIO_PHASE_INFO_VERSION: u32 = 4;
pub const PF_ROBUSTNESS_CONTROL_VERSION: u32 = 1;
pub const PF_MEMORY_LIST_INFO_VERSION: u32 = 1;
pub const PF_PHYSICAL_MEMORY_RANGE_INFO_V1_VERSION: u32 = 1;
pub const PF_PHYSICAL_MEMORY_RANGE_INFO_V2_VERSION: u32 = 2;
pub const PF_REPURPOSED_BY_PREFETCH_INFO_VERSION: u32 = 1;
pub const PF_VIRTUAL_QUERY_VERSION: u32 = 1;
pub const PF_MIN_WS_AGE_RATE_CONTROL_VERSION: u32 = 1;
pub const PF_DEPRIORITIZE_OLD_PAGES_VERSION: u32 = 3;
pub const PF_GPU_UTILIZATION_INFO_VERSION: u32 = 1;
pub const SUPERFETCH_INFORMATION_VERSION: u32 = 45;
pub const SystemPowerPolicyAc: u32 = 0;
pub const SystemPowerPolicyDc: u32 = 1;
pub const VerifySystemPolicyAc: u32 = 2;
pub const VerifySystemPolicyDc: u32 = 3;
pub const SystemPowerCapabilities: u32 = 4;
pub const SystemBatteryState: u32 = 5;
pub const SystemPowerStateHandler: u32 = 6;
pub const ProcessorStateHandler: u32 = 7;
pub const SystemPowerPolicyCurrent: u32 = 8;
pub const AdministratorPowerPolicy: u32 = 9;
pub const SystemReserveHiberFile: u32 = 10;
pub const ProcessorInformation: u32 = 11;
pub const SystemPowerInformation: u32 = 12;
pub const ProcessorStateHandler2: u32 = 13;
pub const LastWakeTime: u32 = 14;
pub const LastSleepTime: u32 = 15;
pub const SystemExecutionState: u32 = 16;
pub const SystemPowerStateNotifyHandler: u32 = 17;
pub const ProcessorPowerPolicyAc: u32 = 18;
pub const ProcessorPowerPolicyDc: u32 = 19;
pub const VerifyProcessorPowerPolicyAc: u32 = 20;
pub const VerifyProcessorPowerPolicyDc: u32 = 21;
pub const ProcessorPowerPolicyCurrent: u32 = 22;
pub const SystemPowerStateLogging: u32 = 23;
pub const SystemPowerLoggingEntry: u32 = 24;
pub const SetPowerSettingValue: u32 = 25;
pub const NotifyUserPowerSetting: u32 = 26;
pub const PowerInformationLevelUnused0: u32 = 27;
pub const SystemMonitorHiberBootPowerOff: u32 = 28;
pub const SystemVideoState: u32 = 29;
pub const TraceApplicationPowerMessage: u32 = 30;
pub const TraceApplicationPowerMessageEnd: u32 = 31;
pub const ProcessorPerfStates: u32 = 32;
pub const ProcessorIdleStates: u32 = 33;
pub const ProcessorCap: u32 = 34;
pub const SystemWakeSource: u32 = 35;
pub const SystemHiberFileInformation: u32 = 36;
pub const TraceServicePowerMessage: u32 = 37;
pub const ProcessorLoad: u32 = 38;
pub const PowerShutdownNotification: u32 = 39;
pub const MonitorCapabilities: u32 = 40;
pub const SessionPowerInit: u32 = 41;
pub const SessionDisplayState: u32 = 42;
pub const PowerRequestCreate: u32 = 43;
pub const PowerRequestAction: u32 = 44;
pub const GetPowerRequestList: u32 = 45;
pub const ProcessorInformationEx: u32 = 46;
pub const NotifyUserModeLegacyPowerEvent: u32 = 47;
pub const GroupPark: u32 = 48;
pub const ProcessorIdleDomains: u32 = 49;
pub const WakeTimerList: u32 = 50;
pub const SystemHiberFileSize: u32 = 51;
pub const ProcessorIdleStatesHv: u32 = 52;
pub const ProcessorPerfStatesHv: u32 = 53;
pub const ProcessorPerfCapHv: u32 = 54;
pub const ProcessorSetIdle: u32 = 55;
pub const LogicalProcessorIdling: u32 = 56;
pub const UserPresence: u32 = 57;
pub const PowerSettingNotificationName: u32 = 58;
pub const GetPowerSettingValue: u32 = 59;
pub const IdleResiliency: u32 = 60;
pub const SessionRITState: u32 = 61;
pub const SessionConnectNotification: u32 = 62;
pub const SessionPowerCleanup: u32 = 63;
pub const SessionLockState: u32 = 64;
pub const SystemHiberbootState: u32 = 65;
pub const PlatformInformation: u32 = 66;
pub const PdcInvocation: u32 = 67;
pub const MonitorInvocation: u32 = 68;
pub const FirmwareTableInformationRegistered: u32 = 69;
pub const SetShutdownSelectedTime: u32 = 70;
pub const SuspendResumeInvocation: u32 = 71;
pub const PlmPowerRequestCreate: u32 = 72;
pub const ScreenOff: u32 = 73;
pub const CsDeviceNotification: u32 = 74;
pub const PlatformRole: u32 = 75;
pub const LastResumePerformance: u32 = 76;
pub const DisplayBurst: u32 = 77;
pub const ExitLatencySamplingPercentage: u32 = 78;
pub const RegisterSpmPowerSettings: u32 = 79;
pub const PlatformIdleStates: u32 = 80;
pub const ProcessorIdleVeto: u32 = 81;
pub const PlatformIdleVeto: u32 = 82;
pub const SystemBatteryStatePrecise: u32 = 83;
pub const ThermalEvent: u32 = 84;
pub const PowerRequestActionInternal: u32 = 85;
pub const BatteryDeviceState: u32 = 86;
pub const PowerInformationInternal: u32 = 87;
pub const ThermalStandby: u32 = 88;
pub const SystemHiberFileType: u32 = 89;
pub const PhysicalPowerButtonPress: u32 = 90;
pub const QueryPotentialDripsConstraint: u32 = 91;
pub const EnergyTrackerCreate: u32 = 92;
pub const EnergyTrackerQuery: u32 = 93;
pub const UpdateBlackBoxRecorder: u32 = 94;
pub const SessionAllowExternalDmaDevices: u32 = 95;
pub const SendSuspendResumeNotification: u32 = 96;
pub const BlackBoxRecorderDirectAccessBuffer: u32 = 97;
pub const PowerInformationLevelMaximum: u32 = 98;
pub const POWER_REQUEST_CONTEXT_NOT_SPECIFIED: u32 = 2147483648;
pub const PROCESSOR_STATE_TYPE_PERFORMANCE: u32 = 1;
pub const PROCESSOR_STATE_TYPE_THROTTLE: u32 = 2;
pub const IDLE_STATE_FLAGS_C1_HLT: u32 = 1;
pub const IDLE_STATE_FLAGS_C1_IO_HLT: u32 = 2;
pub const IDLE_STATE_FLAGS_IO: u32 = 4;
pub const IDLE_STATE_FLAGS_MWAIT: u32 = 8;
pub const POWER_REQUEST_SUPPORTED_TYPES_V1: u32 = 3;
pub const POWER_REQUEST_SUPPORTED_TYPES_V2: u32 = 9;
pub const POWER_REQUEST_SUPPORTED_TYPES_V3: u32 = 5;
pub const POWER_REQUEST_SUPPORTED_TYPES_V4: u32 = 6;
pub const REG_INIT_BOOT_SM: u32 = 0;
pub const REG_INIT_BOOT_SETUP: u32 = 1;
pub const REG_INIT_BOOT_ACCEPTED_BASE: u32 = 2;
pub const REG_INIT_BOOT_ACCEPTED_MAX: u32 = 1001;
pub const REG_MAX_KEY_VALUE_NAME_LENGTH: u32 = 32767;
pub const REG_MAX_KEY_NAME_LENGTH: u32 = 512;
pub const REG_FLAG_VOLATILE: u32 = 1;
pub const REG_FLAG_LINK: u32 = 2;
pub const REG_KEY_DONT_VIRTUALIZE: u32 = 2;
pub const REG_KEY_DONT_SILENT_FAIL: u32 = 4;
pub const REG_KEY_RECURSE_FLAG: u32 = 8;
pub const CM_EXTENDED_PARAMETER_TYPE_BITS: u32 = 8;
pub const VR_DEVICE_NAME: &[u8; 19] = b"\\Device\\VRegDriver\0";
pub const VR_FLAG_INHERIT_TRUST_CLASS: u32 = 1;
pub const VR_FLAG_WRITE_THROUGH_HIVE: u32 = 2;
pub const VR_FLAG_LOCAL_MACHINE_TRUST_CLASS: u32 = 4;
pub const VR_KEY_COMROOT: u32 = 0;
pub const VR_KEY_MACHINE_SOFTWARE: u32 = 1;
pub const VR_KEY_CONTROL_SET: u32 = 2;
pub const RTL_MEG: u32 = 1048576;
pub const RTL_IMAGE_MAX_DOS_HEADER: u32 = 268435456;
pub const RTL_HASH_ALLOCATED_HEADER: u32 = 1;
pub const RTL_HASH_RESERVED_SIGNATURE: u32 = 0;
pub const RTL_BARRIER_FLAGS_SPIN_ONLY: u32 = 1;
pub const RTL_BARRIER_FLAGS_BLOCK_ONLY: u32 = 2;
pub const RTL_BARRIER_FLAGS_NO_DELETE: u32 = 4;
pub const RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE: u32 = 1;
pub const RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING: u32 = 2;
pub const HASH_STRING_ALGORITHM_DEFAULT: u32 = 0;
pub const HASH_STRING_ALGORITHM_X65599: u32 = 1;
pub const HASH_STRING_ALGORITHM_INVALID: u32 = 4294967295;
pub const RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END: u32 = 1;
pub const RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET: u32 = 2;
pub const RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE: u32 = 4;
pub const RTL_USER_PROC_CURDIR_CLOSE: u32 = 2;
pub const RTL_USER_PROC_CURDIR_INHERIT: u32 = 3;
pub const RTL_MAX_DRIVE_LETTERS: u32 = 32;
pub const RTL_USER_PROC_PARAMS_NORMALIZED: u32 = 1;
pub const RTL_USER_PROC_PROFILE_USER: u32 = 2;
pub const RTL_USER_PROC_PROFILE_KERNEL: u32 = 4;
pub const RTL_USER_PROC_PROFILE_SERVER: u32 = 8;
pub const RTL_USER_PROC_RESERVE_1MB: u32 = 32;
pub const RTL_USER_PROC_RESERVE_16MB: u32 = 64;
pub const RTL_USER_PROC_CASE_SENSITIVE: u32 = 128;
pub const RTL_USER_PROC_DISABLE_HEAP_DECOMMIT: u32 = 256;
pub const RTL_USER_PROC_DLL_REDIRECTION_LOCAL: u32 = 4096;
pub const RTL_USER_PROC_APP_MANIFEST_PRESENT: u32 = 8192;
pub const RTL_USER_PROC_IMAGE_KEY_MISSING: u32 = 16384;
pub const RTL_USER_PROC_OPTIN_PROCESS: u32 = 131072;
pub const RTL_USER_PROCESS_EXTENDED_PARAMETERS_VERSION: u32 = 1;
pub const RTL_CLONE_PROCESS_FLAGS_CREATE_SUSPENDED: u32 = 1;
pub const RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES: u32 = 2;
pub const RTL_CLONE_PROCESS_FLAGS_NO_SYNCHRONIZE: u32 = 4;
pub const RTL_PROCESS_REFLECTION_FLAGS_INHERIT_HANDLES: u32 = 2;
pub const RTL_PROCESS_REFLECTION_FLAGS_NO_SUSPEND: u32 = 4;
pub const RTL_PROCESS_REFLECTION_FLAGS_NO_SYNCHRONIZE: u32 = 8;
pub const RTL_PROCESS_REFLECTION_FLAGS_NO_CLOSE_EVENT: u32 = 16;
pub const CONTEXT_ALIGN: u32 = 16;
pub const CONTEXT_FRAME_LENGTH: u32 = 1232;
pub const CONTEXT_EX_PADDING: u32 = 16;
pub const RTL_ACTIVATE_ACTIVATION_CONTEXT_EX_FLAG_RELEASE_ON_STACK_DEALLOCATION: u32 = 1;
pub const RTL_DEACTIVATE_ACTIVATION_CONTEXT_FLAG_FORCE_EARLY_DEACTIVATION: u32 = 1;
pub const FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT: u32 = 1;
pub const FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS: u32 = 2;
pub const FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA: u32 = 4;
pub const RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT: u32 = 1;
pub const RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_MODULE: u32 = 2;
pub const RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_ADDRESS: u32 = 4;
pub const RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_NO_ADDREF: u32 = 2147483648;
pub const RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK: u32 = 1;
pub const RTL_CREATE_ENVIRONMENT_TRANSLATE: u32 = 1;
pub const RTL_CREATE_ENVIRONMENT_TRANSLATE_FROM_OEM: u32 = 2;
pub const RTL_CREATE_ENVIRONMENT_EMPTY: u32 = 4;
pub const RtlNtdllName: &[u8; 10] = b"ntdll.dll\0";
pub const RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION: u32 = 1;
pub const RTL_DOS_SEARCH_PATH_FLAG_DISALLOW_DOT_RELATIVE_PATH_SEARCH: u32 = 2;
pub const RTL_DOS_SEARCH_PATH_FLAG_APPLY_DEFAULT_EXTENSION_WHEN_NOT_RELATIVE_PATH_EVEN_IF_FILE_HAS_EXTENSION : u32 = 4 ;
pub const IMAGE_FILE_NATIVE_MACHINE_I386: u32 = 1;
pub const IMAGE_FILE_NATIVE_MACHINE_AMD64: u32 = 2;
pub const IMAGE_FILE_NATIVE_MACHINE_ARMNT: u32 = 4;
pub const IMAGE_FILE_NATIVE_MACHINE_ARM64: u32 = 8;
pub const RTL_HEAP_SIGNATURE: u32 = 4293853166;
pub const RTL_HEAP_SEGMENT_SIGNATURE: u32 = 3723419118;
pub const SEGMENT_HEAP_PARAMETERS_VERSION: u32 = 3;
pub const SEGMENT_HEAP_FLG_USE_PAGE_HEAP: u32 = 1;
pub const SEGMENT_HEAP_PARAMS_VALID_FLAGS: u32 = 1;
pub const HEAP_SETTABLE_USER_VALUE: u32 = 256;
pub const HEAP_SETTABLE_USER_FLAG1: u32 = 512;
pub const HEAP_SETTABLE_USER_FLAG2: u32 = 1024;
pub const HEAP_SETTABLE_USER_FLAG3: u32 = 2048;
pub const HEAP_SETTABLE_USER_FLAGS: u32 = 3584;
pub const HEAP_CLASS_0: u32 = 0;
pub const HEAP_CLASS_1: u32 = 4096;
pub const HEAP_CLASS_2: u32 = 8192;
pub const HEAP_CLASS_3: u32 = 12288;
pub const HEAP_CLASS_4: u32 = 16384;
pub const HEAP_CLASS_5: u32 = 20480;
pub const HEAP_CLASS_6: u32 = 24576;
pub const HEAP_CLASS_7: u32 = 28672;
pub const HEAP_CLASS_8: u32 = 32768;
pub const HEAP_CLASS_MASK: u32 = 61440;
pub const HEAP_USAGE_ALLOCATED_BLOCKS: u32 = 16;
pub const HEAP_USAGE_FREE_BUFFER: u32 = 8;
pub const HeapCompatibilityInformation: u32 = 0;
pub const HeapEnableTerminationOnCorruption: u32 = 1;
pub const HeapExtendedInformation: u32 = 2;
pub const HeapOptimizeResources: u32 = 3;
pub const HeapTaggingInformation: u32 = 4;
pub const HeapStackDatabase: u32 = 5;
pub const HeapMemoryLimit: u32 = 6;
pub const HeapTag: u32 = 7;
pub const HeapDetailedFailureInformation: u32 = 2147483649;
pub const HeapSetDebuggingInformation: u32 = 2147483650;
pub const HeapPerformanceCountersInformationStandardHeapVersion: u32 = 1;
pub const HeapPerformanceCountersInformationSegmentHeapVersion: u32 = 2;
pub const HeapExtendedProcessHeapInformationLevel: u32 = 1;
pub const HeapExtendedHeapInformationLevel: u32 = 2;
pub const HeapExtendedHeapRegionInformationLevel: u32 = 3;
pub const HeapExtendedHeapRangeInformationLevel: u32 = 4;
pub const HeapExtendedHeapBlockInformationLevel: u32 = 5;
pub const HeapExtendedHeapHeapPerfInformationLevel: u32 = 2147483648;
pub const HEAP_STACK_QUERY_VERSION: u32 = 2;
pub const HEAP_STACK_CONTROL_VERSION: u32 = 1;
pub const HEAP_STACK_CONTROL_FLAGS_STACKTRACE_ENABLE: u32 = 1;
pub const HEAP_STACK_CONTROL_FLAGS_STACKTRACE_DISABLE: u32 = 2;
pub const RTL_QUERY_PROCESS_MODULES: u32 = 1;
pub const RTL_QUERY_PROCESS_BACKTRACES: u32 = 2;
pub const RTL_QUERY_PROCESS_HEAP_SUMMARY: u32 = 4;
pub const RTL_QUERY_PROCESS_HEAP_TAGS: u32 = 8;
pub const RTL_QUERY_PROCESS_HEAP_ENTRIES: u32 = 16;
pub const RTL_QUERY_PROCESS_LOCKS: u32 = 32;
pub const RTL_QUERY_PROCESS_MODULES32: u32 = 64;
pub const RTL_QUERY_PROCESS_VERIFIER_OPTIONS: u32 = 128;
pub const RTL_QUERY_PROCESS_MODULESEX: u32 = 256;
pub const RTL_QUERY_PROCESS_HEAP_SEGMENTS: u32 = 512;
pub const RTL_QUERY_PROCESS_CS_OWNER: u32 = 1024;
pub const RTL_QUERY_PROCESS_NONINVASIVE: u32 = 2147483648;
pub const RTL_QUERY_PROCESS_NONINVASIVE_CS_OWNER: u32 = 2147485696;
pub const RTL_ERRORMODE_FAILCRITICALERRORS: u32 = 16;
pub const RTL_ERRORMODE_NOGPFAULTERRORBOX: u32 = 32;
pub const RTL_ERRORMODE_NOOPENFILEERRORBOX: u32 = 64;
pub const RTL_IMPORT_TABLE_HASH_REVISION: u32 = 1;
pub const SecondsToStartOf1980: u64 = 11960006400;
pub const SecondsToStartOf1970: u64 = 11644473600;
pub const RTL_ATOM_TABLE_DEFAULT_NUMBER_OF_BUCKETS: u32 = 37;
pub const RTL_ATOM_MAXIMUM_NAME_LENGTH: u32 = 255;
pub const RTL_ATOM_PINNED: u32 = 1;
pub const MAX_UNICODE_STACK_BUFFER_LENGTH: u32 = 256;
pub const COMPOUND_ACE_IMPERSONATION: u32 = 1;
pub const RTL_ACQUIRE_PRIVILEGE_REVERT: u32 = 1;
pub const RTL_ACQUIRE_PRIVILEGE_PROCESS: u32 = 2;
pub const BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID: u32 = 1;
pub const RTL_REGISTRY_ABSOLUTE: u32 = 0;
pub const RTL_REGISTRY_SERVICES: u32 = 1;
pub const RTL_REGISTRY_CONTROL: u32 = 2;
pub const RTL_REGISTRY_WINDOWS_NT: u32 = 3;
pub const RTL_REGISTRY_DEVICEMAP: u32 = 4;
pub const RTL_REGISTRY_USER: u32 = 5;
pub const RTL_REGISTRY_MAXIMUM: u32 = 6;
pub const RTL_REGISTRY_HANDLE: u32 = 1073741824;
pub const RTL_REGISTRY_OPTIONAL: u32 = 2147483648;
pub const RTL_QUERY_REGISTRY_SUBKEY: u32 = 1;
pub const RTL_QUERY_REGISTRY_TOPKEY: u32 = 2;
pub const RTL_QUERY_REGISTRY_REQUIRED: u32 = 4;
pub const RTL_QUERY_REGISTRY_NOVALUE: u32 = 8;
pub const RTL_QUERY_REGISTRY_NOEXPAND: u32 = 16;
pub const RTL_QUERY_REGISTRY_DIRECT: u32 = 32;
pub const RTL_QUERY_REGISTRY_DELETE: u32 = 64;
pub const RTL_WALK_USER_MODE_STACK: u32 = 1;
pub const RTL_WALK_VALID_FLAGS: u32 = 1;
pub const RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT: u32 = 8;
pub const RTL_UNLOAD_EVENT_TRACE_NUMBER: u32 = 64;
pub const RTL_IMAGE_MITIGATION_OPTION_STATEMASK: u32 = 3;
pub const RTL_IMAGE_MITIGATION_OPTION_FORCEMASK: u32 = 4;
pub const RTL_IMAGE_MITIGATION_OPTION_OPTIONMASK: u32 = 8;
pub const RTL_IMAGE_MITIGATION_FLAG_RESET: u32 = 1;
pub const RTL_IMAGE_MITIGATION_FLAG_REMOVE: u32 = 2;
pub const RTL_IMAGE_MITIGATION_FLAG_OSDEFAULT: u32 = 4;
pub const RTL_IMAGE_MITIGATION_FLAG_AUDIT: u32 = 8;
pub const PSM_ACTIVATION_TOKEN_PACKAGED_APPLICATION: u32 = 1;
pub const PSM_ACTIVATION_TOKEN_SHARED_ENTITY: u32 = 2;
pub const PSM_ACTIVATION_TOKEN_FULL_TRUST: u32 = 4;
pub const PSM_ACTIVATION_TOKEN_NATIVE_SERVICE: u32 = 8;
pub const PSM_ACTIVATION_TOKEN_DEVELOPMENT_APP: u32 = 16;
pub const PSM_ACTIVATION_TOKEN_BREAKAWAY_INHIBITED: u32 = 32;
pub const PSM_ACTIVATION_TOKEN_RUNTIME_BROKER: u32 = 64;
pub const PSM_ACTIVATION_TOKEN_UNIVERSAL_CONSOLE: u32 = 512;
pub const PSM_ACTIVATION_TOKEN_WIN32ALACARTE_PROCESS: u32 = 65536;
pub const PSMP_MINIMUM_SYSAPP_CLAIM_VALUES: u32 = 2;
pub const PSMP_MAXIMUM_SYSAPP_CLAIM_VALUES: u32 = 4;
pub const WNF_STATE_KEY: u64 = 4739561890659434612;
pub const IMAGE_FILE_MACHINE_CHPE_X86: u32 = 14948;
pub const IMAGE_FILE_MACHINE_ARM64EC: u32 = 42561;
pub const IMAGE_FILE_MACHINE_ARM64X: u32 = 42574;
pub const IMAGE_ARM64EC_CODE_MAP_TYPE_ARM64: u32 = 0;
pub const IMAGE_ARM64EC_CODE_MAP_TYPE_ARM64EC: u32 = 1;
pub const IMAGE_ARM64EC_CODE_MAP_TYPE_AMD64: u32 = 2;
pub const IMAGE_DVRT_ARM64X_FIXUP_TYPE_ZEROFILL: u32 = 0;
pub const IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE: u32 = 1;
pub const IMAGE_DVRT_ARM64X_FIXUP_TYPE_DELTA: u32 = 2;
pub const IMAGE_DVRT_ARM64X_FIXUP_SIZE_2BYTES: u32 = 1;
pub const IMAGE_DVRT_ARM64X_FIXUP_SIZE_4BYTES: u32 = 2;
pub const IMAGE_DVRT_ARM64X_FIXUP_SIZE_8BYTES: u32 = 3;
pub const IMAGE_DYNAMIC_RELOCATION_ARM64X: u32 = 6;
pub const IMAGE_DYNAMIC_RELOCATION_MM_SHARED_USER_DATA_VA: u32 = 2147352576;
pub const SE_MIN_WELL_KNOWN_PRIVILEGE: u32 = 2;
pub const SE_CREATE_TOKEN_PRIVILEGE: u32 = 2;
pub const SE_ASSIGNPRIMARYTOKEN_PRIVILEGE: u32 = 3;
pub const SE_LOCK_MEMORY_PRIVILEGE: u32 = 4;
pub const SE_INCREASE_QUOTA_PRIVILEGE: u32 = 5;
pub const SE_MACHINE_ACCOUNT_PRIVILEGE: u32 = 6;
pub const SE_TCB_PRIVILEGE: u32 = 7;
pub const SE_SECURITY_PRIVILEGE: u32 = 8;
pub const SE_TAKE_OWNERSHIP_PRIVILEGE: u32 = 9;
pub const SE_LOAD_DRIVER_PRIVILEGE: u32 = 10;
pub const SE_SYSTEM_PROFILE_PRIVILEGE: u32 = 11;
pub const SE_SYSTEMTIME_PRIVILEGE: u32 = 12;
pub const SE_PROF_SINGLE_PROCESS_PRIVILEGE: u32 = 13;
pub const SE_INC_BASE_PRIORITY_PRIVILEGE: u32 = 14;
pub const SE_CREATE_PAGEFILE_PRIVILEGE: u32 = 15;
pub const SE_CREATE_PERMANENT_PRIVILEGE: u32 = 16;
pub const SE_BACKUP_PRIVILEGE: u32 = 17;
pub const SE_RESTORE_PRIVILEGE: u32 = 18;
pub const SE_SHUTDOWN_PRIVILEGE: u32 = 19;
pub const SE_DEBUG_PRIVILEGE: u32 = 20;
pub const SE_AUDIT_PRIVILEGE: u32 = 21;
pub const SE_SYSTEM_ENVIRONMENT_PRIVILEGE: u32 = 22;
pub const SE_CHANGE_NOTIFY_PRIVILEGE: u32 = 23;
pub const SE_REMOTE_SHUTDOWN_PRIVILEGE: u32 = 24;
pub const SE_UNDOCK_PRIVILEGE: u32 = 25;
pub const SE_SYNC_AGENT_PRIVILEGE: u32 = 26;
pub const SE_ENABLE_DELEGATION_PRIVILEGE: u32 = 27;
pub const SE_MANAGE_VOLUME_PRIVILEGE: u32 = 28;
pub const SE_IMPERSONATE_PRIVILEGE: u32 = 29;
pub const SE_CREATE_GLOBAL_PRIVILEGE: u32 = 30;
pub const SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE: u32 = 31;
pub const SE_RELABEL_PRIVILEGE: u32 = 32;
pub const SE_INC_WORKING_SET_PRIVILEGE: u32 = 33;
pub const SE_TIME_ZONE_PRIVILEGE: u32 = 34;
pub const SE_CREATE_SYMBOLIC_LINK_PRIVILEGE: u32 = 35;
pub const SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE: u32 = 36;
pub const SE_MAX_WELL_KNOWN_PRIVILEGE: u32 = 36;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_INVALID: u32 = 0;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64: u32 = 1;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64: u32 = 2;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING: u32 = 3;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN: u32 = 4;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_SID: u32 = 5;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN: u32 = 6;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING: u32 = 16;
pub const TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE: u32 = 1;
pub const TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE: u32 = 2;
pub const TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY: u32 = 4;
pub const TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT: u32 = 8;
pub const TOKEN_SECURITY_ATTRIBUTE_DISABLED: u32 = 16;
pub const TOKEN_SECURITY_ATTRIBUTE_MANDATORY: u32 = 32;
pub const TOKEN_SECURITY_ATTRIBUTE_COMPARE_IGNORE: u32 = 64;
pub const TOKEN_SECURITY_ATTRIBUTE_VALID_FLAGS: u32 = 63;
pub const TOKEN_SECURITY_ATTRIBUTE_CUSTOM_FLAGS: u32 = 4294901760;
pub const TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1: u32 = 1;
pub const TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION: u32 = 1;
pub const KCONTINUE_FLAG_TEST_ALERT: u32 = 1;
pub const KCONTINUE_FLAG_DELIVER_APC: u32 = 2;
pub const WOW64_SYSTEM_DIRECTORY: &[u8; 9] = b"SysWOW64\0";
pub const WOW64_SYSTEM_DIRECTORY_U: &[u8; 9] = b"SysWOW64\0";
pub const WOW64_X86_TAG: &[u8; 7] = b" (x86)\0";
pub const WOW64_X86_TAG_U: &[u8; 7] = b" (x86)\0";
pub const PAGE_SIZE_X86NT: u32 = 4096;
pub const PAGE_SHIFT_X86NT: u32 = 12;
pub const WOW64_SPLITS_PER_PAGE: u32 = 1;
pub const WOW64_CPUFLAGS_MSFT64: u32 = 1;
pub const WOW64_CPUFLAGS_SOFTWARE: u32 = 2;
pub const WOW64_CPUFLAGS_IA64: u32 = 4;
pub const SAM_MAXIMUM_LOOKUP_COUNT: u32 = 1000;
pub const SAM_MAXIMUM_LOOKUP_LENGTH: u32 = 32000;
pub const SAM_MAX_PASSWORD_LENGTH: u32 = 256;
pub const SAM_PASSWORD_ENCRYPTION_SALT_LEN: u32 = 16;
pub const SAM_SERVER_CONNECT: u32 = 1;
pub const SAM_SERVER_SHUTDOWN: u32 = 2;
pub const SAM_SERVER_INITIALIZE: u32 = 4;
pub const SAM_SERVER_CREATE_DOMAIN: u32 = 8;
pub const SAM_SERVER_ENUMERATE_DOMAINS: u32 = 16;
pub const SAM_SERVER_LOOKUP_DOMAIN: u32 = 32;
pub const SAM_SERVER_ALL_ACCESS: u32 = 983103;
pub const SAM_SERVER_READ: u32 = 131088;
pub const SAM_SERVER_WRITE: u32 = 131086;
pub const SAM_SERVER_EXECUTE: u32 = 131105;
pub const DOMAIN_READ_PASSWORD_PARAMETERS: u32 = 1;
pub const DOMAIN_WRITE_PASSWORD_PARAMS: u32 = 2;
pub const DOMAIN_READ_OTHER_PARAMETERS: u32 = 4;
pub const DOMAIN_WRITE_OTHER_PARAMETERS: u32 = 8;
pub const DOMAIN_CREATE_USER: u32 = 16;
pub const DOMAIN_CREATE_GROUP: u32 = 32;
pub const DOMAIN_CREATE_ALIAS: u32 = 64;
pub const DOMAIN_GET_ALIAS_MEMBERSHIP: u32 = 128;
pub const DOMAIN_LIST_ACCOUNTS: u32 = 256;
pub const DOMAIN_LOOKUP: u32 = 512;
pub const DOMAIN_ADMINISTER_SERVER: u32 = 1024;
pub const DOMAIN_ALL_ACCESS: u32 = 985087;
pub const DOMAIN_READ: u32 = 131204;
pub const DOMAIN_WRITE: u32 = 132218;
pub const DOMAIN_EXECUTE: u32 = 131841;
pub const DOMAIN_PASSWORD_COMPLEX: u32 = 1;
pub const DOMAIN_PASSWORD_NO_ANON_CHANGE: u32 = 2;
pub const DOMAIN_PASSWORD_NO_CLEAR_CHANGE: u32 = 4;
pub const DOMAIN_LOCKOUT_ADMINS: u32 = 8;
pub const DOMAIN_PASSWORD_STORE_CLEARTEXT: u32 = 16;
pub const DOMAIN_REFUSE_PASSWORD_CHANGE: u32 = 32;
pub const DOMAIN_NO_LM_OWF_CHANGE: u32 = 64;
pub const GROUP_READ_INFORMATION: u32 = 1;
pub const GROUP_WRITE_ACCOUNT: u32 = 2;
pub const GROUP_ADD_MEMBER: u32 = 4;
pub const GROUP_REMOVE_MEMBER: u32 = 8;
pub const GROUP_LIST_MEMBERS: u32 = 16;
pub const GROUP_ALL_ACCESS: u32 = 983071;
pub const GROUP_READ: u32 = 131088;
pub const GROUP_WRITE: u32 = 131086;
pub const GROUP_EXECUTE: u32 = 131073;
pub const ALIAS_ADD_MEMBER: u32 = 1;
pub const ALIAS_REMOVE_MEMBER: u32 = 2;
pub const ALIAS_LIST_MEMBERS: u32 = 4;
pub const ALIAS_READ_INFORMATION: u32 = 8;
pub const ALIAS_WRITE_ACCOUNT: u32 = 16;
pub const ALIAS_ALL_ACCESS: u32 = 983071;
pub const ALIAS_READ: u32 = 131076;
pub const ALIAS_WRITE: u32 = 131091;
pub const ALIAS_EXECUTE: u32 = 131080;
pub const ALIAS_ALL_NAME: u32 = 1;
pub const ALIAS_ALL_MEMBER_COUNT: u32 = 2;
pub const ALIAS_ALL_ADMIN_COMMENT: u32 = 4;
pub const ALIAS_ALL_SHELL_ADMIN_OBJECT_PROPERTIES: u32 = 8;
pub const GROUP_TYPE_BUILTIN_LOCAL_GROUP: u32 = 1;
pub const GROUP_TYPE_ACCOUNT_GROUP: u32 = 2;
pub const GROUP_TYPE_RESOURCE_GROUP: u32 = 4;
pub const GROUP_TYPE_UNIVERSAL_GROUP: u32 = 8;
pub const GROUP_TYPE_APP_BASIC_GROUP: u32 = 16;
pub const GROUP_TYPE_APP_QUERY_GROUP: u32 = 32;
pub const GROUP_TYPE_SECURITY_ENABLED: u32 = 2147483648;
pub const GROUP_TYPE_RESOURCE_BEHAVOIR: u32 = 52;
pub const USER_READ_GENERAL: u32 = 1;
pub const USER_READ_PREFERENCES: u32 = 2;
pub const USER_WRITE_PREFERENCES: u32 = 4;
pub const USER_READ_LOGON: u32 = 8;
pub const USER_READ_ACCOUNT: u32 = 16;
pub const USER_WRITE_ACCOUNT: u32 = 32;
pub const USER_CHANGE_PASSWORD: u32 = 64;
pub const USER_FORCE_PASSWORD_CHANGE: u32 = 128;
pub const USER_LIST_GROUPS: u32 = 256;
pub const USER_READ_GROUP_INFORMATION: u32 = 512;
pub const USER_WRITE_GROUP_INFORMATION: u32 = 1024;
pub const USER_ALL_ACCESS: u32 = 985087;
pub const USER_READ: u32 = 131866;
pub const USER_WRITE: u32 = 131140;
pub const USER_EXECUTE: u32 = 131137;
pub const USER_ACCOUNT_DISABLED: u32 = 1;
pub const USER_HOME_DIRECTORY_REQUIRED: u32 = 2;
pub const USER_PASSWORD_NOT_REQUIRED: u32 = 4;
pub const USER_TEMP_DUPLICATE_ACCOUNT: u32 = 8;
pub const USER_NORMAL_ACCOUNT: u32 = 16;
pub const USER_MNS_LOGON_ACCOUNT: u32 = 32;
pub const USER_INTERDOMAIN_TRUST_ACCOUNT: u32 = 64;
pub const USER_WORKSTATION_TRUST_ACCOUNT: u32 = 128;
pub const USER_SERVER_TRUST_ACCOUNT: u32 = 256;
pub const USER_DONT_EXPIRE_PASSWORD: u32 = 512;
pub const USER_ACCOUNT_AUTO_LOCKED: u32 = 1024;
pub const USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED: u32 = 2048;
pub const USER_SMARTCARD_REQUIRED: u32 = 4096;
pub const USER_TRUSTED_FOR_DELEGATION: u32 = 8192;
pub const USER_NOT_DELEGATED: u32 = 16384;
pub const USER_USE_DES_KEY_ONLY: u32 = 32768;
pub const USER_DONT_REQUIRE_PREAUTH: u32 = 65536;
pub const USER_PASSWORD_EXPIRED: u32 = 131072;
pub const USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION: u32 = 262144;
pub const USER_NO_AUTH_DATA_REQUIRED: u32 = 524288;
pub const USER_PARTIAL_SECRETS_ACCOUNT: u32 = 1048576;
pub const USER_USE_AES_KEYS: u32 = 2097152;
pub const NEXT_FREE_ACCOUNT_CONTROL_BIT: u32 = 4194304;
pub const USER_MACHINE_ACCOUNT_MASK: u32 = 448;
pub const USER_ACCOUNT_TYPE_MASK: u32 = 472;
pub const USER_COMPUTED_ACCOUNT_CONTROL_BITS: u32 = 132096;
pub const SAM_DAYS_PER_WEEK: u32 = 7;
pub const SAM_HOURS_PER_WEEK: u32 = 168;
pub const SAM_MINUTES_PER_WEEK: u32 = 10080;
pub const CYPHER_BLOCK_LENGTH: u32 = 8;
pub const USER_ALL_USERNAME: u32 = 1;
pub const USER_ALL_FULLNAME: u32 = 2;
pub const USER_ALL_USERID: u32 = 4;
pub const USER_ALL_PRIMARYGROUPID: u32 = 8;
pub const USER_ALL_ADMINCOMMENT: u32 = 16;
pub const USER_ALL_USERCOMMENT: u32 = 32;
pub const USER_ALL_HOMEDIRECTORY: u32 = 64;
pub const USER_ALL_HOMEDIRECTORYDRIVE: u32 = 128;
pub const USER_ALL_SCRIPTPATH: u32 = 256;
pub const USER_ALL_PROFILEPATH: u32 = 512;
pub const USER_ALL_WORKSTATIONS: u32 = 1024;
pub const USER_ALL_LASTLOGON: u32 = 2048;
pub const USER_ALL_LASTLOGOFF: u32 = 4096;
pub const USER_ALL_LOGONHOURS: u32 = 8192;
pub const USER_ALL_BADPASSWORDCOUNT: u32 = 16384;
pub const USER_ALL_LOGONCOUNT: u32 = 32768;
pub const USER_ALL_PASSWORDCANCHANGE: u32 = 65536;
pub const USER_ALL_PASSWORDMUSTCHANGE: u32 = 131072;
pub const USER_ALL_PASSWORDLASTSET: u32 = 262144;
pub const USER_ALL_ACCOUNTEXPIRES: u32 = 524288;
pub const USER_ALL_USERACCOUNTCONTROL: u32 = 1048576;
pub const USER_ALL_PARAMETERS: u32 = 2097152;
pub const USER_ALL_COUNTRYCODE: u32 = 4194304;
pub const USER_ALL_CODEPAGE: u32 = 8388608;
pub const USER_ALL_NTPASSWORDPRESENT: u32 = 16777216;
pub const USER_ALL_LMPASSWORDPRESENT: u32 = 33554432;
pub const USER_ALL_PRIVATEDATA: u32 = 67108864;
pub const USER_ALL_PASSWORDEXPIRED: u32 = 134217728;
pub const USER_ALL_SECURITYDESCRIPTOR: u32 = 268435456;
pub const USER_ALL_OWFPASSWORD: u32 = 536870912;
pub const USER_ALL_UNDEFINED_MASK: u32 = 3221225472;
pub const USER_ALL_READ_GENERAL_MASK: u32 = 63;
pub const USER_ALL_READ_LOGON_MASK: u32 = 262080;
pub const USER_ALL_READ_ACCOUNT_MASK: u32 = 3932160;
pub const USER_ALL_READ_PREFERENCES_MASK: u32 = 12582912;
pub const USER_ALL_READ_TRUSTED_MASK: u32 = 520093696;
pub const USER_ALL_READ_CANT_MASK: u32 = 3221225472;
pub const USER_ALL_WRITE_ACCOUNT_MASK: u32 = 3680219;
pub const USER_ALL_WRITE_PREFERENCES_MASK: u32 = 12582944;
pub const USER_ALL_WRITE_FORCE_PASSWORD_CHANGE_MASK: u32 = 184549376;
pub const USER_ALL_WRITE_TRUSTED_MASK: u32 = 335861760;
pub const USER_ALL_WRITE_CANT_MASK: u32 = 3221422084;
pub const USER_EXTENDED_FIELD_UPN: u32 = 1;
pub const USER_EXTENDED_FIELD_A2D2: u32 = 2;
pub const USER_EXTENDED_FIELD_USER_TILE: u32 = 4096;
pub const USER_EXTENDED_FIELD_PASSWORD_HINT: u32 = 8192;
pub const USER_EXTENDED_FIELD_DONT_SHOW_IN_LOGON_UI: u32 = 16384;
pub const USER_EXTENDED_FIELD_SHELL_ADMIN_OBJECT_PROPERTIES: u32 = 32768;
pub const SAM_PWD_CHANGE_NO_ERROR: u32 = 0;
pub const SAM_PWD_CHANGE_PASSWORD_TOO_SHORT: u32 = 1;
pub const SAM_PWD_CHANGE_PWD_IN_HISTORY: u32 = 2;
pub const SAM_PWD_CHANGE_USERNAME_IN_PASSWORD: u32 = 3;
pub const SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD: u32 = 4;
pub const SAM_PWD_CHANGE_NOT_COMPLEX: u32 = 5;
pub const SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT: u32 = 6;
pub const SAM_PWD_CHANGE_FAILED_BY_FILTER: u32 = 7;
pub const SAM_PWD_CHANGE_PASSWORD_TOO_LONG: u32 = 8;
pub const SAM_PWD_CHANGE_FAILURE_REASON_MAX: u32 = 8;
pub const SAM_USER_ACCOUNT: u32 = 1;
pub const SAM_GLOBAL_GROUP_ACCOUNT: u32 = 2;
pub const SAM_LOCAL_GROUP_ACCOUNT: u32 = 4;
pub const SAM_DELTA_NOTIFY_ROUTINE: &[u8; 12] = b"DeltaNotify\0";
pub const SAM_SID_COMPATIBILITY_ALL: u32 = 0;
pub const SAM_SID_COMPATIBILITY_LAX: u32 = 1;
pub const SAM_SID_COMPATIBILITY_STRICT: u32 = 2;
pub const SAM_VALIDATE_PASSWORD_LAST_SET: u32 = 1;
pub const SAM_VALIDATE_BAD_PASSWORD_TIME: u32 = 2;
pub const SAM_VALIDATE_LOCKOUT_TIME: u32 = 4;
pub const SAM_VALIDATE_BAD_PASSWORD_COUNT: u32 = 8;
pub const SAM_VALIDATE_PASSWORD_HISTORY_LENGTH: u32 = 16;
pub const SAM_VALIDATE_PASSWORD_HISTORY: u32 = 32;
pub const FLT_PORT_CONNECT: u32 = 1;
pub const FLT_PORT_ALL_ACCESS: u32 = 2031617;
pub const MIN_ETW_BUFFER_SIZE: u32 = 1;
pub const MAX_ETW_BUFFER_SIZE: u32 = 16384;
pub const MAX_ETW_BUFFER_SIZE_WIN7: u32 = 1024;
pub const MAX_ETW_EVENT_SIZE: u32 = 65535;
pub const ETW_KERNEL_RUNDOWN_START: u32 = 1;
pub const ETW_KERNEL_RUNDOWN_STOP: u32 = 2;
pub const ETW_CKCL_RUNDOWN_START: u32 = 4;
pub const ETW_CKCL_RUNDOWN_STOP: u32 = 8;
pub const ETW_FILENAME_RUNDOWN: u32 = 16;
pub const ETW_UMGL_INDEX_HEAP: u32 = 0;
pub const ETW_UMGL_INDEX_CRITSEC: u32 = 1;
pub const ETW_UMGL_INDEX_LDR: u32 = 2;
pub const ETW_UMGL_INDEX_THREAD_POOL: u32 = 3;
pub const ETW_UMGL_INDEX_HEAPRANGE: u32 = 4;
pub const ETW_UMGL_INDEX_HEAPSUMMARY: u32 = 5;
pub const ETW_UMGL_INDEX_UMS: u32 = 6;
pub const ETW_UMGL_INDEX_WNF: u32 = 7;
pub const ETW_UMGL_INDEX_THREAD: u32 = 8;
pub const ETW_UMGL_INDEX_SPARE2: u32 = 9;
pub const ETW_UMGL_INDEX_SPARE3: u32 = 10;
pub const ETW_UMGL_INDEX_SPARE4: u32 = 11;
pub const ETW_UMGL_INDEX_SPARE5: u32 = 12;
pub const ETW_UMGL_INDEX_SPARE6: u32 = 13;
pub const ETW_UMGL_INDEX_SPARE7: u32 = 14;
pub const ETW_UMGL_INDEX_SPARE8: u32 = 15;
pub const ETW_UMGL_MAX_PROVIDERS: u32 = 9;
pub const ETW_UMGL_LDR_MUI_VERBOSE_FLAG: u32 = 1;
pub const ETW_UMGL_LDR_MUI_TEST_FLAG: u32 = 2;
pub const ETW_UMGL_LDR_RELOCATION_FLAG: u32 = 4;
pub const ETW_UMGL_LDR_NEW_DLL_FLAG: u32 = 16;
pub const ETW_UMGL_LDR_TEST_FLAG: u32 = 32;
pub const ETW_UMGL_LDR_SECURITY_FLAG: u32 = 64;
pub const MEMORY_FROM_LOOKASIDE: u32 = 1;
pub const MEMORY_FROM_LOWFRAG: u32 = 2;
pub const MEMORY_FROM_MAINPATH: u32 = 3;
pub const MEMORY_FROM_SLOWPATH: u32 = 4;
pub const MEMORY_FROM_INVALID: u32 = 5;
pub const MEMORY_FROM_SEGMENT_HEAP: u32 = 6;
pub const TRACE_HEADER_TYPE_SYSTEM32: u32 = 1;
pub const TRACE_HEADER_TYPE_SYSTEM64: u32 = 2;
pub const TRACE_HEADER_TYPE_COMPACT32: u32 = 3;
pub const TRACE_HEADER_TYPE_COMPACT64: u32 = 4;
pub const TRACE_HEADER_TYPE_FULL_HEADER32: u32 = 10;
pub const TRACE_HEADER_TYPE_INSTANCE32: u32 = 11;
pub const TRACE_HEADER_TYPE_TIMED: u32 = 12;
pub const TRACE_HEADER_TYPE_ERROR: u32 = 13;
pub const TRACE_HEADER_TYPE_WNODE_HEADER: u32 = 14;
pub const TRACE_HEADER_TYPE_MESSAGE: u32 = 15;
pub const TRACE_HEADER_TYPE_PERFINFO32: u32 = 16;
pub const TRACE_HEADER_TYPE_PERFINFO64: u32 = 17;
pub const TRACE_HEADER_TYPE_EVENT_HEADER32: u32 = 18;
pub const TRACE_HEADER_TYPE_EVENT_HEADER64: u32 = 19;
pub const TRACE_HEADER_TYPE_FULL_HEADER64: u32 = 20;
pub const TRACE_HEADER_TYPE_INSTANCE64: u32 = 21;
pub const EVENT_HEADER_SIZE_MASK: u32 = 65535;
pub const SYSTEM_TRACE_VERSION: u32 = 2;
pub const TRACE_HEADER_FLAG: u32 = 2147483648;
pub const TRACE_HEADER_FULL32: u32 = 3221880832;
pub const TRACE_HEADER_FULL64: u32 = 3222536192;
pub const TRACE_HEADER_INSTANCE32: u32 = 3221946368;
pub const TRACE_HEADER_INSTANCE64: u32 = 3222601728;
pub const TRACE_HEADER_FULL: u32 = 3222536192;
pub const TRACE_HEADER_INSTANCE: u32 = 3222601728;
pub const EVENT_TRACE_USE_RAWTIMESTAMP: u32 = 2;
pub const EVENT_TRACE_GET_RAWEVENT: u32 = 256;
pub const EVENT_TRACE_READ_BEHIND: u32 = 512;
pub const EVENT_TRACE_USE_SEQUENCE: u32 = 4;
pub const ETW_KERNEL_EVENT_VERSION: u32 = 60;
pub const ETW_SET_MARK_WITH_FLUSH: u32 = 1;
pub const ETW_MAX_DATA_BLOCK_BUFFER_SIZE: u32 = 65536;
pub type va_list = *mut cty::c_char;
pub type wchar_t = cty::c_ushort;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EXCEPTION_DISPOSITION {
   ExceptionContinueExecution = 0,
   ExceptionContinueSearch = 1,
   ExceptionNestedException = 2,
   ExceptionCollidedUnwind = 3,
}
pub use self::_EXCEPTION_DISPOSITION as EXCEPTION_DISPOSITION;
pub type ULONG = cty::c_ulong;
pub type PULONG = *mut ULONG;
pub type USHORT = cty::c_ushort;
pub type PUSHORT = *mut USHORT;
pub type UCHAR = cty::c_uchar;
pub type PUCHAR = *mut UCHAR;
pub type DWORD = cty::c_ulong;
pub type BYTE = cty::c_uchar;
pub type WORD = cty::c_ushort;
pub type PBOOL = *mut BOOL;
pub type PDWORD = *mut DWORD;
pub type LPVOID = *mut cty::c_void;
pub type ULONG32 = cty::c_uint;
pub type LONG_PTR = cty::c_longlong;
pub type ULONG_PTR = cty::c_ulonglong;
pub type PULONG_PTR = *mut cty::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type PLONG64 = *mut cty::c_longlong;
pub type ULONG64 = cty::c_ulonglong;
pub type PULONG64 = *mut cty::c_ulonglong;
pub type DWORD64 = cty::c_ulonglong;
pub type PDWORD64 = *mut cty::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PVOID = *mut cty::c_void;
pub type CHAR = cty::c_char;
pub type LONG = cty::c_long;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type PWCH = *mut WCHAR;
pub type PCWCH = *const WCHAR;
pub type PWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PZZWSTR = *mut WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type PCWCHAR = *const WCHAR;
pub type PCHAR = *mut CHAR;
pub type PCH = *mut CHAR;
pub type PCCH = *const CHAR;
pub type LPSTR = *mut CHAR;
pub type PSTR = *mut CHAR;
pub type PCSTR = *const CHAR;
pub type PLONG = *mut LONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_NUMBER {
   pub Group: WORD,
   pub Number: BYTE,
   pub Reserved: BYTE,
}
pub type PROCESSOR_NUMBER = _PROCESSOR_NUMBER;
pub type PPROCESSOR_NUMBER = *mut _PROCESSOR_NUMBER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GROUP_AFFINITY {
   pub Mask: KAFFINITY,
   pub Group: WORD,
   pub Reserved: [WORD; 3usize],
}
pub type GROUP_AFFINITY = _GROUP_AFFINITY;
pub type PGROUP_AFFINITY = *mut _GROUP_AFFINITY;
pub type HANDLE = *mut cty::c_void;
pub type PHANDLE = *mut HANDLE;
pub type CCHAR = cty::c_char;
pub type LCID = DWORD;
pub type PLCID = PDWORD;
pub type LANGID = WORD;
pub type LONGLONG = cty::c_longlong;
pub type ULONGLONG = cty::c_ulonglong;
pub type PULONGLONG = *mut ULONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
   pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
   pub u: _LARGE_INTEGER__bindgen_ty_2,
   pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
   pub LowPart: DWORD,
   pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
   pub LowPart: DWORD,
   pub HighPart: LONG,
}
impl Default for _LARGE_INTEGER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
   pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
   pub u: _ULARGE_INTEGER__bindgen_ty_2,
   pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
   pub LowPart: DWORD,
   pub HighPart: DWORD,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
   pub LowPart: DWORD,
   pub HighPart: DWORD,
}
impl Default for _ULARGE_INTEGER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
pub type PULARGE_INTEGER = *mut ULARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LUID {
   pub LowPart: DWORD,
   pub HighPart: LONG,
}
pub type LUID = _LUID;
pub type PLUID = *mut _LUID;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
   pub Flink: *mut _LIST_ENTRY,
   pub Blink: *mut _LIST_ENTRY,
}
impl Default for _LIST_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LIST_ENTRY = _LIST_ENTRY;
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
   pub Next: *mut _SINGLE_LIST_ENTRY,
}
impl Default for _SINGLE_LIST_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LIST_ENTRY32 {
   pub Flink: DWORD,
   pub Blink: DWORD,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GUID {
   pub Data1: cty::c_ulong,
   pub Data2: cty::c_ushort,
   pub Data3: cty::c_ushort,
   pub Data4: [cty::c_uchar; 8usize],
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type PEXCEPTION_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      arg1: *mut _EXCEPTION_RECORD,
      arg2: PVOID,
      arg3: *mut _CONTEXT,
      arg4: PVOID,
   ) -> EXCEPTION_DISPOSITION,
>;
pub type __C_ASSERT__ = [cty::c_char; 1usize];
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _M128A {
   pub Low: ULONGLONG,
   pub High: LONGLONG,
}
pub type M128A = _M128A;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_FORMAT {
   pub ControlWord: WORD,
   pub StatusWord: WORD,
   pub TagWord: BYTE,
   pub Reserved1: BYTE,
   pub ErrorOpcode: WORD,
   pub ErrorOffset: DWORD,
   pub ErrorSelector: WORD,
   pub Reserved2: WORD,
   pub DataOffset: DWORD,
   pub DataSelector: WORD,
   pub Reserved3: WORD,
   pub MxCsr: DWORD,
   pub MxCsr_Mask: DWORD,
   pub FloatRegisters: [M128A; 8usize],
   pub XmmRegisters: [M128A; 16usize],
   pub Reserved4: [BYTE; 96usize],
}
impl Default for _XSAVE_FORMAT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type XSAVE_FORMAT = _XSAVE_FORMAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _XSAVE_AREA_HEADER {
   pub Mask: DWORD64,
   pub CompactionMask: DWORD64,
   pub Reserved2: [DWORD64; 6usize],
}
pub type PXSAVE_AREA_HEADER = *mut _XSAVE_AREA_HEADER;
pub type XMM_SAVE_AREA32 = XSAVE_FORMAT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _CONTEXT {
   pub P1Home: DWORD64,
   pub P2Home: DWORD64,
   pub P3Home: DWORD64,
   pub P4Home: DWORD64,
   pub P5Home: DWORD64,
   pub P6Home: DWORD64,
   pub ContextFlags: DWORD,
   pub MxCsr: DWORD,
   pub SegCs: WORD,
   pub SegDs: WORD,
   pub SegEs: WORD,
   pub SegFs: WORD,
   pub SegGs: WORD,
   pub SegSs: WORD,
   pub EFlags: DWORD,
   pub Dr0: DWORD64,
   pub Dr1: DWORD64,
   pub Dr2: DWORD64,
   pub Dr3: DWORD64,
   pub Dr6: DWORD64,
   pub Dr7: DWORD64,
   pub Rax: DWORD64,
   pub Rcx: DWORD64,
   pub Rdx: DWORD64,
   pub Rbx: DWORD64,
   pub Rsp: DWORD64,
   pub Rbp: DWORD64,
   pub Rsi: DWORD64,
   pub Rdi: DWORD64,
   pub R8: DWORD64,
   pub R9: DWORD64,
   pub R10: DWORD64,
   pub R11: DWORD64,
   pub R12: DWORD64,
   pub R13: DWORD64,
   pub R14: DWORD64,
   pub R15: DWORD64,
   pub Rip: DWORD64,
   pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1,
   pub VectorRegister: [M128A; 26usize],
   pub VectorControl: DWORD64,
   pub DebugControl: DWORD64,
   pub LastBranchToRip: DWORD64,
   pub LastBranchFromRip: DWORD64,
   pub LastExceptionToRip: DWORD64,
   pub LastExceptionFromRip: DWORD64,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _CONTEXT__bindgen_ty_1 {
   pub FltSave: XMM_SAVE_AREA32,
   pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   pub Header: [M128A; 2usize],
   pub Legacy: [M128A; 8usize],
   pub Xmm0: M128A,
   pub Xmm1: M128A,
   pub Xmm2: M128A,
   pub Xmm3: M128A,
   pub Xmm4: M128A,
   pub Xmm5: M128A,
   pub Xmm6: M128A,
   pub Xmm7: M128A,
   pub Xmm8: M128A,
   pub Xmm9: M128A,
   pub Xmm10: M128A,
   pub Xmm11: M128A,
   pub Xmm12: M128A,
   pub Xmm13: M128A,
   pub Xmm14: M128A,
   pub Xmm15: M128A,
}
impl Default for _CONTEXT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CONTEXT = _CONTEXT;
pub type PCONTEXT = *mut _CONTEXT;
pub type PRUNTIME_FUNCTION = *mut _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type GET_RUNTIME_FUNCTION_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(ControlPc: DWORD64, Context: PVOID) -> PRUNTIME_FUNCTION,
>;
pub type PGET_RUNTIME_FUNCTION_CALLBACK = GET_RUNTIME_FUNCTION_CALLBACK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDT_ENTRY {
   pub LimitLow: WORD,
   pub BaseLow: WORD,
   pub HighWord: _LDT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDT_ENTRY__bindgen_ty_1 {
   pub Bytes: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1,
   pub Bits: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub BaseMid: BYTE,
   pub Flags1: BYTE,
   pub Flags2: BYTE,
   pub BaseHi: BYTE,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   #[inline]
   pub fn BaseMid(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_BaseMid(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Type(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub fn Dpl(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_Dpl(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn Pres(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Pres(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LimitHi(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_LimitHi(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn Sys(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Sys(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved_0(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved_0(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Default_Big(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Default_Big(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Granularity(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Granularity(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BaseHi(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_BaseHi(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      BaseMid: DWORD,
      Type: DWORD,
      Dpl: DWORD,
      Pres: DWORD,
      LimitHi: DWORD,
      Sys: DWORD,
      Reserved_0: DWORD,
      Default_Big: DWORD,
      Granularity: DWORD,
      BaseHi: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let BaseMid: u32 = unsafe { ::core::mem::transmute(BaseMid) };
         BaseMid as u64
      });
      __bindgen_bitfield_unit.set(8usize, 5u8, {
         let Type: u32 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(13usize, 2u8, {
         let Dpl: u32 = unsafe { ::core::mem::transmute(Dpl) };
         Dpl as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let Pres: u32 = unsafe { ::core::mem::transmute(Pres) };
         Pres as u64
      });
      __bindgen_bitfield_unit.set(16usize, 4u8, {
         let LimitHi: u32 = unsafe { ::core::mem::transmute(LimitHi) };
         LimitHi as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let Sys: u32 = unsafe { ::core::mem::transmute(Sys) };
         Sys as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let Reserved_0: u32 = unsafe { ::core::mem::transmute(Reserved_0) };
         Reserved_0 as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let Default_Big: u32 = unsafe { ::core::mem::transmute(Default_Big) };
         Default_Big as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let Granularity: u32 = unsafe { ::core::mem::transmute(Granularity) };
         Granularity as u64
      });
      __bindgen_bitfield_unit.set(24usize, 8u8, {
         let BaseHi: u32 = unsafe { ::core::mem::transmute(BaseHi) };
         BaseHi as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _LDT_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDT_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDT_ENTRY = _LDT_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_FLOATING_SAVE_AREA {
   pub ControlWord: DWORD,
   pub StatusWord: DWORD,
   pub TagWord: DWORD,
   pub ErrorOffset: DWORD,
   pub ErrorSelector: DWORD,
   pub DataOffset: DWORD,
   pub DataSelector: DWORD,
   pub RegisterArea: [BYTE; 80usize],
   pub Cr0NpxState: DWORD,
}
impl Default for _WOW64_FLOATING_SAVE_AREA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WOW64_FLOATING_SAVE_AREA = _WOW64_FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_CONTEXT {
   pub ContextFlags: DWORD,
   pub Dr0: DWORD,
   pub Dr1: DWORD,
   pub Dr2: DWORD,
   pub Dr3: DWORD,
   pub Dr6: DWORD,
   pub Dr7: DWORD,
   pub FloatSave: WOW64_FLOATING_SAVE_AREA,
   pub SegGs: DWORD,
   pub SegFs: DWORD,
   pub SegEs: DWORD,
   pub SegDs: DWORD,
   pub Edi: DWORD,
   pub Esi: DWORD,
   pub Ebx: DWORD,
   pub Edx: DWORD,
   pub Ecx: DWORD,
   pub Eax: DWORD,
   pub Ebp: DWORD,
   pub Eip: DWORD,
   pub SegCs: DWORD,
   pub EFlags: DWORD,
   pub Esp: DWORD,
   pub SegSs: DWORD,
   pub ExtendedRegisters: [BYTE; 512usize],
}
impl Default for _WOW64_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WOW64_CONTEXT = _WOW64_CONTEXT;
pub type PWOW64_CONTEXT = *mut WOW64_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
   pub ExceptionCode: DWORD,
   pub ExceptionFlags: DWORD,
   pub ExceptionRecord: *mut _EXCEPTION_RECORD,
   pub ExceptionAddress: PVOID,
   pub NumberParameters: DWORD,
   pub ExceptionInformation: [ULONG_PTR; 15usize],
}
impl Default for _EXCEPTION_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_POINTERS {
   pub ExceptionRecord: PEXCEPTION_RECORD,
   pub ContextRecord: PCONTEXT,
}
impl Default for _EXCEPTION_POINTERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEXCEPTION_POINTERS = *mut _EXCEPTION_POINTERS;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type ACCESS_MASK = DWORD;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GENERIC_MAPPING {
   pub GenericRead: ACCESS_MASK,
   pub GenericWrite: ACCESS_MASK,
   pub GenericExecute: ACCESS_MASK,
   pub GenericAll: ACCESS_MASK,
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
   pub Luid: LUID,
   pub Attributes: DWORD,
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
pub type PLUID_AND_ATTRIBUTES = *mut _LUID_AND_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
   pub Value: [BYTE; 6usize],
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
pub type PSID_IDENTIFIER_AUTHORITY = *mut _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SID {
   pub Revision: BYTE,
   pub SubAuthorityCount: BYTE,
   pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
   pub SubAuthority: [DWORD; 1usize],
}
pub type SID = _SID;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SID_NAME_USE {
   SidTypeUser = 1,
   SidTypeGroup = 2,
   SidTypeDomain = 3,
   SidTypeAlias = 4,
   SidTypeWellKnownGroup = 5,
   SidTypeDeletedAccount = 6,
   SidTypeInvalid = 7,
   SidTypeUnknown = 8,
   SidTypeComputer = 9,
   SidTypeLabel = 10,
   SidTypeLogonSession = 11,
}
pub use self::_SID_NAME_USE as SID_NAME_USE;
pub type PSID_NAME_USE = *mut _SID_NAME_USE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES {
   pub Sid: PSID,
   pub Attributes: DWORD,
}
impl Default for _SID_AND_ATTRIBUTES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES;
pub type PSID_AND_ATTRIBUTES = *mut _SID_AND_ATTRIBUTES;
pub type SID_HASH_ENTRY = ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES_HASH {
   pub SidCount: DWORD,
   pub SidAttr: PSID_AND_ATTRIBUTES,
   pub Hash: [SID_HASH_ENTRY; 32usize],
}
impl Default for _SID_AND_ATTRIBUTES_HASH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PSID_AND_ATTRIBUTES_HASH = *mut _SID_AND_ATTRIBUTES_HASH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACL {
   pub AclRevision: BYTE,
   pub Sbz1: BYTE,
   pub AclSize: WORD,
   pub AceCount: WORD,
   pub Sbz2: WORD,
}
pub type ACL = _ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACE_HEADER {
   pub AceType: BYTE,
   pub AceFlags: BYTE,
   pub AceSize: WORD,
}
pub type ACE_HEADER = _ACE_HEADER;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ACL_INFORMATION_CLASS {
   AclRevisionInformation = 1,
   AclSizeInformation = 2,
}
pub use self::_ACL_INFORMATION_CLASS as ACL_INFORMATION_CLASS;
pub type SECURITY_DESCRIPTOR_CONTROL = WORD;
pub type PSECURITY_DESCRIPTOR_CONTROL = *mut WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE_LIST {
   pub Level: WORD,
   pub Sbz: WORD,
   pub ObjectType: *mut GUID,
}
impl Default for _OBJECT_TYPE_LIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POBJECT_TYPE_LIST = *mut _OBJECT_TYPE_LIST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _AUDIT_EVENT_TYPE {
   AuditEventObjectAccess = 0,
   AuditEventDirectoryServiceAccess = 1,
}
pub use self::_AUDIT_EVENT_TYPE as AUDIT_EVENT_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PRIVILEGE_SET {
   pub PrivilegeCount: DWORD,
   pub Control: DWORD,
   pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURITY_IMPERSONATION_LEVEL {
   SecurityAnonymous = 0,
   SecurityIdentification = 1,
   SecurityImpersonation = 2,
   SecurityDelegation = 3,
}
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TOKEN_TYPE {
   TokenPrimary = 1,
   TokenImpersonation = 2,
}
pub use self::_TOKEN_TYPE as TOKEN_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TOKEN_INFORMATION_CLASS {
   TokenUser = 1,
   TokenGroups = 2,
   TokenPrivileges = 3,
   TokenOwner = 4,
   TokenPrimaryGroup = 5,
   TokenDefaultDacl = 6,
   TokenSource = 7,
   TokenType = 8,
   TokenImpersonationLevel = 9,
   TokenStatistics = 10,
   TokenRestrictedSids = 11,
   TokenSessionId = 12,
   TokenGroupsAndPrivileges = 13,
   TokenSessionReference = 14,
   TokenSandBoxInert = 15,
   TokenAuditPolicy = 16,
   TokenOrigin = 17,
   TokenElevationType = 18,
   TokenLinkedToken = 19,
   TokenElevation = 20,
   TokenHasRestrictions = 21,
   TokenAccessInformation = 22,
   TokenVirtualizationAllowed = 23,
   TokenVirtualizationEnabled = 24,
   TokenIntegrityLevel = 25,
   TokenUIAccess = 26,
   TokenMandatoryPolicy = 27,
   TokenLogonSid = 28,
   TokenIsAppContainer = 29,
   TokenCapabilities = 30,
   TokenAppContainerSid = 31,
   TokenAppContainerNumber = 32,
   TokenUserClaimAttributes = 33,
   TokenDeviceClaimAttributes = 34,
   TokenRestrictedUserClaimAttributes = 35,
   TokenRestrictedDeviceClaimAttributes = 36,
   TokenDeviceGroups = 37,
   TokenRestrictedDeviceGroups = 38,
   TokenSecurityAttributes = 39,
   TokenIsRestricted = 40,
   TokenProcessTrustLevel = 41,
   TokenPrivateNameSpace = 42,
   TokenSingletonAttributes = 43,
   TokenBnoIsolation = 44,
   TokenChildProcessFlags = 45,
   TokenIsLessPrivilegedAppContainer = 46,
   TokenIsSandboxed = 47,
   TokenIsAppSilo = 48,
   MaxTokenInfoClass = 49,
}
pub use self::_TOKEN_INFORMATION_CLASS as TOKEN_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER {
   pub User: SID_AND_ATTRIBUTES,
}
impl Default for _TOKEN_USER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTOKEN_USER = *mut _TOKEN_USER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_GROUPS {
   pub GroupCount: DWORD,
   pub Groups: [SID_AND_ATTRIBUTES; 1usize],
}
impl Default for _TOKEN_GROUPS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTOKEN_GROUPS = *mut _TOKEN_GROUPS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_PRIVILEGES {
   pub PrivilegeCount: DWORD,
   pub Privileges: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type PTOKEN_PRIVILEGES = *mut _TOKEN_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_OWNER {
   pub Owner: PSID,
}
impl Default for _TOKEN_OWNER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTOKEN_OWNER = *mut _TOKEN_OWNER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PRIMARY_GROUP {
   pub PrimaryGroup: PSID,
}
impl Default for _TOKEN_PRIMARY_GROUP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTOKEN_PRIMARY_GROUP = *mut _TOKEN_PRIMARY_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_DEFAULT_DACL {
   pub DefaultDacl: PACL,
}
impl Default for _TOKEN_DEFAULT_DACL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTOKEN_DEFAULT_DACL = *mut _TOKEN_DEFAULT_DACL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_MANDATORY_POLICY {
   pub Policy: DWORD,
}
pub type PTOKEN_MANDATORY_POLICY = *mut _TOKEN_MANDATORY_POLICY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_SOURCE {
   pub SourceName: [CHAR; 8usize],
   pub SourceIdentifier: LUID,
}
pub type PTOKEN_SOURCE = *mut _TOKEN_SOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
   pub Version: DWORD64,
   pub Name: PWSTR,
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = *mut _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
   pub pValue: PVOID,
   pub ValueLength: DWORD,
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE =
   *mut _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_V1 {
   pub Name: PWSTR,
   pub ValueType: WORD,
   pub Reserved: WORD,
   pub Flags: DWORD,
   pub ValueCount: DWORD,
   pub Values: _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
   pub pInt64: PLONG64,
   pub pUint64: PDWORD64,
   pub ppString: *mut PWSTR,
   pub pFqbn: PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE,
   pub pOctetString: PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PCLAIM_SECURITY_ATTRIBUTE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
   pub Version: WORD,
   pub Reserved: WORD,
   pub AttributeCount: DWORD,
   pub Attribute: _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
   pub pAttributeV1: PCLAIM_SECURITY_ATTRIBUTE_V1,
}
impl Default for _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = *mut _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
#[repr(C)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
   pub Length: DWORD,
   pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
   pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
   pub EffectiveOnly: BOOLEAN,
}
impl Default for _SECURITY_QUALITY_OF_SERVICE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
pub type SECURITY_INFORMATION = DWORD;
pub type SE_SIGNING_LEVEL = BYTE;
pub type PSE_SIGNING_LEVEL = *mut BYTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_SET_ARRAY {
   pub JobHandle: HANDLE,
   pub MemberLevel: DWORD,
   pub Flags: DWORD,
}
impl Default for _JOB_SET_ARRAY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PJOB_SET_ARRAY = *mut _JOB_SET_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_REGISTRATION_RECORD {
   pub Next: *mut _EXCEPTION_REGISTRATION_RECORD,
   pub Handler: PEXCEPTION_ROUTINE,
}
impl Default for _EXCEPTION_REGISTRATION_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB {
   pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
   pub StackBase: PVOID,
   pub StackLimit: PVOID,
   pub SubSystemTib: PVOID,
   pub __bindgen_anon_1: _NT_TIB__bindgen_ty_1,
   pub ArbitraryUserPointer: PVOID,
   pub Self_: *mut _NT_TIB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB__bindgen_ty_1 {
   pub FiberData: PVOID,
   pub Version: DWORD,
}
impl Default for _NT_TIB__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _NT_TIB {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type NT_TIB = _NT_TIB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB32 {
   pub ExceptionList: DWORD,
   pub StackBase: DWORD,
   pub StackLimit: DWORD,
   pub SubSystemTib: DWORD,
   pub __bindgen_anon_1: _NT_TIB32__bindgen_ty_1,
   pub ArbitraryUserPointer: DWORD,
   pub Self_: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB32__bindgen_ty_1 {
   pub FiberData: DWORD,
   pub Version: DWORD,
}
impl Default for _NT_TIB32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _NT_TIB32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type NT_TIB32 = _NT_TIB32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_COUNTERS {
   pub ReadOperationCount: ULONGLONG,
   pub WriteOperationCount: ULONGLONG,
   pub OtherOperationCount: ULONGLONG,
   pub ReadTransferCount: ULONGLONG,
   pub WriteTransferCount: ULONGLONG,
   pub OtherTransferCount: ULONGLONG,
}
pub type IO_COUNTERS = _IO_COUNTERS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HARDWARE_COUNTER_TYPE {
   PMCCounter = 0,
   MaxHardwareCounterType = 1,
}
pub use self::_HARDWARE_COUNTER_TYPE as HARDWARE_COUNTER_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_MITIGATION_POLICY {
   ProcessDEPPolicy = 0,
   ProcessASLRPolicy = 1,
   ProcessDynamicCodePolicy = 2,
   ProcessStrictHandleCheckPolicy = 3,
   ProcessSystemCallDisablePolicy = 4,
   ProcessMitigationOptionsMask = 5,
   ProcessExtensionPointDisablePolicy = 6,
   ProcessControlFlowGuardPolicy = 7,
   ProcessSignaturePolicy = 8,
   ProcessFontDisablePolicy = 9,
   ProcessImageLoadPolicy = 10,
   ProcessSystemCallFilterPolicy = 11,
   ProcessPayloadRestrictionPolicy = 12,
   ProcessChildProcessPolicy = 13,
   ProcessSideChannelIsolationPolicy = 14,
   ProcessUserShadowStackPolicy = 15,
   ProcessRedirectionTrustPolicy = 16,
   ProcessUserPointerAuthPolicy = 17,
   ProcessSEHOPPolicy = 18,
   MaxProcessMitigationPolicy = 19,
}
pub use self::_PROCESS_MITIGATION_POLICY as PROCESS_MITIGATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnableBottomUpRandomization(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableBottomUpRandomization(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableForceRelocateImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableForceRelocateImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableHighEntropy(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableHighEntropy(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DisallowStrippedImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisallowStrippedImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableBottomUpRandomization: DWORD,
      EnableForceRelocateImages: DWORD,
      EnableHighEntropy: DWORD,
      DisallowStrippedImages: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableBottomUpRandomization: u32 =
            unsafe { ::core::mem::transmute(EnableBottomUpRandomization) };
         EnableBottomUpRandomization as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let EnableForceRelocateImages: u32 =
            unsafe { ::core::mem::transmute(EnableForceRelocateImages) };
         EnableForceRelocateImages as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let EnableHighEntropy: u32 = unsafe { ::core::mem::transmute(EnableHighEntropy) };
         EnableHighEntropy as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let DisallowStrippedImages: u32 =
            unsafe { ::core::mem::transmute(DisallowStrippedImages) };
         DisallowStrippedImages as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_ASLR_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_ASLR_POLICY = _PROCESS_MITIGATION_ASLR_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SEHOP_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnableSehop(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableSehop(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableSehop: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableSehop: u32 = unsafe { ::core::mem::transmute(EnableSehop) };
         EnableSehop as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_SEHOP_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_SEHOP_POLICY = _PROCESS_MITIGATION_SEHOP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn RaiseExceptionOnInvalidHandleReference(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RaiseExceptionOnInvalidHandleReference(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HandleExceptionsPermanentlyEnabled(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HandleExceptionsPermanentlyEnabled(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      RaiseExceptionOnInvalidHandleReference: DWORD,
      HandleExceptionsPermanentlyEnabled: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let RaiseExceptionOnInvalidHandleReference: u32 =
            unsafe { ::core::mem::transmute(RaiseExceptionOnInvalidHandleReference) };
         RaiseExceptionOnInvalidHandleReference as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let HandleExceptionsPermanentlyEnabled: u32 =
            unsafe { ::core::mem::transmute(HandleExceptionsPermanentlyEnabled) };
         HandleExceptionsPermanentlyEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
   _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn DisallowWin32kSystemCalls(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisallowWin32kSystemCalls(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditDisallowWin32kSystemCalls(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditDisallowWin32kSystemCalls(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DisallowWin32kSystemCalls: DWORD,
      AuditDisallowWin32kSystemCalls: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DisallowWin32kSystemCalls: u32 =
            unsafe { ::core::mem::transmute(DisallowWin32kSystemCalls) };
         DisallowWin32kSystemCalls as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditDisallowWin32kSystemCalls: u32 =
            unsafe { ::core::mem::transmute(AuditDisallowWin32kSystemCalls) };
         AuditDisallowWin32kSystemCalls as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
   _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1:
      _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn DisableExtensionPoints(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisableExtensionPoints(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DisableExtensionPoints: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DisableExtensionPoints: u32 =
            unsafe { ::core::mem::transmute(DisableExtensionPoints) };
         DisableExtensionPoints as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
   _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ProhibitDynamicCode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProhibitDynamicCode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AllowThreadOptOut(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AllowThreadOptOut(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AllowRemoteDowngrade(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AllowRemoteDowngrade(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditProhibitDynamicCode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditProhibitDynamicCode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ProhibitDynamicCode: DWORD,
      AllowThreadOptOut: DWORD,
      AllowRemoteDowngrade: DWORD,
      AuditProhibitDynamicCode: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ProhibitDynamicCode: u32 = unsafe { ::core::mem::transmute(ProhibitDynamicCode) };
         ProhibitDynamicCode as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AllowThreadOptOut: u32 = unsafe { ::core::mem::transmute(AllowThreadOptOut) };
         AllowThreadOptOut as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let AllowRemoteDowngrade: u32 = unsafe { ::core::mem::transmute(AllowRemoteDowngrade) };
         AllowRemoteDowngrade as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditProhibitDynamicCode: u32 =
            unsafe { ::core::mem::transmute(AuditProhibitDynamicCode) };
         AuditProhibitDynamicCode as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnableControlFlowGuard(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableControlFlowGuard(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableExportSuppression(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableExportSuppression(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn StrictMode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_StrictMode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableXfg(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableXfg(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableXfgAuditMode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableXfgAuditMode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableControlFlowGuard: DWORD,
      EnableExportSuppression: DWORD,
      StrictMode: DWORD,
      EnableXfg: DWORD,
      EnableXfgAuditMode: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableControlFlowGuard: u32 =
            unsafe { ::core::mem::transmute(EnableControlFlowGuard) };
         EnableControlFlowGuard as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let EnableExportSuppression: u32 =
            unsafe { ::core::mem::transmute(EnableExportSuppression) };
         EnableExportSuppression as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let StrictMode: u32 = unsafe { ::core::mem::transmute(StrictMode) };
         StrictMode as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let EnableXfg: u32 = unsafe { ::core::mem::transmute(EnableXfg) };
         EnableXfg as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let EnableXfgAuditMode: u32 = unsafe { ::core::mem::transmute(EnableXfgAuditMode) };
         EnableXfgAuditMode as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
   _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn MicrosoftSignedOnly(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MicrosoftSignedOnly(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn StoreSignedOnly(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_StoreSignedOnly(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MitigationOptIn(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MitigationOptIn(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditMicrosoftSignedOnly(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditMicrosoftSignedOnly(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditStoreSignedOnly(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditStoreSignedOnly(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      MicrosoftSignedOnly: DWORD,
      StoreSignedOnly: DWORD,
      MitigationOptIn: DWORD,
      AuditMicrosoftSignedOnly: DWORD,
      AuditStoreSignedOnly: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let MicrosoftSignedOnly: u32 = unsafe { ::core::mem::transmute(MicrosoftSignedOnly) };
         MicrosoftSignedOnly as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let StoreSignedOnly: u32 = unsafe { ::core::mem::transmute(StoreSignedOnly) };
         StoreSignedOnly as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let MitigationOptIn: u32 = unsafe { ::core::mem::transmute(MitigationOptIn) };
         MitigationOptIn as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditMicrosoftSignedOnly: u32 =
            unsafe { ::core::mem::transmute(AuditMicrosoftSignedOnly) };
         AuditMicrosoftSignedOnly as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let AuditStoreSignedOnly: u32 = unsafe { ::core::mem::transmute(AuditStoreSignedOnly) };
         AuditStoreSignedOnly as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn DisableNonSystemFonts(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisableNonSystemFonts(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditNonSystemFontLoading(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditNonSystemFontLoading(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DisableNonSystemFonts: DWORD,
      AuditNonSystemFontLoading: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DisableNonSystemFonts: u32 = unsafe { ::core::mem::transmute(DisableNonSystemFonts) };
         DisableNonSystemFonts as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditNonSystemFontLoading: u32 =
            unsafe { ::core::mem::transmute(AuditNonSystemFontLoading) };
         AuditNonSystemFontLoading as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_FONT_DISABLE_POLICY = _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn NoRemoteImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoRemoteImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn NoLowMandatoryLabelImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoLowMandatoryLabelImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn PreferSystem32Images(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PreferSystem32Images(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditNoRemoteImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditNoRemoteImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditNoLowMandatoryLabelImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditNoLowMandatoryLabelImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      NoRemoteImages: DWORD,
      NoLowMandatoryLabelImages: DWORD,
      PreferSystem32Images: DWORD,
      AuditNoRemoteImages: DWORD,
      AuditNoLowMandatoryLabelImages: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let NoRemoteImages: u32 = unsafe { ::core::mem::transmute(NoRemoteImages) };
         NoRemoteImages as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let NoLowMandatoryLabelImages: u32 =
            unsafe { ::core::mem::transmute(NoLowMandatoryLabelImages) };
         NoLowMandatoryLabelImages as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let PreferSystem32Images: u32 = unsafe { ::core::mem::transmute(PreferSystem32Images) };
         PreferSystem32Images as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditNoRemoteImages: u32 = unsafe { ::core::mem::transmute(AuditNoRemoteImages) };
         AuditNoRemoteImages as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let AuditNoLowMandatoryLabelImages: u32 =
            unsafe { ::core::mem::transmute(AuditNoLowMandatoryLabelImages) };
         AuditNoLowMandatoryLabelImages as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_IMAGE_LOAD_POLICY = _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn FilterId(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_FilterId(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      FilterId: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let FilterId: u32 = unsafe { ::core::mem::transmute(FilterId) };
         FilterId as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
   _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnableExportAddressFilter(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableExportAddressFilter(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditExportAddressFilter(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditExportAddressFilter(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableExportAddressFilterPlus(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableExportAddressFilterPlus(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditExportAddressFilterPlus(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditExportAddressFilterPlus(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableImportAddressFilter(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableImportAddressFilter(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditImportAddressFilter(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditImportAddressFilter(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableRopStackPivot(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableRopStackPivot(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditRopStackPivot(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditRopStackPivot(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableRopCallerCheck(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableRopCallerCheck(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditRopCallerCheck(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditRopCallerCheck(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableRopSimExec(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableRopSimExec(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditRopSimExec(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditRopSimExec(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 20u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableExportAddressFilter: DWORD,
      AuditExportAddressFilter: DWORD,
      EnableExportAddressFilterPlus: DWORD,
      AuditExportAddressFilterPlus: DWORD,
      EnableImportAddressFilter: DWORD,
      AuditImportAddressFilter: DWORD,
      EnableRopStackPivot: DWORD,
      AuditRopStackPivot: DWORD,
      EnableRopCallerCheck: DWORD,
      AuditRopCallerCheck: DWORD,
      EnableRopSimExec: DWORD,
      AuditRopSimExec: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableExportAddressFilter: u32 =
            unsafe { ::core::mem::transmute(EnableExportAddressFilter) };
         EnableExportAddressFilter as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditExportAddressFilter: u32 =
            unsafe { ::core::mem::transmute(AuditExportAddressFilter) };
         AuditExportAddressFilter as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let EnableExportAddressFilterPlus: u32 =
            unsafe { ::core::mem::transmute(EnableExportAddressFilterPlus) };
         EnableExportAddressFilterPlus as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditExportAddressFilterPlus: u32 =
            unsafe { ::core::mem::transmute(AuditExportAddressFilterPlus) };
         AuditExportAddressFilterPlus as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let EnableImportAddressFilter: u32 =
            unsafe { ::core::mem::transmute(EnableImportAddressFilter) };
         EnableImportAddressFilter as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let AuditImportAddressFilter: u32 =
            unsafe { ::core::mem::transmute(AuditImportAddressFilter) };
         AuditImportAddressFilter as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let EnableRopStackPivot: u32 = unsafe { ::core::mem::transmute(EnableRopStackPivot) };
         EnableRopStackPivot as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let AuditRopStackPivot: u32 = unsafe { ::core::mem::transmute(AuditRopStackPivot) };
         AuditRopStackPivot as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let EnableRopCallerCheck: u32 = unsafe { ::core::mem::transmute(EnableRopCallerCheck) };
         EnableRopCallerCheck as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let AuditRopCallerCheck: u32 = unsafe { ::core::mem::transmute(AuditRopCallerCheck) };
         AuditRopCallerCheck as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let EnableRopSimExec: u32 = unsafe { ::core::mem::transmute(EnableRopSimExec) };
         EnableRopSimExec as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let AuditRopSimExec: u32 = unsafe { ::core::mem::transmute(AuditRopSimExec) };
         AuditRopSimExec as u64
      });
      __bindgen_bitfield_unit.set(12usize, 20u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
   _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn NoChildProcessCreation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoChildProcessCreation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditNoChildProcessCreation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditNoChildProcessCreation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AllowSecureProcessCreation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AllowSecureProcessCreation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      NoChildProcessCreation: DWORD,
      AuditNoChildProcessCreation: DWORD,
      AllowSecureProcessCreation: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let NoChildProcessCreation: u32 =
            unsafe { ::core::mem::transmute(NoChildProcessCreation) };
         NoChildProcessCreation as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditNoChildProcessCreation: u32 =
            unsafe { ::core::mem::transmute(AuditNoChildProcessCreation) };
         AuditNoChildProcessCreation as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let AllowSecureProcessCreation: u32 =
            unsafe { ::core::mem::transmute(AllowSecureProcessCreation) };
         AllowSecureProcessCreation as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_CHILD_PROCESS_POLICY = _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1:
      _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn SmtBranchTargetIsolation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SmtBranchTargetIsolation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsolateSecurityDomain(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsolateSecurityDomain(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DisablePageCombine(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisablePageCombine(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisable(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisable(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn RestrictCoreSharing(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RestrictCoreSharing(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SmtBranchTargetIsolation: DWORD,
      IsolateSecurityDomain: DWORD,
      DisablePageCombine: DWORD,
      SpeculativeStoreBypassDisable: DWORD,
      RestrictCoreSharing: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SmtBranchTargetIsolation: u32 =
            unsafe { ::core::mem::transmute(SmtBranchTargetIsolation) };
         SmtBranchTargetIsolation as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsolateSecurityDomain: u32 = unsafe { ::core::mem::transmute(IsolateSecurityDomain) };
         IsolateSecurityDomain as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let DisablePageCombine: u32 = unsafe { ::core::mem::transmute(DisablePageCombine) };
         DisablePageCombine as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SpeculativeStoreBypassDisable: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisable) };
         SpeculativeStoreBypassDisable as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let RestrictCoreSharing: u32 = unsafe { ::core::mem::transmute(RestrictCoreSharing) };
         RestrictCoreSharing as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY =
   _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnableUserShadowStack(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableUserShadowStack(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditUserShadowStack(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditUserShadowStack(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SetContextIpValidation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SetContextIpValidation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditSetContextIpValidation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditSetContextIpValidation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableUserShadowStackStrictMode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableUserShadowStackStrictMode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BlockNonCetBinaries(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BlockNonCetBinaries(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BlockNonCetBinariesNonEhcont(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BlockNonCetBinariesNonEhcont(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditBlockNonCetBinaries(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditBlockNonCetBinaries(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CetDynamicApisOutOfProcOnly(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CetDynamicApisOutOfProcOnly(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SetContextIpValidationRelaxedMode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SetContextIpValidationRelaxedMode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 22u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableUserShadowStack: DWORD,
      AuditUserShadowStack: DWORD,
      SetContextIpValidation: DWORD,
      AuditSetContextIpValidation: DWORD,
      EnableUserShadowStackStrictMode: DWORD,
      BlockNonCetBinaries: DWORD,
      BlockNonCetBinariesNonEhcont: DWORD,
      AuditBlockNonCetBinaries: DWORD,
      CetDynamicApisOutOfProcOnly: DWORD,
      SetContextIpValidationRelaxedMode: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableUserShadowStack: u32 = unsafe { ::core::mem::transmute(EnableUserShadowStack) };
         EnableUserShadowStack as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditUserShadowStack: u32 = unsafe { ::core::mem::transmute(AuditUserShadowStack) };
         AuditUserShadowStack as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let SetContextIpValidation: u32 =
            unsafe { ::core::mem::transmute(SetContextIpValidation) };
         SetContextIpValidation as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditSetContextIpValidation: u32 =
            unsafe { ::core::mem::transmute(AuditSetContextIpValidation) };
         AuditSetContextIpValidation as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let EnableUserShadowStackStrictMode: u32 =
            unsafe { ::core::mem::transmute(EnableUserShadowStackStrictMode) };
         EnableUserShadowStackStrictMode as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let BlockNonCetBinaries: u32 = unsafe { ::core::mem::transmute(BlockNonCetBinaries) };
         BlockNonCetBinaries as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let BlockNonCetBinariesNonEhcont: u32 =
            unsafe { ::core::mem::transmute(BlockNonCetBinariesNonEhcont) };
         BlockNonCetBinariesNonEhcont as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let AuditBlockNonCetBinaries: u32 =
            unsafe { ::core::mem::transmute(AuditBlockNonCetBinaries) };
         AuditBlockNonCetBinaries as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let CetDynamicApisOutOfProcOnly: u32 =
            unsafe { ::core::mem::transmute(CetDynamicApisOutOfProcOnly) };
         CetDynamicApisOutOfProcOnly as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let SetContextIpValidationRelaxedMode: u32 =
            unsafe { ::core::mem::transmute(SetContextIpValidationRelaxedMode) };
         SetContextIpValidationRelaxedMode as u64
      });
      __bindgen_bitfield_unit.set(10usize, 22u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY = _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnablePointerAuthUserIp(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnablePointerAuthUserIp(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnablePointerAuthUserIp: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnablePointerAuthUserIp: u32 =
            unsafe { ::core::mem::transmute(EnablePointerAuthUserIp) };
         EnablePointerAuthUserIp as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY = _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnforceRedirectionTrust(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnforceRedirectionTrust(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditRedirectionTrust(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditRedirectionTrust(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnforceRedirectionTrust: DWORD,
      AuditRedirectionTrust: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnforceRedirectionTrust: u32 =
            unsafe { ::core::mem::transmute(EnforceRedirectionTrust) };
         EnforceRedirectionTrust as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditRedirectionTrust: u32 = unsafe { ::core::mem::transmute(AuditRedirectionTrust) };
         AuditRedirectionTrust as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY = _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
   pub TotalUserTime: LARGE_INTEGER,
   pub TotalKernelTime: LARGE_INTEGER,
   pub ThisPeriodTotalUserTime: LARGE_INTEGER,
   pub ThisPeriodTotalKernelTime: LARGE_INTEGER,
   pub TotalPageFaultCount: DWORD,
   pub TotalProcesses: DWORD,
   pub ActiveProcesses: DWORD,
   pub TotalTerminatedProcesses: DWORD,
}
impl Default for _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
   pub PerProcessUserTimeLimit: LARGE_INTEGER,
   pub PerJobUserTimeLimit: LARGE_INTEGER,
   pub LimitFlags: DWORD,
   pub MinimumWorkingSetSize: SIZE_T,
   pub MaximumWorkingSetSize: SIZE_T,
   pub ActiveProcessLimit: DWORD,
   pub Affinity: ULONG_PTR,
   pub PriorityClass: DWORD,
   pub SchedulingClass: DWORD,
}
impl Default for _JOBOBJECT_BASIC_LIMIT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_BASIC_LIMIT_INFORMATION = _JOBOBJECT_BASIC_LIMIT_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _JOBOBJECTINFOCLASS {
   JobObjectBasicAccountingInformation = 1,
   JobObjectBasicLimitInformation = 2,
   JobObjectBasicProcessIdList = 3,
   JobObjectBasicUIRestrictions = 4,
   JobObjectSecurityLimitInformation = 5,
   JobObjectEndOfJobTimeInformation = 6,
   JobObjectAssociateCompletionPortInformation = 7,
   JobObjectBasicAndIoAccountingInformation = 8,
   JobObjectExtendedLimitInformation = 9,
   JobObjectJobSetInformation = 10,
   JobObjectGroupInformation = 11,
   JobObjectNotificationLimitInformation = 12,
   JobObjectLimitViolationInformation = 13,
   JobObjectGroupInformationEx = 14,
   JobObjectCpuRateControlInformation = 15,
   JobObjectCompletionFilter = 16,
   JobObjectCompletionCounter = 17,
   JobObjectReserved1Information = 18,
   JobObjectReserved2Information = 19,
   JobObjectReserved3Information = 20,
   JobObjectReserved4Information = 21,
   JobObjectReserved5Information = 22,
   JobObjectReserved6Information = 23,
   JobObjectReserved7Information = 24,
   JobObjectReserved8Information = 25,
   JobObjectReserved9Information = 26,
   JobObjectReserved10Information = 27,
   JobObjectReserved11Information = 28,
   JobObjectReserved12Information = 29,
   JobObjectReserved13Information = 30,
   JobObjectReserved14Information = 31,
   JobObjectNetRateControlInformation = 32,
   JobObjectNotificationLimitInformation2 = 33,
   JobObjectLimitViolationInformation2 = 34,
   JobObjectCreateSilo = 35,
   JobObjectSiloBasicInformation = 36,
   JobObjectReserved15Information = 37,
   JobObjectReserved16Information = 38,
   JobObjectReserved17Information = 39,
   JobObjectReserved18Information = 40,
   JobObjectReserved19Information = 41,
   JobObjectReserved20Information = 42,
   JobObjectReserved21Information = 43,
   JobObjectReserved22Information = 44,
   JobObjectReserved23Information = 45,
   JobObjectReserved24Information = 46,
   JobObjectReserved25Information = 47,
   JobObjectReserved26Information = 48,
   JobObjectReserved27Information = 49,
   MaxJobObjectInfoClass = 50,
}
pub use self::_JOBOBJECTINFOCLASS as JOBOBJECTINFOCLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FIRMWARE_TYPE {
   FirmwareTypeUnknown = 0,
   FirmwareTypeBios = 1,
   FirmwareTypeUefi = 2,
   FirmwareTypeMax = 3,
}
pub use self::_FIRMWARE_TYPE as FIRMWARE_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _XSTATE_FEATURE {
   pub Offset: DWORD,
   pub Size: DWORD,
}
pub type XSTATE_FEATURE = _XSTATE_FEATURE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSTATE_CONFIGURATION {
   pub EnabledFeatures: DWORD64,
   pub EnabledVolatileFeatures: DWORD64,
   pub Size: DWORD,
   pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1,
   pub Features: [XSTATE_FEATURE; 64usize],
   pub EnabledSupervisorFeatures: DWORD64,
   pub AlignedFeatures: DWORD64,
   pub AllFeatureSize: DWORD,
   pub AllFeatures: [DWORD; 64usize],
   pub EnabledUserVisibleSupervisorFeatures: DWORD64,
   pub ExtendedFeatureDisableFeatures: DWORD64,
   pub AllNonLargeFeatureSize: DWORD,
   pub Spare: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XSTATE_CONFIGURATION__bindgen_ty_1 {
   pub ControlFlags: DWORD,
   pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn OptimizedSave(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_OptimizedSave(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CompactionEnabled(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CompactionEnabled(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ExtendedFeatureDisable(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ExtendedFeatureDisable(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      OptimizedSave: DWORD,
      CompactionEnabled: DWORD,
      ExtendedFeatureDisable: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let OptimizedSave: u32 = unsafe { ::core::mem::transmute(OptimizedSave) };
         OptimizedSave as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let CompactionEnabled: u32 = unsafe { ::core::mem::transmute(CompactionEnabled) };
         CompactionEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ExtendedFeatureDisable: u32 =
            unsafe { ::core::mem::transmute(ExtendedFeatureDisable) };
         ExtendedFeatureDisable as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _XSTATE_CONFIGURATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _XSTATE_CONFIGURATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type XSTATE_CONFIGURATION = _XSTATE_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CFG_CALL_TARGET_INFO {
   pub Offset: ULONG_PTR,
   pub Flags: ULONG_PTR,
}
pub type PCFG_CALL_TARGET_INFO = *mut _CFG_CALL_TARGET_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER {
   pub __bindgen_anon_1: MEM_EXTENDED_PARAMETER__bindgen_ty_1,
   pub __bindgen_anon_2: MEM_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
   #[inline]
   pub fn Type(&self) -> DWORD64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: DWORD64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> DWORD64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: DWORD64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 56u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Type: DWORD64, Reserved: DWORD64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Type: u64 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(8usize, 56u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MEM_EXTENDED_PARAMETER__bindgen_ty_2 {
   pub ULong64: DWORD64,
   pub Pointer: PVOID,
   pub Size: SIZE_T,
   pub Handle: HANDLE,
   pub ULong: DWORD,
}
impl Default for MEM_EXTENDED_PARAMETER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for MEM_EXTENDED_PARAMETER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PMEM_EXTENDED_PARAMETER = *mut MEM_EXTENDED_PARAMETER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_ID_128 {
   pub Identifier: [BYTE; 16usize],
}
pub type FILE_ID_128 = _FILE_ID_128;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
   pub Buffer: *mut cty::c_void,
   pub Alignment: ULONGLONG,
}
impl Default for _FILE_SEGMENT_ELEMENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER {
   pub ReparseTag: DWORD,
   pub ReparseDataLength: WORD,
   pub Reserved: WORD,
   pub ReparseGuid: GUID,
   pub GenericReparseBuffer: _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1 {
   pub DataBuffer: [BYTE; 1usize],
}
pub type REPARSE_GUID_DATA_BUFFER = _REPARSE_GUID_DATA_BUFFER;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_POWER_STATE {
   PowerSystemUnspecified = 0,
   PowerSystemWorking = 1,
   PowerSystemSleeping1 = 2,
   PowerSystemSleeping2 = 3,
   PowerSystemSleeping3 = 4,
   PowerSystemHibernate = 5,
   PowerSystemShutdown = 6,
   PowerSystemMaximum = 7,
}
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_ACTION {
   PowerActionNone = 0,
   PowerActionReserved = 1,
   PowerActionSleep = 2,
   PowerActionHibernate = 3,
   PowerActionShutdown = 4,
   PowerActionShutdownReset = 5,
   PowerActionShutdownOff = 6,
   PowerActionWarmEject = 7,
   PowerActionDisplayOff = 8,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_POWER_STATE {
   PowerDeviceUnspecified = 0,
   PowerDeviceD0 = 1,
   PowerDeviceD1 = 2,
   PowerDeviceD2 = 3,
   PowerDeviceD3 = 4,
   PowerDeviceMaximum = 5,
}
pub use self::_DEVICE_POWER_STATE as DEVICE_POWER_STATE;
pub type PDEVICE_POWER_STATE = *mut _DEVICE_POWER_STATE;
pub type EXECUTION_STATE = DWORD;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LATENCY_TIME {
   LT_DONT_CARE = 0,
   LT_LOWEST_LATENCY = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_INFORMATION_LEVEL {
   SystemPowerPolicyAc = 0,
   SystemPowerPolicyDc = 1,
   VerifySystemPolicyAc = 2,
   VerifySystemPolicyDc = 3,
   SystemPowerCapabilities = 4,
   SystemBatteryState = 5,
   SystemPowerStateHandler = 6,
   ProcessorStateHandler = 7,
   SystemPowerPolicyCurrent = 8,
   AdministratorPowerPolicy = 9,
   SystemReserveHiberFile = 10,
   ProcessorInformation = 11,
   SystemPowerInformation = 12,
   ProcessorStateHandler2 = 13,
   LastWakeTime = 14,
   LastSleepTime = 15,
   SystemExecutionState = 16,
   SystemPowerStateNotifyHandler = 17,
   ProcessorPowerPolicyAc = 18,
   ProcessorPowerPolicyDc = 19,
   VerifyProcessorPowerPolicyAc = 20,
   VerifyProcessorPowerPolicyDc = 21,
   ProcessorPowerPolicyCurrent = 22,
   SystemPowerStateLogging = 23,
   SystemPowerLoggingEntry = 24,
   SetPowerSettingValue = 25,
   NotifyUserPowerSetting = 26,
   PowerInformationLevelUnused0 = 27,
   SystemMonitorHiberBootPowerOff = 28,
   SystemVideoState = 29,
   TraceApplicationPowerMessage = 30,
   TraceApplicationPowerMessageEnd = 31,
   ProcessorPerfStates = 32,
   ProcessorIdleStates = 33,
   ProcessorCap = 34,
   SystemWakeSource = 35,
   SystemHiberFileInformation = 36,
   TraceServicePowerMessage = 37,
   ProcessorLoad = 38,
   PowerShutdownNotification = 39,
   MonitorCapabilities = 40,
   SessionPowerInit = 41,
   SessionDisplayState = 42,
   PowerRequestCreate = 43,
   PowerRequestAction = 44,
   GetPowerRequestList = 45,
   ProcessorInformationEx = 46,
   NotifyUserModeLegacyPowerEvent = 47,
   GroupPark = 48,
   ProcessorIdleDomains = 49,
   WakeTimerList = 50,
   SystemHiberFileSize = 51,
   ProcessorIdleStatesHv = 52,
   ProcessorPerfStatesHv = 53,
   ProcessorPerfCapHv = 54,
   ProcessorSetIdle = 55,
   LogicalProcessorIdling = 56,
   UserPresence = 57,
   PowerSettingNotificationName = 58,
   GetPowerSettingValue = 59,
   IdleResiliency = 60,
   SessionRITState = 61,
   SessionConnectNotification = 62,
   SessionPowerCleanup = 63,
   SessionLockState = 64,
   SystemHiberbootState = 65,
   PlatformInformation = 66,
   PdcInvocation = 67,
   MonitorInvocation = 68,
   FirmwareTableInformationRegistered = 69,
   SetShutdownSelectedTime = 70,
   SuspendResumeInvocation = 71,
   PlmPowerRequestCreate = 72,
   ScreenOff = 73,
   CsDeviceNotification = 74,
   PlatformRole = 75,
   LastResumePerformance = 76,
   DisplayBurst = 77,
   ExitLatencySamplingPercentage = 78,
   RegisterSpmPowerSettings = 79,
   PlatformIdleStates = 80,
   ProcessorIdleVeto = 81,
   PlatformIdleVeto = 82,
   SystemBatteryStatePrecise = 83,
   ThermalEvent = 84,
   PowerRequestActionInternal = 85,
   BatteryDeviceState = 86,
   PowerInformationInternal = 87,
   ThermalStandby = 88,
   SystemHiberFileType = 89,
   PhysicalPowerButtonPress = 90,
   QueryPotentialDripsConstraint = 91,
   EnergyTrackerCreate = 92,
   EnergyTrackerQuery = 93,
   UpdateBlackBoxRecorder = 94,
   SessionAllowExternalDmaDevices = 95,
   SendSuspendResumeNotification = 96,
   BlackBoxRecorderDirectAccessBuffer = 97,
   PowerInformationLevelMaximum = 98,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_MONITOR_REQUEST_REASON {
   MonitorRequestReasonUnknown = 0,
   MonitorRequestReasonPowerButton = 1,
   MonitorRequestReasonRemoteConnection = 2,
   MonitorRequestReasonScMonitorpower = 3,
   MonitorRequestReasonUserInput = 4,
   MonitorRequestReasonAcDcDisplayBurst = 5,
   MonitorRequestReasonUserDisplayBurst = 6,
   MonitorRequestReasonPoSetSystemState = 7,
   MonitorRequestReasonSetThreadExecutionState = 8,
   MonitorRequestReasonFullWake = 9,
   MonitorRequestReasonSessionUnlock = 10,
   MonitorRequestReasonScreenOffRequest = 11,
   MonitorRequestReasonIdleTimeout = 12,
   MonitorRequestReasonPolicyChange = 13,
   MonitorRequestReasonSleepButton = 14,
   MonitorRequestReasonLid = 15,
   MonitorRequestReasonBatteryCountChange = 16,
   MonitorRequestReasonGracePeriod = 17,
   MonitorRequestReasonPnP = 18,
   MonitorRequestReasonDP = 19,
   MonitorRequestReasonSxTransition = 20,
   MonitorRequestReasonSystemIdle = 21,
   MonitorRequestReasonNearProximity = 22,
   MonitorRequestReasonThermalStandby = 23,
   MonitorRequestReasonResumePdc = 24,
   MonitorRequestReasonResumeS4 = 25,
   MonitorRequestReasonTerminal = 26,
   MonitorRequestReasonPdcSignal = 27,
   MonitorRequestReasonAcDcDisplayBurstSuppressed = 28,
   MonitorRequestReasonSystemStateEntered = 29,
   MonitorRequestReasonWinrt = 30,
   MonitorRequestReasonUserInputKeyboard = 31,
   MonitorRequestReasonUserInputMouse = 32,
   MonitorRequestReasonUserInputTouchpad = 33,
   MonitorRequestReasonUserInputPen = 34,
   MonitorRequestReasonUserInputAccelerometer = 35,
   MonitorRequestReasonUserInputHid = 36,
   MonitorRequestReasonUserInputPoUserPresent = 37,
   MonitorRequestReasonUserInputSessionSwitch = 38,
   MonitorRequestReasonUserInputInitialization = 39,
   MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = 40,
   MonitorRequestReasonPdcSignalWindowsMobileShell = 41,
   MonitorRequestReasonPdcSignalHeyCortana = 42,
   MonitorRequestReasonPdcSignalHolographicShell = 43,
   MonitorRequestReasonPdcSignalFingerprint = 44,
   MonitorRequestReasonDirectedDrips = 45,
   MonitorRequestReasonDim = 46,
   MonitorRequestReasonBuiltinPanel = 47,
   MonitorRequestReasonDisplayRequiredUnDim = 48,
   MonitorRequestReasonBatteryCountChangeSuppressed = 49,
   MonitorRequestReasonResumeModernStandby = 50,
   MonitorRequestReasonTerminalInit = 51,
   MonitorRequestReasonPdcSignalSensorsHumanPresence = 52,
   MonitorRequestReasonBatteryPreCritical = 53,
   MonitorRequestReasonUserInputTouch = 54,
   MonitorRequestReasonMax = 55,
}
#[repr(C, packed(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DOS_HEADER {
   pub e_magic: WORD,
   pub e_cblp: WORD,
   pub e_cp: WORD,
   pub e_crlc: WORD,
   pub e_cparhdr: WORD,
   pub e_minalloc: WORD,
   pub e_maxalloc: WORD,
   pub e_ss: WORD,
   pub e_sp: WORD,
   pub e_csum: WORD,
   pub e_ip: WORD,
   pub e_cs: WORD,
   pub e_lfarlc: WORD,
   pub e_ovno: WORD,
   pub e_res: [WORD; 4usize],
   pub e_oemid: WORD,
   pub e_oeminfo: WORD,
   pub e_res2: [WORD; 10usize],
   pub e_lfanew: LONG,
}
pub type IMAGE_DOS_HEADER = _IMAGE_DOS_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_FILE_HEADER {
   pub Machine: WORD,
   pub NumberOfSections: WORD,
   pub TimeDateStamp: DWORD,
   pub PointerToSymbolTable: DWORD,
   pub NumberOfSymbols: DWORD,
   pub SizeOfOptionalHeader: WORD,
   pub Characteristics: WORD,
}
pub type IMAGE_FILE_HEADER = _IMAGE_FILE_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DATA_DIRECTORY {
   pub VirtualAddress: DWORD,
   pub Size: DWORD,
}
pub type IMAGE_DATA_DIRECTORY = _IMAGE_DATA_DIRECTORY;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_OPTIONAL_HEADER64 {
   pub Magic: WORD,
   pub MajorLinkerVersion: BYTE,
   pub MinorLinkerVersion: BYTE,
   pub SizeOfCode: DWORD,
   pub SizeOfInitializedData: DWORD,
   pub SizeOfUninitializedData: DWORD,
   pub AddressOfEntryPoint: DWORD,
   pub BaseOfCode: DWORD,
   pub ImageBase: ULONGLONG,
   pub SectionAlignment: DWORD,
   pub FileAlignment: DWORD,
   pub MajorOperatingSystemVersion: WORD,
   pub MinorOperatingSystemVersion: WORD,
   pub MajorImageVersion: WORD,
   pub MinorImageVersion: WORD,
   pub MajorSubsystemVersion: WORD,
   pub MinorSubsystemVersion: WORD,
   pub Win32VersionValue: DWORD,
   pub SizeOfImage: DWORD,
   pub SizeOfHeaders: DWORD,
   pub CheckSum: DWORD,
   pub Subsystem: WORD,
   pub DllCharacteristics: WORD,
   pub SizeOfStackReserve: ULONGLONG,
   pub SizeOfStackCommit: ULONGLONG,
   pub SizeOfHeapReserve: ULONGLONG,
   pub SizeOfHeapCommit: ULONGLONG,
   pub LoaderFlags: DWORD,
   pub NumberOfRvaAndSizes: DWORD,
   pub DataDirectory: [IMAGE_DATA_DIRECTORY; 16usize],
}
pub type IMAGE_OPTIONAL_HEADER64 = _IMAGE_OPTIONAL_HEADER64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS64 {
   pub Signature: DWORD,
   pub FileHeader: IMAGE_FILE_HEADER,
   pub OptionalHeader: IMAGE_OPTIONAL_HEADER64,
}
pub type PIMAGE_NT_HEADERS64 = *mut _IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_SECTION_HEADER {
   pub Name: [BYTE; 8usize],
   pub Misc: _IMAGE_SECTION_HEADER__bindgen_ty_1,
   pub VirtualAddress: DWORD,
   pub SizeOfRawData: DWORD,
   pub PointerToRawData: DWORD,
   pub PointerToRelocations: DWORD,
   pub PointerToLinenumbers: DWORD,
   pub NumberOfRelocations: WORD,
   pub NumberOfLinenumbers: WORD,
   pub Characteristics: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SECTION_HEADER__bindgen_ty_1 {
   pub PhysicalAddress: DWORD,
   pub VirtualSize: DWORD,
}
impl Default for _IMAGE_SECTION_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_SECTION_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PIMAGE_SECTION_HEADER = *mut _IMAGE_SECTION_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_BASE_RELOCATION {
   pub VirtualAddress: DWORD,
   pub SizeOfBlock: DWORD,
}
pub type IMAGE_BASE_RELOCATION = _IMAGE_BASE_RELOCATION;
pub type PIMAGE_BASE_RELOCATION = *mut IMAGE_BASE_RELOCATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_EXPORT_DIRECTORY {
   pub Characteristics: DWORD,
   pub TimeDateStamp: DWORD,
   pub MajorVersion: WORD,
   pub MinorVersion: WORD,
   pub Name: DWORD,
   pub Base: DWORD,
   pub NumberOfFunctions: DWORD,
   pub NumberOfNames: DWORD,
   pub AddressOfFunctions: DWORD,
   pub AddressOfNames: DWORD,
   pub AddressOfNameOrdinals: DWORD,
}
pub type PIMAGE_EXPORT_DIRECTORY = *mut _IMAGE_EXPORT_DIRECTORY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_THUNK_DATA64 {
   pub u1: _IMAGE_THUNK_DATA64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA64__bindgen_ty_1 {
   pub ForwarderString: ULONGLONG,
   pub Function: ULONGLONG,
   pub Ordinal: ULONGLONG,
   pub AddressOfData: ULONGLONG,
}
impl Default for _IMAGE_THUNK_DATA64__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_THUNK_DATA64 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IMAGE_THUNK_DATA64 = _IMAGE_THUNK_DATA64;
pub type PIMAGE_THUNK_DATA64 = *mut IMAGE_THUNK_DATA64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_THUNK_DATA32 {
   pub u1: _IMAGE_THUNK_DATA32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA32__bindgen_ty_1 {
   pub ForwarderString: DWORD,
   pub Function: DWORD,
   pub Ordinal: DWORD,
   pub AddressOfData: DWORD,
}
impl Default for _IMAGE_THUNK_DATA32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_THUNK_DATA32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IMAGE_THUNK_DATA32 = _IMAGE_THUNK_DATA32;
pub type PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR {
   pub Attributes: _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1,
   pub DllNameRVA: DWORD,
   pub ModuleHandleRVA: DWORD,
   pub ImportAddressTableRVA: DWORD,
   pub ImportNameTableRVA: DWORD,
   pub BoundImportAddressTableRVA: DWORD,
   pub UnloadInformationTableRVA: DWORD,
   pub TimeDateStamp: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {
   pub AllAttributes: DWORD,
   pub __bindgen_anon_1: _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn RvaBased(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RvaBased(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedAttributes(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedAttributes(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      RvaBased: DWORD,
      ReservedAttributes: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let RvaBased: u32 = unsafe { ::core::mem::transmute(RvaBased) };
         RvaBased as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let ReservedAttributes: u32 = unsafe { ::core::mem::transmute(ReservedAttributes) };
         ReservedAttributes as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_DELAYLOAD_DESCRIPTOR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IMAGE_DELAYLOAD_DESCRIPTOR = _IMAGE_DELAYLOAD_DESCRIPTOR;
pub type PCIMAGE_DELAYLOAD_DESCRIPTOR = *const IMAGE_DELAYLOAD_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY {
   pub Characteristics: DWORD,
   pub TimeDateStamp: DWORD,
   pub MajorVersion: WORD,
   pub MinorVersion: WORD,
   pub NumberOfNamedEntries: WORD,
   pub NumberOfIdEntries: WORD,
}
pub type PIMAGE_RESOURCE_DIRECTORY = *mut _IMAGE_RESOURCE_DIRECTORY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_STRING {
   pub Length: WORD,
   pub NameString: [CHAR; 1usize],
}
pub type PIMAGE_RESOURCE_DIRECTORY_STRING = *mut _IMAGE_RESOURCE_DIRECTORY_STRING;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DATA_ENTRY {
   pub OffsetToData: DWORD,
   pub Size: DWORD,
   pub CodePage: DWORD,
   pub Reserved: DWORD,
}
pub type PIMAGE_RESOURCE_DATA_ENTRY = *mut _IMAGE_RESOURCE_DATA_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
   pub BeginAddress: DWORD,
   pub EndAddress: DWORD,
   pub __bindgen_anon_1: _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
   pub UnwindInfoAddress: DWORD,
   pub UnwindData: DWORD,
}
impl Default for _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_RUNTIME_FUNCTION_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
   pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
   pub HeaderX64: _SLIST_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
   pub Alignment: ULONGLONG,
   pub Region: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl _SLIST_HEADER__bindgen_ty_2 {
   #[inline]
   pub fn Depth(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
   }
   #[inline]
   pub fn set_Depth(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn Sequence(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_Sequence(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 4u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(64usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn NextEntry(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
   }
   #[inline]
   pub fn set_NextEntry(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(68usize, 60u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Depth: ULONGLONG,
      Sequence: ULONGLONG,
      Reserved: ULONGLONG,
      NextEntry: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 16u8, {
         let Depth: u64 = unsafe { ::core::mem::transmute(Depth) };
         Depth as u64
      });
      __bindgen_bitfield_unit.set(16usize, 48u8, {
         let Sequence: u64 = unsafe { ::core::mem::transmute(Sequence) };
         Sequence as u64
      });
      __bindgen_bitfield_unit.set(64usize, 4u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(68usize, 60u8, {
         let NextEntry: u64 = unsafe { ::core::mem::transmute(NextEntry) };
         NextEntry as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SLIST_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_RUN_ONCE {
   pub Ptr: PVOID,
}
impl Default for _RTL_RUN_ONCE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PRTL_RUN_ONCE = *mut _RTL_RUN_ONCE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BARRIER {
   pub Reserved1: DWORD,
   pub Reserved2: DWORD,
   pub Reserved3: [ULONG_PTR; 2usize],
   pub Reserved4: DWORD,
   pub Reserved5: DWORD,
}
pub type PRTL_BARRIER = *mut _RTL_BARRIER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_ENTRY {
   pub Length: WORD,
   pub Flags: WORD,
   pub Text: [BYTE; 1usize],
}
pub type PMESSAGE_RESOURCE_ENTRY = *mut _MESSAGE_RESOURCE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOEXW {
   pub dwOSVersionInfoSize: DWORD,
   pub dwMajorVersion: DWORD,
   pub dwMinorVersion: DWORD,
   pub dwBuildNumber: DWORD,
   pub dwPlatformId: DWORD,
   pub szCSDVersion: [WCHAR; 128usize],
   pub wServicePackMajor: WORD,
   pub wServicePackMinor: WORD,
   pub wSuiteMask: WORD,
   pub wProductType: BYTE,
   pub wReserved: BYTE,
}
impl Default for _OSVERSIONINFOEXW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PRTL_OSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
   pub Type: WORD,
   pub CreatorBackTraceIndex: WORD,
   pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
   pub ProcessLocksList: LIST_ENTRY,
   pub EntryCount: DWORD,
   pub ContentionCount: DWORD,
   pub Flags: DWORD,
   pub CreatorBackTraceIndexHigh: WORD,
   pub Identifier: WORD,
}
impl Default for _RTL_CRITICAL_SECTION_DEBUG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PRTL_CRITICAL_SECTION_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
pub type PRTL_RESOURCE_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
   pub DebugInfo: PRTL_CRITICAL_SECTION_DEBUG,
   pub LockCount: LONG,
   pub RecursionCount: LONG,
   pub OwningThread: HANDLE,
   pub LockSemaphore: HANDLE,
   pub SpinCount: ULONG_PTR,
}
impl Default for _RTL_CRITICAL_SECTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SRWLOCK {
   pub Ptr: PVOID,
}
impl Default for _RTL_SRWLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SRWLOCK = _RTL_SRWLOCK;
pub type PRTL_SRWLOCK = *mut _RTL_SRWLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CONDITION_VARIABLE {
   pub Ptr: PVOID,
}
impl Default for _RTL_CONDITION_VARIABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PRTL_CONDITION_VARIABLE = *mut _RTL_CONDITION_VARIABLE;
pub type PVECTORED_EXCEPTION_HANDLER =
   ::core::option::Option<unsafe extern "C" fn(ExceptionInfo: *mut _EXCEPTION_POINTERS) -> LONG>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HEAP_INFORMATION_CLASS {
   HeapCompatibilityInformation = 0,
   HeapEnableTerminationOnCorruption = 1,
   HeapOptimizeResources = 3,
   HeapTag = 7,
}
pub use self::_HEAP_INFORMATION_CLASS as HEAP_INFORMATION_CLASS;
pub type WAITORTIMERCALLBACKFUNC =
   ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: BOOLEAN)>;
pub type WORKERCALLBACKFUNC = ::core::option::Option<unsafe extern "C" fn(arg1: PVOID)>;
pub type APC_CALLBACK_FUNCTION =
   ::core::option::Option<unsafe extern "C" fn(arg1: DWORD, arg2: PVOID, arg3: PVOID)>;
pub type PFLS_CALLBACK_FUNCTION = ::core::option::Option<unsafe extern "C" fn(lpFlsData: PVOID)>;
impl _ACTIVATION_CONTEXT_INFO_CLASS {
   pub const AssemblyDetailedInformationInActivationContxt: _ACTIVATION_CONTEXT_INFO_CLASS =
      _ACTIVATION_CONTEXT_INFO_CLASS::AssemblyDetailedInformationInActivationContext;
}
impl _ACTIVATION_CONTEXT_INFO_CLASS {
   pub const FileInformationInAssemblyOfAssemblyInActivationContxt: _ACTIVATION_CONTEXT_INFO_CLASS =
      _ACTIVATION_CONTEXT_INFO_CLASS::FileInformationInAssemblyOfAssemblyInActivationContext;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ACTIVATION_CONTEXT_INFO_CLASS {
   ActivationContextBasicInformation = 1,
   ActivationContextDetailedInformation = 2,
   AssemblyDetailedInformationInActivationContext = 3,
   FileInformationInAssemblyOfAssemblyInActivationContext = 4,
   RunlevelInformationInActivationContext = 5,
   CompatibilityInformationInActivationContext = 6,
   ActivationContextManifestResourceName = 7,
   MaxActivationContextInfoClass = 8,
}
pub use self::_ACTIVATION_CONTEXT_INFO_CLASS as ACTIVATION_CONTEXT_INFO_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_QUERY_INDEX {
   pub ulAssemblyIndex: DWORD,
   pub ulFileIndexInAssembly: DWORD,
}
pub type PACTIVATION_CONTEXT_QUERY_INDEX = *mut _ACTIVATION_CONTEXT_QUERY_INDEX;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ACTCTX_REQUESTED_RUN_LEVEL {
   ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
   ACTCTX_RUN_LEVEL_AS_INVOKER = 1,
   ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 2,
   ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = 3,
   ACTCTX_RUN_LEVEL_NUMBERS = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ACTCTX_COMPATIBILITY_ELEMENT_TYPE {
   ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
   ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = 1,
   ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = 2,
   ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HARDWARE_COUNTER_DATA {
   pub Type: HARDWARE_COUNTER_TYPE,
   pub Reserved: DWORD,
   pub Value: DWORD64,
}
impl Default for _HARDWARE_COUNTER_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HARDWARE_COUNTER_DATA = _HARDWARE_COUNTER_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFORMANCE_DATA {
   pub Size: WORD,
   pub Version: BYTE,
   pub HwCountersCount: BYTE,
   pub ContextSwitchCount: DWORD,
   pub WaitReasonBitMap: DWORD64,
   pub CycleTime: DWORD64,
   pub RetryCount: DWORD,
   pub Reserved: DWORD,
   pub HwCounters: [HARDWARE_COUNTER_DATA; 16usize],
}
impl Default for _PERFORMANCE_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PPERFORMANCE_DATA = *mut _PERFORMANCE_DATA;
pub type PCRM_PROTOCOL_ID = *mut GUID;
pub type NOTIFICATION_MASK = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION {
   pub TransactionKey: PVOID,
   pub TransactionNotification: ULONG,
   pub TmVirtualClock: LARGE_INTEGER,
   pub ArgumentLength: ULONG,
}
impl Default for _TRANSACTION_NOTIFICATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTRANSACTION_NOTIFICATION = *mut _TRANSACTION_NOTIFICATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TRANSACTION_INFORMATION_CLASS {
   TransactionBasicInformation = 0,
   TransactionPropertiesInformation = 1,
   TransactionEnlistmentInformation = 2,
   TransactionSuperiorEnlistmentInformation = 3,
   TransactionBindInformation = 4,
   TransactionDTCPrivateInformation = 5,
}
pub use self::_TRANSACTION_INFORMATION_CLASS as TRANSACTION_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
   TransactionManagerBasicInformation = 0,
   TransactionManagerLogInformation = 1,
   TransactionManagerLogPathInformation = 2,
   TransactionManagerRecoveryInformation = 4,
   TransactionManagerOnlineProbeInformation = 3,
   TransactionManagerOldestTransactionInformation = 5,
}
pub use self::_TRANSACTIONMANAGER_INFORMATION_CLASS as TRANSACTIONMANAGER_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RESOURCEMANAGER_INFORMATION_CLASS {
   ResourceManagerBasicInformation = 0,
   ResourceManagerCompletionInformation = 1,
}
pub use self::_RESOURCEMANAGER_INFORMATION_CLASS as RESOURCEMANAGER_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ENLISTMENT_INFORMATION_CLASS {
   EnlistmentBasicInformation = 0,
   EnlistmentRecoveryInformation = 1,
   EnlistmentCrmInformation = 2,
}
pub use self::_ENLISTMENT_INFORMATION_CLASS as ENLISTMENT_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTMOBJECT_TYPE {
   KTMOBJECT_TRANSACTION = 0,
   KTMOBJECT_TRANSACTION_MANAGER = 1,
   KTMOBJECT_RESOURCE_MANAGER = 2,
   KTMOBJECT_ENLISTMENT = 3,
   KTMOBJECT_INVALID = 4,
}
pub use self::_KTMOBJECT_TYPE as KTMOBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTMOBJECT_CURSOR {
   pub LastQuery: GUID,
   pub ObjectIdCount: DWORD,
   pub ObjectIds: [GUID; 1usize],
}
pub type PKTMOBJECT_CURSOR = *mut _KTMOBJECT_CURSOR;
pub type TP_VERSION = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CALLBACK_INSTANCE {
   _unused: [u8; 0],
}
pub type PTP_CALLBACK_INSTANCE = *mut _TP_CALLBACK_INSTANCE;
pub type PTP_SIMPLE_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_POOL {
   _unused: [u8; 0],
}
pub type PTP_POOL = *mut _TP_POOL;
impl _TP_CALLBACK_PRIORITY {
   pub const TP_CALLBACK_PRIORITY_COUNT: _TP_CALLBACK_PRIORITY =
      _TP_CALLBACK_PRIORITY::TP_CALLBACK_PRIORITY_INVALID;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TP_CALLBACK_PRIORITY {
   TP_CALLBACK_PRIORITY_HIGH = 0,
   TP_CALLBACK_PRIORITY_NORMAL = 1,
   TP_CALLBACK_PRIORITY_LOW = 2,
   TP_CALLBACK_PRIORITY_INVALID = 3,
}
pub use self::_TP_CALLBACK_PRIORITY as TP_CALLBACK_PRIORITY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TP_POOL_STACK_INFORMATION {
   pub StackReserve: SIZE_T,
   pub StackCommit: SIZE_T,
}
pub type PTP_POOL_STACK_INFORMATION = *mut _TP_POOL_STACK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CLEANUP_GROUP {
   _unused: [u8; 0],
}
pub type PTP_CLEANUP_GROUP = *mut _TP_CLEANUP_GROUP;
pub type PTP_CLEANUP_GROUP_CANCEL_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(ObjectContext: PVOID, CleanupContext: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3 {
   pub Version: TP_VERSION,
   pub Pool: PTP_POOL,
   pub CleanupGroup: PTP_CLEANUP_GROUP,
   pub CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
   pub RaceDll: PVOID,
   pub ActivationContext: *mut _ACTIVATION_CONTEXT,
   pub FinalizationCallback: PTP_SIMPLE_CALLBACK,
   pub u: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1,
   pub CallbackPriority: TP_CALLBACK_PRIORITY,
   pub Size: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
   pub Flags: DWORD,
   pub s: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn LongFunction(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LongFunction(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Persistent(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Persistent(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Private(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Private(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      LongFunction: DWORD,
      Persistent: DWORD,
      Private: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let LongFunction: u32 = unsafe { ::core::mem::transmute(LongFunction) };
         LongFunction as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let Persistent: u32 = unsafe { ::core::mem::transmute(Persistent) };
         Persistent as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Private: u32 = unsafe { ::core::mem::transmute(Private) };
         Private as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TP_CALLBACK_ENVIRON_V3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TP_CALLBACK_ENVIRON_V3 = _TP_CALLBACK_ENVIRON_V3;
pub type PTP_CALLBACK_ENVIRON = *mut TP_CALLBACK_ENVIRON_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WORK {
   _unused: [u8; 0],
}
pub type PTP_WORK = *mut _TP_WORK;
pub type PTP_WORK_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Work: PTP_WORK),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_TIMER {
   _unused: [u8; 0],
}
pub type PTP_TIMER = *mut _TP_TIMER;
pub type PTP_TIMER_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Timer: PTP_TIMER),
>;
pub type TP_WAIT_RESULT = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WAIT {
   _unused: [u8; 0],
}
pub type PTP_WAIT = *mut _TP_WAIT;
pub type PTP_WAIT_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      Instance: PTP_CALLBACK_INSTANCE,
      Context: PVOID,
      Wait: PTP_WAIT,
      WaitResult: TP_WAIT_RESULT,
   ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_IO {
   _unused: [u8; 0],
}
pub type PTP_IO = *mut _TP_IO;
pub type PTHREAD_START_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(lpThreadParameter: LPVOID) -> DWORD>;
pub type LPTHREAD_START_ROUTINE = PTHREAD_START_ROUTINE;
pub type PENCLAVE_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(lpThreadParameter: LPVOID) -> LPVOID>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_DEBUG_INFO {
   pub ExceptionRecord: EXCEPTION_RECORD,
   pub dwFirstChance: DWORD,
}
impl Default for _EXCEPTION_DEBUG_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EXCEPTION_DEBUG_INFO = _EXCEPTION_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATE_THREAD_DEBUG_INFO {
   pub hThread: HANDLE,
   pub lpThreadLocalBase: LPVOID,
   pub lpStartAddress: LPTHREAD_START_ROUTINE,
}
impl Default for _CREATE_THREAD_DEBUG_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CREATE_THREAD_DEBUG_INFO = _CREATE_THREAD_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATE_PROCESS_DEBUG_INFO {
   pub hFile: HANDLE,
   pub hProcess: HANDLE,
   pub hThread: HANDLE,
   pub lpBaseOfImage: LPVOID,
   pub dwDebugInfoFileOffset: DWORD,
   pub nDebugInfoSize: DWORD,
   pub lpThreadLocalBase: LPVOID,
   pub lpStartAddress: LPTHREAD_START_ROUTINE,
   pub lpImageName: LPVOID,
   pub fUnicode: WORD,
}
impl Default for _CREATE_PROCESS_DEBUG_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CREATE_PROCESS_DEBUG_INFO = _CREATE_PROCESS_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EXIT_THREAD_DEBUG_INFO {
   pub dwExitCode: DWORD,
}
pub type EXIT_THREAD_DEBUG_INFO = _EXIT_THREAD_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EXIT_PROCESS_DEBUG_INFO {
   pub dwExitCode: DWORD,
}
pub type EXIT_PROCESS_DEBUG_INFO = _EXIT_PROCESS_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOAD_DLL_DEBUG_INFO {
   pub hFile: HANDLE,
   pub lpBaseOfDll: LPVOID,
   pub dwDebugInfoFileOffset: DWORD,
   pub nDebugInfoSize: DWORD,
   pub lpImageName: LPVOID,
   pub fUnicode: WORD,
}
impl Default for _LOAD_DLL_DEBUG_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LOAD_DLL_DEBUG_INFO = _LOAD_DLL_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNLOAD_DLL_DEBUG_INFO {
   pub lpBaseOfDll: LPVOID,
}
impl Default for _UNLOAD_DLL_DEBUG_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type UNLOAD_DLL_DEBUG_INFO = _UNLOAD_DLL_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OUTPUT_DEBUG_STRING_INFO {
   pub lpDebugStringData: LPSTR,
   pub fUnicode: WORD,
   pub nDebugStringLength: WORD,
}
impl Default for _OUTPUT_DEBUG_STRING_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OUTPUT_DEBUG_STRING_INFO = _OUTPUT_DEBUG_STRING_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RIP_INFO {
   pub dwError: DWORD,
   pub dwType: DWORD,
}
pub type RIP_INFO = _RIP_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEBUG_EVENT {
   pub dwDebugEventCode: DWORD,
   pub dwProcessId: DWORD,
   pub dwThreadId: DWORD,
   pub u: _DEBUG_EVENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEBUG_EVENT__bindgen_ty_1 {
   pub Exception: EXCEPTION_DEBUG_INFO,
   pub CreateThread: CREATE_THREAD_DEBUG_INFO,
   pub CreateProcessInfo: CREATE_PROCESS_DEBUG_INFO,
   pub ExitThread: EXIT_THREAD_DEBUG_INFO,
   pub ExitProcess: EXIT_PROCESS_DEBUG_INFO,
   pub LoadDll: LOAD_DLL_DEBUG_INFO,
   pub UnloadDll: UNLOAD_DLL_DEBUG_INFO,
   pub DebugString: OUTPUT_DEBUG_STRING_INFO,
   pub RipInfo: RIP_INFO,
}
impl Default for _DEBUG_EVENT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _DEBUG_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LPDEBUG_EVENT = *mut _DEBUG_EVENT;
pub type PPROC_THREAD_ATTRIBUTE_LIST = *mut _PROC_THREAD_ATTRIBUTE_LIST;
pub type DLL_DIRECTORY_COOKIE = PVOID;
pub type PDLL_DIRECTORY_COOKIE = *mut PVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
   pub lpInformation: PVOID,
   pub lpSectionBase: PVOID,
   pub ulSectionLength: ULONG,
   pub lpSectionGlobalDataBase: PVOID,
   pub ulSectionGlobalDataLength: ULONG,
}
impl Default for tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA =
   tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACTCTX_SECTION_KEYED_DATA {
   pub cbSize: ULONG,
   pub ulDataFormatVersion: ULONG,
   pub lpData: PVOID,
   pub ulLength: ULONG,
   pub lpSectionGlobalData: PVOID,
   pub ulSectionGlobalDataLength: ULONG,
   pub lpSectionBase: PVOID,
   pub ulSectionTotalLength: ULONG,
   pub hActCtx: HANDLE,
   pub ulAssemblyRosterIndex: ULONG,
   pub ulFlags: ULONG,
   pub AssemblyMetadata: ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA,
}
impl Default for tagACTCTX_SECTION_KEYED_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PACTCTX_SECTION_KEYED_DATA = *mut tagACTCTX_SECTION_KEYED_DATA;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_RESERVE_ID {
   StorageReserveIdNone = 0,
   StorageReserveIdHard = 1,
   StorageReserveIdSoft = 2,
   StorageReserveIdUpdateScratch = 3,
   StorageReserveIdMax = 4,
}
pub use self::_STORAGE_RESERVE_ID as STORAGE_RESERVE_ID;
pub type TRACEHANDLE = ULONG64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_DESCRIPTOR {
   _unused: [u8; 0],
}
pub type PEVENT_FILTER_DESCRIPTOR = *mut _EVENT_FILTER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROFILE_SOURCE_INFO {
   pub NextEntryOffset: ULONG,
   pub Source: ULONG,
   pub MinInterval: ULONG,
   pub MaxInterval: ULONG,
   pub Reserved: ULONG64,
   pub Description: [WCHAR; 1usize],
}
pub type PPROFILE_SOURCE_INFO = *mut _PROFILE_SOURCE_INFO;
pub type PGUID = *mut GUID;
pub type PCGUID = *const GUID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUAD {
   pub __bindgen_anon_1: _QUAD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUAD__bindgen_ty_1 {
   pub UseThisFieldToCopy: cty::c_longlong,
   pub DoNotUseThisField: f64,
}
impl Default for _QUAD__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _QUAD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type QUAD = _QUAD;
pub type PQUAD = *mut _QUAD;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _QUAD_PTR {
   pub DoNotUseThisField1: ULONG_PTR,
   pub DoNotUseThisField2: ULONG_PTR,
}
pub type QUAD_PTR = _QUAD_PTR;
pub type PQUAD_PTR = *mut _QUAD_PTR;
pub type LOGICAL = ULONG;
pub type PLOGICAL = *mut ULONG;
pub type PNTSTATUS = *mut NTSTATUS;
pub type CSHORT = cty::c_short;
pub type CLONG = ULONG;
pub type PCCHAR = *mut CCHAR;
pub type PCSHORT = *mut CSHORT;
pub type PCLONG = *mut CLONG;
pub type PCSZ = PCSTR;
pub type PPVOID = *mut PVOID;
pub type KIRQL = UCHAR;
pub type PKIRQL = *mut UCHAR;
pub type KPRIORITY = LONG;
pub type PKPRIORITY = *mut LONG;
pub type RTL_ATOM = USHORT;
pub type PRTL_ATOM = *mut USHORT;
pub type PHYSICAL_ADDRESS = LARGE_INTEGER;
pub type PPHYSICAL_ADDRESS = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LARGE_INTEGER_128 {
   pub QuadPart: [LONGLONG; 2usize],
}
pub type LARGE_INTEGER_128 = _LARGE_INTEGER_128;
pub type PLARGE_INTEGER_128 = *mut _LARGE_INTEGER_128;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_TYPE {
   NotificationEvent = 0,
   SynchronizationEvent = 1,
}
pub use self::_EVENT_TYPE as EVENT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TIMER_TYPE {
   NotificationTimer = 0,
   SynchronizationTimer = 1,
}
pub use self::_TIMER_TYPE as TIMER_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WAIT_TYPE {
   WaitAll = 0,
   WaitAny = 1,
   WaitNotification = 2,
}
pub use self::_WAIT_TYPE as WAIT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
   pub Length: USHORT,
   pub MaximumLength: USHORT,
   pub Buffer: PCHAR,
}
impl Default for _STRING {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type STRING = _STRING;
pub type PSTRING = *mut _STRING;
pub type ANSI_STRING = _STRING;
pub type PANSI_STRING = *mut _STRING;
pub type OEM_STRING = _STRING;
pub type POEM_STRING = *mut _STRING;
pub type UTF8_STRING = STRING;
pub type PUTF8_STRING = PSTRING;
pub type PCSTRING = *const STRING;
pub type PCANSI_STRING = *const ANSI_STRING;
pub type PCOEM_STRING = *const OEM_STRING;
pub type PUNICODE_STRING = *mut _UNICODE_STRING;
pub type PCUNICODE_STRING = *const UNICODE_STRING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_BALANCED_NODE {
   pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1,
   pub __bindgen_anon_2: _RTL_BALANCED_NODE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE__bindgen_ty_1 {
   pub Children: [*mut _RTL_BALANCED_NODE; 2usize],
   pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 {
   pub Left: *mut _RTL_BALANCED_NODE,
   pub Right: *mut _RTL_BALANCED_NODE,
}
impl Default for _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_BALANCED_NODE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE__bindgen_ty_2 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub ParentValue: ULONG_PTR,
}
impl Default for _RTL_BALANCED_NODE__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _RTL_BALANCED_NODE__bindgen_ty_2 {
   #[inline]
   pub fn Red(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Red(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Balance(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_Balance(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Red: UCHAR, Balance: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Red: u8 = unsafe { ::core::mem::transmute(Red) };
         Red as u64
      });
      __bindgen_bitfield_unit.set(1usize, 2u8, {
         let Balance: u8 = unsafe { ::core::mem::transmute(Balance) };
         Balance as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_BALANCED_NODE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BALANCED_NODE = _RTL_BALANCED_NODE;
pub type PRTL_BALANCED_NODE = *mut _RTL_BALANCED_NODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY32 {
   pub Next: ULONG,
}
pub type SINGLE_LIST_ENTRY32 = _SINGLE_LIST_ENTRY32;
pub type PSINGLE_LIST_ENTRY32 = *mut _SINGLE_LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _STRING32 {
   pub Length: USHORT,
   pub MaximumLength: USHORT,
   pub Buffer: ULONG,
}
pub type STRING32 = _STRING32;
pub type PSTRING32 = *mut _STRING32;
pub type UNICODE_STRING32 = STRING32;
pub type PUNICODE_STRING32 = *mut STRING32;
pub type ANSI_STRING32 = STRING32;
pub type PANSI_STRING32 = *mut STRING32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _STRING64 {
   pub Length: USHORT,
   pub MaximumLength: USHORT,
   pub Buffer: ULONGLONG,
}
pub type STRING64 = _STRING64;
pub type PSTRING64 = *mut _STRING64;
pub type UNICODE_STRING64 = STRING64;
pub type PUNICODE_STRING64 = *mut STRING64;
pub type ANSI_STRING64 = STRING64;
pub type PANSI_STRING64 = *mut STRING64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES {
   pub Length: ULONG,
   pub RootDirectory: HANDLE,
   pub ObjectName: PUNICODE_STRING,
   pub Attributes: ULONG,
   pub SecurityDescriptor: PVOID,
   pub SecurityQualityOfService: PVOID,
}
impl Default for _OBJECT_ATTRIBUTES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES;
pub type POBJECT_ATTRIBUTES = *mut _OBJECT_ATTRIBUTES;
pub type PCOBJECT_ATTRIBUTES = *const OBJECT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES64 {
   pub Length: ULONG,
   pub RootDirectory: ULONG64,
   pub ObjectName: ULONG64,
   pub Attributes: ULONG,
   pub SecurityDescriptor: ULONG64,
   pub SecurityQualityOfService: ULONG64,
}
pub type OBJECT_ATTRIBUTES64 = _OBJECT_ATTRIBUTES64;
pub type POBJECT_ATTRIBUTES64 = *mut _OBJECT_ATTRIBUTES64;
pub type PCOBJECT_ATTRIBUTES64 = *const OBJECT_ATTRIBUTES64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES32 {
   pub Length: ULONG,
   pub RootDirectory: ULONG,
   pub ObjectName: ULONG,
   pub Attributes: ULONG,
   pub SecurityDescriptor: ULONG,
   pub SecurityQualityOfService: ULONG,
}
pub type OBJECT_ATTRIBUTES32 = _OBJECT_ATTRIBUTES32;
pub type POBJECT_ATTRIBUTES32 = *mut _OBJECT_ATTRIBUTES32;
pub type PCOBJECT_ATTRIBUTES32 = *const OBJECT_ATTRIBUTES32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NT_PRODUCT_TYPE {
   NtProductWinNt = 1,
   NtProductLanManNt = 2,
   NtProductServer = 3,
}
pub use self::_NT_PRODUCT_TYPE as NT_PRODUCT_TYPE;
pub type PNT_PRODUCT_TYPE = *mut _NT_PRODUCT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SUITE_TYPE {
   SmallBusiness = 0,
   Enterprise = 1,
   BackOffice = 2,
   CommunicationServer = 3,
   TerminalServer = 4,
   SmallBusinessRestricted = 5,
   EmbeddedNT = 6,
   DataCenter = 7,
   SingleUserTS = 8,
   Personal = 9,
   Blade = 10,
   EmbeddedRestricted = 11,
   SecurityAppliance = 12,
   StorageServer = 13,
   ComputeServer = 14,
   WHServer = 15,
   PhoneNT = 16,
   MaxSuiteType = 17,
}
pub use self::_SUITE_TYPE as SUITE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLIENT_ID {
   pub UniqueProcess: HANDLE,
   pub UniqueThread: HANDLE,
}
impl Default for _CLIENT_ID {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CLIENT_ID = _CLIENT_ID;
pub type PCLIENT_ID = *mut _CLIENT_ID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CLIENT_ID32 {
   pub UniqueProcess: ULONG,
   pub UniqueThread: ULONG,
}
pub type CLIENT_ID32 = _CLIENT_ID32;
pub type PCLIENT_ID32 = *mut _CLIENT_ID32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CLIENT_ID64 {
   pub UniqueProcess: ULONGLONG,
   pub UniqueThread: ULONGLONG,
}
pub type CLIENT_ID64 = _CLIENT_ID64;
pub type PCLIENT_ID64 = *mut _CLIENT_ID64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KSYSTEM_TIME {
   pub LowPart: ULONG,
   pub High1Time: LONG,
   pub High2Time: LONG,
}
pub type KSYSTEM_TIME = _KSYSTEM_TIME;
pub type PKSYSTEM_TIME = *mut _KSYSTEM_TIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPTABLEINFO {
   pub CodePage: USHORT,
   pub MaximumCharacterSize: USHORT,
   pub DefaultChar: USHORT,
   pub UniDefaultChar: USHORT,
   pub TransDefaultChar: USHORT,
   pub TransUniDefaultChar: USHORT,
   pub DBCSCodePage: USHORT,
   pub LeadByte: [UCHAR; 12usize],
   pub MultiByteTable: PUSHORT,
   pub WideCharTable: PVOID,
   pub DBCSRanges: PUSHORT,
   pub DBCSOffsets: PUSHORT,
}
impl Default for _CPTABLEINFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CPTABLEINFO = _CPTABLEINFO;
pub type PCPTABLEINFO = *mut _CPTABLEINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NLSTABLEINFO {
   pub OemTableInfo: CPTABLEINFO,
   pub AnsiTableInfo: CPTABLEINFO,
   pub UpperCaseTable: PUSHORT,
   pub LowerCaseTable: PUSHORT,
}
impl Default for _NLSTABLEINFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type NLSTABLEINFO = _NLSTABLEINFO;
pub type PNLSTABLEINFO = *mut _NLSTABLEINFO;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTHREAD_STATE {
   Initialized = 0,
   Ready = 1,
   Running = 2,
   Standby = 3,
   Terminated = 4,
   Waiting = 5,
   Transition = 6,
   DeferredReady = 7,
   GateWaitObsolete = 8,
   WaitingForProcessInSwap = 9,
   MaximumThreadState = 10,
}
pub use self::_KTHREAD_STATE as KTHREAD_STATE;
pub type PKTHREAD_STATE = *mut _KTHREAD_STATE;
impl _KHETERO_CPU_POLICY {
   pub const KHeteroCpuPolicyStaticMax: _KHETERO_CPU_POLICY =
      _KHETERO_CPU_POLICY::KHeteroCpuPolicyDynamic;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KHETERO_CPU_POLICY {
   KHeteroCpuPolicyAll = 0,
   KHeteroCpuPolicyLarge = 1,
   KHeteroCpuPolicyLargeOrIdle = 2,
   KHeteroCpuPolicySmall = 3,
   KHeteroCpuPolicySmallOrIdle = 4,
   KHeteroCpuPolicyDynamic = 5,
   KHeteroCpuPolicyBiasedSmall = 6,
   KHeteroCpuPolicyBiasedLarge = 7,
   KHeteroCpuPolicyDefault = 8,
   KHeteroCpuPolicyMax = 9,
}
pub use self::_KHETERO_CPU_POLICY as KHETERO_CPU_POLICY;
pub type PKHETERO_CPU_POLICY = *mut _KHETERO_CPU_POLICY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KWAIT_REASON {
   Executive = 0,
   FreePage = 1,
   PageIn = 2,
   PoolAllocation = 3,
   DelayExecution = 4,
   Suspended = 5,
   UserRequest = 6,
   WrExecutive = 7,
   WrFreePage = 8,
   WrPageIn = 9,
   WrPoolAllocation = 10,
   WrDelayExecution = 11,
   WrSuspended = 12,
   WrUserRequest = 13,
   WrEventPair = 14,
   WrQueue = 15,
   WrLpcReceive = 16,
   WrLpcReply = 17,
   WrVirtualMemory = 18,
   WrPageOut = 19,
   WrRendezvous = 20,
   WrKeyedEvent = 21,
   WrTerminated = 22,
   WrProcessInSwap = 23,
   WrCpuRateControl = 24,
   WrCalloutStack = 25,
   WrKernel = 26,
   WrResource = 27,
   WrPushLock = 28,
   WrMutex = 29,
   WrQuantumEnd = 30,
   WrDispatchInt = 31,
   WrPreempted = 32,
   WrYieldExecution = 33,
   WrFastMutex = 34,
   WrGuardedMutex = 35,
   WrRundown = 36,
   WrAlertByThreadId = 37,
   WrDeferredPreempt = 38,
   WrPhysicalFault = 39,
   WrIoRing = 40,
   WrMdlCache = 41,
   MaximumWaitReason = 42,
}
pub use self::_KWAIT_REASON as KWAIT_REASON;
pub type PKWAIT_REASON = *mut _KWAIT_REASON;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KPROFILE_SOURCE {
   ProfileTime = 0,
   ProfileAlignmentFixup = 1,
   ProfileTotalIssues = 2,
   ProfilePipelineDry = 3,
   ProfileLoadInstructions = 4,
   ProfilePipelineFrozen = 5,
   ProfileBranchInstructions = 6,
   ProfileTotalNonissues = 7,
   ProfileDcacheMisses = 8,
   ProfileIcacheMisses = 9,
   ProfileCacheMisses = 10,
   ProfileBranchMispredictions = 11,
   ProfileStoreInstructions = 12,
   ProfileFpInstructions = 13,
   ProfileIntegerInstructions = 14,
   Profile2Issue = 15,
   Profile3Issue = 16,
   Profile4Issue = 17,
   ProfileSpecialInstructions = 18,
   ProfileTotalCycles = 19,
   ProfileIcacheIssues = 20,
   ProfileDcacheAccesses = 21,
   ProfileMemoryBarrierCycles = 22,
   ProfileLoadLinkedIssues = 23,
   ProfileMaximum = 24,
}
pub use self::_KPROFILE_SOURCE as KPROFILE_SOURCE;
pub type PLDR_INIT_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(DllHandle: PVOID, Reason: ULONG, Context: PVOID) -> BOOLEAN,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_SERVICE_TAG_RECORD {
   pub Next: *mut _LDR_SERVICE_TAG_RECORD,
   pub ServiceTag: ULONG,
}
impl Default for _LDR_SERVICE_TAG_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_SERVICE_TAG_RECORD = _LDR_SERVICE_TAG_RECORD;
pub type PLDR_SERVICE_TAG_RECORD = *mut _LDR_SERVICE_TAG_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDRP_CSLIST {
   pub Tail: PSINGLE_LIST_ENTRY,
}
impl Default for _LDRP_CSLIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDRP_CSLIST = _LDRP_CSLIST;
pub type PLDRP_CSLIST = *mut _LDRP_CSLIST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LDR_DDAG_STATE {
   LdrModulesMerged = -5,
   LdrModulesInitError = -4,
   LdrModulesSnapError = -3,
   LdrModulesUnloaded = -2,
   LdrModulesUnloading = -1,
   LdrModulesPlaceHolder = 0,
   LdrModulesMapping = 1,
   LdrModulesMapped = 2,
   LdrModulesWaitingForDependencies = 3,
   LdrModulesSnapping = 4,
   LdrModulesSnapped = 5,
   LdrModulesCondensed = 6,
   LdrModulesReadyToInit = 7,
   LdrModulesInitializing = 8,
   LdrModulesReadyToRun = 9,
}
pub use self::_LDR_DDAG_STATE as LDR_DDAG_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_DDAG_NODE {
   pub Modules: LIST_ENTRY,
   pub ServiceTagList: PLDR_SERVICE_TAG_RECORD,
   pub LoadCount: ULONG,
   pub LoadWhileUnloadingCount: ULONG,
   pub LowestLink: ULONG,
   pub __bindgen_anon_1: _LDR_DDAG_NODE__bindgen_ty_1,
   pub IncomingDependencies: LDRP_CSLIST,
   pub State: LDR_DDAG_STATE,
   pub CondenseLink: SINGLE_LIST_ENTRY,
   pub PreorderNumber: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DDAG_NODE__bindgen_ty_1 {
   pub Dependencies: LDRP_CSLIST,
   pub RemovalLink: SINGLE_LIST_ENTRY,
}
impl Default for _LDR_DDAG_NODE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDR_DDAG_NODE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DDAG_NODE = _LDR_DDAG_NODE;
pub type PLDR_DDAG_NODE = *mut _LDR_DDAG_NODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DEPENDENCY_RECORD {
   pub DependencyLink: SINGLE_LIST_ENTRY,
   pub DependencyNode: PLDR_DDAG_NODE,
   pub IncomingDependencyLink: SINGLE_LIST_ENTRY,
   pub IncomingDependencyNode: PLDR_DDAG_NODE,
}
impl Default for _LDR_DEPENDENCY_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DEPENDENCY_RECORD = _LDR_DEPENDENCY_RECORD;
pub type PLDR_DEPENDENCY_RECORD = *mut _LDR_DEPENDENCY_RECORD;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LDR_DLL_LOAD_REASON {
   LoadReasonStaticDependency = 0,
   LoadReasonStaticForwarderDependency = 1,
   LoadReasonDynamicForwarderDependency = 2,
   LoadReasonDelayloadDependency = 3,
   LoadReasonDynamicLoad = 4,
   LoadReasonAsImageLoad = 5,
   LoadReasonAsDataLoad = 6,
   LoadReasonEnclavePrimary = 7,
   LoadReasonEnclaveDependency = 8,
   LoadReasonPatchImage = 9,
   LoadReasonUnknown = -1,
}
pub use self::_LDR_DLL_LOAD_REASON as LDR_DLL_LOAD_REASON;
pub type PLDR_DLL_LOAD_REASON = *mut _LDR_DLL_LOAD_REASON;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LDR_HOT_PATCH_STATE {
   LdrHotPatchBaseImage = 0,
   LdrHotPatchNotApplied = 1,
   LdrHotPatchAppliedReverse = 2,
   LdrHotPatchAppliedForward = 3,
   LdrHotPatchFailedToPatch = 4,
   LdrHotPatchStateMax = 5,
}
pub use self::_LDR_HOT_PATCH_STATE as LDR_HOT_PATCH_STATE;
pub type PLDR_HOT_PATCH_STATE = *mut _LDR_HOT_PATCH_STATE;
pub type PACTIVATION_CONTEXT = *mut _ACTIVATION_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDRP_LOAD_CONTEXT {
   _unused: [u8; 0],
}
pub type PLDRP_LOAD_CONTEXT = *mut _LDRP_LOAD_CONTEXT;
#[repr(C)]
pub struct _LDR_DATA_TABLE_ENTRY {
   pub InLoadOrderLinks: LIST_ENTRY,
   pub InMemoryOrderLinks: LIST_ENTRY,
   pub InInitializationOrderLinks: LIST_ENTRY,
   pub DllBase: PVOID,
   pub EntryPoint: PLDR_INIT_ROUTINE,
   pub SizeOfImage: ULONG,
   pub FullDllName: UNICODE_STRING,
   pub BaseDllName: UNICODE_STRING,
   pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY__bindgen_ty_1,
   pub ObsoleteLoadCount: USHORT,
   pub TlsIndex: USHORT,
   pub HashLinks: LIST_ENTRY,
   pub TimeDateStamp: ULONG,
   pub EntryPointActivationContext: PACTIVATION_CONTEXT,
   pub Lock: PVOID,
   pub DdagNode: PLDR_DDAG_NODE,
   pub NodeModuleLink: LIST_ENTRY,
   pub LoadContext: PLDRP_LOAD_CONTEXT,
   pub ParentDllBase: PVOID,
   pub SwitchBackContext: PVOID,
   pub BaseAddressIndexNode: RTL_BALANCED_NODE,
   pub MappingInfoIndexNode: RTL_BALANCED_NODE,
   pub OriginalBase: ULONG_PTR,
   pub LoadTime: LARGE_INTEGER,
   pub BaseNameHashValue: ULONG,
   pub LoadReason: LDR_DLL_LOAD_REASON,
   pub ImplicitPathOptions: ULONG,
   pub ReferenceCount: ULONG,
   pub DependentLoadFlags: ULONG,
   pub SigningLevel: UCHAR,
   pub CheckSum: ULONG,
   pub ActivePatchImageBase: PVOID,
   pub HotPatchState: LDR_HOT_PATCH_STATE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
   pub FlagGroup: [UCHAR; 4usize],
   pub Flags: ULONG,
   pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn PackagedBinary(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PackagedBinary(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MarkedForRemoval(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MarkedForRemoval(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageDll(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageDll(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LoadNotificationsSent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadNotificationsSent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn TelemetryEntryProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_TelemetryEntryProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessStaticImport(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessStaticImport(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InLegacyLists(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InLegacyLists(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InIndexes(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InIndexes(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ShimDll(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ShimDll(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InExceptionTable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InExceptionTable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn LoadInProgress(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadInProgress(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LoadConfigProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadConfigProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EntryProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EntryProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProtectDelayLoad(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProtectDelayLoad(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags3(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags3(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn DontCallForThreads(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DontCallForThreads(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessAttachCalled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessAttachCalled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(19usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessAttachFailed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessAttachFailed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CorDeferredValidate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorDeferredValidate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CorImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DontRelocate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DontRelocate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CorILOnly(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorILOnly(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ChpeImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ChpeImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(25usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ChpeEmulatorImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ChpeEmulatorImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(26usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags5(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags5(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(27usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Redirected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Redirected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags6(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags6(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(29usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn CompatDatabaseProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CompatDatabaseProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      PackagedBinary: ULONG,
      MarkedForRemoval: ULONG,
      ImageDll: ULONG,
      LoadNotificationsSent: ULONG,
      TelemetryEntryProcessed: ULONG,
      ProcessStaticImport: ULONG,
      InLegacyLists: ULONG,
      InIndexes: ULONG,
      ShimDll: ULONG,
      InExceptionTable: ULONG,
      ReservedFlags1: ULONG,
      LoadInProgress: ULONG,
      LoadConfigProcessed: ULONG,
      EntryProcessed: ULONG,
      ProtectDelayLoad: ULONG,
      ReservedFlags3: ULONG,
      DontCallForThreads: ULONG,
      ProcessAttachCalled: ULONG,
      ProcessAttachFailed: ULONG,
      CorDeferredValidate: ULONG,
      CorImage: ULONG,
      DontRelocate: ULONG,
      CorILOnly: ULONG,
      ChpeImage: ULONG,
      ChpeEmulatorImage: ULONG,
      ReservedFlags5: ULONG,
      Redirected: ULONG,
      ReservedFlags6: ULONG,
      CompatDatabaseProcessed: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let PackagedBinary: u32 = unsafe { ::core::mem::transmute(PackagedBinary) };
         PackagedBinary as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let MarkedForRemoval: u32 = unsafe { ::core::mem::transmute(MarkedForRemoval) };
         MarkedForRemoval as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ImageDll: u32 = unsafe { ::core::mem::transmute(ImageDll) };
         ImageDll as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let LoadNotificationsSent: u32 = unsafe { ::core::mem::transmute(LoadNotificationsSent) };
         LoadNotificationsSent as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let TelemetryEntryProcessed: u32 =
            unsafe { ::core::mem::transmute(TelemetryEntryProcessed) };
         TelemetryEntryProcessed as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let ProcessStaticImport: u32 = unsafe { ::core::mem::transmute(ProcessStaticImport) };
         ProcessStaticImport as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let InLegacyLists: u32 = unsafe { ::core::mem::transmute(InLegacyLists) };
         InLegacyLists as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let InIndexes: u32 = unsafe { ::core::mem::transmute(InIndexes) };
         InIndexes as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let ShimDll: u32 = unsafe { ::core::mem::transmute(ShimDll) };
         ShimDll as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let InExceptionTable: u32 = unsafe { ::core::mem::transmute(InExceptionTable) };
         InExceptionTable as u64
      });
      __bindgen_bitfield_unit.set(10usize, 2u8, {
         let ReservedFlags1: u32 = unsafe { ::core::mem::transmute(ReservedFlags1) };
         ReservedFlags1 as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let LoadInProgress: u32 = unsafe { ::core::mem::transmute(LoadInProgress) };
         LoadInProgress as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let LoadConfigProcessed: u32 = unsafe { ::core::mem::transmute(LoadConfigProcessed) };
         LoadConfigProcessed as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let EntryProcessed: u32 = unsafe { ::core::mem::transmute(EntryProcessed) };
         EntryProcessed as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let ProtectDelayLoad: u32 = unsafe { ::core::mem::transmute(ProtectDelayLoad) };
         ProtectDelayLoad as u64
      });
      __bindgen_bitfield_unit.set(16usize, 2u8, {
         let ReservedFlags3: u32 = unsafe { ::core::mem::transmute(ReservedFlags3) };
         ReservedFlags3 as u64
      });
      __bindgen_bitfield_unit.set(18usize, 1u8, {
         let DontCallForThreads: u32 = unsafe { ::core::mem::transmute(DontCallForThreads) };
         DontCallForThreads as u64
      });
      __bindgen_bitfield_unit.set(19usize, 1u8, {
         let ProcessAttachCalled: u32 = unsafe { ::core::mem::transmute(ProcessAttachCalled) };
         ProcessAttachCalled as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let ProcessAttachFailed: u32 = unsafe { ::core::mem::transmute(ProcessAttachFailed) };
         ProcessAttachFailed as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let CorDeferredValidate: u32 = unsafe { ::core::mem::transmute(CorDeferredValidate) };
         CorDeferredValidate as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let CorImage: u32 = unsafe { ::core::mem::transmute(CorImage) };
         CorImage as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let DontRelocate: u32 = unsafe { ::core::mem::transmute(DontRelocate) };
         DontRelocate as u64
      });
      __bindgen_bitfield_unit.set(24usize, 1u8, {
         let CorILOnly: u32 = unsafe { ::core::mem::transmute(CorILOnly) };
         CorILOnly as u64
      });
      __bindgen_bitfield_unit.set(25usize, 1u8, {
         let ChpeImage: u32 = unsafe { ::core::mem::transmute(ChpeImage) };
         ChpeImage as u64
      });
      __bindgen_bitfield_unit.set(26usize, 1u8, {
         let ChpeEmulatorImage: u32 = unsafe { ::core::mem::transmute(ChpeEmulatorImage) };
         ChpeEmulatorImage as u64
      });
      __bindgen_bitfield_unit.set(27usize, 1u8, {
         let ReservedFlags5: u32 = unsafe { ::core::mem::transmute(ReservedFlags5) };
         ReservedFlags5 as u64
      });
      __bindgen_bitfield_unit.set(28usize, 1u8, {
         let Redirected: u32 = unsafe { ::core::mem::transmute(Redirected) };
         Redirected as u64
      });
      __bindgen_bitfield_unit.set(29usize, 2u8, {
         let ReservedFlags6: u32 = unsafe { ::core::mem::transmute(ReservedFlags6) };
         ReservedFlags6 as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let CompatDatabaseProcessed: u32 =
            unsafe { ::core::mem::transmute(CompatDatabaseProcessed) };
         CompatDatabaseProcessed as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _LDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDR_DATA_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DATA_TABLE_ENTRY = _LDR_DATA_TABLE_ENTRY;
pub type PLDR_DATA_TABLE_ENTRY = *mut _LDR_DATA_TABLE_ENTRY;
pub type PLDR_IMPORT_MODULE_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(Parameter: PVOID, ModuleName: PSTR)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_IMPORT_CALLBACK_INFO {
   pub ImportCallbackRoutine: PLDR_IMPORT_MODULE_CALLBACK,
   pub ImportCallbackParameter: PVOID,
}
impl Default for _LDR_IMPORT_CALLBACK_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_IMPORT_CALLBACK_INFO = _LDR_IMPORT_CALLBACK_INFO;
pub type PLDR_IMPORT_CALLBACK_INFO = *mut _LDR_IMPORT_CALLBACK_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_SECTION_INFO {
   pub SectionHandle: HANDLE,
   pub DesiredAccess: ACCESS_MASK,
   pub ObjA: POBJECT_ATTRIBUTES,
   pub SectionPageProtection: ULONG,
   pub AllocationAttributes: ULONG,
}
impl Default for _LDR_SECTION_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_SECTION_INFO = _LDR_SECTION_INFO;
pub type PLDR_SECTION_INFO = *mut _LDR_SECTION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_VERIFY_IMAGE_INFO {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub CallbackInfo: LDR_IMPORT_CALLBACK_INFO,
   pub SectionInfo: LDR_SECTION_INFO,
   pub ImageCharacteristics: USHORT,
}
impl Default for _LDR_VERIFY_IMAGE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_VERIFY_IMAGE_INFO = _LDR_VERIFY_IMAGE_INFO;
pub type PLDR_VERIFY_IMAGE_INFO = *mut _LDR_VERIFY_IMAGE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
   pub Flags: ULONG,
   pub FullDllName: PUNICODE_STRING,
   pub BaseDllName: PUNICODE_STRING,
   pub DllBase: PVOID,
   pub SizeOfImage: ULONG,
}
impl Default for _LDR_DLL_LOADED_NOTIFICATION_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DLL_LOADED_NOTIFICATION_DATA = _LDR_DLL_LOADED_NOTIFICATION_DATA;
pub type PLDR_DLL_LOADED_NOTIFICATION_DATA = *mut _LDR_DLL_LOADED_NOTIFICATION_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
   pub Flags: ULONG,
   pub FullDllName: PCUNICODE_STRING,
   pub BaseDllName: PCUNICODE_STRING,
   pub DllBase: PVOID,
   pub SizeOfImage: ULONG,
}
impl Default for _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DLL_UNLOADED_NOTIFICATION_DATA = _LDR_DLL_UNLOADED_NOTIFICATION_DATA;
pub type PLDR_DLL_UNLOADED_NOTIFICATION_DATA = *mut _LDR_DLL_UNLOADED_NOTIFICATION_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DLL_NOTIFICATION_DATA {
   pub Loaded: LDR_DLL_LOADED_NOTIFICATION_DATA,
   pub Unloaded: LDR_DLL_UNLOADED_NOTIFICATION_DATA,
}
impl Default for _LDR_DLL_NOTIFICATION_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DLL_NOTIFICATION_DATA = _LDR_DLL_NOTIFICATION_DATA;
pub type PLDR_DLL_NOTIFICATION_DATA = *mut _LDR_DLL_NOTIFICATION_DATA;
pub type PLDR_DLL_NOTIFICATION_FUNCTION = ::core::option::Option<
   unsafe extern "C" fn(
      NotificationReason: ULONG,
      NotificationData: PLDR_DLL_NOTIFICATION_DATA,
      Context: PVOID,
   ),
>;
#[repr(C)]
pub struct _LDR_FAILURE_DATA {
   pub Status: NTSTATUS,
   pub DllName: [WCHAR; 32usize],
   pub AdditionalInfo: [WCHAR; 32usize],
}
impl Default for _LDR_FAILURE_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_FAILURE_DATA = _LDR_FAILURE_DATA;
pub type PLDR_FAILURE_DATA = *mut _LDR_FAILURE_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_MITIGATION_OPTIONS_MAP {
   pub Map: [ULONG_PTR; 3usize],
}
pub type PS_MITIGATION_OPTIONS_MAP = _PS_MITIGATION_OPTIONS_MAP;
pub type PPS_MITIGATION_OPTIONS_MAP = *mut _PS_MITIGATION_OPTIONS_MAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_MITIGATION_AUDIT_OPTIONS_MAP {
   pub Map: [ULONG_PTR; 3usize],
}
pub type PS_MITIGATION_AUDIT_OPTIONS_MAP = _PS_MITIGATION_AUDIT_OPTIONS_MAP;
pub type PPS_MITIGATION_AUDIT_OPTIONS_MAP = *mut _PS_MITIGATION_AUDIT_OPTIONS_MAP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_SYSTEM_DLL_INIT_BLOCK {
   pub Size: ULONG,
   pub SystemDllWowRelocation: ULONG_PTR,
   pub SystemDllNativeRelocation: ULONG_PTR,
   pub Wow64SharedInformation: [ULONG_PTR; 16usize],
   pub RngData: ULONG,
   pub __bindgen_anon_1: _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1,
   pub MitigationOptionsMap: PS_MITIGATION_OPTIONS_MAP,
   pub CfgBitMap: ULONG_PTR,
   pub CfgBitMapSize: ULONG_PTR,
   pub Wow64CfgBitMap: ULONG_PTR,
   pub Wow64CfgBitMapSize: ULONG_PTR,
   pub MitigationAuditOptionsMap: PS_MITIGATION_AUDIT_OPTIONS_MAP,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn CfgOverride(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CfgOverride(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      CfgOverride: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let CfgOverride: u32 = unsafe { ::core::mem::transmute(CfgOverride) };
         CfgOverride as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_SYSTEM_DLL_INIT_BLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_SYSTEM_DLL_INIT_BLOCK = _PS_SYSTEM_DLL_INIT_BLOCK;
pub type PPS_SYSTEM_DLL_INIT_BLOCK = *mut _PS_SYSTEM_DLL_INIT_BLOCK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_RESOURCE_INFO {
   pub Type: ULONG_PTR,
   pub Name: ULONG_PTR,
   pub Language: ULONG_PTR,
}
pub type LDR_RESOURCE_INFO = _LDR_RESOURCE_INFO;
pub type PLDR_RESOURCE_INFO = *mut _LDR_RESOURCE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_ENUM_RESOURCE_ENTRY {
   pub Path: [_LDR_ENUM_RESOURCE_ENTRY__bindgen_ty_1; 3usize],
   pub Data: PVOID,
   pub Size: ULONG,
   pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_ENUM_RESOURCE_ENTRY__bindgen_ty_1 {
   pub NameOrId: ULONG_PTR,
   pub Name: PIMAGE_RESOURCE_DIRECTORY_STRING,
   pub __bindgen_anon_1: _LDR_ENUM_RESOURCE_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_ENUM_RESOURCE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub Id: USHORT,
   pub NameIsPresent: USHORT,
}
impl Default for _LDR_ENUM_RESOURCE_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDR_ENUM_RESOURCE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_ENUM_RESOURCE_ENTRY = _LDR_ENUM_RESOURCE_ENTRY;
pub type PLDR_ENUM_RESOURCE_ENTRY = *mut _LDR_ENUM_RESOURCE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_MODULE_INFORMATION {
   pub Section: PVOID,
   pub MappedBase: PVOID,
   pub ImageBase: PVOID,
   pub ImageSize: ULONG,
   pub Flags: ULONG,
   pub LoadOrderIndex: USHORT,
   pub InitOrderIndex: USHORT,
   pub LoadCount: USHORT,
   pub OffsetToFileName: USHORT,
   pub FullPathName: [UCHAR; 256usize],
}
impl Default for _RTL_PROCESS_MODULE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_MODULE_INFORMATION = _RTL_PROCESS_MODULE_INFORMATION;
pub type PRTL_PROCESS_MODULE_INFORMATION = *mut _RTL_PROCESS_MODULE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_MODULES {
   pub NumberOfModules: ULONG,
   pub Modules: [RTL_PROCESS_MODULE_INFORMATION; 1usize],
}
impl Default for _RTL_PROCESS_MODULES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_MODULES = _RTL_PROCESS_MODULES;
pub type PRTL_PROCESS_MODULES = *mut _RTL_PROCESS_MODULES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_MODULE_INFORMATION_EX {
   pub NextOffset: USHORT,
   pub BaseInfo: RTL_PROCESS_MODULE_INFORMATION,
   pub ImageChecksum: ULONG,
   pub TimeDateStamp: ULONG,
   pub DefaultBase: PVOID,
}
impl Default for _RTL_PROCESS_MODULE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_MODULE_INFORMATION_EX = _RTL_PROCESS_MODULE_INFORMATION_EX;
pub type PRTL_PROCESS_MODULE_INFORMATION_EX = *mut _RTL_PROCESS_MODULE_INFORMATION_EX;
pub type PLDR_ENUM_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      ModuleInformation: PLDR_DATA_TABLE_ENTRY,
      Parameter: PVOID,
      Stop: *mut BOOLEAN,
   ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DELAYLOAD_PROC_DESCRIPTOR {
   pub ImportDescribedByName: ULONG,
   pub Description: _DELAYLOAD_PROC_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DELAYLOAD_PROC_DESCRIPTOR__bindgen_ty_1 {
   pub Name: PCSTR,
   pub Ordinal: ULONG,
}
impl Default for _DELAYLOAD_PROC_DESCRIPTOR__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _DELAYLOAD_PROC_DESCRIPTOR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DELAYLOAD_PROC_DESCRIPTOR = _DELAYLOAD_PROC_DESCRIPTOR;
pub type PDELAYLOAD_PROC_DESCRIPTOR = *mut _DELAYLOAD_PROC_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DELAYLOAD_INFO {
   pub Size: ULONG,
   pub DelayloadDescriptor: PCIMAGE_DELAYLOAD_DESCRIPTOR,
   pub ThunkAddress: PIMAGE_THUNK_DATA,
   pub TargetDllName: PCSTR,
   pub TargetApiDescriptor: DELAYLOAD_PROC_DESCRIPTOR,
   pub TargetModuleBase: PVOID,
   pub Unused: PVOID,
   pub LastError: ULONG,
}
impl Default for _DELAYLOAD_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DELAYLOAD_INFO = _DELAYLOAD_INFO;
pub type PDELAYLOAD_INFO = *mut _DELAYLOAD_INFO;
pub type PDELAYLOAD_FAILURE_DLL_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(NotificationReason: ULONG, DelayloadInfo: PDELAYLOAD_INFO) -> PVOID,
>;
pub type PDELAYLOAD_FAILURE_SYSTEM_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(DllName: PCSTR, ProcedureName: PCSTR) -> PVOID>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_SOFTWARE_ENCLAVE {
   pub Links: LIST_ENTRY,
   pub CriticalSection: RTL_CRITICAL_SECTION,
   pub EnclaveType: ULONG,
   pub ReferenceCount: LONG,
   pub EnclaveState: ULONG,
   pub BaseAddress: PVOID,
   pub Size: SIZE_T,
   pub PreviousBaseAddress: PVOID,
   pub Modules: LIST_ENTRY,
   pub PrimaryModule: PLDR_DATA_TABLE_ENTRY,
   pub BCryptModule: PLDR_DATA_TABLE_ENTRY,
   pub BCryptPrimitivesModule: PLDR_DATA_TABLE_ENTRY,
}
impl Default for _LDR_SOFTWARE_ENCLAVE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_SOFTWARE_ENCLAVE = _LDR_SOFTWARE_ENCLAVE;
pub type PLDR_SOFTWARE_ENCLAVE = *mut _LDR_SOFTWARE_ENCLAVE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_ENVIRONMENT_INFORMATION_CLASS {
   SystemEnvironmentNameInformation = 1,
   SystemEnvironmentValueInformation = 2,
   MaxSystemEnvironmentInfoClass = 3,
}
pub use self::_SYSTEM_ENVIRONMENT_INFORMATION_CLASS as SYSTEM_ENVIRONMENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VARIABLE_NAME {
   pub NextEntryOffset: ULONG,
   pub VendorGuid: GUID,
   pub Name: [WCHAR; 1usize],
}
pub type VARIABLE_NAME = _VARIABLE_NAME;
pub type PVARIABLE_NAME = *mut _VARIABLE_NAME;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VARIABLE_NAME_AND_VALUE {
   pub NextEntryOffset: ULONG,
   pub ValueOffset: ULONG,
   pub ValueLength: ULONG,
   pub Attributes: ULONG,
   pub VendorGuid: GUID,
   pub Name: [WCHAR; 1usize],
}
pub type VARIABLE_NAME_AND_VALUE = _VARIABLE_NAME_AND_VALUE;
pub type PVARIABLE_NAME_AND_VALUE = *mut _VARIABLE_NAME_AND_VALUE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BOOT_ENTRY {
   pub Version: ULONG,
   pub Length: ULONG,
   pub Id: ULONG,
   pub Attributes: ULONG,
   pub FriendlyNameOffset: ULONG,
   pub BootFilePathOffset: ULONG,
   pub OsOptionsLength: ULONG,
   pub OsOptions: [UCHAR; 1usize],
}
pub type BOOT_ENTRY = _BOOT_ENTRY;
pub type PBOOT_ENTRY = *mut _BOOT_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BOOT_ENTRY_LIST {
   pub NextEntryOffset: ULONG,
   pub BootEntry: BOOT_ENTRY,
}
pub type BOOT_ENTRY_LIST = _BOOT_ENTRY_LIST;
pub type PBOOT_ENTRY_LIST = *mut _BOOT_ENTRY_LIST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BOOT_OPTIONS {
   pub Version: ULONG,
   pub Length: ULONG,
   pub Timeout: ULONG,
   pub CurrentBootEntryId: ULONG,
   pub NextBootEntryId: ULONG,
   pub HeadlessRedirection: [WCHAR; 1usize],
}
pub type BOOT_OPTIONS = _BOOT_OPTIONS;
pub type PBOOT_OPTIONS = *mut _BOOT_OPTIONS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PATH {
   pub Version: ULONG,
   pub Length: ULONG,
   pub Type: ULONG,
   pub FilePath: [UCHAR; 1usize],
}
pub type FILE_PATH = _FILE_PATH;
pub type PFILE_PATH = *mut _FILE_PATH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EFI_DRIVER_ENTRY {
   pub Version: ULONG,
   pub Length: ULONG,
   pub Id: ULONG,
   pub FriendlyNameOffset: ULONG,
   pub DriverFilePathOffset: ULONG,
}
pub type EFI_DRIVER_ENTRY = _EFI_DRIVER_ENTRY;
pub type PEFI_DRIVER_ENTRY = *mut _EFI_DRIVER_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EFI_DRIVER_ENTRY_LIST {
   pub NextEntryOffset: ULONG,
   pub DriverEntry: EFI_DRIVER_ENTRY,
}
pub type EFI_DRIVER_ENTRY_LIST = _EFI_DRIVER_ENTRY_LIST;
pub type PEFI_DRIVER_ENTRY_LIST = *mut _EFI_DRIVER_ENTRY_LIST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILTER_BOOT_OPTION_OPERATION {
   FilterBootOptionOperationOpenSystemStore = 0,
   FilterBootOptionOperationSetElement = 1,
   FilterBootOptionOperationDeleteElement = 2,
   FilterBootOptionOperationMax = 3,
}
pub use self::_FILTER_BOOT_OPTION_OPERATION as FILTER_BOOT_OPTION_OPERATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_INFORMATION_CLASS {
   EventBasicInformation = 0,
}
pub use self::_EVENT_INFORMATION_CLASS as EVENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_BASIC_INFORMATION {
   pub EventType: EVENT_TYPE,
   pub EventState: LONG,
}
impl Default for _EVENT_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_BASIC_INFORMATION = _EVENT_BASIC_INFORMATION;
pub type PEVENT_BASIC_INFORMATION = *mut _EVENT_BASIC_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MUTANT_INFORMATION_CLASS {
   MutantBasicInformation = 0,
   MutantOwnerInformation = 1,
}
pub use self::_MUTANT_INFORMATION_CLASS as MUTANT_INFORMATION_CLASS;
#[repr(C)]
pub struct _MUTANT_BASIC_INFORMATION {
   pub CurrentCount: LONG,
   pub OwnedByCaller: BOOLEAN,
   pub AbandonedState: BOOLEAN,
}
impl Default for _MUTANT_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MUTANT_BASIC_INFORMATION = _MUTANT_BASIC_INFORMATION;
pub type PMUTANT_BASIC_INFORMATION = *mut _MUTANT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MUTANT_OWNER_INFORMATION {
   pub ClientId: CLIENT_ID,
}
impl Default for _MUTANT_OWNER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MUTANT_OWNER_INFORMATION = _MUTANT_OWNER_INFORMATION;
pub type PMUTANT_OWNER_INFORMATION = *mut _MUTANT_OWNER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SEMAPHORE_INFORMATION_CLASS {
   SemaphoreBasicInformation = 0,
}
pub use self::_SEMAPHORE_INFORMATION_CLASS as SEMAPHORE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SEMAPHORE_BASIC_INFORMATION {
   pub CurrentCount: LONG,
   pub MaximumCount: LONG,
}
pub type SEMAPHORE_BASIC_INFORMATION = _SEMAPHORE_BASIC_INFORMATION;
pub type PSEMAPHORE_BASIC_INFORMATION = *mut _SEMAPHORE_BASIC_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TIMER_INFORMATION_CLASS {
   TimerBasicInformation = 0,
}
pub use self::_TIMER_INFORMATION_CLASS as TIMER_INFORMATION_CLASS;
#[repr(C)]
pub struct _TIMER_BASIC_INFORMATION {
   pub RemainingTime: LARGE_INTEGER,
   pub TimerState: BOOLEAN,
}
impl Default for _TIMER_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TIMER_BASIC_INFORMATION = _TIMER_BASIC_INFORMATION;
pub type PTIMER_BASIC_INFORMATION = *mut _TIMER_BASIC_INFORMATION;
pub type PTIMER_APC_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(TimerContext: PVOID, TimerLowValue: ULONG, TimerHighValue: LONG),
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TIMER_SET_INFORMATION_CLASS {
   TimerSetCoalescableTimer = 0,
   MaxTimerInfoClass = 1,
}
pub use self::_TIMER_SET_INFORMATION_CLASS as TIMER_SET_INFORMATION_CLASS;
pub type PCOUNTED_REASON_CONTEXT = *mut _COUNTED_REASON_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TIMER_SET_COALESCABLE_TIMER_INFO {
   pub DueTime: LARGE_INTEGER,
   pub TimerApcRoutine: PTIMER_APC_ROUTINE,
   pub TimerContext: PVOID,
   pub WakeContext: PCOUNTED_REASON_CONTEXT,
   pub Period: ULONG,
   pub TolerableDelay: ULONG,
   pub PreviousState: PBOOLEAN,
}
impl Default for _TIMER_SET_COALESCABLE_TIMER_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TIMER_SET_COALESCABLE_TIMER_INFO = _TIMER_SET_COALESCABLE_TIMER_INFO;
pub type PTIMER_SET_COALESCABLE_TIMER_INFO = *mut _TIMER_SET_COALESCABLE_TIMER_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _T2_SET_PARAMETERS_V0 {
   pub Version: ULONG,
   pub Reserved: ULONG,
   pub NoWakeTolerance: LONGLONG,
}
pub type T2_SET_PARAMETERS = _T2_SET_PARAMETERS_V0;
pub type PT2_SET_PARAMETERS = *mut _T2_SET_PARAMETERS_V0;
pub type PT2_CANCEL_PARAMETERS = PVOID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WNF_STATE_NAME {
   pub Data: [ULONG; 2usize],
}
pub type WNF_STATE_NAME = _WNF_STATE_NAME;
pub type PWNF_STATE_NAME = *mut _WNF_STATE_NAME;
pub type PCWNF_STATE_NAME = *const WNF_STATE_NAME;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WNF_STATE_NAME_LIFETIME {
   WnfWellKnownStateName = 0,
   WnfPermanentStateName = 1,
   WnfPersistentStateName = 2,
   WnfTemporaryStateName = 3,
}
pub use self::_WNF_STATE_NAME_LIFETIME as WNF_STATE_NAME_LIFETIME;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WNF_STATE_NAME_INFORMATION {
   WnfInfoStateNameExist = 0,
   WnfInfoSubscribersPresent = 1,
   WnfInfoIsQuiescent = 2,
}
pub use self::_WNF_STATE_NAME_INFORMATION as WNF_STATE_NAME_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WNF_DATA_SCOPE {
   WnfDataScopeSystem = 0,
   WnfDataScopeSession = 1,
   WnfDataScopeUser = 2,
   WnfDataScopeProcess = 3,
   WnfDataScopeMachine = 4,
   WnfDataScopePhysicalMachine = 5,
}
pub use self::_WNF_DATA_SCOPE as WNF_DATA_SCOPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WNF_TYPE_ID {
   pub TypeId: GUID,
}
pub type WNF_TYPE_ID = _WNF_TYPE_ID;
pub type PWNF_TYPE_ID = *mut _WNF_TYPE_ID;
pub type PCWNF_TYPE_ID = *const WNF_TYPE_ID;
pub type WNF_CHANGE_STAMP = ULONG;
pub type PWNF_CHANGE_STAMP = *mut ULONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WNF_DELIVERY_DESCRIPTOR {
   pub SubscriptionId: ULONGLONG,
   pub StateName: WNF_STATE_NAME,
   pub ChangeStamp: WNF_CHANGE_STAMP,
   pub StateDataSize: ULONG,
   pub EventMask: ULONG,
   pub TypeId: WNF_TYPE_ID,
   pub StateDataOffset: ULONG,
}
pub type WNF_DELIVERY_DESCRIPTOR = _WNF_DELIVERY_DESCRIPTOR;
pub type PWNF_DELIVERY_DESCRIPTOR = *mut _WNF_DELIVERY_DESCRIPTOR;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WORKERFACTORYINFOCLASS {
   WorkerFactoryTimeout = 0,
   WorkerFactoryRetryTimeout = 1,
   WorkerFactoryIdleTimeout = 2,
   WorkerFactoryBindingCount = 3,
   WorkerFactoryThreadMinimum = 4,
   WorkerFactoryThreadMaximum = 5,
   WorkerFactoryPaused = 6,
   WorkerFactoryBasicInformation = 7,
   WorkerFactoryAdjustThreadGoal = 8,
   WorkerFactoryCallbackType = 9,
   WorkerFactoryStackInformation = 10,
   WorkerFactoryThreadBasePriority = 11,
   WorkerFactoryTimeoutWaiters = 12,
   WorkerFactoryFlags = 13,
   WorkerFactoryThreadSoftMaximum = 14,
   WorkerFactoryThreadCpuSets = 15,
   MaxWorkerFactoryInfoClass = 16,
}
pub use self::_WORKERFACTORYINFOCLASS as WORKERFACTORYINFOCLASS;
pub type PWORKERFACTORYINFOCLASS = *mut _WORKERFACTORYINFOCLASS;
#[repr(C)]
pub struct _WORKER_FACTORY_BASIC_INFORMATION {
   pub Timeout: LARGE_INTEGER,
   pub RetryTimeout: LARGE_INTEGER,
   pub IdleTimeout: LARGE_INTEGER,
   pub Paused: BOOLEAN,
   pub TimerSet: BOOLEAN,
   pub QueuedToExWorker: BOOLEAN,
   pub MayCreate: BOOLEAN,
   pub CreateInProgress: BOOLEAN,
   pub InsertedIntoQueue: BOOLEAN,
   pub Shutdown: BOOLEAN,
   pub BindingCount: ULONG,
   pub ThreadMinimum: ULONG,
   pub ThreadMaximum: ULONG,
   pub PendingWorkerCount: ULONG,
   pub WaitingWorkerCount: ULONG,
   pub TotalWorkerCount: ULONG,
   pub ReleaseCount: ULONG,
   pub InfiniteWaitGoal: LONGLONG,
   pub StartRoutine: PVOID,
   pub StartParameter: PVOID,
   pub ProcessId: HANDLE,
   pub StackReserve: SIZE_T,
   pub StackCommit: SIZE_T,
   pub LastThreadCreationStatus: NTSTATUS,
}
impl Default for _WORKER_FACTORY_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WORKER_FACTORY_BASIC_INFORMATION = _WORKER_FACTORY_BASIC_INFORMATION;
pub type PWORKER_FACTORY_BASIC_INFORMATION = *mut _WORKER_FACTORY_BASIC_INFORMATION;
pub type PFILE_IO_COMPLETION_INFORMATION = *mut _FILE_IO_COMPLETION_INFORMATION;
pub type PPORT_MESSAGE = *mut _PORT_MESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WORKER_FACTORY_DEFERRED_WORK {
   pub AlpcSendMessage: PPORT_MESSAGE,
   pub AlpcSendMessagePort: PVOID,
   pub AlpcSendMessageFlags: ULONG,
   pub Flags: ULONG,
}
impl Default for _WORKER_FACTORY_DEFERRED_WORK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WORKER_FACTORY_DEFERRED_WORK = _WORKER_FACTORY_DEFERRED_WORK;
pub type PWORKER_FACTORY_DEFERRED_WORK = *mut _WORKER_FACTORY_DEFERRED_WORK;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_INFORMATION_CLASS {
   SystemBasicInformation = 0,
   SystemProcessorInformation = 1,
   SystemPerformanceInformation = 2,
   SystemTimeOfDayInformation = 3,
   SystemPathInformation = 4,
   SystemProcessInformation = 5,
   SystemCallCountInformation = 6,
   SystemDeviceInformation = 7,
   SystemProcessorPerformanceInformation = 8,
   SystemFlagsInformation = 9,
   SystemCallTimeInformation = 10,
   SystemModuleInformation = 11,
   SystemLocksInformation = 12,
   SystemStackTraceInformation = 13,
   SystemPagedPoolInformation = 14,
   SystemNonPagedPoolInformation = 15,
   SystemHandleInformation = 16,
   SystemObjectInformation = 17,
   SystemPageFileInformation = 18,
   SystemVdmInstemulInformation = 19,
   SystemVdmBopInformation = 20,
   SystemFileCacheInformation = 21,
   SystemPoolTagInformation = 22,
   SystemInterruptInformation = 23,
   SystemDpcBehaviorInformation = 24,
   SystemFullMemoryInformation = 25,
   SystemLoadGdiDriverInformation = 26,
   SystemUnloadGdiDriverInformation = 27,
   SystemTimeAdjustmentInformation = 28,
   SystemSummaryMemoryInformation = 29,
   SystemMirrorMemoryInformation = 30,
   SystemPerformanceTraceInformation = 31,
   SystemObsolete0 = 32,
   SystemExceptionInformation = 33,
   SystemCrashDumpStateInformation = 34,
   SystemKernelDebuggerInformation = 35,
   SystemContextSwitchInformation = 36,
   SystemRegistryQuotaInformation = 37,
   SystemExtendServiceTableInformation = 38,
   SystemPrioritySeperation = 39,
   SystemVerifierAddDriverInformation = 40,
   SystemVerifierRemoveDriverInformation = 41,
   SystemProcessorIdleInformation = 42,
   SystemLegacyDriverInformation = 43,
   SystemCurrentTimeZoneInformation = 44,
   SystemLookasideInformation = 45,
   SystemTimeSlipNotification = 46,
   SystemSessionCreate = 47,
   SystemSessionDetach = 48,
   SystemSessionInformation = 49,
   SystemRangeStartInformation = 50,
   SystemVerifierInformation = 51,
   SystemVerifierThunkExtend = 52,
   SystemSessionProcessInformation = 53,
   SystemLoadGdiDriverInSystemSpace = 54,
   SystemNumaProcessorMap = 55,
   SystemPrefetcherInformation = 56,
   SystemExtendedProcessInformation = 57,
   SystemRecommendedSharedDataAlignment = 58,
   SystemComPlusPackage = 59,
   SystemNumaAvailableMemory = 60,
   SystemProcessorPowerInformation = 61,
   SystemEmulationBasicInformation = 62,
   SystemEmulationProcessorInformation = 63,
   SystemExtendedHandleInformation = 64,
   SystemLostDelayedWriteInformation = 65,
   SystemBigPoolInformation = 66,
   SystemSessionPoolTagInformation = 67,
   SystemSessionMappedViewInformation = 68,
   SystemHotpatchInformation = 69,
   SystemObjectSecurityMode = 70,
   SystemWatchdogTimerHandler = 71,
   SystemWatchdogTimerInformation = 72,
   SystemLogicalProcessorInformation = 73,
   SystemWow64SharedInformationObsolete = 74,
   SystemRegisterFirmwareTableInformationHandler = 75,
   SystemFirmwareTableInformation = 76,
   SystemModuleInformationEx = 77,
   SystemVerifierTriageInformation = 78,
   SystemSuperfetchInformation = 79,
   SystemMemoryListInformation = 80,
   SystemFileCacheInformationEx = 81,
   SystemThreadPriorityClientIdInformation = 82,
   SystemProcessorIdleCycleTimeInformation = 83,
   SystemVerifierCancellationInformation = 84,
   SystemProcessorPowerInformationEx = 85,
   SystemRefTraceInformation = 86,
   SystemSpecialPoolInformation = 87,
   SystemProcessIdInformation = 88,
   SystemErrorPortInformation = 89,
   SystemBootEnvironmentInformation = 90,
   SystemHypervisorInformation = 91,
   SystemVerifierInformationEx = 92,
   SystemTimeZoneInformation = 93,
   SystemImageFileExecutionOptionsInformation = 94,
   SystemCoverageInformation = 95,
   SystemPrefetchPatchInformation = 96,
   SystemVerifierFaultsInformation = 97,
   SystemSystemPartitionInformation = 98,
   SystemSystemDiskInformation = 99,
   SystemProcessorPerformanceDistribution = 100,
   SystemNumaProximityNodeInformation = 101,
   SystemDynamicTimeZoneInformation = 102,
   SystemCodeIntegrityInformation = 103,
   SystemProcessorMicrocodeUpdateInformation = 104,
   SystemProcessorBrandString = 105,
   SystemVirtualAddressInformation = 106,
   SystemLogicalProcessorAndGroupInformation = 107,
   SystemProcessorCycleTimeInformation = 108,
   SystemStoreInformation = 109,
   SystemRegistryAppendString = 110,
   SystemAitSamplingValue = 111,
   SystemVhdBootInformation = 112,
   SystemCpuQuotaInformation = 113,
   SystemNativeBasicInformation = 114,
   SystemErrorPortTimeouts = 115,
   SystemLowPriorityIoInformation = 116,
   SystemTpmBootEntropyInformation = 117,
   SystemVerifierCountersInformation = 118,
   SystemPagedPoolInformationEx = 119,
   SystemSystemPtesInformationEx = 120,
   SystemNodeDistanceInformation = 121,
   SystemAcpiAuditInformation = 122,
   SystemBasicPerformanceInformation = 123,
   SystemQueryPerformanceCounterInformation = 124,
   SystemSessionBigPoolInformation = 125,
   SystemBootGraphicsInformation = 126,
   SystemScrubPhysicalMemoryInformation = 127,
   SystemBadPageInformation = 128,
   SystemProcessorProfileControlArea = 129,
   SystemCombinePhysicalMemoryInformation = 130,
   SystemEntropyInterruptTimingInformation = 131,
   SystemConsoleInformation = 132,
   SystemPlatformBinaryInformation = 133,
   SystemPolicyInformation = 134,
   SystemHypervisorProcessorCountInformation = 135,
   SystemDeviceDataInformation = 136,
   SystemDeviceDataEnumerationInformation = 137,
   SystemMemoryTopologyInformation = 138,
   SystemMemoryChannelInformation = 139,
   SystemBootLogoInformation = 140,
   SystemProcessorPerformanceInformationEx = 141,
   SystemCriticalProcessErrorLogInformation = 142,
   SystemSecureBootPolicyInformation = 143,
   SystemPageFileInformationEx = 144,
   SystemSecureBootInformation = 145,
   SystemEntropyInterruptTimingRawInformation = 146,
   SystemPortableWorkspaceEfiLauncherInformation = 147,
   SystemFullProcessInformation = 148,
   SystemKernelDebuggerInformationEx = 149,
   SystemBootMetadataInformation = 150,
   SystemSoftRebootInformation = 151,
   SystemElamCertificateInformation = 152,
   SystemOfflineDumpConfigInformation = 153,
   SystemProcessorFeaturesInformation = 154,
   SystemRegistryReconciliationInformation = 155,
   SystemEdidInformation = 156,
   SystemManufacturingInformation = 157,
   SystemEnergyEstimationConfigInformation = 158,
   SystemHypervisorDetailInformation = 159,
   SystemProcessorCycleStatsInformation = 160,
   SystemVmGenerationCountInformation = 161,
   SystemTrustedPlatformModuleInformation = 162,
   SystemKernelDebuggerFlags = 163,
   SystemCodeIntegrityPolicyInformation = 164,
   SystemIsolatedUserModeInformation = 165,
   SystemHardwareSecurityTestInterfaceResultsInformation = 166,
   SystemSingleModuleInformation = 167,
   SystemAllowedCpuSetsInformation = 168,
   SystemVsmProtectionInformation = 169,
   SystemInterruptCpuSetsInformation = 170,
   SystemSecureBootPolicyFullInformation = 171,
   SystemCodeIntegrityPolicyFullInformation = 172,
   SystemAffinitizedInterruptProcessorInformation = 173,
   SystemRootSiloInformation = 174,
   SystemCpuSetInformation = 175,
   SystemCpuSetTagInformation = 176,
   SystemWin32WerStartCallout = 177,
   SystemSecureKernelProfileInformation = 178,
   SystemCodeIntegrityPlatformManifestInformation = 179,
   SystemInterruptSteeringInformation = 180,
   SystemSupportedProcessorArchitectures = 181,
   SystemMemoryUsageInformation = 182,
   SystemCodeIntegrityCertificateInformation = 183,
   SystemPhysicalMemoryInformation = 184,
   SystemControlFlowTransition = 185,
   SystemKernelDebuggingAllowed = 186,
   SystemActivityModerationExeState = 187,
   SystemActivityModerationUserSettings = 188,
   SystemCodeIntegrityPoliciesFullInformation = 189,
   SystemCodeIntegrityUnlockInformation = 190,
   SystemIntegrityQuotaInformation = 191,
   SystemFlushInformation = 192,
   SystemProcessorIdleMaskInformation = 193,
   SystemSecureDumpEncryptionInformation = 194,
   SystemWriteConstraintInformation = 195,
   SystemKernelVaShadowInformation = 196,
   SystemHypervisorSharedPageInformation = 197,
   SystemFirmwareBootPerformanceInformation = 198,
   SystemCodeIntegrityVerificationInformation = 199,
   SystemFirmwarePartitionInformation = 200,
   SystemSpeculationControlInformation = 201,
   SystemDmaGuardPolicyInformation = 202,
   SystemEnclaveLaunchControlInformation = 203,
   SystemWorkloadAllowedCpuSetsInformation = 204,
   SystemCodeIntegrityUnlockModeInformation = 205,
   SystemLeapSecondInformation = 206,
   SystemFlags2Information = 207,
   SystemSecurityModelInformation = 208,
   SystemCodeIntegritySyntheticCacheInformation = 209,
   SystemFeatureConfigurationInformation = 210,
   SystemFeatureConfigurationSectionInformation = 211,
   SystemFeatureUsageSubscriptionInformation = 212,
   SystemSecureSpeculationControlInformation = 213,
   SystemSpacesBootInformation = 214,
   SystemFwRamdiskInformation = 215,
   SystemWheaIpmiHardwareInformation = 216,
   SystemDifSetRuleClassInformation = 217,
   SystemDifClearRuleClassInformation = 218,
   SystemDifApplyPluginVerificationOnDriver = 219,
   SystemDifRemovePluginVerificationOnDriver = 220,
   SystemShadowStackInformation = 221,
   SystemBuildVersionInformation = 222,
   SystemPoolLimitInformation = 223,
   SystemCodeIntegrityAddDynamicStore = 224,
   SystemCodeIntegrityClearDynamicStores = 225,
   SystemDifPoolTrackingInformation = 226,
   SystemPoolZeroingInformation = 227,
   SystemDpcWatchdogInformation = 228,
   SystemDpcWatchdogInformation2 = 229,
   SystemSupportedProcessorArchitectures2 = 230,
   SystemSingleProcessorRelationshipInformation = 231,
   SystemXfgCheckFailureInformation = 232,
   SystemIommuStateInformation = 233,
   SystemHypervisorMinrootInformation = 234,
   SystemHypervisorBootPagesInformation = 235,
   SystemPointerAuthInformation = 236,
   SystemSecureKernelDebuggerInformation = 237,
   SystemOriginalImageFeatureInformation = 238,
   MaxSystemInfoClass = 239,
}
pub use self::_SYSTEM_INFORMATION_CLASS as SYSTEM_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BASIC_INFORMATION {
   pub Reserved: ULONG,
   pub TimerResolution: ULONG,
   pub PageSize: ULONG,
   pub NumberOfPhysicalPages: ULONG,
   pub LowestPhysicalPageNumber: ULONG,
   pub HighestPhysicalPageNumber: ULONG,
   pub AllocationGranularity: ULONG,
   pub MinimumUserModeAddress: ULONG_PTR,
   pub MaximumUserModeAddress: ULONG_PTR,
   pub ActiveProcessorsAffinityMask: KAFFINITY,
   pub NumberOfProcessors: CCHAR,
}
pub type SYSTEM_BASIC_INFORMATION = _SYSTEM_BASIC_INFORMATION;
pub type PSYSTEM_BASIC_INFORMATION = *mut _SYSTEM_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_INFORMATION {
   pub ProcessorArchitecture: USHORT,
   pub ProcessorLevel: USHORT,
   pub ProcessorRevision: USHORT,
   pub MaximumProcessors: USHORT,
   pub ProcessorFeatureBits: ULONG,
}
pub type SYSTEM_PROCESSOR_INFORMATION = _SYSTEM_PROCESSOR_INFORMATION;
pub type PSYSTEM_PROCESSOR_INFORMATION = *mut _SYSTEM_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PERFORMANCE_INFORMATION {
   pub IdleProcessTime: LARGE_INTEGER,
   pub IoReadTransferCount: LARGE_INTEGER,
   pub IoWriteTransferCount: LARGE_INTEGER,
   pub IoOtherTransferCount: LARGE_INTEGER,
   pub IoReadOperationCount: ULONG,
   pub IoWriteOperationCount: ULONG,
   pub IoOtherOperationCount: ULONG,
   pub AvailablePages: ULONG,
   pub CommittedPages: ULONG,
   pub CommitLimit: ULONG,
   pub PeakCommitment: ULONG,
   pub PageFaultCount: ULONG,
   pub CopyOnWriteCount: ULONG,
   pub TransitionCount: ULONG,
   pub CacheTransitionCount: ULONG,
   pub DemandZeroCount: ULONG,
   pub PageReadCount: ULONG,
   pub PageReadIoCount: ULONG,
   pub CacheReadCount: ULONG,
   pub CacheIoCount: ULONG,
   pub DirtyPagesWriteCount: ULONG,
   pub DirtyWriteIoCount: ULONG,
   pub MappedPagesWriteCount: ULONG,
   pub MappedWriteIoCount: ULONG,
   pub PagedPoolPages: ULONG,
   pub NonPagedPoolPages: ULONG,
   pub PagedPoolAllocs: ULONG,
   pub PagedPoolFrees: ULONG,
   pub NonPagedPoolAllocs: ULONG,
   pub NonPagedPoolFrees: ULONG,
   pub FreeSystemPtes: ULONG,
   pub ResidentSystemCodePage: ULONG,
   pub TotalSystemDriverPages: ULONG,
   pub TotalSystemCodePages: ULONG,
   pub NonPagedPoolLookasideHits: ULONG,
   pub PagedPoolLookasideHits: ULONG,
   pub AvailablePagedPoolPages: ULONG,
   pub ResidentSystemCachePage: ULONG,
   pub ResidentPagedPoolPage: ULONG,
   pub ResidentSystemDriverPage: ULONG,
   pub CcFastReadNoWait: ULONG,
   pub CcFastReadWait: ULONG,
   pub CcFastReadResourceMiss: ULONG,
   pub CcFastReadNotPossible: ULONG,
   pub CcFastMdlReadNoWait: ULONG,
   pub CcFastMdlReadWait: ULONG,
   pub CcFastMdlReadResourceMiss: ULONG,
   pub CcFastMdlReadNotPossible: ULONG,
   pub CcMapDataNoWait: ULONG,
   pub CcMapDataWait: ULONG,
   pub CcMapDataNoWaitMiss: ULONG,
   pub CcMapDataWaitMiss: ULONG,
   pub CcPinMappedDataCount: ULONG,
   pub CcPinReadNoWait: ULONG,
   pub CcPinReadWait: ULONG,
   pub CcPinReadNoWaitMiss: ULONG,
   pub CcPinReadWaitMiss: ULONG,
   pub CcCopyReadNoWait: ULONG,
   pub CcCopyReadWait: ULONG,
   pub CcCopyReadNoWaitMiss: ULONG,
   pub CcCopyReadWaitMiss: ULONG,
   pub CcMdlReadNoWait: ULONG,
   pub CcMdlReadWait: ULONG,
   pub CcMdlReadNoWaitMiss: ULONG,
   pub CcMdlReadWaitMiss: ULONG,
   pub CcReadAheadIos: ULONG,
   pub CcLazyWriteIos: ULONG,
   pub CcLazyWritePages: ULONG,
   pub CcDataFlushes: ULONG,
   pub CcDataPages: ULONG,
   pub ContextSwitches: ULONG,
   pub FirstLevelTbFills: ULONG,
   pub SecondLevelTbFills: ULONG,
   pub SystemCalls: ULONG,
   pub CcTotalDirtyPages: ULONGLONG,
   pub CcDirtyPageThreshold: ULONGLONG,
   pub ResidentAvailablePages: LONGLONG,
   pub SharedCommittedPages: ULONGLONG,
}
impl Default for _SYSTEM_PERFORMANCE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PERFORMANCE_INFORMATION = _SYSTEM_PERFORMANCE_INFORMATION;
pub type PSYSTEM_PERFORMANCE_INFORMATION = *mut _SYSTEM_PERFORMANCE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_TIMEOFDAY_INFORMATION {
   pub BootTime: LARGE_INTEGER,
   pub CurrentTime: LARGE_INTEGER,
   pub TimeZoneBias: LARGE_INTEGER,
   pub TimeZoneId: ULONG,
   pub Reserved: ULONG,
   pub BootTimeBias: ULONGLONG,
   pub SleepTimeBias: ULONGLONG,
}
impl Default for _SYSTEM_TIMEOFDAY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_TIMEOFDAY_INFORMATION = _SYSTEM_TIMEOFDAY_INFORMATION;
pub type PSYSTEM_TIMEOFDAY_INFORMATION = *mut _SYSTEM_TIMEOFDAY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_THREAD_INFORMATION {
   pub KernelTime: LARGE_INTEGER,
   pub UserTime: LARGE_INTEGER,
   pub CreateTime: LARGE_INTEGER,
   pub WaitTime: ULONG,
   pub StartAddress: ULONG_PTR,
   pub ClientId: CLIENT_ID,
   pub Priority: KPRIORITY,
   pub BasePriority: KPRIORITY,
   pub ContextSwitches: ULONG,
   pub ThreadState: KTHREAD_STATE,
   pub WaitReason: KWAIT_REASON,
}
impl Default for _SYSTEM_THREAD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_THREAD_INFORMATION = _SYSTEM_THREAD_INFORMATION;
pub type PSYSTEM_THREAD_INFORMATION = *mut _SYSTEM_THREAD_INFORMATION;
pub type PTEB = *mut _TEB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
   pub ThreadInfo: SYSTEM_THREAD_INFORMATION,
   pub StackBase: PVOID,
   pub StackLimit: PVOID,
   pub Win32StartAddress: ULONG_PTR,
   pub TebBase: PTEB,
   pub Reserved2: ULONG_PTR,
   pub Reserved3: ULONG_PTR,
   pub Reserved4: ULONG_PTR,
}
impl Default for _SYSTEM_EXTENDED_THREAD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_EXTENDED_THREAD_INFORMATION = _SYSTEM_EXTENDED_THREAD_INFORMATION;
pub type PSYSTEM_EXTENDED_THREAD_INFORMATION = *mut _SYSTEM_EXTENDED_THREAD_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_PROCESS_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub NumberOfThreads: ULONG,
   pub WorkingSetPrivateSize: LARGE_INTEGER,
   pub HardFaultCount: ULONG,
   pub NumberOfThreadsHighWatermark: ULONG,
   pub CycleTime: ULONGLONG,
   pub CreateTime: LARGE_INTEGER,
   pub UserTime: LARGE_INTEGER,
   pub KernelTime: LARGE_INTEGER,
   pub ImageName: UNICODE_STRING,
   pub BasePriority: KPRIORITY,
   pub UniqueProcessId: HANDLE,
   pub InheritedFromUniqueProcessId: HANDLE,
   pub HandleCount: ULONG,
   pub SessionId: ULONG,
   pub UniqueProcessKey: ULONG_PTR,
   pub PeakVirtualSize: SIZE_T,
   pub VirtualSize: SIZE_T,
   pub PageFaultCount: ULONG,
   pub PeakWorkingSetSize: SIZE_T,
   pub WorkingSetSize: SIZE_T,
   pub QuotaPeakPagedPoolUsage: SIZE_T,
   pub QuotaPagedPoolUsage: SIZE_T,
   pub QuotaPeakNonPagedPoolUsage: SIZE_T,
   pub QuotaNonPagedPoolUsage: SIZE_T,
   pub PagefileUsage: SIZE_T,
   pub PeakPagefileUsage: SIZE_T,
   pub PrivatePageCount: SIZE_T,
   pub ReadOperationCount: LARGE_INTEGER,
   pub WriteOperationCount: LARGE_INTEGER,
   pub OtherOperationCount: LARGE_INTEGER,
   pub ReadTransferCount: LARGE_INTEGER,
   pub WriteTransferCount: LARGE_INTEGER,
   pub OtherTransferCount: LARGE_INTEGER,
   pub Threads: [SYSTEM_THREAD_INFORMATION; 1usize],
}
impl Default for _SYSTEM_PROCESS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESS_INFORMATION = _SYSTEM_PROCESS_INFORMATION;
pub type PSYSTEM_PROCESS_INFORMATION = *mut _SYSTEM_PROCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CALL_COUNT_INFORMATION {
   pub Length: ULONG,
   pub NumberOfTables: ULONG,
}
pub type SYSTEM_CALL_COUNT_INFORMATION = _SYSTEM_CALL_COUNT_INFORMATION;
pub type PSYSTEM_CALL_COUNT_INFORMATION = *mut _SYSTEM_CALL_COUNT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_DEVICE_INFORMATION {
   pub NumberOfDisks: ULONG,
   pub NumberOfFloppies: ULONG,
   pub NumberOfCdRoms: ULONG,
   pub NumberOfTapes: ULONG,
   pub NumberOfSerialPorts: ULONG,
   pub NumberOfParallelPorts: ULONG,
}
pub type SYSTEM_DEVICE_INFORMATION = _SYSTEM_DEVICE_INFORMATION;
pub type PSYSTEM_DEVICE_INFORMATION = *mut _SYSTEM_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
   pub IdleTime: LARGE_INTEGER,
   pub KernelTime: LARGE_INTEGER,
   pub UserTime: LARGE_INTEGER,
   pub DpcTime: LARGE_INTEGER,
   pub InterruptTime: LARGE_INTEGER,
   pub InterruptCount: ULONG,
}
impl Default for _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION = _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION = *mut _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FLAGS_INFORMATION {
   pub Flags: ULONG,
}
pub type SYSTEM_FLAGS_INFORMATION = _SYSTEM_FLAGS_INFORMATION;
pub type PSYSTEM_FLAGS_INFORMATION = *mut _SYSTEM_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CALL_TIME_INFORMATION {
   pub Length: ULONG,
   pub TotalCalls: ULONG,
   pub TimeOfCalls: [LARGE_INTEGER; 1usize],
}
impl Default for _SYSTEM_CALL_TIME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_CALL_TIME_INFORMATION = _SYSTEM_CALL_TIME_INFORMATION;
pub type PSYSTEM_CALL_TIME_INFORMATION = *mut _SYSTEM_CALL_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_LOCK_INFORMATION {
   pub Address: PVOID,
   pub Type: USHORT,
   pub CreatorBackTraceIndex: USHORT,
   pub OwningThread: HANDLE,
   pub LockCount: LONG,
   pub ContentionCount: ULONG,
   pub EntryCount: ULONG,
   pub RecursionCount: LONG,
   pub NumberOfWaitingShared: ULONG,
   pub NumberOfWaitingExclusive: ULONG,
}
impl Default for _RTL_PROCESS_LOCK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_LOCK_INFORMATION = _RTL_PROCESS_LOCK_INFORMATION;
pub type PRTL_PROCESS_LOCK_INFORMATION = *mut _RTL_PROCESS_LOCK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_LOCKS {
   pub NumberOfLocks: ULONG,
   pub Locks: [RTL_PROCESS_LOCK_INFORMATION; 1usize],
}
impl Default for _RTL_PROCESS_LOCKS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_LOCKS = _RTL_PROCESS_LOCKS;
pub type PRTL_PROCESS_LOCKS = *mut _RTL_PROCESS_LOCKS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_BACKTRACE_INFORMATION {
   pub SymbolicBackTrace: PCHAR,
   pub TraceCount: ULONG,
   pub Index: USHORT,
   pub Depth: USHORT,
   pub BackTrace: [PVOID; 32usize],
}
impl Default for _RTL_PROCESS_BACKTRACE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_BACKTRACE_INFORMATION = _RTL_PROCESS_BACKTRACE_INFORMATION;
pub type PRTL_PROCESS_BACKTRACE_INFORMATION = *mut _RTL_PROCESS_BACKTRACE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_BACKTRACES {
   pub CommittedMemory: ULONG,
   pub ReservedMemory: ULONG,
   pub NumberOfBackTraceLookups: ULONG,
   pub NumberOfBackTraces: ULONG,
   pub BackTraces: [RTL_PROCESS_BACKTRACE_INFORMATION; 1usize],
}
impl Default for _RTL_PROCESS_BACKTRACES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_BACKTRACES = _RTL_PROCESS_BACKTRACES;
pub type PRTL_PROCESS_BACKTRACES = *mut _RTL_PROCESS_BACKTRACES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
   pub UniqueProcessId: USHORT,
   pub CreatorBackTraceIndex: USHORT,
   pub ObjectTypeIndex: UCHAR,
   pub HandleAttributes: UCHAR,
   pub HandleValue: USHORT,
   pub Object: PVOID,
   pub GrantedAccess: ULONG,
}
impl Default for _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HANDLE_TABLE_ENTRY_INFO = _SYSTEM_HANDLE_TABLE_ENTRY_INFO;
pub type PSYSTEM_HANDLE_TABLE_ENTRY_INFO = *mut _SYSTEM_HANDLE_TABLE_ENTRY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HANDLE_INFORMATION {
   pub NumberOfHandles: ULONG,
   pub Handles: [SYSTEM_HANDLE_TABLE_ENTRY_INFO; 1usize],
}
impl Default for _SYSTEM_HANDLE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HANDLE_INFORMATION = _SYSTEM_HANDLE_INFORMATION;
pub type PSYSTEM_HANDLE_INFORMATION = *mut _SYSTEM_HANDLE_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_OBJECTTYPE_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub NumberOfObjects: ULONG,
   pub NumberOfHandles: ULONG,
   pub TypeIndex: ULONG,
   pub InvalidAttributes: ULONG,
   pub GenericMapping: GENERIC_MAPPING,
   pub ValidAccessMask: ULONG,
   pub PoolType: ULONG,
   pub SecurityRequired: BOOLEAN,
   pub WaitableObject: BOOLEAN,
   pub TypeName: UNICODE_STRING,
}
impl Default for _SYSTEM_OBJECTTYPE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_OBJECTTYPE_INFORMATION = _SYSTEM_OBJECTTYPE_INFORMATION;
pub type PSYSTEM_OBJECTTYPE_INFORMATION = *mut _SYSTEM_OBJECTTYPE_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_OBJECT_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub Object: PVOID,
   pub CreatorUniqueProcess: HANDLE,
   pub CreatorBackTraceIndex: USHORT,
   pub Flags: USHORT,
   pub PointerCount: LONG,
   pub HandleCount: LONG,
   pub PagedPoolCharge: ULONG,
   pub NonPagedPoolCharge: ULONG,
   pub ExclusiveProcessId: HANDLE,
   pub SecurityDescriptor: PVOID,
   pub NameInfo: UNICODE_STRING,
}
impl Default for _SYSTEM_OBJECT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_OBJECT_INFORMATION = _SYSTEM_OBJECT_INFORMATION;
pub type PSYSTEM_OBJECT_INFORMATION = *mut _SYSTEM_OBJECT_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_PAGEFILE_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub TotalSize: ULONG,
   pub TotalInUse: ULONG,
   pub PeakUsage: ULONG,
   pub PageFileName: UNICODE_STRING,
}
impl Default for _SYSTEM_PAGEFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PAGEFILE_INFORMATION = _SYSTEM_PAGEFILE_INFORMATION;
pub type PSYSTEM_PAGEFILE_INFORMATION = *mut _SYSTEM_PAGEFILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_VDM_INSTEMUL_INFO {
   pub SegmentNotPresent: ULONG,
   pub VdmOpcode0F: ULONG,
   pub OpcodeESPrefix: ULONG,
   pub OpcodeCSPrefix: ULONG,
   pub OpcodeSSPrefix: ULONG,
   pub OpcodeDSPrefix: ULONG,
   pub OpcodeFSPrefix: ULONG,
   pub OpcodeGSPrefix: ULONG,
   pub OpcodeOPER32Prefix: ULONG,
   pub OpcodeADDR32Prefix: ULONG,
   pub OpcodeINSB: ULONG,
   pub OpcodeINSW: ULONG,
   pub OpcodeOUTSB: ULONG,
   pub OpcodeOUTSW: ULONG,
   pub OpcodePUSHF: ULONG,
   pub OpcodePOPF: ULONG,
   pub OpcodeINTnn: ULONG,
   pub OpcodeINTO: ULONG,
   pub OpcodeIRET: ULONG,
   pub OpcodeINBimm: ULONG,
   pub OpcodeINWimm: ULONG,
   pub OpcodeOUTBimm: ULONG,
   pub OpcodeOUTWimm: ULONG,
   pub OpcodeINB: ULONG,
   pub OpcodeINW: ULONG,
   pub OpcodeOUTB: ULONG,
   pub OpcodeOUTW: ULONG,
   pub OpcodeLOCKPrefix: ULONG,
   pub OpcodeREPNEPrefix: ULONG,
   pub OpcodeREPPrefix: ULONG,
   pub OpcodeHLT: ULONG,
   pub OpcodeCLI: ULONG,
   pub OpcodeSTI: ULONG,
   pub BopCount: ULONG,
}
pub type SYSTEM_VDM_INSTEMUL_INFO = _SYSTEM_VDM_INSTEMUL_INFO;
pub type PSYSTEM_VDM_INSTEMUL_INFO = *mut _SYSTEM_VDM_INSTEMUL_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FILECACHE_INFORMATION {
   pub CurrentSize: SIZE_T,
   pub PeakSize: SIZE_T,
   pub PageFaultCount: ULONG,
   pub MinimumWorkingSet: SIZE_T,
   pub MaximumWorkingSet: SIZE_T,
   pub CurrentSizeIncludingTransitionInPages: SIZE_T,
   pub PeakSizeIncludingTransitionInPages: SIZE_T,
   pub TransitionRePurposeCount: ULONG,
   pub Flags: ULONG,
}
pub type SYSTEM_FILECACHE_INFORMATION = _SYSTEM_FILECACHE_INFORMATION;
pub type PSYSTEM_FILECACHE_INFORMATION = *mut _SYSTEM_FILECACHE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BASIC_WORKING_SET_INFORMATION {
   pub CurrentSize: SIZE_T,
   pub PeakSize: SIZE_T,
   pub PageFaultCount: ULONG,
}
pub type SYSTEM_BASIC_WORKING_SET_INFORMATION = _SYSTEM_BASIC_WORKING_SET_INFORMATION;
pub type PSYSTEM_BASIC_WORKING_SET_INFORMATION = *mut _SYSTEM_BASIC_WORKING_SET_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POOLTAG {
   pub __bindgen_anon_1: _SYSTEM_POOLTAG__bindgen_ty_1,
   pub PagedAllocs: ULONG,
   pub PagedFrees: ULONG,
   pub PagedUsed: SIZE_T,
   pub NonPagedAllocs: ULONG,
   pub NonPagedFrees: ULONG,
   pub NonPagedUsed: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POOLTAG__bindgen_ty_1 {
   pub Tag: [UCHAR; 4usize],
   pub TagUlong: ULONG,
}
impl Default for _SYSTEM_POOLTAG__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_POOLTAG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POOLTAG = _SYSTEM_POOLTAG;
pub type PSYSTEM_POOLTAG = *mut _SYSTEM_POOLTAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POOLTAG_INFORMATION {
   pub Count: ULONG,
   pub TagInfo: [SYSTEM_POOLTAG; 1usize],
}
impl Default for _SYSTEM_POOLTAG_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POOLTAG_INFORMATION = _SYSTEM_POOLTAG_INFORMATION;
pub type PSYSTEM_POOLTAG_INFORMATION = *mut _SYSTEM_POOLTAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_INTERRUPT_INFORMATION {
   pub ContextSwitches: ULONG,
   pub DpcCount: ULONG,
   pub DpcRate: ULONG,
   pub TimeIncrement: ULONG,
   pub DpcBypassCount: ULONG,
   pub ApcBypassCount: ULONG,
}
pub type SYSTEM_INTERRUPT_INFORMATION = _SYSTEM_INTERRUPT_INFORMATION;
pub type PSYSTEM_INTERRUPT_INFORMATION = *mut _SYSTEM_INTERRUPT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_DPC_BEHAVIOR_INFORMATION {
   pub Spare: ULONG,
   pub DpcQueueDepth: ULONG,
   pub MinimumDpcRate: ULONG,
   pub AdjustDpcThreshold: ULONG,
   pub IdealDpcRate: ULONG,
}
pub type SYSTEM_DPC_BEHAVIOR_INFORMATION = _SYSTEM_DPC_BEHAVIOR_INFORMATION;
pub type PSYSTEM_DPC_BEHAVIOR_INFORMATION = *mut _SYSTEM_DPC_BEHAVIOR_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
   pub TimeAdjustment: ULONG,
   pub TimeIncrement: ULONG,
   pub Enable: BOOLEAN,
}
impl Default for _SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_QUERY_TIME_ADJUST_INFORMATION = _SYSTEM_QUERY_TIME_ADJUST_INFORMATION;
pub type PSYSTEM_QUERY_TIME_ADJUST_INFORMATION = *mut _SYSTEM_QUERY_TIME_ADJUST_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE {
   pub TimeAdjustment: ULONGLONG,
   pub TimeIncrement: ULONGLONG,
   pub Enable: BOOLEAN,
}
impl Default for _SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE =
   _SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE;
pub type PSYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE =
   *mut _SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE;
#[repr(C)]
pub struct _SYSTEM_SET_TIME_ADJUST_INFORMATION {
   pub TimeAdjustment: ULONG,
   pub Enable: BOOLEAN,
}
impl Default for _SYSTEM_SET_TIME_ADJUST_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SET_TIME_ADJUST_INFORMATION = _SYSTEM_SET_TIME_ADJUST_INFORMATION;
pub type PSYSTEM_SET_TIME_ADJUST_INFORMATION = *mut _SYSTEM_SET_TIME_ADJUST_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE {
   pub TimeAdjustment: ULONGLONG,
   pub Enable: BOOLEAN,
}
impl Default for _SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE = _SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE;
pub type PSYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE =
   *mut _SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_TRACE_INFORMATION_CLASS {
   EventTraceKernelVersionInformation = 0,
   EventTraceGroupMaskInformation = 1,
   EventTracePerformanceInformation = 2,
   EventTraceTimeProfileInformation = 3,
   EventTraceSessionSecurityInformation = 4,
   EventTraceSpinlockInformation = 5,
   EventTraceStackTracingInformation = 6,
   EventTraceExecutiveResourceInformation = 7,
   EventTraceHeapTracingInformation = 8,
   EventTraceHeapSummaryTracingInformation = 9,
   EventTracePoolTagFilterInformation = 10,
   EventTracePebsTracingInformation = 11,
   EventTraceProfileConfigInformation = 12,
   EventTraceProfileSourceListInformation = 13,
   EventTraceProfileEventListInformation = 14,
   EventTraceProfileCounterListInformation = 15,
   EventTraceStackCachingInformation = 16,
   EventTraceObjectTypeFilterInformation = 17,
   EventTraceSoftRestartInformation = 18,
   EventTraceLastBranchConfigurationInformation = 19,
   EventTraceLastBranchEventListInformation = 20,
   EventTraceProfileSourceAddInformation = 21,
   EventTraceProfileSourceRemoveInformation = 22,
   EventTraceProcessorTraceConfigurationInformation = 23,
   EventTraceProcessorTraceEventListInformation = 24,
   EventTraceCoverageSamplerInformation = 25,
   EventTraceUnifiedStackCachingInformation = 26,
   MaxEventTraceInfoClass = 27,
}
pub use self::_EVENT_TRACE_INFORMATION_CLASS as EVENT_TRACE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRACE_ENABLE_FLAG_EXTENSION {
   pub Offset: USHORT,
   pub Length: UCHAR,
   pub Flag: UCHAR,
}
pub type TRACE_ENABLE_FLAG_EXTENSION = _TRACE_ENABLE_FLAG_EXTENSION;
pub type PTRACE_ENABLE_FLAG_EXTENSION = *mut _TRACE_ENABLE_FLAG_EXTENSION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRACE_ENABLE_FLAG_EXT_HEADER {
   pub Length: USHORT,
   pub Items: USHORT,
}
pub type TRACE_ENABLE_FLAG_EXT_HEADER = _TRACE_ENABLE_FLAG_EXT_HEADER;
pub type PTRACE_ENABLE_FLAG_EXT_HEADER = *mut _TRACE_ENABLE_FLAG_EXT_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRACE_ENABLE_FLAG_EXT_ITEM {
   pub Offset: USHORT,
   pub Type: USHORT,
}
pub type TRACE_ENABLE_FLAG_EXT_ITEM = _TRACE_ENABLE_FLAG_EXT_ITEM;
pub type PTRACE_ENABLE_FLAG_EXT_ITEM = *mut _TRACE_ENABLE_FLAG_EXT_ITEM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_STACK_CACHING_CONFIG {
   pub CacheSize: ULONG,
   pub BucketCount: ULONG,
}
pub type ETW_STACK_CACHING_CONFIG = _ETW_STACK_CACHING_CONFIG;
pub type PETW_STACK_CACHING_CONFIG = *mut _ETW_STACK_CACHING_CONFIG;
pub type PERFINFO_MASK = ULONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_GROUPMASK {
   pub Masks: [ULONG; 8usize],
}
pub type PERFINFO_GROUPMASK = _PERFINFO_GROUPMASK;
pub type PPERFINFO_GROUPMASK = *mut _PERFINFO_GROUPMASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_VERSION_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub EventTraceKernelVersion: ULONG,
}
impl Default for _EVENT_TRACE_VERSION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_VERSION_INFORMATION = _EVENT_TRACE_VERSION_INFORMATION;
pub type PEVENT_TRACE_VERSION_INFORMATION = *mut _EVENT_TRACE_VERSION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_GROUPMASK_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub EventTraceGroupMasks: PERFINFO_GROUPMASK,
}
impl Default for _EVENT_TRACE_GROUPMASK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_GROUPMASK_INFORMATION = _EVENT_TRACE_GROUPMASK_INFORMATION;
pub type PEVENT_TRACE_GROUPMASK_INFORMATION = *mut _EVENT_TRACE_GROUPMASK_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EVENT_TRACE_PERFORMANCE_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub LogfileBytesWritten: LARGE_INTEGER,
}
impl Default for _EVENT_TRACE_PERFORMANCE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PERFORMANCE_INFORMATION = _EVENT_TRACE_PERFORMANCE_INFORMATION;
pub type PEVENT_TRACE_PERFORMANCE_INFORMATION = *mut _EVENT_TRACE_PERFORMANCE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_TIME_PROFILE_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub ProfileInterval: ULONG,
}
impl Default for _EVENT_TRACE_TIME_PROFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_TIME_PROFILE_INFORMATION = _EVENT_TRACE_TIME_PROFILE_INFORMATION;
pub type PEVENT_TRACE_TIME_PROFILE_INFORMATION = *mut _EVENT_TRACE_TIME_PROFILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_SESSION_SECURITY_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub SecurityInformation: ULONG,
   pub TraceHandle: TRACEHANDLE,
   pub SecurityDescriptor: [UCHAR; 1usize],
}
impl Default for _EVENT_TRACE_SESSION_SECURITY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_SESSION_SECURITY_INFORMATION = _EVENT_TRACE_SESSION_SECURITY_INFORMATION;
pub type PEVENT_TRACE_SESSION_SECURITY_INFORMATION = *mut _EVENT_TRACE_SESSION_SECURITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_SPINLOCK_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub SpinLockSpinThreshold: ULONG,
   pub SpinLockAcquireSampleRate: ULONG,
   pub SpinLockContentionSampleRate: ULONG,
   pub SpinLockHoldThreshold: ULONG,
}
impl Default for _EVENT_TRACE_SPINLOCK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_SPINLOCK_INFORMATION = _EVENT_TRACE_SPINLOCK_INFORMATION;
pub type PEVENT_TRACE_SPINLOCK_INFORMATION = *mut _EVENT_TRACE_SPINLOCK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_SYSTEM_EVENT_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub HookId: [ULONG; 1usize],
}
impl Default for _EVENT_TRACE_SYSTEM_EVENT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_SYSTEM_EVENT_INFORMATION = _EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type PEVENT_TRACE_SYSTEM_EVENT_INFORMATION = *mut _EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type EVENT_TRACE_STACK_TRACING_INFORMATION = EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type PEVENT_TRACE_STACK_TRACING_INFORMATION = *mut EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type EVENT_TRACE_PEBS_TRACING_INFORMATION = EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type PEVENT_TRACE_PEBS_TRACING_INFORMATION = *mut EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type EVENT_TRACE_PROFILE_EVENT_INFORMATION = EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type PEVENT_TRACE_PROFILE_EVENT_INFORMATION = *mut EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub ReleaseSamplingRate: ULONG,
   pub ContentionSamplingRate: ULONG,
   pub NumberOfExcessiveTimeouts: ULONG,
}
impl Default for _EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION = _EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION;
pub type PEVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION =
   *mut _EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_HEAP_TRACING_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub ProcessId: [ULONG; 1usize],
}
impl Default for _EVENT_TRACE_HEAP_TRACING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_HEAP_TRACING_INFORMATION = _EVENT_TRACE_HEAP_TRACING_INFORMATION;
pub type PEVENT_TRACE_HEAP_TRACING_INFORMATION = *mut _EVENT_TRACE_HEAP_TRACING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_TAG_FILTER_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub Filter: [ULONG; 1usize],
}
impl Default for _EVENT_TRACE_TAG_FILTER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_TAG_FILTER_INFORMATION = _EVENT_TRACE_TAG_FILTER_INFORMATION;
pub type PEVENT_TRACE_TAG_FILTER_INFORMATION = *mut _EVENT_TRACE_TAG_FILTER_INFORMATION;
pub type EVENT_TRACE_POOLTAG_FILTER_INFORMATION = EVENT_TRACE_TAG_FILTER_INFORMATION;
pub type PEVENT_TRACE_POOLTAG_FILTER_INFORMATION = *mut EVENT_TRACE_TAG_FILTER_INFORMATION;
pub type EVENT_TRACE_OBJECT_TYPE_FILTER_INFORMATION = EVENT_TRACE_TAG_FILTER_INFORMATION;
pub type PEVENT_TRACE_OBJECT_TYPE_FILTER_INFORMATION = *mut EVENT_TRACE_TAG_FILTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_COUNTER_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub ProfileSource: [ULONG; 1usize],
}
impl Default for _EVENT_TRACE_PROFILE_COUNTER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PROFILE_COUNTER_INFORMATION = _EVENT_TRACE_PROFILE_COUNTER_INFORMATION;
pub type PEVENT_TRACE_PROFILE_COUNTER_INFORMATION = *mut _EVENT_TRACE_PROFILE_COUNTER_INFORMATION;
pub type EVENT_TRACE_PROFILE_CONFIG_INFORMATION = EVENT_TRACE_PROFILE_COUNTER_INFORMATION;
pub type PEVENT_TRACE_PROFILE_CONFIG_INFORMATION = *mut EVENT_TRACE_PROFILE_COUNTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_LIST_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub Spare: ULONG,
   pub Profile: [PPROFILE_SOURCE_INFO; 1usize],
}
impl Default for _EVENT_TRACE_PROFILE_LIST_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PROFILE_LIST_INFORMATION = _EVENT_TRACE_PROFILE_LIST_INFORMATION;
pub type PEVENT_TRACE_PROFILE_LIST_INFORMATION = *mut _EVENT_TRACE_PROFILE_LIST_INFORMATION;
#[repr(C)]
pub struct _EVENT_TRACE_STACK_CACHING_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub Enabled: BOOLEAN,
   pub Reserved: [UCHAR; 3usize],
   pub CacheSize: ULONG,
   pub BucketCount: ULONG,
}
impl Default for _EVENT_TRACE_STACK_CACHING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_STACK_CACHING_INFORMATION = _EVENT_TRACE_STACK_CACHING_INFORMATION;
pub type PEVENT_TRACE_STACK_CACHING_INFORMATION = *mut _EVENT_TRACE_STACK_CACHING_INFORMATION;
#[repr(C)]
pub struct _EVENT_TRACE_SOFT_RESTART_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub PersistTraceBuffers: BOOLEAN,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _EVENT_TRACE_SOFT_RESTART_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_SOFT_RESTART_INFORMATION = _EVENT_TRACE_SOFT_RESTART_INFORMATION;
pub type PEVENT_TRACE_SOFT_RESTART_INFORMATION = *mut _EVENT_TRACE_SOFT_RESTART_INFORMATION;
#[repr(C)]
pub struct _EVENT_TRACE_PROFILE_ADD_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub PerfEvtEventSelect: BOOLEAN,
   pub PerfEvtUnitSelect: BOOLEAN,
   pub PerfEvtType: ULONG,
   pub CpuInfoHierarchy: [ULONG; 3usize],
   pub InitialInterval: ULONG,
   pub AllowsHalt: BOOLEAN,
   pub Persist: BOOLEAN,
   pub ProfileSourceDescription: [WCHAR; 1usize],
}
impl Default for _EVENT_TRACE_PROFILE_ADD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PROFILE_ADD_INFORMATION = _EVENT_TRACE_PROFILE_ADD_INFORMATION;
pub type PEVENT_TRACE_PROFILE_ADD_INFORMATION = *mut _EVENT_TRACE_PROFILE_ADD_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_REMOVE_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub ProfileSource: KPROFILE_SOURCE,
   pub CpuInfoHierarchy: [ULONG; 3usize],
}
impl Default for _EVENT_TRACE_PROFILE_REMOVE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PROFILE_REMOVE_INFORMATION = _EVENT_TRACE_PROFILE_REMOVE_INFORMATION;
pub type PEVENT_TRACE_PROFILE_REMOVE_INFORMATION = *mut _EVENT_TRACE_PROFILE_REMOVE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub CoverageSamplerInformationClass: UCHAR,
   pub MajorVersion: UCHAR,
   pub MinorVersion: UCHAR,
   pub Reserved: UCHAR,
   pub SamplerHandle: HANDLE,
}
impl Default for _EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION = _EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION;
pub type PEVENT_TRACE_COVERAGE_SAMPLER_INFORMATION = *mut _EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_EXCEPTION_INFORMATION {
   pub AlignmentFixupCount: ULONG,
   pub ExceptionDispatchCount: ULONG,
   pub FloatingEmulationCount: ULONG,
   pub ByteWordEmulationCount: ULONG,
}
pub type SYSTEM_EXCEPTION_INFORMATION = _SYSTEM_EXCEPTION_INFORMATION;
pub type PSYSTEM_EXCEPTION_INFORMATION = *mut _SYSTEM_EXCEPTION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS {
   SystemCrashDumpDisable = 0,
   SystemCrashDumpReconfigure = 1,
   SystemCrashDumpInitializationComplete = 2,
}
pub use self::_SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS as SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS;
pub type PSYSTEM_CRASH_DUMP_CONFIGURATION_CLASS = *mut _SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CRASH_DUMP_STATE_INFORMATION {
   pub CrashDumpConfigurationClass: SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS,
}
impl Default for _SYSTEM_CRASH_DUMP_STATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_CRASH_DUMP_STATE_INFORMATION = _SYSTEM_CRASH_DUMP_STATE_INFORMATION;
pub type PSYSTEM_CRASH_DUMP_STATE_INFORMATION = *mut _SYSTEM_CRASH_DUMP_STATE_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
   pub KernelDebuggerEnabled: BOOLEAN,
   pub KernelDebuggerNotPresent: BOOLEAN,
}
impl Default for _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_KERNEL_DEBUGGER_INFORMATION = _SYSTEM_KERNEL_DEBUGGER_INFORMATION;
pub type PSYSTEM_KERNEL_DEBUGGER_INFORMATION = *mut _SYSTEM_KERNEL_DEBUGGER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CONTEXT_SWITCH_INFORMATION {
   pub ContextSwitches: ULONG,
   pub FindAny: ULONG,
   pub FindLast: ULONG,
   pub FindIdeal: ULONG,
   pub IdleAny: ULONG,
   pub IdleCurrent: ULONG,
   pub IdleLast: ULONG,
   pub IdleIdeal: ULONG,
   pub PreemptAny: ULONG,
   pub PreemptCurrent: ULONG,
   pub PreemptLast: ULONG,
   pub SwitchToIdle: ULONG,
}
pub type SYSTEM_CONTEXT_SWITCH_INFORMATION = _SYSTEM_CONTEXT_SWITCH_INFORMATION;
pub type PSYSTEM_CONTEXT_SWITCH_INFORMATION = *mut _SYSTEM_CONTEXT_SWITCH_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {
   pub RegistryQuotaAllowed: ULONG,
   pub RegistryQuotaUsed: ULONG,
   pub PagedPoolSize: SIZE_T,
}
pub type SYSTEM_REGISTRY_QUOTA_INFORMATION = _SYSTEM_REGISTRY_QUOTA_INFORMATION;
pub type PSYSTEM_REGISTRY_QUOTA_INFORMATION = *mut _SYSTEM_REGISTRY_QUOTA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_IDLE_INFORMATION {
   pub IdleTime: ULONGLONG,
   pub C1Time: ULONGLONG,
   pub C2Time: ULONGLONG,
   pub C3Time: ULONGLONG,
   pub C1Transitions: ULONG,
   pub C2Transitions: ULONG,
   pub C3Transitions: ULONG,
   pub Padding: ULONG,
}
pub type SYSTEM_PROCESSOR_IDLE_INFORMATION = _SYSTEM_PROCESSOR_IDLE_INFORMATION;
pub type PSYSTEM_PROCESSOR_IDLE_INFORMATION = *mut _SYSTEM_PROCESSOR_IDLE_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_LEGACY_DRIVER_INFORMATION {
   pub VetoType: ULONG,
   pub VetoList: UNICODE_STRING,
}
impl Default for _SYSTEM_LEGACY_DRIVER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_LEGACY_DRIVER_INFORMATION = _SYSTEM_LEGACY_DRIVER_INFORMATION;
pub type PSYSTEM_LEGACY_DRIVER_INFORMATION = *mut _SYSTEM_LEGACY_DRIVER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_LOOKASIDE_INFORMATION {
   pub CurrentDepth: USHORT,
   pub MaximumDepth: USHORT,
   pub TotalAllocates: ULONG,
   pub AllocateMisses: ULONG,
   pub TotalFrees: ULONG,
   pub FreeMisses: ULONG,
   pub Type: ULONG,
   pub Tag: ULONG,
   pub Size: ULONG,
}
pub type SYSTEM_LOOKASIDE_INFORMATION = _SYSTEM_LOOKASIDE_INFORMATION;
pub type PSYSTEM_LOOKASIDE_INFORMATION = *mut _SYSTEM_LOOKASIDE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_RANGE_START_INFORMATION {
   pub SystemRangeStart: ULONG_PTR,
}
pub type SYSTEM_RANGE_START_INFORMATION = _SYSTEM_RANGE_START_INFORMATION;
pub type PSYSTEM_RANGE_START_INFORMATION = *mut _SYSTEM_RANGE_START_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_VERIFIER_INFORMATION_LEGACY {
   pub NextEntryOffset: ULONG,
   pub Level: ULONG,
   pub DriverName: UNICODE_STRING,
   pub RaiseIrqls: ULONG,
   pub AcquireSpinLocks: ULONG,
   pub SynchronizeExecutions: ULONG,
   pub AllocationsAttempted: ULONG,
   pub AllocationsSucceeded: ULONG,
   pub AllocationsSucceededSpecialPool: ULONG,
   pub AllocationsWithNoTag: ULONG,
   pub TrimRequests: ULONG,
   pub Trims: ULONG,
   pub AllocationsFailed: ULONG,
   pub AllocationsFailedDeliberately: ULONG,
   pub Loads: ULONG,
   pub Unloads: ULONG,
   pub UnTrackedPool: ULONG,
   pub CurrentPagedPoolAllocations: ULONG,
   pub CurrentNonPagedPoolAllocations: ULONG,
   pub PeakPagedPoolAllocations: ULONG,
   pub PeakNonPagedPoolAllocations: ULONG,
   pub PagedPoolUsageInBytes: SIZE_T,
   pub NonPagedPoolUsageInBytes: SIZE_T,
   pub PeakPagedPoolUsageInBytes: SIZE_T,
   pub PeakNonPagedPoolUsageInBytes: SIZE_T,
}
impl Default for _SYSTEM_VERIFIER_INFORMATION_LEGACY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_INFORMATION_LEGACY = _SYSTEM_VERIFIER_INFORMATION_LEGACY;
pub type PSYSTEM_VERIFIER_INFORMATION_LEGACY = *mut _SYSTEM_VERIFIER_INFORMATION_LEGACY;
#[repr(C)]
pub struct _SYSTEM_VERIFIER_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub Level: ULONG,
   pub RuleClasses: [ULONG; 2usize],
   pub TriageContext: ULONG,
   pub AreAllDriversBeingVerified: ULONG,
   pub DriverName: UNICODE_STRING,
   pub RaiseIrqls: ULONG,
   pub AcquireSpinLocks: ULONG,
   pub SynchronizeExecutions: ULONG,
   pub AllocationsAttempted: ULONG,
   pub AllocationsSucceeded: ULONG,
   pub AllocationsSucceededSpecialPool: ULONG,
   pub AllocationsWithNoTag: ULONG,
   pub TrimRequests: ULONG,
   pub Trims: ULONG,
   pub AllocationsFailed: ULONG,
   pub AllocationsFailedDeliberately: ULONG,
   pub Loads: ULONG,
   pub Unloads: ULONG,
   pub UnTrackedPool: ULONG,
   pub CurrentPagedPoolAllocations: ULONG,
   pub CurrentNonPagedPoolAllocations: ULONG,
   pub PeakPagedPoolAllocations: ULONG,
   pub PeakNonPagedPoolAllocations: ULONG,
   pub PagedPoolUsageInBytes: SIZE_T,
   pub NonPagedPoolUsageInBytes: SIZE_T,
   pub PeakPagedPoolUsageInBytes: SIZE_T,
   pub PeakNonPagedPoolUsageInBytes: SIZE_T,
}
impl Default for _SYSTEM_VERIFIER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_INFORMATION = _SYSTEM_VERIFIER_INFORMATION;
pub type PSYSTEM_VERIFIER_INFORMATION = *mut _SYSTEM_VERIFIER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SESSION_PROCESS_INFORMATION {
   pub SessionId: ULONG,
   pub SizeOfBuf: ULONG,
   pub Buffer: PVOID,
}
impl Default for _SYSTEM_SESSION_PROCESS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SESSION_PROCESS_INFORMATION = _SYSTEM_SESSION_PROCESS_INFORMATION;
pub type PSYSTEM_SESSION_PROCESS_INFORMATION = *mut _SYSTEM_SESSION_PROCESS_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_GDI_DRIVER_INFORMATION {
   pub DriverName: UNICODE_STRING,
   pub ImageAddress: PVOID,
   pub SectionPointer: PVOID,
   pub EntryPoint: PVOID,
   pub ExportSectionPointer: PIMAGE_EXPORT_DIRECTORY,
   pub ImageLength: ULONG,
}
impl Default for _SYSTEM_GDI_DRIVER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_GDI_DRIVER_INFORMATION = _SYSTEM_GDI_DRIVER_INFORMATION;
pub type PSYSTEM_GDI_DRIVER_INFORMATION = *mut _SYSTEM_GDI_DRIVER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_NUMA_INFORMATION {
   pub HighestNodeNumber: ULONG,
   pub Reserved: ULONG,
   pub __bindgen_anon_1: _SYSTEM_NUMA_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_NUMA_INFORMATION__bindgen_ty_1 {
   pub ActiveProcessorsGroupAffinity: [GROUP_AFFINITY; 64usize],
   pub AvailableMemory: [ULONGLONG; 64usize],
   pub Pad: [ULONGLONG; 128usize],
}
impl Default for _SYSTEM_NUMA_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_NUMA_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_NUMA_INFORMATION = _SYSTEM_NUMA_INFORMATION;
pub type PSYSTEM_NUMA_INFORMATION = *mut _SYSTEM_NUMA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_POWER_INFORMATION {
   pub CurrentFrequency: UCHAR,
   pub ThermalLimitFrequency: UCHAR,
   pub ConstantThrottleFrequency: UCHAR,
   pub DegradedThrottleFrequency: UCHAR,
   pub LastBusyFrequency: UCHAR,
   pub LastC3Frequency: UCHAR,
   pub LastAdjustedBusyFrequency: UCHAR,
   pub ProcessorMinThrottle: UCHAR,
   pub ProcessorMaxThrottle: UCHAR,
   pub NumberOfFrequencies: ULONG,
   pub PromotionCount: ULONG,
   pub DemotionCount: ULONG,
   pub ErrorCount: ULONG,
   pub RetryCount: ULONG,
   pub CurrentFrequencyTime: ULONGLONG,
   pub CurrentProcessorTime: ULONGLONG,
   pub CurrentProcessorIdleTime: ULONGLONG,
   pub LastProcessorTime: ULONGLONG,
   pub LastProcessorIdleTime: ULONGLONG,
   pub Energy: ULONGLONG,
}
pub type SYSTEM_PROCESSOR_POWER_INFORMATION = _SYSTEM_PROCESSOR_POWER_INFORMATION;
pub type PSYSTEM_PROCESSOR_POWER_INFORMATION = *mut _SYSTEM_PROCESSOR_POWER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
   pub Object: PVOID,
   pub UniqueProcessId: ULONG_PTR,
   pub HandleValue: ULONG_PTR,
   pub GrantedAccess: ULONG,
   pub CreatorBackTraceIndex: USHORT,
   pub ObjectTypeIndex: USHORT,
   pub HandleAttributes: ULONG,
   pub Reserved: ULONG,
}
impl Default for _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX = _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;
pub type PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX = *mut _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HANDLE_INFORMATION_EX {
   pub NumberOfHandles: ULONG_PTR,
   pub Reserved: ULONG_PTR,
   pub Handles: [SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX; 1usize],
}
impl Default for _SYSTEM_HANDLE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HANDLE_INFORMATION_EX = _SYSTEM_HANDLE_INFORMATION_EX;
pub type PSYSTEM_HANDLE_INFORMATION_EX = *mut _SYSTEM_HANDLE_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_BIGPOOL_ENTRY {
   pub __bindgen_anon_1: _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_1,
   pub SizeInBytes: SIZE_T,
   pub __bindgen_anon_2: _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_1 {
   pub VirtualAddress: PVOID,
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_1 {
   #[inline]
   pub fn NonPaged(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_NonPaged(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(NonPaged: ULONG_PTR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let NonPaged: u64 = unsafe { ::core::mem::transmute(NonPaged) };
         NonPaged as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_2 {
   pub Tag: [UCHAR; 4usize],
   pub TagUlong: ULONG,
}
impl Default for _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_BIGPOOL_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BIGPOOL_ENTRY = _SYSTEM_BIGPOOL_ENTRY;
pub type PSYSTEM_BIGPOOL_ENTRY = *mut _SYSTEM_BIGPOOL_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_BIGPOOL_INFORMATION {
   pub Count: ULONG,
   pub AllocatedInfo: [SYSTEM_BIGPOOL_ENTRY; 1usize],
}
impl Default for _SYSTEM_BIGPOOL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BIGPOOL_INFORMATION = _SYSTEM_BIGPOOL_INFORMATION;
pub type PSYSTEM_BIGPOOL_INFORMATION = *mut _SYSTEM_BIGPOOL_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_POOL_ENTRY {
   pub Allocated: BOOLEAN,
   pub Spare0: BOOLEAN,
   pub AllocatorBackTraceIndex: USHORT,
   pub Size: ULONG,
   pub __bindgen_anon_1: _SYSTEM_POOL_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POOL_ENTRY__bindgen_ty_1 {
   pub Tag: [UCHAR; 4usize],
   pub TagUlong: ULONG,
   pub ProcessChargedQuota: PVOID,
}
impl Default for _SYSTEM_POOL_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_POOL_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POOL_ENTRY = _SYSTEM_POOL_ENTRY;
pub type PSYSTEM_POOL_ENTRY = *mut _SYSTEM_POOL_ENTRY;
#[repr(C)]
pub struct _SYSTEM_POOL_INFORMATION {
   pub TotalSize: SIZE_T,
   pub FirstEntry: PVOID,
   pub EntryOverhead: USHORT,
   pub PoolTagPresent: BOOLEAN,
   pub Spare0: BOOLEAN,
   pub NumberOfEntries: ULONG,
   pub Entries: [SYSTEM_POOL_ENTRY; 1usize],
}
impl Default for _SYSTEM_POOL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POOL_INFORMATION = _SYSTEM_POOL_INFORMATION;
pub type PSYSTEM_POOL_INFORMATION = *mut _SYSTEM_POOL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_SESSION_POOLTAG_INFORMATION {
   pub NextEntryOffset: SIZE_T,
   pub SessionId: ULONG,
   pub Count: ULONG,
   pub TagInfo: [SYSTEM_POOLTAG; 1usize],
}
impl Default for _SYSTEM_SESSION_POOLTAG_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SESSION_POOLTAG_INFORMATION = _SYSTEM_SESSION_POOLTAG_INFORMATION;
pub type PSYSTEM_SESSION_POOLTAG_INFORMATION = *mut _SYSTEM_SESSION_POOLTAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION {
   pub NextEntryOffset: SIZE_T,
   pub SessionId: ULONG,
   pub ViewFailures: ULONG,
   pub NumberOfBytesAvailable: SIZE_T,
   pub NumberOfBytesAvailableContiguous: SIZE_T,
}
pub type SYSTEM_SESSION_MAPPED_VIEW_INFORMATION = _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION;
pub type PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION = *mut _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WATCHDOG_HANDLER_ACTION {
   WdActionSetTimeoutValue = 0,
   WdActionQueryTimeoutValue = 1,
   WdActionResetTimer = 2,
   WdActionStopTimer = 3,
   WdActionStartTimer = 4,
   WdActionSetTriggerAction = 5,
   WdActionQueryTriggerAction = 6,
   WdActionQueryState = 7,
}
pub use self::_WATCHDOG_HANDLER_ACTION as WATCHDOG_HANDLER_ACTION;
pub type PSYSTEM_WATCHDOG_HANDLER = ::core::option::Option<
   unsafe extern "C" fn(
      Action: WATCHDOG_HANDLER_ACTION,
      Context: PVOID,
      DataValue: PULONG,
      NoLocks: BOOLEAN,
   ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_WATCHDOG_HANDLER_INFORMATION {
   pub WdHandler: PSYSTEM_WATCHDOG_HANDLER,
   pub Context: PVOID,
}
impl Default for _SYSTEM_WATCHDOG_HANDLER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_WATCHDOG_HANDLER_INFORMATION = _SYSTEM_WATCHDOG_HANDLER_INFORMATION;
pub type PSYSTEM_WATCHDOG_HANDLER_INFORMATION = *mut _SYSTEM_WATCHDOG_HANDLER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WATCHDOG_INFORMATION_CLASS {
   WdInfoTimeoutValue = 0,
   WdInfoResetTimer = 1,
   WdInfoStopTimer = 2,
   WdInfoStartTimer = 3,
   WdInfoTriggerAction = 4,
   WdInfoState = 5,
   WdInfoTriggerReset = 6,
   WdInfoNop = 7,
   WdInfoGeneratedLastReset = 8,
   WdInfoInvalid = 9,
}
pub use self::_WATCHDOG_INFORMATION_CLASS as WATCHDOG_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_WATCHDOG_TIMER_INFORMATION {
   pub WdInfoClass: WATCHDOG_INFORMATION_CLASS,
   pub DataValue: ULONG,
}
impl Default for _SYSTEM_WATCHDOG_TIMER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_WATCHDOG_TIMER_INFORMATION = _SYSTEM_WATCHDOG_TIMER_INFORMATION;
pub type PSYSTEM_WATCHDOG_TIMER_INFORMATION = *mut _SYSTEM_WATCHDOG_TIMER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_FIRMWARE_TABLE_ACTION {
   SystemFirmwareTableEnumerate = 0,
   SystemFirmwareTableGet = 1,
   SystemFirmwareTableMax = 2,
}
pub use self::_SYSTEM_FIRMWARE_TABLE_ACTION as SYSTEM_FIRMWARE_TABLE_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
   pub ProviderSignature: ULONG,
   pub Action: SYSTEM_FIRMWARE_TABLE_ACTION,
   pub TableID: ULONG,
   pub TableBufferLength: ULONG,
   pub TableBuffer: [UCHAR; 1usize],
}
impl Default for _SYSTEM_FIRMWARE_TABLE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FIRMWARE_TABLE_INFORMATION = _SYSTEM_FIRMWARE_TABLE_INFORMATION;
pub type PSYSTEM_FIRMWARE_TABLE_INFORMATION = *mut _SYSTEM_FIRMWARE_TABLE_INFORMATION;
pub type PFNFTH = ::core::option::Option<
   unsafe extern "C" fn(SystemFirmwareTableInfo: PSYSTEM_FIRMWARE_TABLE_INFORMATION) -> NTSTATUS,
>;
#[repr(C)]
pub struct _SYSTEM_FIRMWARE_TABLE_HANDLER {
   pub ProviderSignature: ULONG,
   pub Register: BOOLEAN,
   pub FirmwareTableHandler: PFNFTH,
   pub DriverObject: PVOID,
}
impl Default for _SYSTEM_FIRMWARE_TABLE_HANDLER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FIRMWARE_TABLE_HANDLER = _SYSTEM_FIRMWARE_TABLE_HANDLER;
pub type PSYSTEM_FIRMWARE_TABLE_HANDLER = *mut _SYSTEM_FIRMWARE_TABLE_HANDLER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_MEMORY_LIST_INFORMATION {
   pub ZeroPageCount: ULONG_PTR,
   pub FreePageCount: ULONG_PTR,
   pub ModifiedPageCount: ULONG_PTR,
   pub ModifiedNoWritePageCount: ULONG_PTR,
   pub BadPageCount: ULONG_PTR,
   pub PageCountByPriority: [ULONG_PTR; 8usize],
   pub RepurposedPagesByPriority: [ULONG_PTR; 8usize],
   pub ModifiedPageCountPageFile: ULONG_PTR,
}
pub type SYSTEM_MEMORY_LIST_INFORMATION = _SYSTEM_MEMORY_LIST_INFORMATION;
pub type PSYSTEM_MEMORY_LIST_INFORMATION = *mut _SYSTEM_MEMORY_LIST_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_MEMORY_LIST_COMMAND {
   MemoryCaptureAccessedBits = 0,
   MemoryCaptureAndResetAccessedBits = 1,
   MemoryEmptyWorkingSets = 2,
   MemoryFlushModifiedList = 3,
   MemoryPurgeStandbyList = 4,
   MemoryPurgeLowPriorityStandbyList = 5,
   MemoryCommandMax = 6,
}
pub use self::_SYSTEM_MEMORY_LIST_COMMAND as SYSTEM_MEMORY_LIST_COMMAND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_THREAD_CID_PRIORITY_INFORMATION {
   pub ClientId: CLIENT_ID,
   pub Priority: KPRIORITY,
}
impl Default for _SYSTEM_THREAD_CID_PRIORITY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_THREAD_CID_PRIORITY_INFORMATION = _SYSTEM_THREAD_CID_PRIORITY_INFORMATION;
pub type PSYSTEM_THREAD_CID_PRIORITY_INFORMATION = *mut _SYSTEM_THREAD_CID_PRIORITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION {
   pub CycleTime: ULONGLONG,
}
pub type SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION =
   _SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION;
pub type PSYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION =
   *mut _SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_VERIFIER_ISSUE {
   pub IssueType: ULONGLONG,
   pub Address: PVOID,
   pub Parameters: [ULONGLONG; 2usize],
}
impl Default for _SYSTEM_VERIFIER_ISSUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_ISSUE = _SYSTEM_VERIFIER_ISSUE;
pub type PSYSTEM_VERIFIER_ISSUE = *mut _SYSTEM_VERIFIER_ISSUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_VERIFIER_CANCELLATION_INFORMATION {
   pub CancelProbability: ULONG,
   pub CancelThreshold: ULONG,
   pub CompletionThreshold: ULONG,
   pub CancellationVerifierDisabled: ULONG,
   pub AvailableIssues: ULONG,
   pub Issues: [SYSTEM_VERIFIER_ISSUE; 128usize],
}
impl Default for _SYSTEM_VERIFIER_CANCELLATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_CANCELLATION_INFORMATION = _SYSTEM_VERIFIER_CANCELLATION_INFORMATION;
pub type PSYSTEM_VERIFIER_CANCELLATION_INFORMATION = *mut _SYSTEM_VERIFIER_CANCELLATION_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_REF_TRACE_INFORMATION {
   pub TraceEnable: BOOLEAN,
   pub TracePermanent: BOOLEAN,
   pub TraceProcessName: UNICODE_STRING,
   pub TracePoolTags: UNICODE_STRING,
}
impl Default for _SYSTEM_REF_TRACE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_REF_TRACE_INFORMATION = _SYSTEM_REF_TRACE_INFORMATION;
pub type PSYSTEM_REF_TRACE_INFORMATION = *mut _SYSTEM_REF_TRACE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SPECIAL_POOL_INFORMATION {
   pub PoolTag: ULONG,
   pub Flags: ULONG,
}
pub type SYSTEM_SPECIAL_POOL_INFORMATION = _SYSTEM_SPECIAL_POOL_INFORMATION;
pub type PSYSTEM_SPECIAL_POOL_INFORMATION = *mut _SYSTEM_SPECIAL_POOL_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_PROCESS_ID_INFORMATION {
   pub ProcessId: HANDLE,
   pub ImageName: UNICODE_STRING,
}
impl Default for _SYSTEM_PROCESS_ID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESS_ID_INFORMATION = _SYSTEM_PROCESS_ID_INFORMATION;
pub type PSYSTEM_PROCESS_ID_INFORMATION = *mut _SYSTEM_PROCESS_ID_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_HYPERVISOR_QUERY_INFORMATION {
   pub HypervisorConnected: BOOLEAN,
   pub HypervisorDebuggingEnabled: BOOLEAN,
   pub HypervisorPresent: BOOLEAN,
   pub Spare0: [BOOLEAN; 5usize],
   pub EnabledEnlightenments: ULONGLONG,
}
impl Default for _SYSTEM_HYPERVISOR_QUERY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HYPERVISOR_QUERY_INFORMATION = _SYSTEM_HYPERVISOR_QUERY_INFORMATION;
pub type PSYSTEM_HYPERVISOR_QUERY_INFORMATION = *mut _SYSTEM_HYPERVISOR_QUERY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
   pub BootIdentifier: GUID,
   pub FirmwareType: FIRMWARE_TYPE,
   pub __bindgen_anon_1: _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1 {
   pub BootFlags: ULONGLONG,
   pub __bindgen_anon_1: _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
   pub __bindgen_padding_0: [u16; 3usize],
}
impl _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn DbgMenuOsSelection(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgMenuOsSelection(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgHiberBoot(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgHiberBoot(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgSoftBoot(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgSoftBoot(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgMeasuredLaunch(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgMeasuredLaunch(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgMeasuredLaunchCapable(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgMeasuredLaunchCapable(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgSystemHiveReplace(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgSystemHiveReplace(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgMeasuredLaunchSmmProtections(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgMeasuredLaunchSmmProtections(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgMeasuredLaunchSmmLevel(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 7u8) as u64) }
   }
   #[inline]
   pub fn set_DbgMeasuredLaunchSmmLevel(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DbgMenuOsSelection: ULONGLONG,
      DbgHiberBoot: ULONGLONG,
      DbgSoftBoot: ULONGLONG,
      DbgMeasuredLaunch: ULONGLONG,
      DbgMeasuredLaunchCapable: ULONGLONG,
      DbgSystemHiveReplace: ULONGLONG,
      DbgMeasuredLaunchSmmProtections: ULONGLONG,
      DbgMeasuredLaunchSmmLevel: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DbgMenuOsSelection: u64 = unsafe { ::core::mem::transmute(DbgMenuOsSelection) };
         DbgMenuOsSelection as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let DbgHiberBoot: u64 = unsafe { ::core::mem::transmute(DbgHiberBoot) };
         DbgHiberBoot as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let DbgSoftBoot: u64 = unsafe { ::core::mem::transmute(DbgSoftBoot) };
         DbgSoftBoot as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let DbgMeasuredLaunch: u64 = unsafe { ::core::mem::transmute(DbgMeasuredLaunch) };
         DbgMeasuredLaunch as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let DbgMeasuredLaunchCapable: u64 =
            unsafe { ::core::mem::transmute(DbgMeasuredLaunchCapable) };
         DbgMeasuredLaunchCapable as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let DbgSystemHiveReplace: u64 = unsafe { ::core::mem::transmute(DbgSystemHiveReplace) };
         DbgSystemHiveReplace as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let DbgMeasuredLaunchSmmProtections: u64 =
            unsafe { ::core::mem::transmute(DbgMeasuredLaunchSmmProtections) };
         DbgMeasuredLaunchSmmProtections as u64
      });
      __bindgen_bitfield_unit.set(7usize, 7u8, {
         let DbgMeasuredLaunchSmmLevel: u64 =
            unsafe { ::core::mem::transmute(DbgMeasuredLaunchSmmLevel) };
         DbgMeasuredLaunchSmmLevel as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BOOT_ENVIRONMENT_INFORMATION = _SYSTEM_BOOT_ENVIRONMENT_INFORMATION;
pub type PSYSTEM_BOOT_ENVIRONMENT_INFORMATION = *mut _SYSTEM_BOOT_ENVIRONMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION {
   pub FlagsToEnable: ULONG,
   pub FlagsToDisable: ULONG,
}
pub type SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION =
   _SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION;
pub type PSYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION =
   *mut _SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _COVERAGE_REQUEST_CODES {
   CoverageAllModules = 0,
   CoverageSearchByHash = 1,
   CoverageSearchByName = 2,
}
pub use self::_COVERAGE_REQUEST_CODES as COVERAGE_REQUEST_CODES;
#[repr(C)]
pub struct _COVERAGE_MODULE_REQUEST {
   pub RequestType: COVERAGE_REQUEST_CODES,
   pub SearchInfo: _COVERAGE_MODULE_REQUEST__bindgen_ty_1,
}
#[repr(C)]
pub union _COVERAGE_MODULE_REQUEST__bindgen_ty_1 {
   pub MD5Hash: ::core::mem::ManuallyDrop<[UCHAR; 16usize]>,
   pub ModuleName: ::core::mem::ManuallyDrop<UNICODE_STRING>,
}
impl Default for _COVERAGE_MODULE_REQUEST__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _COVERAGE_MODULE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COVERAGE_MODULE_REQUEST = _COVERAGE_MODULE_REQUEST;
pub type PCOVERAGE_MODULE_REQUEST = *mut _COVERAGE_MODULE_REQUEST;
#[repr(C)]
pub struct _COVERAGE_MODULE_INFO {
   pub ModuleInfoSize: ULONG,
   pub IsBinaryLoaded: ULONG,
   pub ModulePathName: UNICODE_STRING,
   pub CoverageSectionSize: ULONG,
   pub CoverageSection: [UCHAR; 1usize],
}
impl Default for _COVERAGE_MODULE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COVERAGE_MODULE_INFO = _COVERAGE_MODULE_INFO;
pub type PCOVERAGE_MODULE_INFO = *mut _COVERAGE_MODULE_INFO;
#[repr(C)]
pub struct _COVERAGE_MODULES {
   pub ListAndReset: ULONG,
   pub NumberOfModules: ULONG,
   pub ModuleRequestInfo: COVERAGE_MODULE_REQUEST,
   pub Modules: [COVERAGE_MODULE_INFO; 1usize],
}
impl Default for _COVERAGE_MODULES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COVERAGE_MODULES = _COVERAGE_MODULES;
pub type PCOVERAGE_MODULES = *mut _COVERAGE_MODULES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PREFETCH_PATCH_INFORMATION {
   pub PrefetchPatchCount: ULONG,
}
pub type SYSTEM_PREFETCH_PATCH_INFORMATION = _SYSTEM_PREFETCH_PATCH_INFORMATION;
pub type PSYSTEM_PREFETCH_PATCH_INFORMATION = *mut _SYSTEM_PREFETCH_PATCH_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_VERIFIER_FAULTS_INFORMATION {
   pub Probability: ULONG,
   pub MaxProbability: ULONG,
   pub PoolTags: UNICODE_STRING,
   pub Applications: UNICODE_STRING,
}
impl Default for _SYSTEM_VERIFIER_FAULTS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_FAULTS_INFORMATION = _SYSTEM_VERIFIER_FAULTS_INFORMATION;
pub type PSYSTEM_VERIFIER_FAULTS_INFORMATION = *mut _SYSTEM_VERIFIER_FAULTS_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_VERIFIER_INFORMATION_EX {
   pub VerifyMode: ULONG,
   pub OptionChanges: ULONG,
   pub PreviousBucketName: UNICODE_STRING,
   pub IrpCancelTimeoutMsec: ULONG,
   pub VerifierExtensionEnabled: ULONG,
   pub Reserved: [ULONG; 1usize],
}
impl Default for _SYSTEM_VERIFIER_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_INFORMATION_EX = _SYSTEM_VERIFIER_INFORMATION_EX;
pub type PSYSTEM_VERIFIER_INFORMATION_EX = *mut _SYSTEM_VERIFIER_INFORMATION_EX;
#[repr(C)]
pub struct _SYSTEM_SYSTEM_PARTITION_INFORMATION {
   pub SystemPartition: UNICODE_STRING,
}
impl Default for _SYSTEM_SYSTEM_PARTITION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SYSTEM_PARTITION_INFORMATION = _SYSTEM_SYSTEM_PARTITION_INFORMATION;
pub type PSYSTEM_SYSTEM_PARTITION_INFORMATION = *mut _SYSTEM_SYSTEM_PARTITION_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_SYSTEM_DISK_INFORMATION {
   pub SystemDisk: UNICODE_STRING,
}
impl Default for _SYSTEM_SYSTEM_DISK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SYSTEM_DISK_INFORMATION = _SYSTEM_SYSTEM_DISK_INFORMATION;
pub type PSYSTEM_SYSTEM_DISK_INFORMATION = *mut _SYSTEM_SYSTEM_DISK_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_NUMA_PROXIMITY_MAP {
   pub NodeProximityId: ULONG,
   pub NodeNumber: USHORT,
}
pub type SYSTEM_NUMA_PROXIMITY_MAP = _SYSTEM_NUMA_PROXIMITY_MAP;
pub type PSYSTEM_NUMA_PROXIMITY_MAP = *mut _SYSTEM_NUMA_PROXIMITY_MAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT {
   pub Hits: ULONGLONG,
   pub PercentFrequency: UCHAR,
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT = _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT = *mut _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8 {
   pub Hits: ULONG,
   pub PercentFrequency: UCHAR,
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8 = _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8 =
   *mut _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION {
   pub ProcessorNumber: ULONG,
   pub StateCount: ULONG,
   pub States: [SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT; 1usize],
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION =
   _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION =
   *mut _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION {
   pub ProcessorCount: ULONG,
   pub Offsets: [ULONG; 1usize],
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION = _SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION =
   *mut _SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITY_INFORMATION {
   pub Length: ULONG,
   pub CodeIntegrityOptions: ULONG,
}
pub type SYSTEM_CODEINTEGRITY_INFORMATION = _SYSTEM_CODEINTEGRITY_INFORMATION;
pub type PSYSTEM_CODEINTEGRITY_INFORMATION = *mut _SYSTEM_CODEINTEGRITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION {
   pub Operation: ULONG,
}
pub type SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION =
   _SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION;
pub type PSYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION =
   *mut _SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_VA_TYPE {
   SystemVaTypeAll = 0,
   SystemVaTypeNonPagedPool = 1,
   SystemVaTypePagedPool = 2,
   SystemVaTypeSystemCache = 3,
   SystemVaTypeSystemPtes = 4,
   SystemVaTypeSessionSpace = 5,
   SystemVaTypeMax = 6,
}
pub use self::_SYSTEM_VA_TYPE as SYSTEM_VA_TYPE;
pub type PSYSTEM_VA_TYPE = *mut _SYSTEM_VA_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_VA_LIST_INFORMATION {
   pub VirtualSize: SIZE_T,
   pub VirtualPeak: SIZE_T,
   pub VirtualLimit: SIZE_T,
   pub AllocationFailures: SIZE_T,
}
pub type SYSTEM_VA_LIST_INFORMATION = _SYSTEM_VA_LIST_INFORMATION;
pub type PSYSTEM_VA_LIST_INFORMATION = *mut _SYSTEM_VA_LIST_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORE_INFORMATION_CLASS {
   StorePageRequest = 1,
   StoreStatsRequest = 2,
   StoreCreateRequest = 3,
   StoreDeleteRequest = 4,
   StoreListRequest = 5,
   Available1 = 6,
   StoreEmptyRequest = 7,
   CacheListRequest = 8,
   CacheCreateRequest = 9,
   CacheDeleteRequest = 10,
   CacheStoreCreateRequest = 11,
   CacheStoreDeleteRequest = 12,
   CacheStatsRequest = 13,
   Available2 = 14,
   RegistrationRequest = 15,
   GlobalCacheStatsRequest = 16,
   StoreResizeRequest = 17,
   CacheStoreResizeRequest = 18,
   SmConfigRequest = 19,
   StoreHighMemoryPriorityRequest = 20,
   SystemStoreTrimRequest = 21,
   MemCompressionInfoRequest = 22,
   ProcessStoreInfoRequest = 23,
   StoreInformationMax = 24,
}
pub use self::_STORE_INFORMATION_CLASS as STORE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_STORE_INFORMATION {
   pub Version: ULONG,
   pub StoreInformationClass: STORE_INFORMATION_CLASS,
   pub Data: PVOID,
   pub Length: ULONG,
}
impl Default for _SYSTEM_STORE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_STORE_INFORMATION = _SYSTEM_STORE_INFORMATION;
pub type PSYSTEM_STORE_INFORMATION = *mut _SYSTEM_STORE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ST_STATS_LEVEL {
   StStatsLevelBasic = 0,
   StStatsLevelIoStats = 1,
   StStatsLevelRegionSpace = 2,
   StStatsLevelSpaceBitmap = 3,
   StStatsLevelMax = 4,
}
pub use self::_ST_STATS_LEVEL as ST_STATS_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_STATS_REQUEST {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub BufferSize: ULONG,
   pub Buffer: PVOID,
}
impl Default for _SM_STATS_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SM_STATS_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn DetailLevel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_DetailLevel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn StoreId(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_StoreId(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      DetailLevel: ULONG,
      StoreId: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 8u8, {
         let DetailLevel: u32 = unsafe { ::core::mem::transmute(DetailLevel) };
         DetailLevel as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let StoreId: u32 = unsafe { ::core::mem::transmute(StoreId) };
         StoreId as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_STATS_REQUEST = _SM_STATS_REQUEST;
pub type PSM_STATS_REQUEST = *mut _SM_STATS_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_DATA_MGR_STATS {
   pub RegionCount: ULONG,
   pub PagesStored: ULONG,
   pub UniquePagesStored: ULONG,
   pub LazyCleanupRegionCount: ULONG,
   pub Space: [_ST_DATA_MGR_STATS__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_DATA_MGR_STATS__bindgen_ty_1 {
   pub RegionsInUse: ULONG,
   pub SpaceUsed: ULONG,
}
pub type ST_DATA_MGR_STATS = _ST_DATA_MGR_STATS;
pub type PST_DATA_MGR_STATS = *mut _ST_DATA_MGR_STATS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_IO_STATS_PERIOD {
   pub PageCounts: [ULONG; 5usize],
}
pub type ST_IO_STATS_PERIOD = _ST_IO_STATS_PERIOD;
pub type PST_IO_STATS_PERIOD = *mut _ST_IO_STATS_PERIOD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_IO_STATS {
   pub PeriodCount: ULONG,
   pub Periods: [ST_IO_STATS_PERIOD; 64usize],
}
impl Default for _ST_IO_STATS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ST_IO_STATS = _ST_IO_STATS;
pub type PST_IO_STATS = *mut _ST_IO_STATS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_READ_LATENCY_BUCKET {
   pub LatencyUs: ULONG,
   pub Count: ULONG,
}
pub type ST_READ_LATENCY_BUCKET = _ST_READ_LATENCY_BUCKET;
pub type PST_READ_LATENCY_BUCKET = *mut _ST_READ_LATENCY_BUCKET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_READ_LATENCY_STATS {
   pub Buckets: [ST_READ_LATENCY_BUCKET; 8usize],
}
pub type ST_READ_LATENCY_STATS = _ST_READ_LATENCY_STATS;
pub type PST_READ_LATENCY_STATS = *mut _ST_READ_LATENCY_STATS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_STATS_REGION_INFO {
   pub SpaceUsed: USHORT,
   pub Priority: UCHAR,
   pub Spare: UCHAR,
}
pub type ST_STATS_REGION_INFO = _ST_STATS_REGION_INFO;
pub type PST_STATS_REGION_INFO = *mut _ST_STATS_REGION_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_STATS_SPACE_BITMAP {
   pub CompressedBytes: SIZE_T,
   pub BytesPerBit: ULONG,
   pub StoreBitmap: [UCHAR; 1usize],
}
pub type ST_STATS_SPACE_BITMAP = _ST_STATS_SPACE_BITMAP;
pub type PST_STATS_SPACE_BITMAP = *mut _ST_STATS_SPACE_BITMAP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_STATS {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub Size: ULONG,
   pub CompressionFormat: USHORT,
   pub Spare: USHORT,
   pub Basic: _ST_STATS__bindgen_ty_1,
   pub Io: _ST_STATS__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_STATS__bindgen_ty_1 {
   pub RegionSize: ULONG,
   pub RegionCount: ULONG,
   pub RegionCountMax: ULONG,
   pub Granularity: ULONG,
   pub UserData: ST_DATA_MGR_STATS,
   pub Metadata: ST_DATA_MGR_STATS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_STATS__bindgen_ty_2 {
   pub IoStats: ST_IO_STATS,
   pub ReadLatencyStats: ST_READ_LATENCY_STATS,
}
impl Default for _ST_STATS__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ST_STATS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _ST_STATS {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Level(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Level(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn StoreType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_StoreType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn NoDuplication(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoDuplication(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn NoCompression(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoCompression(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EncryptionStrength(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 12u8) as u32) }
   }
   #[inline]
   pub fn set_EncryptionStrength(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub fn VirtualRegions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualRegions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(30usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare0(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Spare0(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      Level: ULONG,
      StoreType: ULONG,
      NoDuplication: ULONG,
      NoCompression: ULONG,
      EncryptionStrength: ULONG,
      VirtualRegions: ULONG,
      Spare0: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 4u8, {
         let Level: u32 = unsafe { ::core::mem::transmute(Level) };
         Level as u64
      });
      __bindgen_bitfield_unit.set(12usize, 4u8, {
         let StoreType: u32 = unsafe { ::core::mem::transmute(StoreType) };
         StoreType as u64
      });
      __bindgen_bitfield_unit.set(16usize, 1u8, {
         let NoDuplication: u32 = unsafe { ::core::mem::transmute(NoDuplication) };
         NoDuplication as u64
      });
      __bindgen_bitfield_unit.set(17usize, 1u8, {
         let NoCompression: u32 = unsafe { ::core::mem::transmute(NoCompression) };
         NoCompression as u64
      });
      __bindgen_bitfield_unit.set(18usize, 12u8, {
         let EncryptionStrength: u32 = unsafe { ::core::mem::transmute(EncryptionStrength) };
         EncryptionStrength as u64
      });
      __bindgen_bitfield_unit.set(30usize, 1u8, {
         let VirtualRegions: u32 = unsafe { ::core::mem::transmute(VirtualRegions) };
         VirtualRegions as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let Spare0: u32 = unsafe { ::core::mem::transmute(Spare0) };
         Spare0 as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type ST_STATS = _ST_STATS;
pub type PST_STATS = *mut _ST_STATS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SM_STORE_TYPE {
   StoreTypeInMemory = 0,
   StoreTypeFile = 1,
   StoreTypeMax = 2,
}
pub use self::_SM_STORE_TYPE as SM_STORE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SM_STORE_BASIC_PARAMS {
   pub __bindgen_anon_1: _SM_STORE_BASIC_PARAMS__bindgen_ty_1,
   pub Granularity: ULONG,
   pub RegionSize: ULONG,
   pub RegionCountMax: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SM_STORE_BASIC_PARAMS__bindgen_ty_1 {
   pub __bindgen_anon_1: _SM_STORE_BASIC_PARAMS__bindgen_ty_1__bindgen_ty_1,
   pub StoreFlags: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_STORE_BASIC_PARAMS__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SM_STORE_BASIC_PARAMS__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn StoreType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_StoreType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn NoDuplication(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoDuplication(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn FailNoCompression(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FailNoCompression(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn NoCompression(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoCompression(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn NoEncryption(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoEncryption(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn NoEvictOnAdd(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoEvictOnAdd(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn PerformsFileIo(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PerformsFileIo(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VdlNotSet(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VdlNotSet(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn UseIntermediateAddBuffer(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UseIntermediateAddBuffer(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CompressNoHuff(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CompressNoHuff(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LockActiveRegions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LockActiveRegions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VirtualRegions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualRegions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(19usize, 13u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      StoreType: ULONG,
      NoDuplication: ULONG,
      FailNoCompression: ULONG,
      NoCompression: ULONG,
      NoEncryption: ULONG,
      NoEvictOnAdd: ULONG,
      PerformsFileIo: ULONG,
      VdlNotSet: ULONG,
      UseIntermediateAddBuffer: ULONG,
      CompressNoHuff: ULONG,
      LockActiveRegions: ULONG,
      VirtualRegions: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let StoreType: u32 = unsafe { ::core::mem::transmute(StoreType) };
         StoreType as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let NoDuplication: u32 = unsafe { ::core::mem::transmute(NoDuplication) };
         NoDuplication as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let FailNoCompression: u32 = unsafe { ::core::mem::transmute(FailNoCompression) };
         FailNoCompression as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let NoCompression: u32 = unsafe { ::core::mem::transmute(NoCompression) };
         NoCompression as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let NoEncryption: u32 = unsafe { ::core::mem::transmute(NoEncryption) };
         NoEncryption as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let NoEvictOnAdd: u32 = unsafe { ::core::mem::transmute(NoEvictOnAdd) };
         NoEvictOnAdd as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let PerformsFileIo: u32 = unsafe { ::core::mem::transmute(PerformsFileIo) };
         PerformsFileIo as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let VdlNotSet: u32 = unsafe { ::core::mem::transmute(VdlNotSet) };
         VdlNotSet as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let UseIntermediateAddBuffer: u32 =
            unsafe { ::core::mem::transmute(UseIntermediateAddBuffer) };
         UseIntermediateAddBuffer as u64
      });
      __bindgen_bitfield_unit.set(16usize, 1u8, {
         let CompressNoHuff: u32 = unsafe { ::core::mem::transmute(CompressNoHuff) };
         CompressNoHuff as u64
      });
      __bindgen_bitfield_unit.set(17usize, 1u8, {
         let LockActiveRegions: u32 = unsafe { ::core::mem::transmute(LockActiveRegions) };
         LockActiveRegions as u64
      });
      __bindgen_bitfield_unit.set(18usize, 1u8, {
         let VirtualRegions: u32 = unsafe { ::core::mem::transmute(VirtualRegions) };
         VirtualRegions as u64
      });
      __bindgen_bitfield_unit.set(19usize, 13u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SM_STORE_BASIC_PARAMS__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SM_STORE_BASIC_PARAMS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SM_STORE_BASIC_PARAMS = _SM_STORE_BASIC_PARAMS;
pub type PSM_STORE_BASIC_PARAMS = *mut _SM_STORE_BASIC_PARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SMKM_REGION_EXTENT {
   pub RegionCount: ULONG,
   pub ByteOffset: SIZE_T,
}
pub type SMKM_REGION_EXTENT = _SMKM_REGION_EXTENT;
pub type PSMKM_REGION_EXTENT = *mut _SMKM_REGION_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_OBJECT {
   _unused: [u8; 0],
}
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT {
   _unused: [u8; 0],
}
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IRP {
   _unused: [u8; 0],
}
pub type PIRP = *mut _IRP;
pub type PRTL_BITMAP = *mut _RTL_BITMAP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMKM_FILE_INFO {
   pub FileHandle: HANDLE,
   pub FileObject: PFILE_OBJECT,
   pub VolumeFileObject: PFILE_OBJECT,
   pub VolumeDeviceObject: PDEVICE_OBJECT,
   pub VolumePnpHandle: HANDLE,
   pub UsageNotificationIrp: PIRP,
   pub Extents: PSMKM_REGION_EXTENT,
   pub ExtentCount: ULONG,
}
impl Default for _SMKM_FILE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SMKM_FILE_INFO = _SMKM_FILE_INFO;
pub type PSMKM_FILE_INFO = *mut _SMKM_FILE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_STORE_CACHE_BACKED_PARAMS {
   pub SectorSize: ULONG,
   pub EncryptionKey: PCHAR,
   pub EncryptionKeySize: ULONG,
   pub FileInfo: PSMKM_FILE_INFO,
   pub EtaContext: PVOID,
   pub StoreRegionBitmap: PRTL_BITMAP,
}
impl Default for _SM_STORE_CACHE_BACKED_PARAMS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SM_STORE_CACHE_BACKED_PARAMS = _SM_STORE_CACHE_BACKED_PARAMS;
pub type PSM_STORE_CACHE_BACKED_PARAMS = *mut _SM_STORE_CACHE_BACKED_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SM_STORE_PARAMETERS {
   pub Store: SM_STORE_BASIC_PARAMS,
   pub Priority: ULONG,
   pub Flags: ULONG,
   pub CacheBacked: SM_STORE_CACHE_BACKED_PARAMS,
}
impl Default for _SM_STORE_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SM_STORE_PARAMETERS = _SM_STORE_PARAMETERS;
pub type PSM_STORE_PARAMETERS = *mut _SM_STORE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SM_CREATE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub Params: SM_STORE_PARAMETERS,
   pub StoreId: ULONG,
}
impl Default for _SM_CREATE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SM_CREATE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn AcquireReference(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AcquireReference(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KeyedStore(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KeyedStore(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 22u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      AcquireReference: ULONG,
      KeyedStore: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let AcquireReference: u32 = unsafe { ::core::mem::transmute(AcquireReference) };
         AcquireReference as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let KeyedStore: u32 = unsafe { ::core::mem::transmute(KeyedStore) };
         KeyedStore as u64
      });
      __bindgen_bitfield_unit.set(10usize, 22u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_CREATE_REQUEST = _SM_CREATE_REQUEST;
pub type PSM_CREATE_REQUEST = *mut _SM_CREATE_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_DELETE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub StoreId: ULONG,
}
impl _SM_DELETE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_DELETE_REQUEST = _SM_DELETE_REQUEST;
pub type PSM_DELETE_REQUEST = *mut _SM_DELETE_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_STORE_LIST_REQUEST {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub StoreId: [ULONG; 32usize],
}
impl _SM_STORE_LIST_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn StoreCount(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_StoreCount(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn ExtendedRequest(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ExtendedRequest(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 15u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      StoreCount: ULONG,
      ExtendedRequest: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 8u8, {
         let StoreCount: u32 = unsafe { ::core::mem::transmute(StoreCount) };
         StoreCount as u64
      });
      __bindgen_bitfield_unit.set(16usize, 1u8, {
         let ExtendedRequest: u32 = unsafe { ::core::mem::transmute(ExtendedRequest) };
         ExtendedRequest as u64
      });
      __bindgen_bitfield_unit.set(17usize, 15u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_STORE_LIST_REQUEST = _SM_STORE_LIST_REQUEST;
pub type PSM_STORE_LIST_REQUEST = *mut _SM_STORE_LIST_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_STORE_LIST_REQUEST_EX {
   pub Request: SM_STORE_LIST_REQUEST,
   pub NameBuffer: [[WCHAR; 64usize]; 32usize],
}
impl Default for _SM_STORE_LIST_REQUEST_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SM_STORE_LIST_REQUEST_EX = _SM_STORE_LIST_REQUEST_EX;
pub type PSM_STORE_LIST_REQUEST_EX = *mut _SM_STORE_LIST_REQUEST_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SMC_CACHE_LIST_REQUEST {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: [ULONG; 16usize],
}
impl _SMC_CACHE_LIST_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn CacheCount(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_CacheCount(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      CacheCount: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 8u8, {
         let CacheCount: u32 = unsafe { ::core::mem::transmute(CacheCount) };
         CacheCount as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_LIST_REQUEST = _SMC_CACHE_LIST_REQUEST;
pub type PSMC_CACHE_LIST_REQUEST = *mut _SMC_CACHE_LIST_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SMC_CACHE_PARAMETERS {
   pub CacheFileSize: SIZE_T,
   pub StoreAlignment: ULONG,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheFlags: ULONG,
   pub Priority: ULONG,
}
impl _SMC_CACHE_PARAMETERS {
   #[inline]
   pub fn PerformsFileIo(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PerformsFileIo(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VdlNotSet(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VdlNotSet(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      PerformsFileIo: ULONG,
      VdlNotSet: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let PerformsFileIo: u32 = unsafe { ::core::mem::transmute(PerformsFileIo) };
         PerformsFileIo as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let VdlNotSet: u32 = unsafe { ::core::mem::transmute(VdlNotSet) };
         VdlNotSet as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_PARAMETERS = _SMC_CACHE_PARAMETERS;
pub type PSMC_CACHE_PARAMETERS = *mut _SMC_CACHE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_CACHE_CREATE_PARAMETERS {
   pub CacheParameters: SMC_CACHE_PARAMETERS,
   pub TemplateFilePath: [WCHAR; 512usize],
}
impl Default for _SMC_CACHE_CREATE_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SMC_CACHE_CREATE_PARAMETERS = _SMC_CACHE_CREATE_PARAMETERS;
pub type PSMC_CACHE_CREATE_PARAMETERS = *mut _SMC_CACHE_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_CACHE_CREATE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: ULONG,
   pub CacheCreateParams: SMC_CACHE_CREATE_PARAMETERS,
}
impl Default for _SMC_CACHE_CREATE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_CACHE_CREATE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_CREATE_REQUEST = _SMC_CACHE_CREATE_REQUEST;
pub type PSMC_CACHE_CREATE_REQUEST = *mut _SMC_CACHE_CREATE_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SMC_CACHE_DELETE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: ULONG,
}
impl _SMC_CACHE_DELETE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_DELETE_REQUEST = _SMC_CACHE_DELETE_REQUEST;
pub type PSMC_CACHE_DELETE_REQUEST = *mut _SMC_CACHE_DELETE_REQUEST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SM_STORE_MANAGER_TYPE {
   SmStoreManagerTypePhysical = 0,
   SmStoreManagerTypeVirtual = 1,
   SmStoreManagerTypeMax = 2,
}
pub use self::_SM_STORE_MANAGER_TYPE as SM_STORE_MANAGER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SMC_STORE_CREATE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub StoreParams: SM_STORE_BASIC_PARAMS,
   pub CacheId: ULONG,
   pub StoreManagerType: SM_STORE_MANAGER_TYPE,
   pub StoreId: ULONG,
}
impl Default for _SMC_STORE_CREATE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_STORE_CREATE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_STORE_CREATE_REQUEST = _SMC_STORE_CREATE_REQUEST;
pub type PSMC_STORE_CREATE_REQUEST = *mut _SMC_STORE_CREATE_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_STORE_DELETE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: ULONG,
   pub StoreManagerType: SM_STORE_MANAGER_TYPE,
   pub StoreId: ULONG,
}
impl Default for _SMC_STORE_DELETE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_STORE_DELETE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_STORE_DELETE_REQUEST = _SMC_STORE_DELETE_REQUEST;
pub type PSMC_STORE_DELETE_REQUEST = *mut _SMC_STORE_DELETE_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_CACHE_STATS {
   pub TotalFileSize: SIZE_T,
   pub StoreCount: ULONG,
   pub RegionCount: ULONG,
   pub RegionSizeBytes: ULONG,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub StoreIds: [ULONG; 16usize],
   pub PhysicalStoreBitmap: ULONG,
   pub Priority: ULONG,
   pub TemplateFilePath: [WCHAR; 512usize],
}
impl Default for _SMC_CACHE_STATS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_CACHE_STATS {
   #[inline]
   pub fn FileCount(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_FileCount(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub fn PerformsFileIo(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PerformsFileIo(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 25u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      FileCount: ULONG,
      PerformsFileIo: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 6u8, {
         let FileCount: u32 = unsafe { ::core::mem::transmute(FileCount) };
         FileCount as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let PerformsFileIo: u32 = unsafe { ::core::mem::transmute(PerformsFileIo) };
         PerformsFileIo as u64
      });
      __bindgen_bitfield_unit.set(7usize, 25u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_STATS = _SMC_CACHE_STATS;
pub type PSMC_CACHE_STATS = *mut _SMC_CACHE_STATS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_CACHE_STATS_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: ULONG,
   pub CacheStats: SMC_CACHE_STATS,
}
impl Default for _SMC_CACHE_STATS_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_CACHE_STATS_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn NoFilePath(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoFilePath(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 23u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      NoFilePath: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let NoFilePath: u32 = unsafe { ::core::mem::transmute(NoFilePath) };
         NoFilePath as u64
      });
      __bindgen_bitfield_unit.set(9usize, 23u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_STATS_REQUEST = _SMC_CACHE_STATS_REQUEST;
pub type PSMC_CACHE_STATS_REQUEST = *mut _SMC_CACHE_STATS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_REGISTRATION_INFO {
   pub CachesUpdatedEvent: HANDLE,
}
impl Default for _SM_REGISTRATION_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SM_REGISTRATION_INFO = _SM_REGISTRATION_INFO;
pub type PSM_REGISTRATION_INFO = *mut _SM_REGISTRATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_REGISTRATION_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub RegInfo: SM_REGISTRATION_INFO,
}
impl Default for _SM_REGISTRATION_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SM_REGISTRATION_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_REGISTRATION_REQUEST = _SM_REGISTRATION_REQUEST;
pub type PSM_REGISTRATION_REQUEST = *mut _SM_REGISTRATION_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_STORE_RESIZE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub StoreId: ULONG,
   pub NumberOfRegions: ULONG,
   pub RegionBitmap: PRTL_BITMAP,
}
impl Default for _SM_STORE_RESIZE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SM_STORE_RESIZE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn AddRegions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AddRegions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 23u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      AddRegions: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let AddRegions: u32 = unsafe { ::core::mem::transmute(AddRegions) };
         AddRegions as u64
      });
      __bindgen_bitfield_unit.set(9usize, 23u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_STORE_RESIZE_REQUEST = _SM_STORE_RESIZE_REQUEST;
pub type PSM_STORE_RESIZE_REQUEST = *mut _SM_STORE_RESIZE_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_STORE_RESIZE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: ULONG,
   pub StoreId: ULONG,
   pub StoreManagerType: SM_STORE_MANAGER_TYPE,
   pub RegionCount: ULONG,
}
impl Default for _SMC_STORE_RESIZE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_STORE_RESIZE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn AddRegions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AddRegions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 23u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      AddRegions: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let AddRegions: u32 = unsafe { ::core::mem::transmute(AddRegions) };
         AddRegions as u64
      });
      __bindgen_bitfield_unit.set(9usize, 23u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_STORE_RESIZE_REQUEST = _SMC_STORE_RESIZE_REQUEST;
pub type PSMC_STORE_RESIZE_REQUEST = *mut _SMC_STORE_RESIZE_REQUEST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SM_CONFIG_TYPE {
   SmConfigDirtyPageCompression = 0,
   SmConfigAsyncInswap = 1,
   SmConfigPrefetchSeekThreshold = 2,
   SmConfigTypeMax = 3,
}
pub use self::_SM_CONFIG_TYPE as SM_CONFIG_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_CONFIG_REQUEST {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub ConfigValue: ULONG,
}
impl _SM_CONFIG_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn ConfigType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_ConfigType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      Spare: ULONG,
      ConfigType: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 16u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit.set(24usize, 8u8, {
         let ConfigType: u32 = unsafe { ::core::mem::transmute(ConfigType) };
         ConfigType as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_CONFIG_REQUEST = _SM_CONFIG_REQUEST;
pub type PSM_CONFIG_REQUEST = *mut _SM_CONFIG_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_STORE_HIGH_MEM_PRIORITY_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub ProcessHandle: HANDLE,
}
impl Default for _SM_STORE_HIGH_MEM_PRIORITY_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SM_STORE_HIGH_MEM_PRIORITY_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn SetHighMemoryPriority(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SetHighMemoryPriority(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 23u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      SetHighMemoryPriority: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let SetHighMemoryPriority: u32 = unsafe { ::core::mem::transmute(SetHighMemoryPriority) };
         SetHighMemoryPriority as u64
      });
      __bindgen_bitfield_unit.set(9usize, 23u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_STORE_HIGH_MEM_PRIORITY_REQUEST = _SM_STORE_HIGH_MEM_PRIORITY_REQUEST;
pub type PSM_STORE_HIGH_MEM_PRIORITY_REQUEST = *mut _SM_STORE_HIGH_MEM_PRIORITY_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_SYSTEM_STORE_TRIM_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub PagesToTrim: SIZE_T,
}
impl _SM_SYSTEM_STORE_TRIM_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_SYSTEM_STORE_TRIM_REQUEST = _SM_SYSTEM_STORE_TRIM_REQUEST;
pub type PSM_SYSTEM_STORE_TRIM_REQUEST = *mut _SM_SYSTEM_STORE_TRIM_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_MEM_COMPRESSION_INFO_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CompressionPid: ULONG,
   pub WorkingSetSize: ULONG,
   pub TotalDataCompressed: SIZE_T,
   pub TotalCompressedSize: SIZE_T,
   pub TotalUniqueDataCompressed: SIZE_T,
}
impl _SM_MEM_COMPRESSION_INFO_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_MEM_COMPRESSION_INFO_REQUEST = _SM_MEM_COMPRESSION_INFO_REQUEST;
pub type PSM_MEM_COMPRESSION_INFO_REQUEST = *mut _SM_MEM_COMPRESSION_INFO_REQUEST;
#[repr(C)]
pub struct _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS {
   pub KeyHandle: HANDLE,
   pub ValueNamePointer: PUNICODE_STRING,
   pub RequiredLengthPointer: PULONG,
   pub Buffer: PUCHAR,
   pub BufferLength: ULONG,
   pub Type: ULONG,
   pub AppendBuffer: PUCHAR,
   pub AppendBufferLength: ULONG,
   pub CreateIfDoesntExist: BOOLEAN,
   pub TruncateExistingValue: BOOLEAN,
}
impl Default for _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS = _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS;
pub type PSYSTEM_REGISTRY_APPEND_STRING_PARAMETERS = *mut _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS;
#[repr(C)]
pub struct _SYSTEM_VHD_BOOT_INFORMATION {
   pub OsDiskIsVhd: BOOLEAN,
   pub OsVhdFilePathOffset: ULONG,
   pub OsVhdParentVolume: [WCHAR; 1usize],
}
impl Default for _SYSTEM_VHD_BOOT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VHD_BOOT_INFORMATION = _SYSTEM_VHD_BOOT_INFORMATION;
pub type PSYSTEM_VHD_BOOT_INFORMATION = *mut _SYSTEM_VHD_BOOT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_CPU_QUOTA_QUERY_ENTRY {
   pub SessionId: ULONG,
   pub Weight: ULONG,
}
pub type PS_CPU_QUOTA_QUERY_ENTRY = _PS_CPU_QUOTA_QUERY_ENTRY;
pub type PPS_CPU_QUOTA_QUERY_ENTRY = *mut _PS_CPU_QUOTA_QUERY_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_CPU_QUOTA_QUERY_INFORMATION {
   pub SessionCount: ULONG,
   pub SessionInformation: [PS_CPU_QUOTA_QUERY_ENTRY; 1usize],
}
pub type PS_CPU_QUOTA_QUERY_INFORMATION = _PS_CPU_QUOTA_QUERY_INFORMATION;
pub type PPS_CPU_QUOTA_QUERY_INFORMATION = *mut _PS_CPU_QUOTA_QUERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_ERROR_PORT_TIMEOUTS {
   pub StartTimeout: ULONG,
   pub CommTimeout: ULONG,
}
pub type SYSTEM_ERROR_PORT_TIMEOUTS = _SYSTEM_ERROR_PORT_TIMEOUTS;
pub type PSYSTEM_ERROR_PORT_TIMEOUTS = *mut _SYSTEM_ERROR_PORT_TIMEOUTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_LOW_PRIORITY_IO_INFORMATION {
   pub LowPriReadOperations: ULONG,
   pub LowPriWriteOperations: ULONG,
   pub KernelBumpedToNormalOperations: ULONG,
   pub LowPriPagingReadOperations: ULONG,
   pub KernelPagingReadsBumpedToNormal: ULONG,
   pub LowPriPagingWriteOperations: ULONG,
   pub KernelPagingWritesBumpedToNormal: ULONG,
   pub BoostedIrpCount: ULONG,
   pub BoostedPagingIrpCount: ULONG,
   pub BlanketBoostCount: ULONG,
}
pub type SYSTEM_LOW_PRIORITY_IO_INFORMATION = _SYSTEM_LOW_PRIORITY_IO_INFORMATION;
pub type PSYSTEM_LOW_PRIORITY_IO_INFORMATION = *mut _SYSTEM_LOW_PRIORITY_IO_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TPM_BOOT_ENTROPY_RESULT_CODE {
   TpmBootEntropyStructureUninitialized = 0,
   TpmBootEntropyDisabledByPolicy = 1,
   TpmBootEntropyNoTpmFound = 2,
   TpmBootEntropyTpmError = 3,
   TpmBootEntropySuccess = 4,
}
pub use self::_TPM_BOOT_ENTROPY_RESULT_CODE as TPM_BOOT_ENTROPY_RESULT_CODE;
#[repr(C)]
pub struct _TPM_BOOT_ENTROPY_NT_RESULT {
   pub Policy: ULONGLONG,
   pub ResultCode: TPM_BOOT_ENTROPY_RESULT_CODE,
   pub ResultStatus: NTSTATUS,
   pub Time: ULONGLONG,
   pub EntropyLength: ULONG,
   pub EntropyData: [UCHAR; 40usize],
}
impl Default for _TPM_BOOT_ENTROPY_NT_RESULT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TPM_BOOT_ENTROPY_NT_RESULT = _TPM_BOOT_ENTROPY_NT_RESULT;
pub type PTPM_BOOT_ENTROPY_NT_RESULT = *mut _TPM_BOOT_ENTROPY_NT_RESULT;
#[repr(C)]
pub struct _SYSTEM_VERIFIER_COUNTERS_INFORMATION {
   pub Legacy: SYSTEM_VERIFIER_INFORMATION,
   pub RaiseIrqls: ULONG,
   pub AcquireSpinLocks: ULONG,
   pub SynchronizeExecutions: ULONG,
   pub AllocationsWithNoTag: ULONG,
   pub AllocationsFailed: ULONG,
   pub AllocationsFailedDeliberately: ULONG,
   pub LockedBytes: SIZE_T,
   pub PeakLockedBytes: SIZE_T,
   pub MappedLockedBytes: SIZE_T,
   pub PeakMappedLockedBytes: SIZE_T,
   pub MappedIoSpaceBytes: SIZE_T,
   pub PeakMappedIoSpaceBytes: SIZE_T,
   pub PagesForMdlBytes: SIZE_T,
   pub PeakPagesForMdlBytes: SIZE_T,
   pub ContiguousMemoryBytes: SIZE_T,
   pub PeakContiguousMemoryBytes: SIZE_T,
   pub ExecutePoolTypes: ULONG,
   pub ExecutePageProtections: ULONG,
   pub ExecutePageMappings: ULONG,
   pub ExecuteWriteSections: ULONG,
   pub SectionAlignmentFailures: ULONG,
   pub UnsupportedRelocs: ULONG,
   pub IATInExecutableSection: ULONG,
}
impl Default for _SYSTEM_VERIFIER_COUNTERS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_COUNTERS_INFORMATION = _SYSTEM_VERIFIER_COUNTERS_INFORMATION;
pub type PSYSTEM_VERIFIER_COUNTERS_INFORMATION = *mut _SYSTEM_VERIFIER_COUNTERS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_ACPI_AUDIT_INFORMATION {
   pub RsdpCount: ULONG,
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _SYSTEM_ACPI_AUDIT_INFORMATION {
   #[inline]
   pub fn SameRsdt(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SameRsdt(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SlicPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SlicPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SlicDifferent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SlicDifferent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SameRsdt: ULONG,
      SlicPresent: ULONG,
      SlicDifferent: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SameRsdt: u32 = unsafe { ::core::mem::transmute(SameRsdt) };
         SameRsdt as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let SlicPresent: u32 = unsafe { ::core::mem::transmute(SlicPresent) };
         SlicPresent as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let SlicDifferent: u32 = unsafe { ::core::mem::transmute(SlicDifferent) };
         SlicDifferent as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SYSTEM_ACPI_AUDIT_INFORMATION = _SYSTEM_ACPI_AUDIT_INFORMATION;
pub type PSYSTEM_ACPI_AUDIT_INFORMATION = *mut _SYSTEM_ACPI_AUDIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BASIC_PERFORMANCE_INFORMATION {
   pub AvailablePages: SIZE_T,
   pub CommittedPages: SIZE_T,
   pub CommitLimit: SIZE_T,
   pub PeakCommitment: SIZE_T,
}
pub type SYSTEM_BASIC_PERFORMANCE_INFORMATION = _SYSTEM_BASIC_PERFORMANCE_INFORMATION;
pub type PSYSTEM_BASIC_PERFORMANCE_INFORMATION = *mut _SYSTEM_BASIC_PERFORMANCE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUERY_PERFORMANCE_COUNTER_FLAGS {
   pub __bindgen_anon_1: _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1 {
   pub __bindgen_anon_1: _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1__bindgen_ty_1,
   pub ul: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn KernelTransition(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KernelTransition(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      KernelTransition: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let KernelTransition: u32 = unsafe { ::core::mem::transmute(KernelTransition) };
         KernelTransition as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _QUERY_PERFORMANCE_COUNTER_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type QUERY_PERFORMANCE_COUNTER_FLAGS = _QUERY_PERFORMANCE_COUNTER_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION {
   pub Version: ULONG,
   pub Flags: QUERY_PERFORMANCE_COUNTER_FLAGS,
   pub ValidFlags: QUERY_PERFORMANCE_COUNTER_FLAGS,
}
impl Default for _SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION =
   _SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION;
pub type PSYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION =
   *mut _SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_PIXEL_FORMAT {
   SystemPixelFormatUnknown = 0,
   SystemPixelFormatR8G8B8 = 1,
   SystemPixelFormatR8G8B8X8 = 2,
   SystemPixelFormatB8G8R8 = 3,
   SystemPixelFormatB8G8R8X8 = 4,
}
pub use self::_SYSTEM_PIXEL_FORMAT as SYSTEM_PIXEL_FORMAT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_BOOT_GRAPHICS_INFORMATION {
   pub FrameBuffer: LARGE_INTEGER,
   pub Width: ULONG,
   pub Height: ULONG,
   pub PixelStride: ULONG,
   pub Flags: ULONG,
   pub Format: SYSTEM_PIXEL_FORMAT,
   pub DisplayRotation: ULONG,
}
impl Default for _SYSTEM_BOOT_GRAPHICS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BOOT_GRAPHICS_INFORMATION = _SYSTEM_BOOT_GRAPHICS_INFORMATION;
pub type PSYSTEM_BOOT_GRAPHICS_INFORMATION = *mut _SYSTEM_BOOT_GRAPHICS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_SCRUB_INFORMATION {
   pub Handle: HANDLE,
   pub PagesScrubbed: ULONG,
}
impl Default for _MEMORY_SCRUB_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_SCRUB_INFORMATION = _MEMORY_SCRUB_INFORMATION;
pub type PMEMORY_SCRUB_INFORMATION = *mut _MEMORY_SCRUB_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEBS_DS_SAVE_AREA32 {
   pub BtsBufferBase: ULONG,
   pub BtsIndex: ULONG,
   pub BtsAbsoluteMaximum: ULONG,
   pub BtsInterruptThreshold: ULONG,
   pub PebsBufferBase: ULONG,
   pub PebsIndex: ULONG,
   pub PebsAbsoluteMaximum: ULONG,
   pub PebsInterruptThreshold: ULONG,
   pub PebsGpCounterReset: [ULONG; 8usize],
   pub PebsFixedCounterReset: [ULONG; 4usize],
}
pub type PEBS_DS_SAVE_AREA32 = _PEBS_DS_SAVE_AREA32;
pub type PPEBS_DS_SAVE_AREA32 = *mut _PEBS_DS_SAVE_AREA32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEBS_DS_SAVE_AREA64 {
   pub BtsBufferBase: ULONGLONG,
   pub BtsIndex: ULONGLONG,
   pub BtsAbsoluteMaximum: ULONGLONG,
   pub BtsInterruptThreshold: ULONGLONG,
   pub PebsBufferBase: ULONGLONG,
   pub PebsIndex: ULONGLONG,
   pub PebsAbsoluteMaximum: ULONGLONG,
   pub PebsInterruptThreshold: ULONGLONG,
   pub PebsGpCounterReset: [ULONGLONG; 8usize],
   pub PebsFixedCounterReset: [ULONGLONG; 4usize],
}
pub type PEBS_DS_SAVE_AREA64 = _PEBS_DS_SAVE_AREA64;
pub type PPEBS_DS_SAVE_AREA64 = *mut _PEBS_DS_SAVE_AREA64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEBS_DS_SAVE_AREA {
   pub As32Bit: PEBS_DS_SAVE_AREA32,
   pub As64Bit: PEBS_DS_SAVE_AREA64,
}
impl Default for _PEBS_DS_SAVE_AREA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEBS_DS_SAVE_AREA = _PEBS_DS_SAVE_AREA;
pub type PPEBS_DS_SAVE_AREA = *mut _PEBS_DS_SAVE_AREA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESSOR_PROFILE_CONTROL_AREA {
   pub PebsDsSaveArea: PEBS_DS_SAVE_AREA,
}
impl Default for _PROCESSOR_PROFILE_CONTROL_AREA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESSOR_PROFILE_CONTROL_AREA = _PROCESSOR_PROFILE_CONTROL_AREA;
pub type PPROCESSOR_PROFILE_CONTROL_AREA = *mut _PROCESSOR_PROFILE_CONTROL_AREA;
#[repr(C)]
pub struct _SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA {
   pub ProcessorProfileControlArea: PROCESSOR_PROFILE_CONTROL_AREA,
   pub Allocate: BOOLEAN,
}
impl Default for _SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA = _SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA;
pub type PSYSTEM_PROCESSOR_PROFILE_CONTROL_AREA = *mut _SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_COMBINE_INFORMATION {
   pub Handle: HANDLE,
   pub PagesCombined: ULONG_PTR,
}
impl Default for _MEMORY_COMBINE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_COMBINE_INFORMATION = _MEMORY_COMBINE_INFORMATION;
pub type PMEMORY_COMBINE_INFORMATION = *mut _MEMORY_COMBINE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_COMBINE_INFORMATION_EX {
   pub Handle: HANDLE,
   pub PagesCombined: ULONG_PTR,
   pub Flags: ULONG,
}
impl Default for _MEMORY_COMBINE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_COMBINE_INFORMATION_EX = _MEMORY_COMBINE_INFORMATION_EX;
pub type PMEMORY_COMBINE_INFORMATION_EX = *mut _MEMORY_COMBINE_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_COMBINE_INFORMATION_EX2 {
   pub Handle: HANDLE,
   pub PagesCombined: ULONG_PTR,
   pub Flags: ULONG,
   pub ProcessHandle: HANDLE,
}
impl Default for _MEMORY_COMBINE_INFORMATION_EX2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_COMBINE_INFORMATION_EX2 = _MEMORY_COMBINE_INFORMATION_EX2;
pub type PMEMORY_COMBINE_INFORMATION_EX2 = *mut _MEMORY_COMBINE_INFORMATION_EX2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ENTROPY_TIMING_INFORMATION {
   pub EntropyRoutine: ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: ULONG)>,
   pub InitializationRoutine:
      ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: ULONG, arg3: PVOID)>,
   pub InitializationContext: PVOID,
}
impl Default for _SYSTEM_ENTROPY_TIMING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ENTROPY_TIMING_INFORMATION = _SYSTEM_ENTROPY_TIMING_INFORMATION;
pub type PSYSTEM_ENTROPY_TIMING_INFORMATION = *mut _SYSTEM_ENTROPY_TIMING_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CONSOLE_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_CONSOLE_INFORMATION {
   #[inline]
   pub fn DriverLoaded(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DriverLoaded(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(DriverLoaded: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DriverLoaded: u32 = unsafe { ::core::mem::transmute(DriverLoaded) };
         DriverLoaded as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SYSTEM_CONSOLE_INFORMATION = _SYSTEM_CONSOLE_INFORMATION;
pub type PSYSTEM_CONSOLE_INFORMATION = *mut _SYSTEM_CONSOLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PLATFORM_BINARY_INFORMATION {
   pub PhysicalAddress: ULONG64,
   pub HandoffBuffer: PVOID,
   pub CommandLineBuffer: PVOID,
   pub HandoffBufferSize: ULONG,
   pub CommandLineBufferSize: ULONG,
}
impl Default for _SYSTEM_PLATFORM_BINARY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PLATFORM_BINARY_INFORMATION = _SYSTEM_PLATFORM_BINARY_INFORMATION;
pub type PSYSTEM_PLATFORM_BINARY_INFORMATION = *mut _SYSTEM_PLATFORM_BINARY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POLICY_INFORMATION {
   pub InputData: PVOID,
   pub OutputData: PVOID,
   pub InputDataSize: ULONG,
   pub OutputDataSize: ULONG,
   pub Version: ULONG,
}
impl Default for _SYSTEM_POLICY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POLICY_INFORMATION = _SYSTEM_POLICY_INFORMATION;
pub type PSYSTEM_POLICY_INFORMATION = *mut _SYSTEM_POLICY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION {
   pub NumberOfLogicalProcessors: ULONG,
   pub NumberOfCores: ULONG,
}
pub type SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION =
   _SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION;
pub type PSYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION =
   *mut _SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_DEVICE_DATA_INFORMATION {
   pub DeviceId: UNICODE_STRING,
   pub DataName: UNICODE_STRING,
   pub DataType: ULONG,
   pub DataBufferLength: ULONG,
   pub DataBuffer: PVOID,
}
impl Default for _SYSTEM_DEVICE_DATA_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_DEVICE_DATA_INFORMATION = _SYSTEM_DEVICE_DATA_INFORMATION;
pub type PSYSTEM_DEVICE_DATA_INFORMATION = *mut _SYSTEM_DEVICE_DATA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PHYSICAL_CHANNEL_RUN {
   pub NodeNumber: ULONG,
   pub ChannelNumber: ULONG,
   pub BasePage: ULONGLONG,
   pub PageCount: ULONGLONG,
   pub Flags: ULONG,
}
pub type PHYSICAL_CHANNEL_RUN = _PHYSICAL_CHANNEL_RUN;
pub type PPHYSICAL_CHANNEL_RUN = *mut _PHYSICAL_CHANNEL_RUN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_MEMORY_TOPOLOGY_INFORMATION {
   pub NumberOfRuns: ULONGLONG,
   pub NumberOfNodes: ULONG,
   pub NumberOfChannels: ULONG,
   pub Run: [PHYSICAL_CHANNEL_RUN; 1usize],
}
pub type SYSTEM_MEMORY_TOPOLOGY_INFORMATION = _SYSTEM_MEMORY_TOPOLOGY_INFORMATION;
pub type PSYSTEM_MEMORY_TOPOLOGY_INFORMATION = *mut _SYSTEM_MEMORY_TOPOLOGY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_MEMORY_CHANNEL_INFORMATION {
   pub ChannelNumber: ULONG,
   pub ChannelHeatIndex: ULONG,
   pub TotalPageCount: ULONGLONG,
   pub ZeroPageCount: ULONGLONG,
   pub FreePageCount: ULONGLONG,
   pub StandbyPageCount: ULONGLONG,
}
pub type SYSTEM_MEMORY_CHANNEL_INFORMATION = _SYSTEM_MEMORY_CHANNEL_INFORMATION;
pub type PSYSTEM_MEMORY_CHANNEL_INFORMATION = *mut _SYSTEM_MEMORY_CHANNEL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BOOT_LOGO_INFORMATION {
   pub Flags: ULONG,
   pub BitmapOffset: ULONG,
}
pub type SYSTEM_BOOT_LOGO_INFORMATION = _SYSTEM_BOOT_LOGO_INFORMATION;
pub type PSYSTEM_BOOT_LOGO_INFORMATION = *mut _SYSTEM_BOOT_LOGO_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX {
   pub IdleTime: LARGE_INTEGER,
   pub KernelTime: LARGE_INTEGER,
   pub UserTime: LARGE_INTEGER,
   pub DpcTime: LARGE_INTEGER,
   pub InterruptTime: LARGE_INTEGER,
   pub InterruptCount: ULONG,
   pub Spare0: ULONG,
   pub AvailableTime: LARGE_INTEGER,
   pub Spare1: LARGE_INTEGER,
   pub Spare2: LARGE_INTEGER,
}
impl Default for _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX = _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX =
   *mut _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION {
   pub PolicyPublisher: GUID,
   pub PolicyVersion: ULONG,
   pub PolicyOptions: ULONG,
}
pub type SYSTEM_SECUREBOOT_POLICY_INFORMATION = _SYSTEM_SECUREBOOT_POLICY_INFORMATION;
pub type PSYSTEM_SECUREBOOT_POLICY_INFORMATION = *mut _SYSTEM_SECUREBOOT_POLICY_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_PAGEFILE_INFORMATION_EX {
   pub __bindgen_anon_1: _SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1,
   pub MinimumSize: ULONG,
   pub MaximumSize: ULONG,
}
#[repr(C)]
pub union _SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1 {
   pub Info: ::core::mem::ManuallyDrop<SYSTEM_PAGEFILE_INFORMATION>,
   pub __bindgen_anon_1:
      ::core::mem::ManuallyDrop<_SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
pub struct _SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   pub NextEntryOffset: ULONG,
   pub TotalSize: ULONG,
   pub TotalInUse: ULONG,
   pub PeakUsage: ULONG,
   pub PageFileName: UNICODE_STRING,
}
impl Default for _SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_PAGEFILE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PAGEFILE_INFORMATION_EX = _SYSTEM_PAGEFILE_INFORMATION_EX;
pub type PSYSTEM_PAGEFILE_INFORMATION_EX = *mut _SYSTEM_PAGEFILE_INFORMATION_EX;
#[repr(C)]
pub struct _SYSTEM_SECUREBOOT_INFORMATION {
   pub SecureBootEnabled: BOOLEAN,
   pub SecureBootCapable: BOOLEAN,
}
impl Default for _SYSTEM_SECUREBOOT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SECUREBOOT_INFORMATION = _SYSTEM_SECUREBOOT_INFORMATION;
pub type PSYSTEM_SECUREBOOT_INFORMATION = *mut _SYSTEM_SECUREBOOT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_DISK_COUNTERS {
   pub BytesRead: ULONGLONG,
   pub BytesWritten: ULONGLONG,
   pub ReadOperationCount: ULONGLONG,
   pub WriteOperationCount: ULONGLONG,
   pub FlushOperationCount: ULONGLONG,
}
pub type PROCESS_DISK_COUNTERS = _PROCESS_DISK_COUNTERS;
pub type PPROCESS_DISK_COUNTERS = *mut _PROCESS_DISK_COUNTERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ENERGY_STATE_DURATION {
   pub Value: ULONGLONG,
   pub __bindgen_anon_1: _ENERGY_STATE_DURATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ENERGY_STATE_DURATION__bindgen_ty_1 {
   pub LastChangeTime: ULONG,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _ENERGY_STATE_DURATION__bindgen_ty_1 {
   #[inline]
   pub fn Duration(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Duration(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn IsInState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsInState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Duration: ULONG, IsInState: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 31u8, {
         let Duration: u32 = unsafe { ::core::mem::transmute(Duration) };
         Duration as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let IsInState: u32 = unsafe { ::core::mem::transmute(IsInState) };
         IsInState as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _ENERGY_STATE_DURATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ENERGY_STATE_DURATION = _ENERGY_STATE_DURATION;
pub type PENERGY_STATE_DURATION = *mut _ENERGY_STATE_DURATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES {
   pub Cycles: [[ULONGLONG; 2usize]; 4usize],
   pub DiskEnergy: ULONGLONG,
   pub NetworkTailEnergy: ULONGLONG,
   pub MBBTailEnergy: ULONGLONG,
   pub NetworkTxRxBytes: ULONGLONG,
   pub MBBTxRxBytes: ULONGLONG,
   pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES__bindgen_ty_1,
   pub CompositionRendered: ULONG,
   pub CompositionDirtyGenerated: ULONG,
   pub CompositionDirtyPropagated: ULONG,
   pub Reserved1: ULONG,
   pub AttributedCycles: [[ULONGLONG; 2usize]; 4usize],
   pub WorkOnBehalfCycles: [[ULONGLONG; 2usize]; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_ENERGY_VALUES__bindgen_ty_1 {
   pub Durations: [ENERGY_STATE_DURATION; 3usize],
   pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES__bindgen_ty_1__bindgen_ty_1 {
   pub ForegroundDuration: ENERGY_STATE_DURATION,
   pub DesktopVisibleDuration: ENERGY_STATE_DURATION,
   pub PSMForegroundDuration: ENERGY_STATE_DURATION,
}
impl Default for _PROCESS_ENERGY_VALUES__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_ENERGY_VALUES__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_ENERGY_VALUES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_ENERGY_VALUES = _PROCESS_ENERGY_VALUES;
pub type PPROCESS_ENERGY_VALUES = *mut _PROCESS_ENERGY_VALUES;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TIMELINE_BITMAP {
   pub Value: ULONGLONG,
   pub __bindgen_anon_1: _TIMELINE_BITMAP__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TIMELINE_BITMAP__bindgen_ty_1 {
   pub EndTime: ULONG,
   pub Bitmap: ULONG,
}
impl Default for _TIMELINE_BITMAP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TIMELINE_BITMAP = _TIMELINE_BITMAP;
pub type PTIMELINE_BITMAP = *mut _TIMELINE_BITMAP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES_EXTENSION {
   pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1,
   pub __bindgen_anon_2: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2,
   pub KeyboardInput: ULONG,
   pub MouseInput: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1 {
   pub Timelines: [TIMELINE_BITMAP; 14usize],
   pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
   pub CpuTimeline: TIMELINE_BITMAP,
   pub DiskTimeline: TIMELINE_BITMAP,
   pub NetworkTimeline: TIMELINE_BITMAP,
   pub MBBTimeline: TIMELINE_BITMAP,
   pub ForegroundTimeline: TIMELINE_BITMAP,
   pub DesktopVisibleTimeline: TIMELINE_BITMAP,
   pub CompositionRenderedTimeline: TIMELINE_BITMAP,
   pub CompositionDirtyGeneratedTimeline: TIMELINE_BITMAP,
   pub CompositionDirtyPropagatedTimeline: TIMELINE_BITMAP,
   pub InputTimeline: TIMELINE_BITMAP,
   pub AudioInTimeline: TIMELINE_BITMAP,
   pub AudioOutTimeline: TIMELINE_BITMAP,
   pub DisplayRequiredTimeline: TIMELINE_BITMAP,
   pub KeyboardInputTimeline: TIMELINE_BITMAP,
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2 {
   pub Durations: [ENERGY_STATE_DURATION; 5usize],
   pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2__bindgen_ty_1 {
   pub InputDuration: ENERGY_STATE_DURATION,
   pub AudioInDuration: ENERGY_STATE_DURATION,
   pub AudioOutDuration: ENERGY_STATE_DURATION,
   pub DisplayRequiredDuration: ENERGY_STATE_DURATION,
   pub PSMBackgroundDuration: ENERGY_STATE_DURATION,
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_ENERGY_VALUES_EXTENSION = _PROCESS_ENERGY_VALUES_EXTENSION;
pub type PPROCESS_ENERGY_VALUES_EXTENSION = *mut _PROCESS_ENERGY_VALUES_EXTENSION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_EXTENDED_ENERGY_VALUES {
   pub Base: PROCESS_ENERGY_VALUES,
   pub Extension: PROCESS_ENERGY_VALUES_EXTENSION,
}
impl Default for _PROCESS_EXTENDED_ENERGY_VALUES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_EXTENDED_ENERGY_VALUES = _PROCESS_EXTENDED_ENERGY_VALUES;
pub type PPROCESS_EXTENDED_ENERGY_VALUES = *mut _PROCESS_EXTENDED_ENERGY_VALUES;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_PROCESS_CLASSIFICATION {
   SystemProcessClassificationNormal = 0,
   SystemProcessClassificationSystem = 1,
   SystemProcessClassificationSecureSystem = 2,
   SystemProcessClassificationMemCompression = 3,
   SystemProcessClassificationRegistry = 4,
   SystemProcessClassificationMaximum = 5,
}
pub use self::_SYSTEM_PROCESS_CLASSIFICATION as SYSTEM_PROCESS_CLASSIFICATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PROCESS_INFORMATION_EXTENSION {
   pub DiskCounters: PROCESS_DISK_COUNTERS,
   pub ContextSwitches: ULONGLONG,
   pub __bindgen_anon_1: _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1,
   pub UserSidOffset: ULONG,
   pub PackageFullNameOffset: ULONG,
   pub EnergyValues: PROCESS_ENERGY_VALUES,
   pub AppIdOffset: ULONG,
   pub SharedCommitCharge: SIZE_T,
   pub JobObjectId: ULONG,
   pub SpareUlong: ULONG,
   pub ProcessSequenceNumber: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn HasStrongId(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HasStrongId(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Classification(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Classification(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn BackgroundActivityModerated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BackgroundActivityModerated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 26u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      HasStrongId: ULONG,
      Classification: ULONG,
      BackgroundActivityModerated: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let HasStrongId: u32 = unsafe { ::core::mem::transmute(HasStrongId) };
         HasStrongId as u64
      });
      __bindgen_bitfield_unit.set(1usize, 4u8, {
         let Classification: u32 = unsafe { ::core::mem::transmute(Classification) };
         Classification as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let BackgroundActivityModerated: u32 =
            unsafe { ::core::mem::transmute(BackgroundActivityModerated) };
         BackgroundActivityModerated as u64
      });
      __bindgen_bitfield_unit.set(6usize, 26u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_PROCESS_INFORMATION_EXTENSION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESS_INFORMATION_EXTENSION = _SYSTEM_PROCESS_INFORMATION_EXTENSION;
pub type PSYSTEM_PROCESS_INFORMATION_EXTENSION = *mut _SYSTEM_PROCESS_INFORMATION_EXTENSION;
#[repr(C)]
pub struct _SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION {
   pub EfiLauncherEnabled: BOOLEAN,
}
impl Default for _SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION =
   _SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION;
pub type PSYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION =
   *mut _SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
   pub DebuggerAllowed: BOOLEAN,
   pub DebuggerEnabled: BOOLEAN,
   pub DebuggerPresent: BOOLEAN,
}
impl Default for _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX = _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;
pub type PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX = *mut _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ELAM_CERTIFICATE_INFORMATION {
   pub ElamDriverFile: HANDLE,
}
impl Default for _SYSTEM_ELAM_CERTIFICATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ELAM_CERTIFICATE_INFORMATION = _SYSTEM_ELAM_CERTIFICATE_INFORMATION;
pub type PSYSTEM_ELAM_CERTIFICATE_INFORMATION = *mut _SYSTEM_ELAM_CERTIFICATE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 {
   pub Version: ULONG,
   pub AbnormalResetOccurred: ULONG,
   pub OfflineMemoryDumpCapable: ULONG,
   pub ResetDataAddress: LARGE_INTEGER,
   pub ResetDataSize: ULONG,
}
impl Default for _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 = _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2;
pub type POFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 = *mut _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1 {
   pub Version: ULONG,
   pub AbnormalResetOccurred: ULONG,
   pub OfflineMemoryDumpCapable: ULONG,
}
pub type OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1 = _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1;
pub type POFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1 = *mut _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_FEATURES_INFORMATION {
   pub ProcessorFeatureBits: ULONGLONG,
   pub Reserved: [ULONGLONG; 3usize],
}
pub type SYSTEM_PROCESSOR_FEATURES_INFORMATION = _SYSTEM_PROCESSOR_FEATURES_INFORMATION;
pub type PSYSTEM_PROCESSOR_FEATURES_INFORMATION = *mut _SYSTEM_PROCESSOR_FEATURES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_EDID_INFORMATION {
   pub Edid: [UCHAR; 128usize],
}
impl Default for _SYSTEM_EDID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_EDID_INFORMATION = _SYSTEM_EDID_INFORMATION;
pub type PSYSTEM_EDID_INFORMATION = *mut _SYSTEM_EDID_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_MANUFACTURING_INFORMATION {
   pub Options: ULONG,
   pub ProfileName: UNICODE_STRING,
}
impl Default for _SYSTEM_MANUFACTURING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_MANUFACTURING_INFORMATION = _SYSTEM_MANUFACTURING_INFORMATION;
pub type PSYSTEM_MANUFACTURING_INFORMATION = *mut _SYSTEM_MANUFACTURING_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION {
   pub Enabled: BOOLEAN,
}
impl Default for _SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION = _SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION;
pub type PSYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION =
   *mut _SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HV_DETAILS {
   pub Data: [ULONG; 4usize],
}
pub type HV_DETAILS = _HV_DETAILS;
pub type PHV_DETAILS = *mut _HV_DETAILS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_DETAIL_INFORMATION {
   pub HvVendorAndMaxFunction: HV_DETAILS,
   pub HypervisorInterface: HV_DETAILS,
   pub HypervisorVersion: HV_DETAILS,
   pub HvFeatures: HV_DETAILS,
   pub HwFeatures: HV_DETAILS,
   pub EnlightenmentInfo: HV_DETAILS,
   pub ImplementationLimits: HV_DETAILS,
}
pub type SYSTEM_HYPERVISOR_DETAIL_INFORMATION = _SYSTEM_HYPERVISOR_DETAIL_INFORMATION;
pub type PSYSTEM_HYPERVISOR_DETAIL_INFORMATION = *mut _SYSTEM_HYPERVISOR_DETAIL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION {
   pub Cycles: [[ULONGLONG; 2usize]; 4usize],
}
pub type SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION = _SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION;
pub type PSYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION = *mut _SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_TPM_INFORMATION {
   pub Flags: ULONG,
}
pub type SYSTEM_TPM_INFORMATION = _SYSTEM_TPM_INFORMATION;
pub type PSYSTEM_TPM_INFORMATION = *mut _SYSTEM_TPM_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_VSM_PROTECTION_INFORMATION {
   pub DmaProtectionsAvailable: BOOLEAN,
   pub DmaProtectionsInUse: BOOLEAN,
   pub HardwareMbecAvailable: BOOLEAN,
   pub ApicVirtualizationAvailable: BOOLEAN,
}
impl Default for _SYSTEM_VSM_PROTECTION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VSM_PROTECTION_INFORMATION = _SYSTEM_VSM_PROTECTION_INFORMATION;
pub type PSYSTEM_VSM_PROTECTION_INFORMATION = *mut _SYSTEM_VSM_PROTECTION_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_KERNEL_DEBUGGER_FLAGS {
   pub KernelDebuggerIgnoreUmExceptions: BOOLEAN,
}
impl Default for _SYSTEM_KERNEL_DEBUGGER_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_KERNEL_DEBUGGER_FLAGS = _SYSTEM_KERNEL_DEBUGGER_FLAGS;
pub type PSYSTEM_KERNEL_DEBUGGER_FLAGS = *mut _SYSTEM_KERNEL_DEBUGGER_FLAGS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITYPOLICY_INFORMATION {
   pub Options: ULONG,
   pub HVCIOptions: ULONG,
   pub Version: ULONGLONG,
   pub PolicyGuid: GUID,
}
pub type SYSTEM_CODEINTEGRITYPOLICY_INFORMATION = _SYSTEM_CODEINTEGRITYPOLICY_INFORMATION;
pub type PSYSTEM_CODEINTEGRITYPOLICY_INFORMATION = *mut _SYSTEM_CODEINTEGRITYPOLICY_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
   pub Spare0: [BOOLEAN; 6usize],
   pub Spare1: ULONGLONG,
}
impl Default for _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
   #[inline]
   pub fn SecureKernelRunning(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SecureKernelRunning(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HvciEnabled(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_HvciEnabled(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HvciStrictMode(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_HvciStrictMode(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DebugEnabled(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_DebugEnabled(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn FirmwarePageProtection(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_FirmwarePageProtection(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EncryptionKeyAvailable(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_EncryptionKeyAvailable(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareFlags(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_SpareFlags(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn TrustletRunning(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_TrustletRunning(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HvciDisableAllowed(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_HvciDisableAllowed(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareFlags2(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u8) }
   }
   #[inline]
   pub fn set_SpareFlags2(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SecureKernelRunning: BOOLEAN,
      HvciEnabled: BOOLEAN,
      HvciStrictMode: BOOLEAN,
      DebugEnabled: BOOLEAN,
      FirmwarePageProtection: BOOLEAN,
      EncryptionKeyAvailable: BOOLEAN,
      SpareFlags: BOOLEAN,
      TrustletRunning: BOOLEAN,
      HvciDisableAllowed: BOOLEAN,
      SpareFlags2: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SecureKernelRunning: u8 = unsafe { ::core::mem::transmute(SecureKernelRunning) };
         SecureKernelRunning as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let HvciEnabled: u8 = unsafe { ::core::mem::transmute(HvciEnabled) };
         HvciEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let HvciStrictMode: u8 = unsafe { ::core::mem::transmute(HvciStrictMode) };
         HvciStrictMode as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let DebugEnabled: u8 = unsafe { ::core::mem::transmute(DebugEnabled) };
         DebugEnabled as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let FirmwarePageProtection: u8 = unsafe { ::core::mem::transmute(FirmwarePageProtection) };
         FirmwarePageProtection as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let EncryptionKeyAvailable: u8 = unsafe { ::core::mem::transmute(EncryptionKeyAvailable) };
         EncryptionKeyAvailable as u64
      });
      __bindgen_bitfield_unit.set(6usize, 2u8, {
         let SpareFlags: u8 = unsafe { ::core::mem::transmute(SpareFlags) };
         SpareFlags as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let TrustletRunning: u8 = unsafe { ::core::mem::transmute(TrustletRunning) };
         TrustletRunning as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let HvciDisableAllowed: u8 = unsafe { ::core::mem::transmute(HvciDisableAllowed) };
         HvciDisableAllowed as u64
      });
      __bindgen_bitfield_unit.set(10usize, 6u8, {
         let SpareFlags2: u8 = unsafe { ::core::mem::transmute(SpareFlags2) };
         SpareFlags2 as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SYSTEM_ISOLATED_USER_MODE_INFORMATION = _SYSTEM_ISOLATED_USER_MODE_INFORMATION;
pub type PSYSTEM_ISOLATED_USER_MODE_INFORMATION = *mut _SYSTEM_ISOLATED_USER_MODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SINGLE_MODULE_INFORMATION {
   pub TargetModuleAddress: PVOID,
   pub ExInfo: RTL_PROCESS_MODULE_INFORMATION_EX,
}
impl Default for _SYSTEM_SINGLE_MODULE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SINGLE_MODULE_INFORMATION = _SYSTEM_SINGLE_MODULE_INFORMATION;
pub type PSYSTEM_SINGLE_MODULE_INFORMATION = *mut _SYSTEM_SINGLE_MODULE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_INTERRUPT_CPU_SET_INFORMATION {
   pub Gsiv: ULONG,
   pub Group: USHORT,
   pub CpuSets: ULONGLONG,
}
pub type SYSTEM_INTERRUPT_CPU_SET_INFORMATION = _SYSTEM_INTERRUPT_CPU_SET_INFORMATION;
pub type PSYSTEM_INTERRUPT_CPU_SET_INFORMATION = *mut _SYSTEM_INTERRUPT_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
   pub PolicyInformation: SYSTEM_SECUREBOOT_POLICY_INFORMATION,
   pub PolicySize: ULONG,
   pub Policy: [UCHAR; 1usize],
}
pub type SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION = _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;
pub type PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION =
   *mut _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_ROOT_SILO_INFORMATION {
   pub NumberOfSilos: ULONG,
   pub SiloIdList: [ULONG; 1usize],
}
pub type SYSTEM_ROOT_SILO_INFORMATION = _SYSTEM_ROOT_SILO_INFORMATION;
pub type PSYSTEM_ROOT_SILO_INFORMATION = *mut _SYSTEM_ROOT_SILO_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CPU_SET_TAG_INFORMATION {
   pub Tag: ULONGLONG,
   pub CpuSets: [ULONGLONG; 1usize],
}
pub type SYSTEM_CPU_SET_TAG_INFORMATION = _SYSTEM_CPU_SET_TAG_INFORMATION;
pub type PSYSTEM_CPU_SET_TAG_INFORMATION = *mut _SYSTEM_CPU_SET_TAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION {
   pub ExtentCount: ULONG,
   pub ValidStructureSize: ULONG,
   pub NextExtentIndex: ULONG,
   pub ExtentRestart: ULONG,
   pub CycleCount: ULONG,
   pub TimeoutCount: ULONG,
   pub CycleTime: ULONGLONG,
   pub CycleTimeMax: ULONGLONG,
   pub ExtentTime: ULONGLONG,
   pub ExtentTimeIndex: ULONG,
   pub ExtentTimeMaxIndex: ULONG,
   pub ExtentTimeMax: ULONGLONG,
   pub HyperFlushTimeMax: ULONGLONG,
   pub TranslateVaTimeMax: ULONGLONG,
   pub DebugExemptionCount: ULONGLONG,
   pub TbHitCount: ULONGLONG,
   pub TbMissCount: ULONGLONG,
   pub VinaPendingYield: ULONGLONG,
   pub HashCycles: ULONGLONG,
   pub HistogramOffset: ULONG,
   pub HistogramBuckets: ULONG,
   pub HistogramShift: ULONG,
   pub Reserved1: ULONG,
   pub PageNotPresentCount: ULONGLONG,
}
pub type SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION =
   _SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION;
pub type PSYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION =
   *mut _SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION {
   pub PlatformManifestSize: ULONG,
   pub PlatformManifest: [UCHAR; 1usize],
}
pub type SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION =
   _SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION;
pub type PSYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION =
   *mut _SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT {
   pub Gsiv: ULONG,
   pub ControllerInterrupt: UCHAR,
   pub EdgeInterrupt: UCHAR,
   pub IsPrimaryInterrupt: UCHAR,
   pub TargetAffinity: GROUP_AFFINITY,
}
pub type SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT = _SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT;
pub type PSYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT =
   *mut _SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT {
   pub AsULONG: ULONG,
   pub __bindgen_anon_1: _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT__bindgen_ty_1 {
   #[inline]
   pub fn Enabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Enabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Enabled: ULONG, Reserved: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Enabled: u32 = unsafe { ::core::mem::transmute(Enabled) };
         Enabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT =
   _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT;
pub type PSYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT =
   *mut _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_MEMORY_USAGE_INFORMATION {
   pub TotalPhysicalBytes: ULONGLONG,
   pub AvailableBytes: ULONGLONG,
   pub ResidentAvailableBytes: LONGLONG,
   pub CommittedBytes: ULONGLONG,
   pub SharedCommittedBytes: ULONGLONG,
   pub CommitLimitBytes: ULONGLONG,
   pub PeakCommitmentBytes: ULONGLONG,
}
pub type SYSTEM_MEMORY_USAGE_INFORMATION = _SYSTEM_MEMORY_USAGE_INFORMATION;
pub type PSYSTEM_MEMORY_USAGE_INFORMATION = *mut _SYSTEM_MEMORY_USAGE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION {
   pub ImageFile: HANDLE,
   pub Type: ULONG,
}
impl Default for _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION =
   _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION;
pub type PSYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION =
   *mut _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PHYSICAL_MEMORY_INFORMATION {
   pub TotalPhysicalBytes: ULONGLONG,
   pub LowestPhysicalAddress: ULONGLONG,
   pub HighestPhysicalAddress: ULONGLONG,
}
pub type SYSTEM_PHYSICAL_MEMORY_INFORMATION = _SYSTEM_PHYSICAL_MEMORY_INFORMATION;
pub type PSYSTEM_PHYSICAL_MEMORY_INFORMATION = *mut _SYSTEM_PHYSICAL_MEMORY_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_ACTIVITY_MODERATION_STATE {
   SystemActivityModerationStateSystemManaged = 0,
   SystemActivityModerationStateUserManagedAllowThrottling = 1,
   SystemActivityModerationStateUserManagedDisableThrottling = 2,
   MaxSystemActivityModerationState = 3,
}
pub use self::_SYSTEM_ACTIVITY_MODERATION_STATE as SYSTEM_ACTIVITY_MODERATION_STATE;
#[repr(C)]
pub struct _SYSTEM_ACTIVITY_MODERATION_EXE_STATE {
   pub ExePathNt: UNICODE_STRING,
   pub ModerationState: SYSTEM_ACTIVITY_MODERATION_STATE,
}
impl Default for _SYSTEM_ACTIVITY_MODERATION_EXE_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ACTIVITY_MODERATION_EXE_STATE = _SYSTEM_ACTIVITY_MODERATION_EXE_STATE;
pub type PSYSTEM_ACTIVITY_MODERATION_EXE_STATE = *mut _SYSTEM_ACTIVITY_MODERATION_EXE_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_ACTIVITY_MODERATION_APP_TYPE {
   SystemActivityModerationAppTypeClassic = 0,
   SystemActivityModerationAppTypePackaged = 1,
   MaxSystemActivityModerationAppType = 2,
}
pub use self::_SYSTEM_ACTIVITY_MODERATION_APP_TYPE as SYSTEM_ACTIVITY_MODERATION_APP_TYPE;
#[repr(C)]
pub struct _SYSTEM_ACTIVITY_MODERATION_INFO {
   pub Identifier: UNICODE_STRING,
   pub ModerationState: SYSTEM_ACTIVITY_MODERATION_STATE,
   pub AppType: SYSTEM_ACTIVITY_MODERATION_APP_TYPE,
}
impl Default for _SYSTEM_ACTIVITY_MODERATION_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ACTIVITY_MODERATION_INFO = _SYSTEM_ACTIVITY_MODERATION_INFO;
pub type PSYSTEM_ACTIVITY_MODERATION_INFO = *mut _SYSTEM_ACTIVITY_MODERATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS {
   pub UserKeyHandle: HANDLE,
}
impl Default for _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS = _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS;
pub type PSYSTEM_ACTIVITY_MODERATION_USER_SETTINGS = *mut _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1,
   pub UnlockId: [UCHAR; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Locked(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Locked(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn UnlockApplied(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UnlockApplied(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn UnlockIdValid(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UnlockIdValid(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Locked: ULONG,
      UnlockApplied: ULONG,
      UnlockIdValid: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Locked: u32 = unsafe { ::core::mem::transmute(Locked) };
         Locked as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let UnlockApplied: u32 = unsafe { ::core::mem::transmute(UnlockApplied) };
         UnlockApplied as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let UnlockIdValid: u32 = unsafe { ::core::mem::transmute(UnlockIdValid) };
         UnlockIdValid as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION = _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION;
pub type PSYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION = *mut _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FLUSH_INFORMATION {
   pub SupportedFlushMethods: ULONG,
   pub ProcessorCacheFlushSize: ULONG,
   pub SystemFlushCapabilities: ULONGLONG,
   pub Reserved: [ULONGLONG; 2usize],
}
pub type SYSTEM_FLUSH_INFORMATION = _SYSTEM_FLUSH_INFORMATION;
pub type PSYSTEM_FLUSH_INFORMATION = *mut _SYSTEM_FLUSH_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_WRITE_CONSTRAINT_INFORMATION {
   pub WriteConstraintPolicy: ULONG,
   pub Reserved: ULONG,
}
pub type SYSTEM_WRITE_CONSTRAINT_INFORMATION = _SYSTEM_WRITE_CONSTRAINT_INFORMATION;
pub type PSYSTEM_WRITE_CONSTRAINT_INFORMATION = *mut _SYSTEM_WRITE_CONSTRAINT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1 {
   pub KvaShadowFlags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn KvaShadowEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KvaShadowUserGlobal(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowUserGlobal(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KvaShadowPcid(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowPcid(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KvaShadowInvpcid(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowInvpcid(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KvaShadowRequired(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowRequired(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KvaShadowRequiredAvailable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowRequiredAvailable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InvalidPteBit(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_InvalidPteBit(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub fn L1DataCacheFlushSupported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_L1DataCacheFlushSupported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn L1TerminalFaultMitigationPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_L1TerminalFaultMitigationPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 18u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      KvaShadowEnabled: ULONG,
      KvaShadowUserGlobal: ULONG,
      KvaShadowPcid: ULONG,
      KvaShadowInvpcid: ULONG,
      KvaShadowRequired: ULONG,
      KvaShadowRequiredAvailable: ULONG,
      InvalidPteBit: ULONG,
      L1DataCacheFlushSupported: ULONG,
      L1TerminalFaultMitigationPresent: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let KvaShadowEnabled: u32 = unsafe { ::core::mem::transmute(KvaShadowEnabled) };
         KvaShadowEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let KvaShadowUserGlobal: u32 = unsafe { ::core::mem::transmute(KvaShadowUserGlobal) };
         KvaShadowUserGlobal as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let KvaShadowPcid: u32 = unsafe { ::core::mem::transmute(KvaShadowPcid) };
         KvaShadowPcid as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let KvaShadowInvpcid: u32 = unsafe { ::core::mem::transmute(KvaShadowInvpcid) };
         KvaShadowInvpcid as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let KvaShadowRequired: u32 = unsafe { ::core::mem::transmute(KvaShadowRequired) };
         KvaShadowRequired as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let KvaShadowRequiredAvailable: u32 =
            unsafe { ::core::mem::transmute(KvaShadowRequiredAvailable) };
         KvaShadowRequiredAvailable as u64
      });
      __bindgen_bitfield_unit.set(6usize, 6u8, {
         let InvalidPteBit: u32 = unsafe { ::core::mem::transmute(InvalidPteBit) };
         InvalidPteBit as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let L1DataCacheFlushSupported: u32 =
            unsafe { ::core::mem::transmute(L1DataCacheFlushSupported) };
         L1DataCacheFlushSupported as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let L1TerminalFaultMitigationPresent: u32 =
            unsafe { ::core::mem::transmute(L1TerminalFaultMitigationPresent) };
         L1TerminalFaultMitigationPresent as u64
      });
      __bindgen_bitfield_unit.set(14usize, 18u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_KERNEL_VA_SHADOW_INFORMATION = _SYSTEM_KERNEL_VA_SHADOW_INFORMATION;
pub type PSYSTEM_KERNEL_VA_SHADOW_INFORMATION = *mut _SYSTEM_KERNEL_VA_SHADOW_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION {
   pub FileHandle: HANDLE,
   pub ImageSize: ULONG,
   pub Image: PVOID,
}
impl Default for _SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION =
   _SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION;
pub type PSYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION =
   *mut _SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION {
   pub HypervisorSharedUserVa: PVOID,
}
impl Default for _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION = _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION;
pub type PSYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION =
   *mut _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_FIRMWARE_PARTITION_INFORMATION {
   pub FirmwarePartition: UNICODE_STRING,
}
impl Default for _SYSTEM_FIRMWARE_PARTITION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FIRMWARE_PARTITION_INFORMATION = _SYSTEM_FIRMWARE_PARTITION_INFORMATION;
pub type PSYSTEM_FIRMWARE_PARTITION_INFORMATION = *mut _SYSTEM_FIRMWARE_PARTITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_SPECULATION_CONTROL_INFORMATION {
   pub SpeculationControlFlags: _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1,
   pub SpeculationControlFlags2: _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn BpbEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BpbDisabledSystemPolicy(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbDisabledSystemPolicy(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BpbDisabledNoHardwareSupport(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbDisabledNoHardwareSupport(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpecCtrlEnumerated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpecCtrlEnumerated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpecCmdEnumerated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpecCmdEnumerated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IbrsPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IbrsPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn StibpPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_StibpPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SmepPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SmepPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisableAvailable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisableAvailable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisableSupported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisableSupported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisabledSystemWide(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisabledSystemWide(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisabledKernel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisabledKernel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisableRequired(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisableRequired(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BpbDisabledKernelToUser(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbDisabledKernelToUser(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpecCtrlRetpolineEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpecCtrlRetpolineEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpecCtrlImportOptimizationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpecCtrlImportOptimizationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnhancedIbrs(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnhancedIbrs(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HvL1tfStatusAvailable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfStatusAvailable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HvL1tfProcessorNotAffected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfProcessorNotAffected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HvL1tfMigitationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfMigitationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(19usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HvL1tfMigitationNotEnabled_Hardware(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfMigitationNotEnabled_Hardware(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HvL1tfMigitationNotEnabled_LoadOption(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfMigitationNotEnabled_LoadOption(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HvL1tfMigitationNotEnabled_CoreScheduler(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfMigitationNotEnabled_CoreScheduler(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnhancedIbrsReported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnhancedIbrsReported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MdsHardwareProtected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MdsHardwareProtected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MbClearEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MbClearEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(25usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MbClearReported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MbClearReported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(26usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedTaa(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedTaa(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(27usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      BpbEnabled: ULONG,
      BpbDisabledSystemPolicy: ULONG,
      BpbDisabledNoHardwareSupport: ULONG,
      SpecCtrlEnumerated: ULONG,
      SpecCmdEnumerated: ULONG,
      IbrsPresent: ULONG,
      StibpPresent: ULONG,
      SmepPresent: ULONG,
      SpeculativeStoreBypassDisableAvailable: ULONG,
      SpeculativeStoreBypassDisableSupported: ULONG,
      SpeculativeStoreBypassDisabledSystemWide: ULONG,
      SpeculativeStoreBypassDisabledKernel: ULONG,
      SpeculativeStoreBypassDisableRequired: ULONG,
      BpbDisabledKernelToUser: ULONG,
      SpecCtrlRetpolineEnabled: ULONG,
      SpecCtrlImportOptimizationEnabled: ULONG,
      EnhancedIbrs: ULONG,
      HvL1tfStatusAvailable: ULONG,
      HvL1tfProcessorNotAffected: ULONG,
      HvL1tfMigitationEnabled: ULONG,
      HvL1tfMigitationNotEnabled_Hardware: ULONG,
      HvL1tfMigitationNotEnabled_LoadOption: ULONG,
      HvL1tfMigitationNotEnabled_CoreScheduler: ULONG,
      EnhancedIbrsReported: ULONG,
      MdsHardwareProtected: ULONG,
      MbClearEnabled: ULONG,
      MbClearReported: ULONG,
      ReservedTaa: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let BpbEnabled: u32 = unsafe { ::core::mem::transmute(BpbEnabled) };
         BpbEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let BpbDisabledSystemPolicy: u32 =
            unsafe { ::core::mem::transmute(BpbDisabledSystemPolicy) };
         BpbDisabledSystemPolicy as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let BpbDisabledNoHardwareSupport: u32 =
            unsafe { ::core::mem::transmute(BpbDisabledNoHardwareSupport) };
         BpbDisabledNoHardwareSupport as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SpecCtrlEnumerated: u32 = unsafe { ::core::mem::transmute(SpecCtrlEnumerated) };
         SpecCtrlEnumerated as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let SpecCmdEnumerated: u32 = unsafe { ::core::mem::transmute(SpecCmdEnumerated) };
         SpecCmdEnumerated as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let IbrsPresent: u32 = unsafe { ::core::mem::transmute(IbrsPresent) };
         IbrsPresent as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let StibpPresent: u32 = unsafe { ::core::mem::transmute(StibpPresent) };
         StibpPresent as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let SmepPresent: u32 = unsafe { ::core::mem::transmute(SmepPresent) };
         SmepPresent as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let SpeculativeStoreBypassDisableAvailable: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisableAvailable) };
         SpeculativeStoreBypassDisableAvailable as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let SpeculativeStoreBypassDisableSupported: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisableSupported) };
         SpeculativeStoreBypassDisableSupported as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let SpeculativeStoreBypassDisabledSystemWide: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisabledSystemWide) };
         SpeculativeStoreBypassDisabledSystemWide as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let SpeculativeStoreBypassDisabledKernel: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisabledKernel) };
         SpeculativeStoreBypassDisabledKernel as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let SpeculativeStoreBypassDisableRequired: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisableRequired) };
         SpeculativeStoreBypassDisableRequired as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let BpbDisabledKernelToUser: u32 =
            unsafe { ::core::mem::transmute(BpbDisabledKernelToUser) };
         BpbDisabledKernelToUser as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let SpecCtrlRetpolineEnabled: u32 =
            unsafe { ::core::mem::transmute(SpecCtrlRetpolineEnabled) };
         SpecCtrlRetpolineEnabled as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let SpecCtrlImportOptimizationEnabled: u32 =
            unsafe { ::core::mem::transmute(SpecCtrlImportOptimizationEnabled) };
         SpecCtrlImportOptimizationEnabled as u64
      });
      __bindgen_bitfield_unit.set(16usize, 1u8, {
         let EnhancedIbrs: u32 = unsafe { ::core::mem::transmute(EnhancedIbrs) };
         EnhancedIbrs as u64
      });
      __bindgen_bitfield_unit.set(17usize, 1u8, {
         let HvL1tfStatusAvailable: u32 = unsafe { ::core::mem::transmute(HvL1tfStatusAvailable) };
         HvL1tfStatusAvailable as u64
      });
      __bindgen_bitfield_unit.set(18usize, 1u8, {
         let HvL1tfProcessorNotAffected: u32 =
            unsafe { ::core::mem::transmute(HvL1tfProcessorNotAffected) };
         HvL1tfProcessorNotAffected as u64
      });
      __bindgen_bitfield_unit.set(19usize, 1u8, {
         let HvL1tfMigitationEnabled: u32 =
            unsafe { ::core::mem::transmute(HvL1tfMigitationEnabled) };
         HvL1tfMigitationEnabled as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let HvL1tfMigitationNotEnabled_Hardware: u32 =
            unsafe { ::core::mem::transmute(HvL1tfMigitationNotEnabled_Hardware) };
         HvL1tfMigitationNotEnabled_Hardware as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let HvL1tfMigitationNotEnabled_LoadOption: u32 =
            unsafe { ::core::mem::transmute(HvL1tfMigitationNotEnabled_LoadOption) };
         HvL1tfMigitationNotEnabled_LoadOption as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let HvL1tfMigitationNotEnabled_CoreScheduler: u32 =
            unsafe { ::core::mem::transmute(HvL1tfMigitationNotEnabled_CoreScheduler) };
         HvL1tfMigitationNotEnabled_CoreScheduler as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let EnhancedIbrsReported: u32 = unsafe { ::core::mem::transmute(EnhancedIbrsReported) };
         EnhancedIbrsReported as u64
      });
      __bindgen_bitfield_unit.set(24usize, 1u8, {
         let MdsHardwareProtected: u32 = unsafe { ::core::mem::transmute(MdsHardwareProtected) };
         MdsHardwareProtected as u64
      });
      __bindgen_bitfield_unit.set(25usize, 1u8, {
         let MbClearEnabled: u32 = unsafe { ::core::mem::transmute(MbClearEnabled) };
         MbClearEnabled as u64
      });
      __bindgen_bitfield_unit.set(26usize, 1u8, {
         let MbClearReported: u32 = unsafe { ::core::mem::transmute(MbClearReported) };
         MbClearReported as u64
      });
      __bindgen_bitfield_unit.set(27usize, 4u8, {
         let ReservedTaa: u32 = unsafe { ::core::mem::transmute(ReservedTaa) };
         ReservedTaa as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn Reserved1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub fn BhbEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BhbEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BhbDisabledSystemPolicy(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BhbDisabledSystemPolicy(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BhbDisabledNoHardwareSupport(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BhbDisabledNoHardwareSupport(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved2(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved2(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn RdclHardwareProtectedReported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RdclHardwareProtectedReported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn RdclHardwareProtected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RdclHardwareProtected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved3(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved3(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved4(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved4(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Reserved1: ULONG,
      BhbEnabled: ULONG,
      BhbDisabledSystemPolicy: ULONG,
      BhbDisabledNoHardwareSupport: ULONG,
      Reserved2: ULONG,
      RdclHardwareProtectedReported: ULONG,
      RdclHardwareProtected: ULONG,
      Reserved3: ULONG,
      Reserved4: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 5u8, {
         let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let BhbEnabled: u32 = unsafe { ::core::mem::transmute(BhbEnabled) };
         BhbEnabled as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let BhbDisabledSystemPolicy: u32 =
            unsafe { ::core::mem::transmute(BhbDisabledSystemPolicy) };
         BhbDisabledSystemPolicy as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let BhbDisabledNoHardwareSupport: u32 =
            unsafe { ::core::mem::transmute(BhbDisabledNoHardwareSupport) };
         BhbDisabledNoHardwareSupport as u64
      });
      __bindgen_bitfield_unit.set(8usize, 3u8, {
         let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
         Reserved2 as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let RdclHardwareProtectedReported: u32 =
            unsafe { ::core::mem::transmute(RdclHardwareProtectedReported) };
         RdclHardwareProtectedReported as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let RdclHardwareProtected: u32 = unsafe { ::core::mem::transmute(RdclHardwareProtected) };
         RdclHardwareProtected as u64
      });
      __bindgen_bitfield_unit.set(13usize, 4u8, {
         let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
         Reserved3 as u64
      });
      __bindgen_bitfield_unit.set(17usize, 3u8, {
         let Reserved4: u32 = unsafe { ::core::mem::transmute(Reserved4) };
         Reserved4 as u64
      });
      __bindgen_bitfield_unit.set(20usize, 12u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_SPECULATION_CONTROL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SPECULATION_CONTROL_INFORMATION = _SYSTEM_SPECULATION_CONTROL_INFORMATION;
pub type PSYSTEM_SPECULATION_CONTROL_INFORMATION = *mut _SYSTEM_SPECULATION_CONTROL_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_DMA_GUARD_POLICY_INFORMATION {
   pub DmaGuardPolicyEnabled: BOOLEAN,
}
impl Default for _SYSTEM_DMA_GUARD_POLICY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_DMA_GUARD_POLICY_INFORMATION = _SYSTEM_DMA_GUARD_POLICY_INFORMATION;
pub type PSYSTEM_DMA_GUARD_POLICY_INFORMATION = *mut _SYSTEM_DMA_GUARD_POLICY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION {
   pub EnclaveLaunchSigner: [UCHAR; 32usize],
}
pub type SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION = _SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION;
pub type PSYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION =
   *mut _SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION {
   pub WorkloadClass: ULONGLONG,
   pub CpuSets: [ULONGLONG; 1usize],
}
pub type SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION = _SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION;
pub type PSYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION =
   *mut _SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_SECURITY_MODEL_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1 {
   pub SecurityModelFlags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn SModeAdminlessEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SModeAdminlessEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AllowDeviceOwnerProtectionDowngrade(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AllowDeviceOwnerProtectionDowngrade(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SModeAdminlessEnabled: ULONG,
      AllowDeviceOwnerProtectionDowngrade: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SModeAdminlessEnabled: u32 = unsafe { ::core::mem::transmute(SModeAdminlessEnabled) };
         SModeAdminlessEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AllowDeviceOwnerProtectionDowngrade: u32 =
            unsafe { ::core::mem::transmute(AllowDeviceOwnerProtectionDowngrade) };
         AllowDeviceOwnerProtectionDowngrade as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_SECURITY_MODEL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SECURITY_MODEL_INFORMATION = _SYSTEM_SECURITY_MODEL_INFORMATION;
pub type PSYSTEM_SECURITY_MODEL_INFORMATION = *mut _SYSTEM_SECURITY_MODEL_INFORMATION;
pub type PRTL_FEATURE_CONFIGURATION = *mut _RTL_FEATURE_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_INFORMATION {
   pub ChangeStamp: ULONGLONG,
   pub Configuration: PRTL_FEATURE_CONFIGURATION,
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FEATURE_CONFIGURATION_INFORMATION = _SYSTEM_FEATURE_CONFIGURATION_INFORMATION;
pub type PSYSTEM_FEATURE_CONFIGURATION_INFORMATION = *mut _SYSTEM_FEATURE_CONFIGURATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY {
   pub ChangeStamp: ULONGLONG,
   pub Section: PVOID,
   pub Size: ULONGLONG,
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY =
   _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY;
pub type PSYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY =
   *mut _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION {
   pub OverallChangeStamp: ULONGLONG,
   pub Descriptors: [SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY; 3usize],
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION =
   _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION;
pub type PSYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION =
   *mut _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET {
   pub Data: [ULONG; 2usize],
}
pub type RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET = _RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET;
pub type PRTL_FEATURE_USAGE_SUBSCRIPTION_TARGET = *mut _RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS {
   pub FeatureId: ULONG,
   pub ReportingKind: USHORT,
   pub ReportingOptions: USHORT,
   pub ReportingTarget: RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET,
}
pub type SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS = _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS;
pub type PSYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS =
   *mut _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECURE_SPECULATION_CONTROL_INFORMATION {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _SECURE_SPECULATION_CONTROL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SECURE_SPECULATION_CONTROL_INFORMATION {
   #[inline]
   pub fn KvaShadowSupported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowSupported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KvaShadowEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KvaShadowUserGlobal(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowUserGlobal(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KvaShadowPcid(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowPcid(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MbClearEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MbClearEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn L1TFMitigated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_L1TFMitigated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BpbEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IbrsPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IbrsPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnhancedIbrs(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnhancedIbrs(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn StibpPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_StibpPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SsbdSupported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SsbdSupported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SsbdRequired(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SsbdRequired(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BpbKernelToUser(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbKernelToUser(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BpbUserToKernel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbUserToKernel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReturnSpeculate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReturnSpeculate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BranchConfusionSafe(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BranchConfusionSafe(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      KvaShadowSupported: ULONG,
      KvaShadowEnabled: ULONG,
      KvaShadowUserGlobal: ULONG,
      KvaShadowPcid: ULONG,
      MbClearEnabled: ULONG,
      L1TFMitigated: ULONG,
      BpbEnabled: ULONG,
      IbrsPresent: ULONG,
      EnhancedIbrs: ULONG,
      StibpPresent: ULONG,
      SsbdSupported: ULONG,
      SsbdRequired: ULONG,
      BpbKernelToUser: ULONG,
      BpbUserToKernel: ULONG,
      ReturnSpeculate: ULONG,
      BranchConfusionSafe: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let KvaShadowSupported: u32 = unsafe { ::core::mem::transmute(KvaShadowSupported) };
         KvaShadowSupported as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let KvaShadowEnabled: u32 = unsafe { ::core::mem::transmute(KvaShadowEnabled) };
         KvaShadowEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let KvaShadowUserGlobal: u32 = unsafe { ::core::mem::transmute(KvaShadowUserGlobal) };
         KvaShadowUserGlobal as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let KvaShadowPcid: u32 = unsafe { ::core::mem::transmute(KvaShadowPcid) };
         KvaShadowPcid as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let MbClearEnabled: u32 = unsafe { ::core::mem::transmute(MbClearEnabled) };
         MbClearEnabled as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let L1TFMitigated: u32 = unsafe { ::core::mem::transmute(L1TFMitigated) };
         L1TFMitigated as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let BpbEnabled: u32 = unsafe { ::core::mem::transmute(BpbEnabled) };
         BpbEnabled as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let IbrsPresent: u32 = unsafe { ::core::mem::transmute(IbrsPresent) };
         IbrsPresent as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let EnhancedIbrs: u32 = unsafe { ::core::mem::transmute(EnhancedIbrs) };
         EnhancedIbrs as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let StibpPresent: u32 = unsafe { ::core::mem::transmute(StibpPresent) };
         StibpPresent as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let SsbdSupported: u32 = unsafe { ::core::mem::transmute(SsbdSupported) };
         SsbdSupported as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let SsbdRequired: u32 = unsafe { ::core::mem::transmute(SsbdRequired) };
         SsbdRequired as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let BpbKernelToUser: u32 = unsafe { ::core::mem::transmute(BpbKernelToUser) };
         BpbKernelToUser as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let BpbUserToKernel: u32 = unsafe { ::core::mem::transmute(BpbUserToKernel) };
         BpbUserToKernel as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let ReturnSpeculate: u32 = unsafe { ::core::mem::transmute(ReturnSpeculate) };
         ReturnSpeculate as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let BranchConfusionSafe: u32 = unsafe { ::core::mem::transmute(BranchConfusionSafe) };
         BranchConfusionSafe as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SECURE_SPECULATION_CONTROL_INFORMATION = _SECURE_SPECULATION_CONTROL_INFORMATION;
pub type PSECURE_SPECULATION_CONTROL_INFORMATION = *mut _SECURE_SPECULATION_CONTROL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FIRMWARE_RAMDISK_INFORMATION {
   pub Version: ULONG,
   pub BlockSize: ULONG,
   pub BaseAddress: ULONG_PTR,
   pub Size: SIZE_T,
}
pub type SYSTEM_FIRMWARE_RAMDISK_INFORMATION = _SYSTEM_FIRMWARE_RAMDISK_INFORMATION;
pub type PSYSTEM_FIRMWARE_RAMDISK_INFORMATION = *mut _SYSTEM_FIRMWARE_RAMDISK_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_SHADOW_STACK_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn CetCapable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CetCapable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn UserCetAllowed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UserCetAllowed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedForUserCet(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedForUserCet(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub fn KernelCetEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KernelCetEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KernelCetAuditModeEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KernelCetAuditModeEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedForKernelCet(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedForKernelCet(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      CetCapable: ULONG,
      UserCetAllowed: ULONG,
      ReservedForUserCet: ULONG,
      KernelCetEnabled: ULONG,
      KernelCetAuditModeEnabled: ULONG,
      ReservedForKernelCet: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let CetCapable: u32 = unsafe { ::core::mem::transmute(CetCapable) };
         CetCapable as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let UserCetAllowed: u32 = unsafe { ::core::mem::transmute(UserCetAllowed) };
         UserCetAllowed as u64
      });
      __bindgen_bitfield_unit.set(2usize, 6u8, {
         let ReservedForUserCet: u32 = unsafe { ::core::mem::transmute(ReservedForUserCet) };
         ReservedForUserCet as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let KernelCetEnabled: u32 = unsafe { ::core::mem::transmute(KernelCetEnabled) };
         KernelCetEnabled as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let KernelCetAuditModeEnabled: u32 =
            unsafe { ::core::mem::transmute(KernelCetAuditModeEnabled) };
         KernelCetAuditModeEnabled as u64
      });
      __bindgen_bitfield_unit.set(10usize, 6u8, {
         let ReservedForKernelCet: u32 = unsafe { ::core::mem::transmute(ReservedForKernelCet) };
         ReservedForKernelCet as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_SHADOW_STACK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SHADOW_STACK_INFORMATION = _SYSTEM_SHADOW_STACK_INFORMATION;
pub type PSYSTEM_SHADOW_STACK_INFORMATION = *mut _SYSTEM_SHADOW_STACK_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS {
   pub Value32: ULONG,
   pub __bindgen_anon_1: _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS__bindgen_ty_1 {
   #[inline]
   pub fn IsTopLevel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsTopLevel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsChecked(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsChecked(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsTopLevel: ULONG,
      IsChecked: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsTopLevel: u32 = unsafe { ::core::mem::transmute(IsTopLevel) };
         IsTopLevel as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsChecked: u32 = unsafe { ::core::mem::transmute(IsChecked) };
         IsChecked as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BUILD_VERSION_INFORMATION_FLAGS = _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS;
pub type PSYSTEM_BUILD_VERSION_INFORMATION_FLAGS = *mut _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_BUILD_VERSION_INFORMATION {
   pub LayerNumber: USHORT,
   pub LayerCount: USHORT,
   pub OsMajorVersion: ULONG,
   pub OsMinorVersion: ULONG,
   pub NtBuildNumber: ULONG,
   pub NtBuildQfe: ULONG,
   pub LayerName: [UCHAR; 128usize],
   pub NtBuildBranch: [UCHAR; 128usize],
   pub NtBuildLab: [UCHAR; 128usize],
   pub NtBuildLabEx: [UCHAR; 128usize],
   pub NtBuildStamp: [UCHAR; 26usize],
   pub NtBuildArch: [UCHAR; 16usize],
   pub Flags: SYSTEM_BUILD_VERSION_INFORMATION_FLAGS,
}
impl Default for _SYSTEM_BUILD_VERSION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BUILD_VERSION_INFORMATION = _SYSTEM_BUILD_VERSION_INFORMATION;
pub type PSYSTEM_BUILD_VERSION_INFORMATION = *mut _SYSTEM_BUILD_VERSION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POOL_LIMIT_MEM_INFO {
   pub MemoryLimit: ULONGLONG,
   pub NotificationLimit: ULONGLONG,
}
pub type SYSTEM_POOL_LIMIT_MEM_INFO = _SYSTEM_POOL_LIMIT_MEM_INFO;
pub type PSYSTEM_POOL_LIMIT_MEM_INFO = *mut _SYSTEM_POOL_LIMIT_MEM_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POOL_LIMIT_INFO {
   pub PoolTag: ULONG,
   pub MemLimits: [SYSTEM_POOL_LIMIT_MEM_INFO; 2usize],
   pub NotificationHandle: WNF_STATE_NAME,
}
pub type SYSTEM_POOL_LIMIT_INFO = _SYSTEM_POOL_LIMIT_INFO;
pub type PSYSTEM_POOL_LIMIT_INFO = *mut _SYSTEM_POOL_LIMIT_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POOL_LIMIT_INFORMATION {
   pub Version: ULONG,
   pub EntryCount: ULONG,
   pub LimitEntries: [SYSTEM_POOL_LIMIT_INFO; 1usize],
}
pub type SYSTEM_POOL_LIMIT_INFORMATION = _SYSTEM_POOL_LIMIT_INFORMATION;
pub type PSYSTEM_POOL_LIMIT_INFORMATION = *mut _SYSTEM_POOL_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HV_MINROOT_NUMA_LPS {
   pub NodeIndex: ULONG,
   pub Mask: [ULONG_PTR; 16usize],
}
pub type HV_MINROOT_NUMA_LPS = _HV_MINROOT_NUMA_LPS;
pub type PHV_MINROOT_NUMA_LPS = *mut _HV_MINROOT_NUMA_LPS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_XFG_FAILURE_INFORMATION {
   pub ReturnAddress: PVOID,
   pub TargetAddress: PVOID,
   pub DispatchMode: ULONG,
   pub XfgValue: ULONGLONG,
}
impl Default for _SYSTEM_XFG_FAILURE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_XFG_FAILURE_INFORMATION = _SYSTEM_XFG_FAILURE_INFORMATION;
pub type PSYSTEM_XFG_FAILURE_INFORMATION = *mut _SYSTEM_XFG_FAILURE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_IOMMU_STATE {
   IommuStateBlock = 0,
   IommuStateUnblock = 1,
}
pub use self::_SYSTEM_IOMMU_STATE as SYSTEM_IOMMU_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_IOMMU_STATE_INFORMATION {
   pub State: SYSTEM_IOMMU_STATE,
   pub Pdo: PVOID,
}
impl Default for _SYSTEM_IOMMU_STATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_IOMMU_STATE_INFORMATION = _SYSTEM_IOMMU_STATE_INFORMATION;
pub type PSYSTEM_IOMMU_STATE_INFORMATION = *mut _SYSTEM_IOMMU_STATE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_MINROOT_INFORMATION {
   pub NumProc: ULONG,
   pub RootProc: ULONG,
   pub RootProcNumaNodesSpecified: ULONG,
   pub RootProcNumaNodes: [USHORT; 64usize],
   pub RootProcPerCore: ULONG,
   pub RootProcPerNode: ULONG,
   pub RootProcNumaNodesLpsSpecified: ULONG,
   pub RootProcNumaNodeLps: [HV_MINROOT_NUMA_LPS; 64usize],
}
impl Default for _SYSTEM_HYPERVISOR_MINROOT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HYPERVISOR_MINROOT_INFORMATION = _SYSTEM_HYPERVISOR_MINROOT_INFORMATION;
pub type PSYSTEM_HYPERVISOR_MINROOT_INFORMATION = *mut _SYSTEM_HYPERVISOR_MINROOT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION {
   pub RangeCount: ULONG,
   pub RangeArray: [ULONG_PTR; 1usize],
}
pub type SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION = _SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION;
pub type PSYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION = *mut _SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POINTER_AUTH_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1,
   pub __bindgen_anon_2: _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1 {
   pub SupportedFlags: USHORT,
   pub __bindgen_anon_1: _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn AddressAuthSupported(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_AddressAuthSupported(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AddressAuthQarma(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_AddressAuthQarma(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn GenericAuthSupported(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_GenericAuthSupported(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn GenericAuthQarma(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_GenericAuthQarma(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SupportedReserved(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u16) }
   }
   #[inline]
   pub fn set_SupportedReserved(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      AddressAuthSupported: USHORT,
      AddressAuthQarma: USHORT,
      GenericAuthSupported: USHORT,
      GenericAuthQarma: USHORT,
      SupportedReserved: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let AddressAuthSupported: u16 = unsafe { ::core::mem::transmute(AddressAuthSupported) };
         AddressAuthSupported as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AddressAuthQarma: u16 = unsafe { ::core::mem::transmute(AddressAuthQarma) };
         AddressAuthQarma as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let GenericAuthSupported: u16 = unsafe { ::core::mem::transmute(GenericAuthSupported) };
         GenericAuthSupported as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let GenericAuthQarma: u16 = unsafe { ::core::mem::transmute(GenericAuthQarma) };
         GenericAuthQarma as u64
      });
      __bindgen_bitfield_unit.set(4usize, 12u8, {
         let SupportedReserved: u16 = unsafe { ::core::mem::transmute(SupportedReserved) };
         SupportedReserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2 {
   pub EnabledFlags: USHORT,
   pub __bindgen_anon_1: _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn UserPerProcessIpAuthEnabled(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_UserPerProcessIpAuthEnabled(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn UserGlobalIpAuthEnabled(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_UserGlobalIpAuthEnabled(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn UserEnabledReserved(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u16) }
   }
   #[inline]
   pub fn set_UserEnabledReserved(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub fn KernelIpAuthEnabled(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_KernelIpAuthEnabled(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KernelEnabledReserved(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u16) }
   }
   #[inline]
   pub fn set_KernelEnabledReserved(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      UserPerProcessIpAuthEnabled: USHORT,
      UserGlobalIpAuthEnabled: USHORT,
      UserEnabledReserved: USHORT,
      KernelIpAuthEnabled: USHORT,
      KernelEnabledReserved: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let UserPerProcessIpAuthEnabled: u16 =
            unsafe { ::core::mem::transmute(UserPerProcessIpAuthEnabled) };
         UserPerProcessIpAuthEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let UserGlobalIpAuthEnabled: u16 =
            unsafe { ::core::mem::transmute(UserGlobalIpAuthEnabled) };
         UserGlobalIpAuthEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 6u8, {
         let UserEnabledReserved: u16 = unsafe { ::core::mem::transmute(UserEnabledReserved) };
         UserEnabledReserved as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let KernelIpAuthEnabled: u16 = unsafe { ::core::mem::transmute(KernelIpAuthEnabled) };
         KernelIpAuthEnabled as u64
      });
      __bindgen_bitfield_unit.set(9usize, 7u8, {
         let KernelEnabledReserved: u16 = unsafe { ::core::mem::transmute(KernelEnabledReserved) };
         KernelEnabledReserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_POINTER_AUTH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POINTER_AUTH_INFORMATION = _SYSTEM_POINTER_AUTH_INFORMATION;
pub type PSYSTEM_POINTER_AUTH_INFORMATION = *mut _SYSTEM_POINTER_AUTH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT {
   pub Version: ULONG,
   pub FeatureName: PWSTR,
   pub BornOnVersion: ULONG,
}
impl Default for _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT =
   _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT;
pub type PSYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT =
   *mut _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT;
#[repr(C)]
pub struct _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT {
   pub Version: ULONG,
   pub FeatureIsEnabled: BOOLEAN,
}
impl Default for _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT =
   _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT;
pub type PSYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT =
   *mut _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSDBG_COMMAND {
   SysDbgQueryModuleInformation = 0,
   SysDbgQueryTraceInformation = 1,
   SysDbgSetTracepoint = 2,
   SysDbgSetSpecialCall = 3,
   SysDbgClearSpecialCalls = 4,
   SysDbgQuerySpecialCalls = 5,
   SysDbgBreakPoint = 6,
   SysDbgQueryVersion = 7,
   SysDbgReadVirtual = 8,
   SysDbgWriteVirtual = 9,
   SysDbgReadPhysical = 10,
   SysDbgWritePhysical = 11,
   SysDbgReadControlSpace = 12,
   SysDbgWriteControlSpace = 13,
   SysDbgReadIoSpace = 14,
   SysDbgWriteIoSpace = 15,
   SysDbgReadMsr = 16,
   SysDbgWriteMsr = 17,
   SysDbgReadBusData = 18,
   SysDbgWriteBusData = 19,
   SysDbgCheckLowMemory = 20,
   SysDbgEnableKernelDebugger = 21,
   SysDbgDisableKernelDebugger = 22,
   SysDbgGetAutoKdEnable = 23,
   SysDbgSetAutoKdEnable = 24,
   SysDbgGetPrintBufferSize = 25,
   SysDbgSetPrintBufferSize = 26,
   SysDbgGetKdUmExceptionEnable = 27,
   SysDbgSetKdUmExceptionEnable = 28,
   SysDbgGetTriageDump = 29,
   SysDbgGetKdBlockEnable = 30,
   SysDbgSetKdBlockEnable = 31,
   SysDbgRegisterForUmBreakInfo = 32,
   SysDbgGetUmBreakPid = 33,
   SysDbgClearUmBreakPid = 34,
   SysDbgGetUmAttachPid = 35,
   SysDbgClearUmAttachPid = 36,
   SysDbgGetLiveKernelDump = 37,
   SysDbgKdPullRemoteFile = 38,
   SysDbgMaxInfoClass = 39,
}
pub use self::_SYSDBG_COMMAND as SYSDBG_COMMAND;
pub type PSYSDBG_COMMAND = *mut _SYSDBG_COMMAND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSDBG_VIRTUAL {
   pub Address: PVOID,
   pub Buffer: PVOID,
   pub Request: ULONG,
}
impl Default for _SYSDBG_VIRTUAL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_VIRTUAL = _SYSDBG_VIRTUAL;
pub type PSYSDBG_VIRTUAL = *mut _SYSDBG_VIRTUAL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSDBG_PHYSICAL {
   pub Address: PHYSICAL_ADDRESS,
   pub Buffer: PVOID,
   pub Request: ULONG,
}
impl Default for _SYSDBG_PHYSICAL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_PHYSICAL = _SYSDBG_PHYSICAL;
pub type PSYSDBG_PHYSICAL = *mut _SYSDBG_PHYSICAL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSDBG_CONTROL_SPACE {
   pub Address: ULONG64,
   pub Buffer: PVOID,
   pub Request: ULONG,
   pub Processor: ULONG,
}
impl Default for _SYSDBG_CONTROL_SPACE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_CONTROL_SPACE = _SYSDBG_CONTROL_SPACE;
pub type PSYSDBG_CONTROL_SPACE = *mut _SYSDBG_CONTROL_SPACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSDBG_IO_SPACE {
   pub Address: ULONG64,
   pub Buffer: PVOID,
   pub Request: ULONG,
   pub InterfaceType: _INTERFACE_TYPE,
   pub BusNumber: ULONG,
   pub AddressSpace: ULONG,
}
impl Default for _SYSDBG_IO_SPACE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_IO_SPACE = _SYSDBG_IO_SPACE;
pub type PSYSDBG_IO_SPACE = *mut _SYSDBG_IO_SPACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSDBG_MSR {
   pub Msr: ULONG,
   pub Data: ULONG64,
}
pub type SYSDBG_MSR = _SYSDBG_MSR;
pub type PSYSDBG_MSR = *mut _SYSDBG_MSR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSDBG_BUS_DATA {
   pub Address: ULONG,
   pub Buffer: PVOID,
   pub Request: ULONG,
   pub BusDataType: _BUS_DATA_TYPE,
   pub BusNumber: ULONG,
   pub SlotNumber: ULONG,
}
impl Default for _SYSDBG_BUS_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_BUS_DATA = _SYSDBG_BUS_DATA;
pub type PSYSDBG_BUS_DATA = *mut _SYSDBG_BUS_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSDBG_TRIAGE_DUMP {
   pub Flags: ULONG,
   pub BugCheckCode: ULONG,
   pub BugCheckParam1: ULONG_PTR,
   pub BugCheckParam2: ULONG_PTR,
   pub BugCheckParam3: ULONG_PTR,
   pub BugCheckParam4: ULONG_PTR,
   pub ProcessHandles: ULONG,
   pub ThreadHandles: ULONG,
   pub Handles: PHANDLE,
}
impl Default for _SYSDBG_TRIAGE_DUMP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_TRIAGE_DUMP = _SYSDBG_TRIAGE_DUMP;
pub type PSYSDBG_TRIAGE_DUMP = *mut _SYSDBG_TRIAGE_DUMP;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSDBG_LIVEDUMP_CONTROL_FLAGS {
   pub __bindgen_anon_1: _SYSDBG_LIVEDUMP_CONTROL_FLAGS__bindgen_ty_1,
   pub AsUlong: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_CONTROL_FLAGS__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSDBG_LIVEDUMP_CONTROL_FLAGS__bindgen_ty_1 {
   #[inline]
   pub fn UseDumpStorageStack(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UseDumpStorageStack(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CompressMemoryPagesData(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CompressMemoryPagesData(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IncludeUserSpaceMemoryPages(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IncludeUserSpaceMemoryPages(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AbortIfMemoryPressure(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AbortIfMemoryPressure(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SelectiveDump(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SelectiveDump(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      UseDumpStorageStack: ULONG,
      CompressMemoryPagesData: ULONG,
      IncludeUserSpaceMemoryPages: ULONG,
      AbortIfMemoryPressure: ULONG,
      SelectiveDump: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let UseDumpStorageStack: u32 = unsafe { ::core::mem::transmute(UseDumpStorageStack) };
         UseDumpStorageStack as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let CompressMemoryPagesData: u32 =
            unsafe { ::core::mem::transmute(CompressMemoryPagesData) };
         CompressMemoryPagesData as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IncludeUserSpaceMemoryPages: u32 =
            unsafe { ::core::mem::transmute(IncludeUserSpaceMemoryPages) };
         IncludeUserSpaceMemoryPages as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AbortIfMemoryPressure: u32 = unsafe { ::core::mem::transmute(AbortIfMemoryPressure) };
         AbortIfMemoryPressure as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let SelectiveDump: u32 = unsafe { ::core::mem::transmute(SelectiveDump) };
         SelectiveDump as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSDBG_LIVEDUMP_CONTROL_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_LIVEDUMP_CONTROL_FLAGS = _SYSDBG_LIVEDUMP_CONTROL_FLAGS;
pub type PSYSDBG_LIVEDUMP_CONTROL_FLAGS = *mut _SYSDBG_LIVEDUMP_CONTROL_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES {
   pub __bindgen_anon_1: _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES__bindgen_ty_1,
   pub AsUlong: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES__bindgen_ty_1 {
   #[inline]
   pub fn HypervisorPages(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HypervisorPages(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn NonEssentialHypervisorPages(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NonEssentialHypervisorPages(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      HypervisorPages: ULONG,
      NonEssentialHypervisorPages: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let HypervisorPages: u32 = unsafe { ::core::mem::transmute(HypervisorPages) };
         HypervisorPages as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let NonEssentialHypervisorPages: u32 =
            unsafe { ::core::mem::transmute(NonEssentialHypervisorPages) };
         NonEssentialHypervisorPages as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_LIVEDUMP_CONTROL_ADDPAGES = _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES;
pub type PSYSDBG_LIVEDUMP_CONTROL_ADDPAGES = *mut _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL {
   pub Version: ULONG,
   pub Size: ULONG,
   pub __bindgen_anon_1: _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1,
   pub Reserved: [ULONGLONG; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1 {
   pub Flags: ULONGLONG,
   pub __bindgen_anon_1: _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ThreadKernelStacks(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_ThreadKernelStacks(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 63u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ThreadKernelStacks: ULONGLONG,
      ReservedFlags: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ThreadKernelStacks: u64 = unsafe { ::core::mem::transmute(ThreadKernelStacks) };
         ThreadKernelStacks as u64
      });
      __bindgen_bitfield_unit.set(1usize, 63u8, {
         let ReservedFlags: u64 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_LIVEDUMP_SELECTIVE_CONTROL = _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL;
pub type PSYSDBG_LIVEDUMP_SELECTIVE_CONTROL = *mut _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_CONTROL {
   pub Version: ULONG,
   pub BugCheckCode: ULONG,
   pub BugCheckParam1: ULONG_PTR,
   pub BugCheckParam2: ULONG_PTR,
   pub BugCheckParam3: ULONG_PTR,
   pub BugCheckParam4: ULONG_PTR,
   pub DumpFileHandle: HANDLE,
   pub CancelEventHandle: HANDLE,
   pub Flags: SYSDBG_LIVEDUMP_CONTROL_FLAGS,
   pub AddPagesControl: SYSDBG_LIVEDUMP_CONTROL_ADDPAGES,
   pub SelectiveControl: PSYSDBG_LIVEDUMP_SELECTIVE_CONTROL,
}
impl Default for _SYSDBG_LIVEDUMP_CONTROL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_LIVEDUMP_CONTROL = _SYSDBG_LIVEDUMP_CONTROL;
pub type PSYSDBG_LIVEDUMP_CONTROL = *mut _SYSDBG_LIVEDUMP_CONTROL;
#[repr(C)]
pub struct _SYSDBG_KD_PULL_REMOTE_FILE {
   pub ImageFileName: UNICODE_STRING,
}
impl Default for _SYSDBG_KD_PULL_REMOTE_FILE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_KD_PULL_REMOTE_FILE = _SYSDBG_KD_PULL_REMOTE_FILE;
pub type PSYSDBG_KD_PULL_REMOTE_FILE = *mut _SYSDBG_KD_PULL_REMOTE_FILE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HARDERROR_RESPONSE_OPTION {
   OptionAbortRetryIgnore = 0,
   OptionOk = 1,
   OptionOkCancel = 2,
   OptionRetryCancel = 3,
   OptionYesNo = 4,
   OptionYesNoCancel = 5,
   OptionShutdownSystem = 6,
   OptionOkNoWait = 7,
   OptionCancelTryContinue = 8,
}
pub use self::_HARDERROR_RESPONSE_OPTION as HARDERROR_RESPONSE_OPTION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HARDERROR_RESPONSE {
   ResponseReturnToCaller = 0,
   ResponseNotHandled = 1,
   ResponseAbort = 2,
   ResponseCancel = 3,
   ResponseIgnore = 4,
   ResponseNo = 5,
   ResponseOk = 6,
   ResponseRetry = 7,
   ResponseYes = 8,
   ResponseTryAgain = 9,
   ResponseContinue = 10,
}
pub use self::_HARDERROR_RESPONSE as HARDERROR_RESPONSE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ALTERNATIVE_ARCHITECTURE_TYPE {
   StandardDesign = 0,
   NEC98x86 = 1,
   EndAlternatives = 2,
}
pub use self::_ALTERNATIVE_ARCHITECTURE_TYPE as ALTERNATIVE_ARCHITECTURE_TYPE;
#[repr(C)]
pub struct _KUSER_SHARED_DATA {
   pub TickCountLowDeprecated: ULONG,
   pub TickCountMultiplier: ULONG,
   pub InterruptTime: KSYSTEM_TIME,
   pub SystemTime: KSYSTEM_TIME,
   pub TimeZoneBias: KSYSTEM_TIME,
   pub ImageNumberLow: USHORT,
   pub ImageNumberHigh: USHORT,
   pub NtSystemRoot: [WCHAR; 260usize],
   pub MaxStackTraceDepth: ULONG,
   pub CryptoExponent: ULONG,
   pub TimeZoneId: ULONG,
   pub LargePageMinimum: ULONG,
   pub AitSamplingValue: ULONG,
   pub AppCompatFlag: ULONG,
   pub RNGSeedVersion: ULONGLONG,
   pub GlobalValidationRunlevel: ULONG,
   pub TimeZoneBiasStamp: LONG,
   pub NtBuildNumber: ULONG,
   pub NtProductType: NT_PRODUCT_TYPE,
   pub ProductTypeIsValid: BOOLEAN,
   pub Reserved0: [BOOLEAN; 1usize],
   pub NativeProcessorArchitecture: USHORT,
   pub NtMajorVersion: ULONG,
   pub NtMinorVersion: ULONG,
   pub ProcessorFeatures: [BOOLEAN; 64usize],
   pub Reserved1: ULONG,
   pub Reserved3: ULONG,
   pub TimeSlip: ULONG,
   pub AlternativeArchitecture: ALTERNATIVE_ARCHITECTURE_TYPE,
   pub BootId: ULONG,
   pub SystemExpirationDate: LARGE_INTEGER,
   pub SuiteMask: ULONG,
   pub KdDebuggerEnabled: BOOLEAN,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1,
   pub CyclesPerYield: USHORT,
   pub ActiveConsoleId: ULONG,
   pub DismountCount: ULONG,
   pub ComPlusPackage: ULONG,
   pub LastSystemRITEventTickCount: ULONG,
   pub NumberOfPhysicalPages: ULONG,
   pub SafeBootMode: BOOLEAN,
   pub __bindgen_anon_2: _KUSER_SHARED_DATA__bindgen_ty_2,
   pub Reserved12: [UCHAR; 2usize],
   pub __bindgen_anon_3: _KUSER_SHARED_DATA__bindgen_ty_3,
   pub DataFlagsPad: [ULONG; 1usize],
   pub TestRetInstruction: ULONGLONG,
   pub QpcFrequency: LONGLONG,
   pub SystemCall: ULONG,
   pub Reserved2: ULONG,
   pub SystemCallPad: [ULONGLONG; 2usize],
   pub __bindgen_anon_4: _KUSER_SHARED_DATA__bindgen_ty_4,
   pub Cookie: ULONG,
   pub CookiePad: [ULONG; 1usize],
   pub ConsoleSessionForegroundProcessId: LONGLONG,
   pub TimeUpdateLock: ULONGLONG,
   pub BaselineSystemTimeQpc: ULONGLONG,
   pub BaselineInterruptTimeQpc: ULONGLONG,
   pub QpcSystemTimeIncrement: ULONGLONG,
   pub QpcInterruptTimeIncrement: ULONGLONG,
   pub QpcSystemTimeIncrementShift: UCHAR,
   pub QpcInterruptTimeIncrementShift: UCHAR,
   pub UnparkedProcessorCount: USHORT,
   pub EnclaveFeatureMask: [ULONG; 4usize],
   pub TelemetryCoverageRound: ULONG,
   pub UserModeGlobalLogger: [USHORT; 16usize],
   pub ImageFileExecutionOptions: ULONG,
   pub LangGenerationCount: ULONG,
   pub Reserved4: ULONGLONG,
   pub InterruptTimeBias: ULONGLONG,
   pub QpcBias: ULONGLONG,
   pub ActiveProcessorCount: ULONG,
   pub ActiveGroupCount: UCHAR,
   pub Reserved9: UCHAR,
   pub __bindgen_anon_5: _KUSER_SHARED_DATA__bindgen_ty_5,
   pub TimeZoneBiasEffectiveStart: LARGE_INTEGER,
   pub TimeZoneBiasEffectiveEnd: LARGE_INTEGER,
   pub XState: XSTATE_CONFIGURATION,
   pub FeatureConfigurationChangeStamp: KSYSTEM_TIME,
   pub Spare: ULONG,
   pub UserPointerAuthMask: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_1 {
   pub MitigationPolicies: UCHAR,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn NXSupportPolicy(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_NXSupportPolicy(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn SEHValidationPolicy(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_SEHValidationPolicy(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn CurDirDevicesSkippedForDlls(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_CurDirDevicesSkippedForDlls(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      NXSupportPolicy: UCHAR,
      SEHValidationPolicy: UCHAR,
      CurDirDevicesSkippedForDlls: UCHAR,
      Reserved: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let NXSupportPolicy: u8 = unsafe { ::core::mem::transmute(NXSupportPolicy) };
         NXSupportPolicy as u64
      });
      __bindgen_bitfield_unit.set(2usize, 2u8, {
         let SEHValidationPolicy: u8 = unsafe { ::core::mem::transmute(SEHValidationPolicy) };
         SEHValidationPolicy as u64
      });
      __bindgen_bitfield_unit.set(4usize, 2u8, {
         let CurDirDevicesSkippedForDlls: u8 =
            unsafe { ::core::mem::transmute(CurDirDevicesSkippedForDlls) };
         CurDirDevicesSkippedForDlls as u64
      });
      __bindgen_bitfield_unit.set(6usize, 2u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_2 {
   pub VirtualizationFlags: UCHAR,
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_3 {
   pub SharedDataFlags: ULONG,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1 {
   #[inline]
   pub fn DbgErrorPortPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgErrorPortPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgElevationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgElevationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgVirtEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgVirtEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgInstallerDetectEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgInstallerDetectEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgLkgEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgLkgEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgDynProcessorEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgDynProcessorEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgConsoleBrokerEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgConsoleBrokerEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgSecureBootEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgSecureBootEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgMultiSessionSku(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgMultiSessionSku(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgMultiUsersInSessionSku(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgMultiUsersInSessionSku(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DbgStateSeparationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgStateSeparationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
   }
   #[inline]
   pub fn set_SpareBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 21u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DbgErrorPortPresent: ULONG,
      DbgElevationEnabled: ULONG,
      DbgVirtEnabled: ULONG,
      DbgInstallerDetectEnabled: ULONG,
      DbgLkgEnabled: ULONG,
      DbgDynProcessorEnabled: ULONG,
      DbgConsoleBrokerEnabled: ULONG,
      DbgSecureBootEnabled: ULONG,
      DbgMultiSessionSku: ULONG,
      DbgMultiUsersInSessionSku: ULONG,
      DbgStateSeparationEnabled: ULONG,
      SpareBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DbgErrorPortPresent: u32 = unsafe { ::core::mem::transmute(DbgErrorPortPresent) };
         DbgErrorPortPresent as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let DbgElevationEnabled: u32 = unsafe { ::core::mem::transmute(DbgElevationEnabled) };
         DbgElevationEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let DbgVirtEnabled: u32 = unsafe { ::core::mem::transmute(DbgVirtEnabled) };
         DbgVirtEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let DbgInstallerDetectEnabled: u32 =
            unsafe { ::core::mem::transmute(DbgInstallerDetectEnabled) };
         DbgInstallerDetectEnabled as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let DbgLkgEnabled: u32 = unsafe { ::core::mem::transmute(DbgLkgEnabled) };
         DbgLkgEnabled as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let DbgDynProcessorEnabled: u32 =
            unsafe { ::core::mem::transmute(DbgDynProcessorEnabled) };
         DbgDynProcessorEnabled as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let DbgConsoleBrokerEnabled: u32 =
            unsafe { ::core::mem::transmute(DbgConsoleBrokerEnabled) };
         DbgConsoleBrokerEnabled as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let DbgSecureBootEnabled: u32 = unsafe { ::core::mem::transmute(DbgSecureBootEnabled) };
         DbgSecureBootEnabled as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let DbgMultiSessionSku: u32 = unsafe { ::core::mem::transmute(DbgMultiSessionSku) };
         DbgMultiSessionSku as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let DbgMultiUsersInSessionSku: u32 =
            unsafe { ::core::mem::transmute(DbgMultiUsersInSessionSku) };
         DbgMultiUsersInSessionSku as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let DbgStateSeparationEnabled: u32 =
            unsafe { ::core::mem::transmute(DbgStateSeparationEnabled) };
         DbgStateSeparationEnabled as u64
      });
      __bindgen_bitfield_unit.set(11usize, 21u8, {
         let SpareBits: u32 = unsafe { ::core::mem::transmute(SpareBits) };
         SpareBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_4 {
   pub TickCount: KSYSTEM_TIME,
   pub TickCountQuad: ULONG64,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1 {
   pub ReservedTickCountOverlay: [ULONG; 3usize],
   pub TickCountPad: [ULONG; 1usize],
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_5 {
   pub QpcData: USHORT,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_5__bindgen_ty_1 {
   pub QpcBypassEnabled: UCHAR,
   pub QpcShift: UCHAR,
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _KUSER_SHARED_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KUSER_SHARED_DATA = _KUSER_SHARED_DATA;
pub type PKUSER_SHARED_DATA = *mut _KUSER_SHARED_DATA;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ATOM_INFORMATION_CLASS {
   AtomBasicInformation = 0,
   AtomTableInformation = 1,
}
pub use self::_ATOM_INFORMATION_CLASS as ATOM_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ATOM_BASIC_INFORMATION {
   pub UsageCount: USHORT,
   pub Flags: USHORT,
   pub NameLength: USHORT,
   pub Name: [WCHAR; 1usize],
}
pub type ATOM_BASIC_INFORMATION = _ATOM_BASIC_INFORMATION;
pub type PATOM_BASIC_INFORMATION = *mut _ATOM_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ATOM_TABLE_INFORMATION {
   pub NumberOfAtoms: ULONG,
   pub Atoms: [RTL_ATOM; 1usize],
}
pub type ATOM_TABLE_INFORMATION = _ATOM_TABLE_INFORMATION;
pub type PATOM_TABLE_INFORMATION = *mut _ATOM_TABLE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SHUTDOWN_ACTION {
   ShutdownNoReboot = 0,
   ShutdownReboot = 1,
   ShutdownPowerOff = 2,
   ShutdownRebootForRecovery = 3,
}
pub use self::_SHUTDOWN_ACTION as SHUTDOWN_ACTION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_MESSAGE_TYPE {
   BCD_MESSAGE_TYPE_NONE = 0,
   BCD_MESSAGE_TYPE_TRACE = 1,
   BCD_MESSAGE_TYPE_INFORMATION = 2,
   BCD_MESSAGE_TYPE_WARNING = 3,
   BCD_MESSAGE_TYPE_ERROR = 4,
   BCD_MESSAGE_TYPE_MAXIMUM = 5,
}
pub use self::_BCD_MESSAGE_TYPE as BCD_MESSAGE_TYPE;
pub type BCD_MESSAGE_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(type_: BCD_MESSAGE_TYPE, Message: PWSTR)>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_IMPORT_FLAGS {
   BCD_IMPORT_NONE = 0,
   BCD_IMPORT_DELETE_FIRMWARE_OBJECTS = 1,
}
pub use self::_BCD_IMPORT_FLAGS as BCD_IMPORT_FLAGS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_OPEN_FLAGS {
   BCD_OPEN_NONE = 0,
   BCD_OPEN_OPEN_STORE_OFFLINE = 1,
   BCD_OPEN_SYNC_FIRMWARE_ENTRIES = 2,
}
pub use self::_BCD_OPEN_FLAGS as BCD_OPEN_FLAGS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_OBJECT_TYPE {
   BCD_OBJECT_TYPE_NONE = 0,
   BCD_OBJECT_TYPE_APPLICATION = 1,
   BCD_OBJECT_TYPE_INHERITED = 2,
   BCD_OBJECT_TYPE_DEVICE = 3,
}
pub use self::_BCD_OBJECT_TYPE as BCD_OBJECT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_APPLICATION_OBJECT_TYPE {
   BCD_APPLICATION_OBJECT_NONE = 0,
   BCD_APPLICATION_OBJECT_FIRMWARE_BOOT_MANAGER = 1,
   BCD_APPLICATION_OBJECT_WINDOWS_BOOT_MANAGER = 2,
   BCD_APPLICATION_OBJECT_WINDOWS_BOOT_LOADER = 3,
   BCD_APPLICATION_OBJECT_WINDOWS_RESUME_APPLICATION = 4,
   BCD_APPLICATION_OBJECT_MEMORY_TESTER = 5,
   BCD_APPLICATION_OBJECT_LEGACY_NTLDR = 6,
   BCD_APPLICATION_OBJECT_LEGACY_SETUPLDR = 7,
   BCD_APPLICATION_OBJECT_BOOT_SECTOR = 8,
   BCD_APPLICATION_OBJECT_STARTUP_MODULE = 9,
   BCD_APPLICATION_OBJECT_GENERIC_APPLICATION = 10,
   BCD_APPLICATION_OBJECT_RESERVED = 1048575,
}
pub use self::_BCD_APPLICATION_OBJECT_TYPE as BCD_APPLICATION_OBJECT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_APPLICATION_IMAGE_TYPE {
   BCD_APPLICATION_IMAGE_NONE = 0,
   BCD_APPLICATION_IMAGE_FIRMWARE_APPLICATION = 1,
   BCD_APPLICATION_IMAGE_BOOT_APPLICATION = 2,
   BCD_APPLICATION_IMAGE_LEGACY_LOADER = 3,
   BCD_APPLICATION_IMAGE_REALMODE_CODE = 4,
}
pub use self::_BCD_APPLICATION_IMAGE_TYPE as BCD_APPLICATION_IMAGE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_INHERITED_CLASS_TYPE {
   BCD_INHERITED_CLASS_NONE = 0,
   BCD_INHERITED_CLASS_LIBRARY = 1,
   BCD_INHERITED_CLASS_APPLICATION = 2,
   BCD_INHERITED_CLASS_DEVICE = 3,
}
pub use self::_BCD_INHERITED_CLASS_TYPE as BCD_INHERITED_CLASS_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_OBJECT_DATATYPE {
   pub PackedValue: ULONG,
   pub __bindgen_anon_1: _BCD_OBJECT_DATATYPE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_OBJECT_DATATYPE__bindgen_ty_1 {
   pub __bindgen_anon_1: _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_1,
   pub Application: _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_2,
   pub Inherit: _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_3,
   pub Device: _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub fn ObjectType(&self) -> BCD_OBJECT_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ObjectType(&mut self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Reserved: ULONG,
      ObjectType: BCD_OBJECT_TYPE,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 28u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(28usize, 4u8, {
         let ObjectType: u32 = unsafe { ::core::mem::transmute(ObjectType) };
         ObjectType as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_2 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_2 {
   #[inline]
   pub fn ApplicationType(&self) -> BCD_APPLICATION_OBJECT_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
   }
   #[inline]
   pub fn set_ApplicationType(&mut self, val: BCD_APPLICATION_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 20u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageType(&self) -> BCD_APPLICATION_IMAGE_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ImageType(&mut self, val: BCD_APPLICATION_IMAGE_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn ObjectType(&self) -> BCD_OBJECT_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ObjectType(&mut self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ApplicationType: BCD_APPLICATION_OBJECT_TYPE,
      ImageType: BCD_APPLICATION_IMAGE_TYPE,
      Reserved: ULONG,
      ObjectType: BCD_OBJECT_TYPE,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 20u8, {
         let ApplicationType: u32 = unsafe { ::core::mem::transmute(ApplicationType) };
         ApplicationType as u64
      });
      __bindgen_bitfield_unit.set(20usize, 4u8, {
         let ImageType: u32 = unsafe { ::core::mem::transmute(ImageType) };
         ImageType as u64
      });
      __bindgen_bitfield_unit.set(24usize, 4u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(28usize, 4u8, {
         let ObjectType: u32 = unsafe { ::core::mem::transmute(ObjectType) };
         ObjectType as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_3 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_3 {
   #[inline]
   pub fn Value(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
   }
   #[inline]
   pub fn set_Value(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 20u8, val as u64)
      }
   }
   #[inline]
   pub fn Class(&self) -> BCD_INHERITED_CLASS_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Class(&mut self, val: BCD_INHERITED_CLASS_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn ObjectType(&self) -> BCD_OBJECT_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ObjectType(&mut self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Value: ULONG,
      Class: BCD_INHERITED_CLASS_TYPE,
      Reserved: ULONG,
      ObjectType: BCD_OBJECT_TYPE,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 20u8, {
         let Value: u32 = unsafe { ::core::mem::transmute(Value) };
         Value as u64
      });
      __bindgen_bitfield_unit.set(20usize, 4u8, {
         let Class: u32 = unsafe { ::core::mem::transmute(Class) };
         Class as u64
      });
      __bindgen_bitfield_unit.set(24usize, 4u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(28usize, 4u8, {
         let ObjectType: u32 = unsafe { ::core::mem::transmute(ObjectType) };
         ObjectType as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_4 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_4 {
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub fn ObjectType(&self) -> BCD_OBJECT_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ObjectType(&mut self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Reserved: ULONG,
      ObjectType: BCD_OBJECT_TYPE,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 28u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(28usize, 4u8, {
         let ObjectType: u32 = unsafe { ::core::mem::transmute(ObjectType) };
         ObjectType as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _BCD_OBJECT_DATATYPE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _BCD_OBJECT_DATATYPE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_OBJECT_DATATYPE = _BCD_OBJECT_DATATYPE;
pub type PBCD_OBJECT_DATATYPE = *mut _BCD_OBJECT_DATATYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_OBJECT_DESCRIPTION {
   pub Version: ULONG,
   pub Type: ULONG,
}
pub type BCD_OBJECT_DESCRIPTION = _BCD_OBJECT_DESCRIPTION;
pub type PBCD_OBJECT_DESCRIPTION = *mut _BCD_OBJECT_DESCRIPTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_OBJECT {
   pub Identifer: GUID,
   pub Description: PBCD_OBJECT_DESCRIPTION,
}
impl Default for _BCD_OBJECT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_OBJECT = _BCD_OBJECT;
pub type PBCD_OBJECT = *mut _BCD_OBJECT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_COPY_FLAGS {
   BCD_COPY_NONE = 0,
   BCD_COPY_COPY_CREATE_NEW_OBJECT_IDENTIFIER = 1,
   BCD_COPY_COPY_DELETE_EXISTING_OBJECT = 2,
   BCD_COPY_COPY_UNKNOWN_FIRMWARE_APPLICATION = 4,
   BCD_COPY_IGNORE_SETUP_TEMPLATE_ELEMENTS = 8,
   BCD_COPY_RETAIN_ELEMENT_DATA = 16,
   BCD_COPY_MIGRATE_ELEMENT_DATA = 32,
}
pub use self::_BCD_COPY_FLAGS as BCD_COPY_FLAGS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_ELEMENT_DATATYPE_FORMAT {
   BCD_ELEMENT_DATATYPE_FORMAT_UNKNOWN = 0,
   BCD_ELEMENT_DATATYPE_FORMAT_DEVICE = 1,
   BCD_ELEMENT_DATATYPE_FORMAT_STRING = 2,
   BCD_ELEMENT_DATATYPE_FORMAT_OBJECT = 3,
   BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST = 4,
   BCD_ELEMENT_DATATYPE_FORMAT_INTEGER = 5,
   BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN = 6,
   BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST = 7,
   BCD_ELEMENT_DATATYPE_FORMAT_BINARY = 8,
}
pub use self::_BCD_ELEMENT_DATATYPE_FORMAT as BCD_ELEMENT_DATATYPE_FORMAT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_ELEMENT_DATATYPE_CLASS {
   BCD_ELEMENT_DATATYPE_CLASS_NONE = 0,
   BCD_ELEMENT_DATATYPE_CLASS_LIBRARY = 1,
   BCD_ELEMENT_DATATYPE_CLASS_APPLICATION = 2,
   BCD_ELEMENT_DATATYPE_CLASS_DEVICE = 3,
   BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE = 4,
   BCD_ELEMENT_DATATYPE_CLASS_OEM = 5,
}
pub use self::_BCD_ELEMENT_DATATYPE_CLASS as BCD_ELEMENT_DATATYPE_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_ELEMENT_DEVICE_TYPE {
   BCD_ELEMENT_DEVICE_TYPE_NONE = 0,
   BCD_ELEMENT_DEVICE_TYPE_BOOT_DEVICE = 1,
   BCD_ELEMENT_DEVICE_TYPE_PARTITION = 2,
   BCD_ELEMENT_DEVICE_TYPE_FILE = 3,
   BCD_ELEMENT_DEVICE_TYPE_RAMDISK = 4,
   BCD_ELEMENT_DEVICE_TYPE_UNKNOWN = 5,
   BCD_ELEMENT_DEVICE_TYPE_QUALIFIED_PARTITION = 6,
   BCD_ELEMENT_DEVICE_TYPE_VMBUS = 7,
   BCD_ELEMENT_DEVICE_TYPE_LOCATE_DEVICE = 8,
   BCD_ELEMENT_DEVICE_TYPE_URI = 9,
   BCD_ELEMENT_DEVICE_TYPE_COMPOSITE = 10,
}
pub use self::_BCD_ELEMENT_DEVICE_TYPE as BCD_ELEMENT_DEVICE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DATATYPE {
   pub PackedValue: ULONG,
   pub __bindgen_anon_1: _BCD_ELEMENT_DATATYPE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_ELEMENT_DATATYPE__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _BCD_ELEMENT_DATATYPE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _BCD_ELEMENT_DATATYPE__bindgen_ty_1 {
   #[inline]
   pub fn SubType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_SubType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn Format(&self) -> BCD_ELEMENT_DATATYPE_FORMAT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Format(&mut self, val: BCD_ELEMENT_DATATYPE_FORMAT) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn Class(&self) -> BCD_ELEMENT_DATATYPE_CLASS {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Class(&mut self, val: BCD_ELEMENT_DATATYPE_CLASS) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SubType: ULONG,
      Format: BCD_ELEMENT_DATATYPE_FORMAT,
      Class: BCD_ELEMENT_DATATYPE_CLASS,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 24u8, {
         let SubType: u32 = unsafe { ::core::mem::transmute(SubType) };
         SubType as u64
      });
      __bindgen_bitfield_unit.set(24usize, 4u8, {
         let Format: u32 = unsafe { ::core::mem::transmute(Format) };
         Format as u64
      });
      __bindgen_bitfield_unit.set(28usize, 4u8, {
         let Class: u32 = unsafe { ::core::mem::transmute(Class) };
         Class as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _BCD_ELEMENT_DATATYPE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_ELEMENT_DATATYPE = _BCD_ELEMENT_DATATYPE;
pub type PBCD_ELEMENT_DATATYPE = *mut _BCD_ELEMENT_DATATYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION {
   pub PartitionStyle: ULONG,
   pub Reserved: ULONG,
   pub __bindgen_anon_1: _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1 {
   pub Mbr: _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_1,
   pub Gpt: _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_1 {
   pub DiskSignature: ULONG,
   pub PartitionOffset: ULONG64,
}
impl Default for _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_2 {
   pub DiskSignature: GUID,
   pub PartitionSignature: GUID,
}
impl Default for _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION = _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION;
pub type PBCD_ELEMENT_DEVICE_QUALIFIED_PARTITION = *mut _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BCD_ELEMENT_DEVICE {
   pub DeviceType: ULONG,
   pub AdditionalOptions: GUID,
   pub __bindgen_anon_1: _BCD_ELEMENT_DEVICE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BCD_ELEMENT_DEVICE__bindgen_ty_1 {
   pub File: _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_1,
   pub Partition: _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_2,
   pub Locate: _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_3,
   pub Vmbus: _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_4,
   pub Unknown: _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_5,
   pub QualifiedPartition: BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_1 {
   pub ParentOffset: ULONG,
   pub Path: [WCHAR; 1usize],
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_2 {
   pub Path: [WCHAR; 1usize],
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_3 {
   pub Type: ULONG,
   pub ParentOffset: ULONG,
   pub ElementType: ULONG,
   pub Path: [WCHAR; 1usize],
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_4 {
   pub InterfaceInstance: GUID,
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_5 {
   pub Data: [ULONG; 1usize],
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _BCD_ELEMENT_DEVICE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_ELEMENT_DEVICE = _BCD_ELEMENT_DEVICE;
pub type PBCD_ELEMENT_DEVICE = *mut _BCD_ELEMENT_DEVICE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_ELEMENT_STRING {
   pub Value: [WCHAR; 1usize],
}
pub type BCD_ELEMENT_STRING = _BCD_ELEMENT_STRING;
pub type PBCD_ELEMENT_STRING = *mut _BCD_ELEMENT_STRING;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_ELEMENT_OBJECT {
   pub Object: GUID,
}
pub type BCD_ELEMENT_OBJECT = _BCD_ELEMENT_OBJECT;
pub type PBCD_ELEMENT_OBJECT = *mut _BCD_ELEMENT_OBJECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_ELEMENT_OBJECT_LIST {
   pub ObjectList: [GUID; 1usize],
}
pub type BCD_ELEMENT_OBJECT_LIST = _BCD_ELEMENT_OBJECT_LIST;
pub type PBCD_ELEMENT_OBJECT_LIST = *mut _BCD_ELEMENT_OBJECT_LIST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_ELEMENT_INTEGER {
   pub Value: ULONG64,
}
pub type BCD_ELEMENT_INTEGER = _BCD_ELEMENT_INTEGER;
pub type PBCD_ELEMENT_INTEGER = *mut _BCD_ELEMENT_INTEGER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_ELEMENT_INTEGER_LIST {
   pub Value: [ULONG64; 1usize],
}
pub type BCD_ELEMENT_INTEGER_LIST = _BCD_ELEMENT_INTEGER_LIST;
pub type PBCD_ELEMENT_INTEGER_LIST = *mut _BCD_ELEMENT_INTEGER_LIST;
#[repr(C)]
pub struct _BCD_ELEMENT_BOOLEAN {
   pub Value: BOOLEAN,
}
impl Default for _BCD_ELEMENT_BOOLEAN {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_ELEMENT_BOOLEAN = _BCD_ELEMENT_BOOLEAN;
pub type PBCD_ELEMENT_BOOLEAN = *mut _BCD_ELEMENT_BOOLEAN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BCD_ELEMENT_DESCRIPTION {
   pub Version: ULONG,
   pub Type: ULONG,
   pub DataSize: ULONG,
}
pub type PBCD_ELEMENT_DESCRIPTION = *mut BCD_ELEMENT_DESCRIPTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_ELEMENT {
   pub Description: PBCD_ELEMENT_DESCRIPTION,
   pub Data: PVOID,
}
impl Default for _BCD_ELEMENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_ELEMENT = _BCD_ELEMENT;
pub type PBCD_ELEMENT = *mut _BCD_ELEMENT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_FLAGS {
   BCD_FLAG_NONE = 0,
   BCD_FLAG_QUALIFIED_PARTITION = 1,
   BCD_FLAG_NO_DEVICE_TRANSLATION = 2,
   BCD_FLAG_ENUMERATE_INHERITED_OBJECTS = 4,
   BCD_FLAG_ENUMERATE_DEVICE_OPTIONS = 8,
   BCD_FLAG_OBSERVE_PRECEDENCE = 16,
   BCD_FLAG_DISABLE_VHD_NT_TRANSLATION = 32,
   BCD_FLAG_DISABLE_VHD_DEVICE_DETECTION = 64,
   BCD_FLAG_DISABLE_POLICY_CHECKS = 128,
}
pub use self::_BCD_FLAGS as BCD_FLAGS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdBootMgrElementTypes {
   #[doc = " <summary>\n The order in which BCD objects should be displayed.\n Objects are displayed using the string specified by the BcdLibraryString_Description element.\n </summary>\n <remarks>0x24000001</remarks>"]
   BcdBootMgrObjectList_DisplayOrder = 603979777,
   #[doc = " <summary>\n List of boot environment applications the boot manager should execute.\n The applications are executed in the order they appear in this list.\n If the firmware boot manager does not support loading multiple applications, this list cannot contain more than one entry.\n </summary>\n <remarks>0x24000002</remarks>"]
   BcdBootMgrObjectList_BootSequence = 603979778,
   #[doc = " <summary>\n The default boot environment application to load if the user does not select one.\n </summary>\n <remarks>0x23000003</remarks>"]
   BcdBootMgrObject_DefaultObject = 587202563,
   #[doc = " <summary>\n The maximum number of seconds a boot selection menu is to be displayed to the user.\n The menu is displayed until the user selects an option or the time-out expires.\n If this value is not specified, the boot manager waits for the user to make a selection.\n </summary>\n <remarks>0x25000004</remarks>"]
   BcdBootMgrInteger_Timeout = 620756996,
   #[doc = " <summary>\n Indicates that a resume operation should be attempted during a system restart.\n </summary>\n <remarks>0x26000005</remarks>"]
   BcdBootMgrBoolean_AttemptResume = 637534213,
   #[doc = " <summary>\n The resume application object.\n </summary>\n <remarks>0x23000006</remarks>"]
   BcdBootMgrObject_ResumeObject = 587202566,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x24000007</remarks>"]
   BcdBootMgrObjectList_StartupSequence = 603979783,
   #[doc = " <summary>\n The boot manager tools display order list.\n </summary>\n <remarks>0x24000010</remarks>"]
   BcdBootMgrObjectList_ToolsDisplayOrder = 603979792,
   #[doc = " <summary>\n Forces the display of the legacy boot menu, regardless of the number of OS entries in the BCD store and their BcdOSLoaderInteger_BootMenuPolicy.\n </summary>\n <remarks>0x26000020</remarks>"]
   BcdBootMgrBoolean_DisplayBootMenu = 637534240,
   #[doc = " <summary>\n Indicates whether the display of errors should be suppressed.\n If this setting is enabled, the boot manager exits to the multi-OS menu on OS launch error.\n </summary>\n <remarks>0x26000021</remarks>"]
   BcdBootMgrBoolean_NoErrorDisplay = 637534241,
   #[doc = " <summary>\n The device on which the boot application resides.\n </summary>\n <remarks>0x21000022</remarks>"]
   BcdBootMgrDevice_BcdDevice = 553648162,
   #[doc = " <summary>\n The boot application.\n </summary>\n <remarks>0x22000023</remarks>"]
   BcdBootMgrString_BcdFilePath = 570425379,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x26000024</remarks>"]
   BcdBootMgrBoolean_HormEnabled = 637534244,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x26000025</remarks>"]
   BcdBootMgrBoolean_HiberRoot = 637534245,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000026</remarks>"]
   BcdBootMgrString_PasswordOverride = 570425382,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000027</remarks>"]
   BcdBootMgrString_PinpassPhraseOverride = 570425383,
   #[doc = " <summary>\n Controls whether custom actions are processed before a boot sequence.\n Note This value is supported starting in Windows 8 and Windows Server 2012.\n </summary>\n <remarks>0x26000028</remarks>"]
   BcdBootMgrBoolean_ProcessCustomActionsFirst = 637534248,
   #[doc = " <summary>\n Custom Bootstrap Actions.\n </summary>\n <remarks>0x27000030</remarks>"]
   BcdBootMgrIntegerList_CustomActionsList = 654311472,
   #[doc = " <summary>\n Controls whether a boot sequence persists across multiple boots.\n Note This value is supported starting in Windows 8 and Windows Server 2012.\n </summary>\n <remarks>0x26000031</remarks>"]
   BcdBootMgrBoolean_PersistBootSequence = 637534257,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x26000032</remarks>"]
   BcdBootMgrBoolean_SkipStartupSequence = 637534258,
}
pub use self::_BcdBootMgrElementTypes as BcdBootMgrElementTypes;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_FirstMegabytePolicy {
   #[doc = " <summary>\n Use none of the first megabyte of memory.\n </summary>"]
   FirstMegabytePolicyUseNone = 0,
   #[doc = " <summary>\n Use all of the first megabyte of memory.\n </summary>"]
   FirstMegabytePolicyUseAll = 1,
   #[doc = " <summary>\n Reserved for future use.\n </summary>"]
   FirstMegabytePolicyUsePrivate = 2,
}
pub use self::_BcdLibrary_FirstMegabytePolicy as BcdLibrary_FirstMegabytePolicy;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_DebuggerType {
   DebuggerSerial = 0,
   Debugger1394 = 1,
   DebuggerUsb = 2,
   DebuggerNet = 3,
   DebuggerLocal = 4,
}
pub use self::_BcdLibrary_DebuggerType as BcdLibrary_DebuggerType;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_DebuggerStartPolicy {
   #[doc = " <summary>\n The debugger will start active.\n </summary>"]
   DebuggerStartActive = 0,
   #[doc = " <summary>\n The debugger will start in the auto-enabled state.\n If a debugger is attached it will be used; otherwise the debugger port will be available for other applications.\n </summary>"]
   DebuggerStartAutoEnable = 1,
   #[doc = " <summary>\n The debugger will not start.\n </summary>"]
   DebuggerStartDisable = 2,
}
pub use self::_BcdLibrary_DebuggerStartPolicy as BcdLibrary_DebuggerStartPolicy;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_ConfigAccessPolicy {
   #[doc = " <summary>\n Access to PCI configuration space through the memory-mapped region is allowed.\n </summary>"]
   ConfigAccessPolicyDefault = 0,
   #[doc = " <summary>\n Access to PCI configuration space through the memory-mapped region is not allowed.\n This setting is used for platforms that implement memory-mapped configuration space incorrectly.\n The CFC/CF8 access mechanism can be used to access configuration space on these platforms.\n </summary>"]
   ConfigAccessPolicyDisallowMmConfig = 1,
}
pub use self::_BcdLibrary_ConfigAccessPolicy as BcdLibrary_ConfigAccessPolicy;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_UxDisplayMessageType {
   DisplayMessageTypeDefault = 0,
   DisplayMessageTypeResume = 1,
   DisplayMessageTypeHyperV = 2,
   DisplayMessageTypeRecovery = 3,
   DisplayMessageTypeStartupRepair = 4,
   DisplayMessageTypeSystemImageRecovery = 5,
   DisplayMessageTypeCommandPrompt = 6,
   DisplayMessageTypeSystemRestore = 7,
   DisplayMessageTypePushButtonReset = 8,
}
pub use self::_BcdLibrary_UxDisplayMessageType as BcdLibrary_UxDisplayMessageType;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BcdLibrary_SafeBoot {
   #[doc = " <summary>\n Load the drivers and services specified by name or group under the following registry key:\n HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Minimal.\n </summary>"]
   SafemodeMinimal = 0,
   #[doc = " <summary>\n Load the drivers and services specified by name or group under the following registry key:\n HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Network\n </summary>"]
   SafemodeNetwork = 1,
   #[doc = " <summary>\n Boot the system into a repair mode that restores the Active Directory service from backup medium.\n </summary>"]
   SafemodeDsRepair = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibraryElementTypes {
   #[doc = " <summary>\n Device on which a boot environment application resides.\n </summary>\n <remarks>0x11000001</remarks>"]
   BcdLibraryDevice_ApplicationDevice = 285212673,
   #[doc = " <summary>\n Path to a boot environment application.\n </summary>\n <remarks>0x12000002</remarks>"]
   BcdLibraryString_ApplicationPath = 301989890,
   #[doc = " <summary>\n Display name of the boot environment application.\n </summary>\n <remarks>0x12000004</remarks>"]
   BcdLibraryString_Description = 301989892,
   #[doc = " <summary>\n Preferred locale, in RFC 3066 format.\n </summary>\n <remarks>0x12000005</remarks>"]
   BcdLibraryString_PreferredLocale = 301989893,
   #[doc = " <summary>\n List of BCD objects from which the current object should inherit elements.\n </summary>\n <remarks>0x14000006</remarks>"]
   BcdLibraryObjectList_InheritedObjects = 335544326,
   #[doc = " <summary>\n Maximum physical address a boot environment application should recognize. All memory above this address is ignored.\n </summary>\n <remarks>0x15000007</remarks>"]
   BcdLibraryInteger_TruncatePhysicalMemory = 352321543,
   #[doc = " <summary>\n List of boot environment applications to be executed if the associated application fails. The applications are executed in the order they appear in this list.\n </summary>\n <remarks>0x14000008</remarks>"]
   BcdLibraryObjectList_RecoverySequence = 335544328,
   #[doc = " <summary>\n Indicates whether the recovery sequence executes automatically if the boot application fails. Otherwise, the recovery sequence only runs on demand.\n </summary>\n <remarks>0x16000009</remarks>"]
   BcdLibraryBoolean_AutoRecoveryEnabled = 369098761,
   #[doc = " <summary>\n List of page frame numbers describing faulty memory in the system.\n </summary>\n <remarks>0x1700000A</remarks>"]
   BcdLibraryIntegerList_BadMemoryList = 385875978,
   #[doc = " <summary>\n If TRUE, indicates that a boot application can use memory listed in the BcdLibraryIntegerList_BadMemoryList.\n </summary>\n <remarks>0x1600000B</remarks>"]
   BcdLibraryBoolean_AllowBadMemoryAccess = 369098763,
   #[doc = " <summary>\n Indicates how the first megabyte of memory is to be used. The Integer property is one of the values from the BcdLibrary_FirstMegabytePolicy enumeration.\n </summary>\n <remarks>0x1500000C</remarks>"]
   BcdLibraryInteger_FirstMegabytePolicy = 352321548,
   #[doc = " <summary>\n Relocates physical memory on certain AMD processors.\n This value is not used in Windows 8 or Windows Server 2012.\n </summary>\n <remarks>0x1500000D</remarks>"]
   BcdLibraryInteger_RelocatePhysicalMemory = 352321549,
   #[doc = " <summary>\n Specifies a minimum physical address to use in the boot environment.\n </summary>\n <remarks>0x1500000E</remarks>"]
   BcdLibraryInteger_AvoidLowPhysicalMemory = 352321550,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1600000F</remarks>"]
   BcdLibraryBoolean_TraditionalKsegMappings = 369098767,
   #[doc = " <summary>\n Indicates whether the boot debugger should be enabled.\n </summary>\n <remarks>0x16000010</remarks>"]
   BcdLibraryBoolean_DebuggerEnabled = 369098768,
   #[doc = " <summary>\n Debugger type. The Integer property is one of the values from the BcdLibrary_DebuggerType enumeration.\n </summary>\n <remarks>0x15000011</remarks>"]
   BcdLibraryInteger_DebuggerType = 352321553,
   #[doc = " <summary>\n I/O port address for the serial debugger.\n </summary>\n <remarks>0x15000012</remarks>"]
   BcdLibraryInteger_SerialDebuggerPortAddress = 352321554,
   #[doc = " <summary>\n Serial port number for serial debugging.\n If this value is not specified, the default is specified by the DBGP ACPI table settings.\n </summary>\n <remarks>0x15000013</remarks>"]
   BcdLibraryInteger_SerialDebuggerPort = 352321555,
   #[doc = " <summary>\n Baud rate for serial debugging.\n </summary>\n <remarks>0x15000014</remarks>"]
   BcdLibraryInteger_SerialDebuggerBaudRate = 352321556,
   #[doc = " <summary>\n Channel number for 1394 debugging.\n </summary>\n <remarks>0x15000015</remarks>"]
   BcdLibraryInteger_1394DebuggerChannel = 352321557,
   #[doc = " <summary>\n The target name for the USB debugger. The target name is arbitrary but must match between the debugger and the debug target.\n </summary>\n <remarks>0x12000016</remarks>"]
   BcdLibraryString_UsbDebuggerTargetName = 301989910,
   #[doc = " <summary>\n If TRUE, the debugger will ignore user mode exceptions and only stop for kernel mode exceptions.\n </summary>\n <remarks>0x16000017</remarks>"]
   BcdLibraryBoolean_DebuggerIgnoreUsermodeExceptions = 369098775,
   #[doc = " <summary>\n Indicates the debugger start policy. The Integer property is one of the values from the BcdLibrary_DebuggerStartPolicy enumeration.\n </summary>\n <remarks>0x15000018</remarks>"]
   BcdLibraryInteger_DebuggerStartPolicy = 352321560,
   #[doc = " <summary>\n Defines the PCI bus, device, and function numbers of the debugging device. For example, 1.5.0 describes the debugging device on bus 1, device 5, function 0.\n </summary>\n <remarks>0x12000019</remarks>"]
   BcdLibraryString_DebuggerBusParameters = 301989913,
   #[doc = " <summary>\n Defines the host IP address for the network debugger.\n </summary>\n <remarks>0x1500001A</remarks>"]
   BcdLibraryInteger_DebuggerNetHostIP = 352321562,
   #[doc = " <summary>\n Defines the network port for the network debugger.\n </summary>\n <remarks>0x1500001B</remarks>"]
   BcdLibraryInteger_DebuggerNetPort = 352321563,
   #[doc = " <summary>\n Controls the use of DHCP by the network debugger. Setting this to false causes the OS to only use link-local addresses.\n This value is supported starting in Windows 8 and Windows Server 2012.\n </summary>\n <remarks>0x1600001C</remarks>"]
   BcdLibraryBoolean_DebuggerNetDhcp = 369098780,
   #[doc = " <summary>\n Holds the key used to encrypt the network debug connection.\n This value is supported starting in Windows 8 and Windows Server 2012.\n </summary>\n <remarks>0x1200001D</remarks>"]
   BcdLibraryString_DebuggerNetKey = 301989917,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1600001E</remarks>"]
   BcdLibraryBoolean_DebuggerNetVM = 369098782,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1200001F</remarks>"]
   BcdLibraryString_DebuggerNetHostIpv6 = 301989919,
   #[doc = " <summary>\n Indicates whether EMS redirection should be enabled.\n </summary>\n <remarks>0x16000020</remarks>"]
   BcdLibraryBoolean_EmsEnabled = 369098784,
   #[doc = " <summary>\n COM port number for EMS redirection.\n </summary>\n <remarks>0x15000022</remarks>"]
   BcdLibraryInteger_EmsPort = 352321570,
   #[doc = " <summary>\n Baud rate for EMS redirection.\n </summary>\n <remarks>0x15000023</remarks>"]
   BcdLibraryInteger_EmsBaudRate = 352321571,
   #[doc = " <summary>\n String that is appended to the load options string passed to the kernel to be consumed by kernel-mode components.\n This is useful for communicating with kernel-mode components that are not BCD-aware.\n </summary>\n <remarks>0x12000030</remarks>"]
   BcdLibraryString_LoadOptionsString = 301989936,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x16000031</remarks>"]
   BcdLibraryBoolean_AttemptNonBcdStart = 369098801,
   #[doc = " <summary>\n Indicates whether the advanced options boot menu (F8) is displayed.\n </summary>\n <remarks>0x16000040</remarks>"]
   BcdLibraryBoolean_DisplayAdvancedOptions = 369098816,
   #[doc = " <summary>\n Indicates whether the boot options editor is enabled.\n </summary>\n <remarks>0x16000041</remarks>"]
   BcdLibraryBoolean_DisplayOptionsEdit = 369098817,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x15000042</remarks>"]
   BcdLibraryInteger_FVEKeyRingAddress = 352321602,
   #[doc = " <summary>\n Allows a device override for the bootstat.dat log in the boot manager and winload.exe.\n </summary>\n <remarks>0x11000043</remarks>"]
   BcdLibraryDevice_BsdLogDevice = 285212739,
   #[doc = " <summary>\n Allows a path override for the bootstat.dat log file in the boot manager and winload.exe.\n </summary>\n <remarks>0x12000044</remarks>"]
   BcdLibraryString_BsdLogPath = 301989956,
   #[doc = " <summary>\n Indicates whether graphics mode is disabled and boot applications must use text mode display.\n </summary>\n <remarks>0x16000045</remarks>"]
   BcdLibraryBoolean_BsdPreserveLog = 369098821,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x16000046</remarks>"]
   BcdLibraryBoolean_GraphicsModeDisabled = 369098822,
   #[doc = " <summary>\n Indicates the access policy for PCI configuration space.\n </summary>\n <remarks>0x15000047</remarks>"]
   BcdLibraryInteger_ConfigAccessPolicy = 352321607,
   #[doc = " <summary>\n Disables integrity checks.\n Cannot be set when secure boot is enabled.\n This value is ignored by Windows 7 and Windows 8.\n </summary>\n <remarks>0x16000048</remarks>"]
   BcdLibraryBoolean_DisableIntegrityChecks = 369098824,
   #[doc = " <summary>\n Indicates whether the test code signing certificate is supported.\n </summary>\n <remarks>0x16000049</remarks>"]
   BcdLibraryBoolean_AllowPrereleaseSignatures = 369098825,
   #[doc = " <summary>\n Overrides the default location of the boot fonts.\n </summary>\n <remarks>0x1200004A</remarks>"]
   BcdLibraryString_FontPath = 301989962,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1500004B</remarks>"]
   BcdLibraryInteger_SiPolicy = 352321611,
   #[doc = " <summary>\n This value (if present) should not be modified.\n </summary>\n <remarks>0x1500004C</remarks>"]
   BcdLibraryInteger_FveBandId = 352321612,
   #[doc = " <summary>\n Specifies that legacy BIOS systems should use INT 16h Function 10h for console input instead of INT 16h Function 0h.\n </summary>\n <remarks>0x16000050</remarks>"]
   BcdLibraryBoolean_ConsoleExtendedInput = 369098832,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x15000051</remarks>"]
   BcdLibraryInteger_InitialConsoleInput = 352321617,
   #[doc = " <summary>\n Forces a specific graphics resolution at boot.\n Possible values include GraphicsResolution1024x768 (0), GraphicsResolution800x600 (1), and GraphicsResolution1024x600 (2).\n </summary>\n <remarks>0x15000052</remarks>"]
   BcdLibraryInteger_GraphicsResolution = 352321618,
   #[doc = " <summary>\n If enabled, specifies that boot error screens are not shown when OS launch errors occur, and the system is reset rather than exiting directly back to the firmware.\n </summary>\n <remarks>0x16000053</remarks>"]
   BcdLibraryBoolean_RestartOnFailure = 369098835,
   #[doc = " <summary>\n Forces highest available graphics resolution at boot.\n This value can only be used on UEFI systems.\n This value is supported starting in Windows 8 and Windows Server 2012.\n </summary>\n <remarks>0x16000054</remarks>"]
   BcdLibraryBoolean_GraphicsForceHighestMode = 369098836,
   #[doc = " <summary>\n This setting is used to differentiate between the Windows 7 and Windows 8 implementations of UEFI.\n Do not modify this setting.\n If this setting is removed from a Windows 8 installation, it will not boot.\n If this setting is added to a Windows 7 installation, it will not boot.\n </summary>\n <remarks>0x16000060</remarks>"]
   BcdLibraryBoolean_IsolatedExecutionContext = 369098848,
   #[doc = " <summary>\n This setting disables the progress bar and default Windows logo. If a custom text string has been defined, it is also disabled by this setting.\n The Integer property is one of the values from the BcdLibrary_UxDisplayMessageType enumeration.\n </summary>\n <remarks>0x15000065</remarks>"]
   BcdLibraryInteger_BootUxDisplayMessage = 352321637,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x15000066</remarks>"]
   BcdLibraryInteger_BootUxDisplayMessageOverride = 352321638,
   #[doc = " <summary>\n This setting disables the boot logo.\n </summary>\n <remarks>0x16000067</remarks>"]
   BcdLibraryBoolean_BootUxLogoDisable = 369098855,
   #[doc = " <summary>\n This setting disables the boot status text.\n </summary>\n <remarks>0x16000068</remarks>"]
   BcdLibraryBoolean_BootUxTextDisable = 369098856,
   #[doc = " <summary>\n This setting disables the boot progress bar.\n </summary>\n <remarks>0x16000069</remarks>"]
   BcdLibraryBoolean_BootUxProgressDisable = 369098857,
   #[doc = " <summary>\n This setting disables the boot transition fading.\n </summary>\n <remarks>0x1600006A</remarks>"]
   BcdLibraryBoolean_BootUxFadeDisable = 369098858,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1600006B</remarks>"]
   BcdLibraryBoolean_BootUxReservePoolDebug = 369098859,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1600006C</remarks>"]
   BcdLibraryBoolean_BootUxDisable = 369098860,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1500006D</remarks>"]
   BcdLibraryInteger_BootUxFadeFrames = 352321645,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1600006E</remarks>"]
   BcdLibraryBoolean_BootUxDumpStats = 369098862,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1600006F</remarks>"]
   BcdLibraryBoolean_BootUxShowStats = 369098863,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x16000071</remarks>"]
   BcdLibraryBoolean_MultiBootSystem = 369098865,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x16000072</remarks>"]
   BcdLibraryBoolean_ForceNoKeyboard = 369098866,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x15000073</remarks>"]
   BcdLibraryInteger_AliasWindowsKey = 352321651,
   #[doc = " <summary>\n Disables the 1-minute timer that triggers shutdown on boot error screens, and the F8 menu, on UEFI systems.\n </summary>\n <remarks>0x16000074</remarks>"]
   BcdLibraryBoolean_BootShutdownDisabled = 369098868,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x15000075</remarks>"]
   BcdLibraryInteger_PerformanceFrequency = 352321653,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x15000076</remarks>"]
   BcdLibraryInteger_SecurebootRawPolicy = 352321654,
   #[doc = " <summary>\n Indicates whether or not an in-memory BCD setting passed between boot apps will trigger BitLocker recovery.\n This value should not be modified as it could trigger a BitLocker recovery action.\n </summary>\n <remarks>0x17000077</remarks>"]
   BcdLibraryIntegerList_AllowedInMemorySettings = 352321655,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x15000079</remarks>"]
   BcdLibraryInteger_BootUxBitmapTransitionTime = 352321657,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1600007A</remarks>"]
   BcdLibraryBoolean_TwoBootImages = 369098874,
   #[doc = " <summary>\n Force the use of FIPS cryptography checks on boot applications.\n BcdLibraryBoolean_ForceFipsCrypto is documented with wrong value 0x16000079\n </summary>\n <remarks>0x1600007B</remarks>"]
   BcdLibraryBoolean_ForceFipsCrypto = 369098875,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1500007D</remarks>"]
   BcdLibraryInteger_BootErrorUx = 352321661,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1600007E</remarks>"]
   BcdLibraryBoolean_AllowFlightSignatures = 369098878,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x1500007F</remarks>"]
   BcdLibraryInteger_BootMeasurementLogFormat = 352321663,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x15000080</remarks>"]
   BcdLibraryInteger_DisplayRotation = 352321664,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x15000081</remarks>"]
   BcdLibraryInteger_LogControl = 352321665,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x16000082</remarks>"]
   BcdLibraryBoolean_NoFirmwareSync = 369098882,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x11000084</remarks>"]
   BcdLibraryDevice_WindowsSystemDevice = 285212804,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x16000087</remarks>"]
   BcdLibraryBoolean_NumLockOn = 369098887,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x12000088</remarks>"]
   BcdLibraryString_AdditionalCiPolicy = 301990024,
}
pub use self::_BcdLibraryElementTypes as BcdLibraryElementTypes;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdTemplateElementTypes {
   #[doc = " <summary>\n\n </summary>\n <remarks>0x45000001</remarks>"]
   BcdSetupInteger_DeviceType = 1157627905,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x42000002</remarks>"]
   BcdSetupString_ApplicationRelativePath = 1107296258,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x42000003</remarks>"]
   BcdSetupString_RamdiskDeviceRelativePath = 1107296259,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x46000004</remarks>"]
   BcdSetupBoolean_OmitOsLoaderElements = 1174405124,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x47000006</remarks>"]
   BcdSetupIntegerList_ElementsToMigrateList = 1191182342,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x46000010</remarks>"]
   BcdSetupBoolean_RecoveryOs = 1174405136,
}
pub use self::_BcdTemplateElementTypes as BcdTemplateElementTypes;
#[repr(i32)]
#[non_exhaustive]
#[doc = " <summary>\n Specifies the no-execute page protection policies.\n </summary>"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdOSLoader_NxPolicy {
   #[doc = " <summary>\n The no-execute page protection is off by default.\n </summary>"]
   NxPolicyOptIn = 0,
   #[doc = " <summary>\n The no-execute page protection is on by default.\n </summary>"]
   NxPolicyOptOut = 1,
   #[doc = " <summary>\n The no-execute page protection is always off.\n </summary>"]
   NxPolicyAlwaysOff = 2,
   #[doc = " <summary>\n The no-execute page protection is always on.\n </summary>"]
   NxPolicyAlwaysOn = 3,
}
#[doc = " <summary>\n Specifies the no-execute page protection policies.\n </summary>"]
pub use self::_BcdOSLoader_NxPolicy as BcdOSLoader_NxPolicy;
#[repr(i32)]
#[non_exhaustive]
#[doc = " <summary>\n Specifies the Physical Address Extension (PAE) policies.\n </summary>"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdOSLoader_PAEPolicy {
   #[doc = " <summary>\n Enable PAE if hot-pluggable memory is defined above 4GB.\n </summary>"]
   PaePolicyDefault = 0,
   #[doc = " <summary>\n PAE is enabled.\n </summary>"]
   PaePolicyForceEnable = 1,
   #[doc = " <summary>\n PAE is disabled.\n </summary>"]
   PaePolicyForceDisable = 2,
}
#[doc = " <summary>\n Specifies the Physical Address Extension (PAE) policies.\n </summary>"]
pub use self::_BcdOSLoader_PAEPolicy as BcdOSLoader_PAEPolicy;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdOSLoader_BootStatusPolicy {
   #[doc = " <summary>\n Display all boot failures.\n </summary>"]
   BootStatusPolicyDisplayAllFailures = 0,
   #[doc = " <summary>\n Ignore all boot failures.\n </summary>"]
   BootStatusPolicyIgnoreAllFailures = 1,
   #[doc = " <summary>\n Ignore all shutdown failures.\n </summary>"]
   BootStatusPolicyIgnoreShutdownFailures = 2,
   #[doc = " <summary>\n Ignore all boot failures.\n </summary>"]
   BootStatusPolicyIgnoreBootFailures = 3,
   #[doc = " <summary>\n Ignore checkpoint failures.\n </summary>"]
   BootStatusPolicyIgnoreCheckpointFailures = 4,
   #[doc = " <summary>\n Display shutdown failures.\n </summary>"]
   BootStatusPolicyDisplayShutdownFailures = 5,
   #[doc = " <summary>\n Display boot failures.\n </summary>"]
   BootStatusPolicyDisplayBootFailures = 6,
   #[doc = " <summary>\n Display checkpoint failures.\n </summary>"]
   BootStatusPolicyDisplayCheckpointFailures = 7,
}
pub use self::_BcdOSLoader_BootStatusPolicy as BcdOSLoaderBootStatusPolicy;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdOSLoaderElementTypes {
   #[doc = " <summary>\n The device on which the operating system resides.\n </summary>\n <remarks>0x21000001</remarks>"]
   BcdOSLoaderDevice_OSDevice = 553648129,
   #[doc = " <summary>\n The file path to the operating system (%SystemRoot% minus the volume).\n </summary>\n <remarks>0x22000002</remarks>"]
   BcdOSLoaderString_SystemRoot = 570425346,
   #[doc = " <summary>\n The resume application associated with the operating system.\n </summary>\n <remarks>0x23000003</remarks>"]
   BcdOSLoaderObject_AssociatedResumeObject = 587202563,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x26000004</remarks>"]
   BcdOSLoaderBoolean_StampDisks = 637534212,
   #[doc = " <summary>\n Indicates whether the operating system loader should determine the kernel and HAL to load based on the platform features.\n </summary>\n <remarks>0x26000010</remarks>"]
   BcdOSLoaderBoolean_DetectKernelAndHal = 637534224,
   #[doc = " <summary>\n The kernel to be loaded by the operating system loader. This value overrides the default kernel.\n </summary>\n <remarks>0x22000011</remarks>"]
   BcdOSLoaderString_KernelPath = 570425361,
   #[doc = " <summary>\n The HAL to be loaded by the operating system loader. This value overrides the default HAL.\n </summary>\n <remarks>0x22000012</remarks>"]
   BcdOSLoaderString_HalPath = 570425362,
   #[doc = " <summary>\n The transport DLL to be loaded by the operating system loader. This value overrides the default Kdcom.dll.\n </summary>\n <remarks>0x22000013</remarks>"]
   BcdOSLoaderString_DbgTransportPath = 570425363,
   #[doc = " <summary>\n The no-execute page protection policy. The Integer property is one of the values from the BcdOSLoader_NxPolicy enumeration.\n </summary>\n <remarks>0x25000020</remarks>"]
   BcdOSLoaderInteger_NxPolicy = 620757024,
   #[doc = " <summary>\n The Physical Address Extension (PAE) policy. The Integer property is one of the values from the BcdOSLoader_PAEPolicy enumeration.\n </summary>\n <remarks>0x25000021</remarks>"]
   BcdOSLoaderInteger_PAEPolicy = 620757025,
   #[doc = " <summary>\n Indicates that the system should be started in Windows Preinstallation Environment (Windows PE) mode.\n </summary>\n <remarks>0x26000022</remarks>"]
   BcdOSLoaderBoolean_WinPEMode = 637534242,
   #[doc = " <summary>\n Indicates that the system should not automatically reboot when it crashes.\n </summary>\n <remarks>0x26000024</remarks>"]
   BcdOSLoaderBoolean_DisableCrashAutoReboot = 637534244,
   #[doc = " <summary>\n Indicates that the system should use the last-known good settings.\n </summary>\n <remarks>0x26000025</remarks>"]
   BcdOSLoaderBoolean_UseLastGoodSettings = 637534245,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x26000026</remarks>"]
   BcdOSLoaderBoolean_DisableCodeIntegrityChecks = 637534246,
   #[doc = " <summary>\n Indicates whether the test code signing certificate is supported.\n </summary>\n <remarks>0x26000027</remarks>"]
   BcdOSLoaderBoolean_AllowPrereleaseSignatures = 637534247,
   #[doc = " <summary>\n Indicates whether the system should utilize the first 4GB of physical memory.\n This option requires 5GB of physical memory, and on x86 systems it requires PAE to be enabled.\n </summary>\n <remarks>0x26000030</remarks>"]
   BcdOSLoaderBoolean_NoLowMemory = 637534256,
   #[doc = " <summary>\n The amount of memory the system should ignore.\n </summary>\n <remarks>0x25000031</remarks>"]
   BcdOSLoaderInteger_RemoveMemory = 620757041,
   #[doc = " <summary>\n The amount of memory that should be utilized by the process address space, in bytes.\n This value should be between 2GB and 3GB.\n Increasing this value from the default 2GB decreases the amount of virtual address space available to the system and device drivers.\n </summary>\n <remarks>0x25000032</remarks>"]
   BcdOSLoaderInteger_IncreaseUserVa = 620757042,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000033</remarks>"]
   BcdOSLoaderInteger_PerformaceDataMemory = 620757043,
   #[doc = " <summary>\n Indicates whether the system should use the standard VGA display driver instead of a high-performance display driver.\n </summary>\n <remarks>0x26000040</remarks>"]
   BcdOSLoaderBoolean_UseVgaDriver = 637534272,
   #[doc = " <summary>\n Indicates whether the system should initialize the VGA driver responsible for displaying simple graphics during the boot process.\n If not, there is no display is presented during the boot process.\n </summary>\n <remarks>0x26000041</remarks>"]
   BcdOSLoaderBoolean_DisableBootDisplay = 637534273,
   #[doc = " <summary>\n Indicates whether the VGA driver should avoid VESA BIOS calls.\n Note This value is ignored by Windows 8 and Windows Server 2012.\n </summary>\n <remarks>0x26000042</remarks>"]
   BcdOSLoaderBoolean_DisableVesaBios = 637534274,
   #[doc = " <summary>\n Disables the use of VGA modes in the OS.\n </summary>\n <remarks>0x26000043</remarks>"]
   BcdOSLoaderBoolean_DisableVgaMode = 637534275,
   #[doc = " <summary>\n Indicates that cluster-mode APIC addressing should be utilized, and the value is the maximum number of processors per cluster.\n </summary>\n <remarks>0x25000050</remarks>"]
   BcdOSLoaderInteger_ClusterModeAddressing = 620757072,
   #[doc = " <summary>\n Indicates whether to enable physical-destination mode for all APIC messages.\n </summary>\n <remarks>0x26000051</remarks>"]
   BcdOSLoaderBoolean_UsePhysicalDestination = 637534289,
   #[doc = " <summary>\n The maximum number of APIC clusters that should be used by cluster-mode addressing.\n </summary>\n <remarks>0x25000052</remarks>"]
   BcdOSLoaderInteger_RestrictApicCluster = 620757074,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000053</remarks>"]
   BcdOSLoaderString_OSLoaderTypeEVStore = 570425427,
   #[doc = " <summary>\n Used to force legacy APIC mode, even if the processors and chipset support extended APIC mode.\n </summary>\n <remarks>0x26000054</remarks>"]
   BcdOSLoaderBoolean_UseLegacyApicMode = 637534292,
   #[doc = " <summary>\n Enables the use of extended APIC mode, if supported.\n Zero (0) indicates default behavior, one (1) indicates that extended APIC mode is disabled, and two (2) indicates that extended APIC mode is enabled.\n The system defaults to using extended APIC mode if available.\n </summary>\n <remarks>0x25000055</remarks>"]
   BcdOSLoaderInteger_X2ApicPolicy = 620757077,
   #[doc = " <summary>\n Indicates whether the operating system should initialize or start non-boot processors.\n </summary>\n <remarks>0x26000060</remarks>"]
   BcdOSLoaderBoolean_UseBootProcessorOnly = 637534304,
   #[doc = " <summary>\n The maximum number of processors that can be utilized by the system; all other processors are ignored.\n </summary>\n <remarks>0x25000061</remarks>"]
   BcdOSLoaderInteger_NumberOfProcessors = 620757089,
   #[doc = " <summary>\n Indicates whether the system should use the maximum number of processors.\n </summary>\n <remarks>0x26000062</remarks>"]
   BcdOSLoaderBoolean_ForceMaximumProcessors = 637534306,
   #[doc = " <summary>\n Indicates whether processor specific configuration flags are to be used.\n </summary>\n <remarks>0x25000063</remarks>"]
   BcdOSLoaderBoolean_ProcessorConfigurationFlags = 620757091,
   #[doc = " <summary>\n Maximizes the number of groups created when assigning nodes to processor groups.\n </summary>\n <remarks>0x26000064</remarks>"]
   BcdOSLoaderBoolean_MaximizeGroupsCreated = 637534308,
   #[doc = " <summary>\n This setting makes drivers group aware and can be used to determine improper group usage.\n </summary>\n <remarks>0x26000065</remarks>"]
   BcdOSLoaderBoolean_ForceGroupAwareness = 637534309,
   #[doc = " <summary>\n Specifies the size of all processor groups. Must be set to a power of 2.\n </summary>\n <remarks>0x25000066</remarks>"]
   BcdOSLoaderInteger_GroupSize = 620757094,
   #[doc = " <summary>\n Indicates whether the system should use I/O and IRQ resources created by the system firmware instead of using dynamically configured resources.\n </summary>\n <remarks>0x26000070</remarks>"]
   BcdOSLoaderInteger_UseFirmwarePciSettings = 637534320,
   #[doc = " <summary>\n The PCI Message Signaled Interrupt (MSI) policy. Zero (0) indicates default, and one (1) indicates that MSI interrupts are disabled.\n </summary>\n <remarks>0x25000071</remarks>"]
   BcdOSLoaderInteger_MsiPolicy = 620757105,
   #[doc = " <summary>\n Undocumented. Zero (0) indicates default, and one (1) indicates that PCI Express is forcefully disabled.\n </summary>\n <remarks>0x25000072</remarks>"]
   BcdOSLoaderInteger_PciExpressPolicy = 620757106,
   #[doc = " <summary>\n The Integer property is one of the values from the BcdLibrary_SafeBoot enumeration.\n </summary>\n <remarks>0x25000080</remarks>"]
   BcdOSLoaderInteger_SafeBoot = 620757120,
   #[doc = " <summary>\n Indicates whether the system should use the shell specified under the following registry key instead of the default shell:\n HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\AlternateShell.\n </summary>\n <remarks>0x26000081</remarks>"]
   BcdOSLoaderBoolean_SafeBootAlternateShell = 637534337,
   #[doc = " <summary>\n Indicates whether the system should write logging information to %SystemRoot%\\Ntbtlog.txt during initialization.\n </summary>\n <remarks>0x26000090</remarks>"]
   BcdOSLoaderBoolean_BootLogInitialization = 637534352,
   #[doc = " <summary>\n Indicates whether the system should display verbose information.\n </summary>\n <remarks>0x26000091</remarks>"]
   BcdOSLoaderBoolean_VerboseObjectLoadMode = 637534353,
   #[doc = " <summary>\n Indicates whether the kernel debugger should be enabled using the settings in the inherited debugger object.\n </summary>\n <remarks>0x260000A0</remarks>"]
   BcdOSLoaderBoolean_KernelDebuggerEnabled = 637534368,
   #[doc = " <summary>\n Indicates whether the HAL should call DbgBreakPoint at the start of HalInitSystem for phase 0 initialization of the kernel.\n </summary>\n <remarks>0x260000A1</remarks>"]
   BcdOSLoaderBoolean_DebuggerHalBreakpoint = 637534369,
   #[doc = " <summary>\n Forces the use of the platform clock as the system's performance counter.\n </summary>\n <remarks>0x260000A2</remarks>"]
   BcdOSLoaderBoolean_UsePlatformClock = 637534370,
   #[doc = " <summary>\n Forces the OS to assume the presence of legacy PC devices like CMOS and keyboard controllers.\n This value should only be used for debugging.\n </summary>\n <remarks>0x260000A3</remarks>"]
   BcdOSLoaderBoolean_ForceLegacyPlatform = 637534371,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x260000A4</remarks>"]
   BcdOSLoaderBoolean_UsePlatformTick = 637534372,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x260000A5</remarks>"]
   BcdOSLoaderBoolean_DisableDynamicTick = 637534373,
   #[doc = " <summary>\n Controls the TSC synchronization policy. Possible values include default (0), legacy (1), or enhanced (2).\n This value is supported starting in Windows 8 and Windows Server 2012.\n </summary>\n <remarks>0x250000A6</remarks>"]
   BcdOSLoaderInteger_TscSyncPolicy = 620757158,
   #[doc = " <summary>\n Indicates whether EMS should be enabled in the kernel.\n </summary>\n <remarks>0x260000B0</remarks>"]
   BcdOSLoaderBoolean_EmsEnabled = 637534384,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x250000C0</remarks>"]
   BcdOSLoaderInteger_ForceFailure = 620757184,
   #[doc = " <summary>\n Indicates the driver load failure policy. Zero (0) indicates that a failed driver load is fatal and the boot will not continue,\n one (1) indicates that the standard error control is used.\n </summary>\n <remarks>0x250000C1</remarks>"]
   BcdOSLoaderInteger_DriverLoadFailurePolicy = 620757185,
   #[doc = " <summary>\n Defines the type of boot menus the system will use. Possible values include menupolicylegacy (0) or menupolicystandard (1).\n The default value is menupolicylegacy (0).\n </summary>\n <remarks>0x250000C2</remarks>"]
   BcdOSLoaderInteger_BootMenuPolicy = 620757186,
   #[doc = " <summary>\n Controls whether the system boots to the legacy menu (F8 menu) on the next boot.\n Note This value is supported starting in Windows 8 and Windows Server 2012.\n </summary>\n <remarks>0x260000C3</remarks>"]
   BcdOSLoaderBoolean_AdvancedOptionsOneTime = 637534403,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x260000C4</remarks>"]
   BcdOSLoaderBoolean_OptionsEditOneTime = 637534404,
   #[doc = " <summary>\n The boot status policy. The Integer property is one of the values from the BcdOSLoaderBootStatusPolicy enumeration\n </summary>\n <remarks>0x250000E0</remarks>"]
   BcdOSLoaderInteger_BootStatusPolicy = 620757216,
   #[doc = " <summary>\n The OS loader removes this entry for security reasons. This option can only be triggered by using the F8 menu; a user must be physically present to trigger this option.\n This value is supported starting in Windows 8 and Windows Server 2012.\n </summary>\n <remarks>0x260000E1</remarks>"]
   BcdOSLoaderBoolean_DisableElamDrivers = 637534433,
   #[doc = " <summary>\n Controls the hypervisor launch type. Options are HyperVisorLaunchOff (0) and HypervisorLaunchAuto (1).\n </summary>\n <remarks>0x250000F0</remarks>"]
   BcdOSLoaderInteger_HypervisorLaunchType = 620757232,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x250000F1</remarks>"]
   BcdOSLoaderString_HypervisorPath = 620757233,
   #[doc = " <summary>\n Controls whether the hypervisor debugger is enabled.\n </summary>\n <remarks>0x260000F2</remarks>"]
   BcdOSLoaderBoolean_HypervisorDebuggerEnabled = 637534450,
   #[doc = " <summary>\n Controls the hypervisor debugger type. Can be set to SERIAL (0), 1394 (1), or NET (2).\n </summary>\n <remarks>0x250000F3</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerType = 620757235,
   #[doc = " <summary>\n Specifies the serial port number for serial debugging.\n </summary>\n <remarks>0x250000F4</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerPortNumber = 620757236,
   #[doc = " <summary>\n Specifies the baud rate for serial debugging.\n </summary>\n <remarks>0x250000F5</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerBaudrate = 620757237,
   #[doc = " <summary>\n Specifies the channel number for 1394 debugging.\n </summary>\n <remarks>0x250000F6</remarks>"]
   BcdOSLoaderInteger_HypervisorDebugger1394Channel = 620757238,
   #[doc = " <summary>\n Values are Disabled (0), Basic (1), and Standard (2).\n </summary>\n <remarks>0x250000F7</remarks>"]
   BcdOSLoaderInteger_BootUxPolicy = 620757239,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x220000F8</remarks>"]
   BcdOSLoaderInteger_HypervisorSlatDisabled = 570425592,
   #[doc = " <summary>\n Defines the PCI bus, device, and function numbers of the debugging device used with the hypervisor.\n For example, 1.5.0 describes the debugging device on bus 1, device 5, function 0.\n </summary>\n <remarks>0x220000F9</remarks>"]
   BcdOSLoaderString_HypervisorDebuggerBusParams = 570425593,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x250000FA</remarks>"]
   BcdOSLoaderInteger_HypervisorNumProc = 620757242,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x250000FB</remarks>"]
   BcdOSLoaderInteger_HypervisorRootProcPerNode = 620757243,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x260000FC</remarks>"]
   BcdOSLoaderBoolean_HypervisorUseLargeVTlb = 637534460,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x250000FD</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerNetHostIp = 620757245,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x250000FE</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerNetHostPort = 620757246,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x250000FF</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerPages = 620757247,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000100</remarks>"]
   BcdOSLoaderInteger_TpmBootEntropyPolicy = 620757248,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000110</remarks>"]
   BcdOSLoaderString_HypervisorDebuggerNetKey = 570425616,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000112</remarks>"]
   BcdOSLoaderString_HypervisorProductSkuType = 570425618,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000113</remarks>"]
   BcdOSLoaderInteger_HypervisorRootProc = 570425619,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x26000114</remarks>"]
   BcdOSLoaderBoolean_HypervisorDebuggerNetDhcp = 637534484,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000115</remarks>"]
   BcdOSLoaderInteger_HypervisorIommuPolicy = 620757269,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x26000116</remarks>"]
   BcdOSLoaderBoolean_HypervisorUseVApic = 637534486,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000117</remarks>"]
   BcdOSLoaderString_HypervisorLoadOptions = 570425623,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000118</remarks>"]
   BcdOSLoaderInteger_HypervisorMsrFilterPolicy = 620757272,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000119</remarks>"]
   BcdOSLoaderInteger_HypervisorMmioNxPolicy = 620757273,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2500011A</remarks>"]
   BcdOSLoaderInteger_HypervisorSchedulerType = 620757274,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2200011B</remarks>"]
   BcdOSLoaderString_HypervisorRootProcNumaNodes = 570425627,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2500011C</remarks>"]
   BcdOSLoaderInteger_HypervisorPerfmon = 620757276,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2500011D</remarks>"]
   BcdOSLoaderInteger_HypervisorRootProcPerCore = 620757277,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2200011E</remarks>"]
   BcdOSLoaderString_HypervisorRootProcNumaNodeLps = 570425630,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000120</remarks>"]
   BcdOSLoaderInteger_XSavePolicy = 620757280,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000121</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature0 = 620757281,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000122</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature1 = 620757282,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000123</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature2 = 620757283,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000124</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature3 = 620757284,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000125</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature4 = 620757285,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000126</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature5 = 620757286,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000127</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature6 = 620757287,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000128</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature7 = 620757288,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000129</remarks>"]
   BcdOSLoaderInteger_XSaveRemoveFeature = 620757289,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2500012A</remarks>"]
   BcdOSLoaderInteger_XSaveProcessorsMask = 620757290,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2500012B</remarks>"]
   BcdOSLoaderInteger_XSaveDisable = 620757291,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2500012C</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerType = 620757292,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2200012D</remarks>"]
   BcdOSLoaderString_KernelDebuggerBusParameters = 570425645,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2500012E</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerPortAddress = 620757294,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x2500012F</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerPortNumber = 620757295,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000130</remarks>"]
   BcdOSLoaderInteger_ClaimedTpmCounter = 620757296,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000131</remarks>"]
   BcdOSLoaderInteger_KernelDebugger1394Channel = 620757297,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000132</remarks>"]
   BcdOSLoaderString_KernelDebuggerUsbTargetname = 570425650,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000133</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerNetHostIp = 620757299,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000134</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerNetHostPort = 620757300,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x26000135</remarks>"]
   BcdOSLoaderBoolean_KernelDebuggerNetDhcp = 637534517,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000136</remarks>"]
   BcdOSLoaderString_KernelDebuggerNetKey = 570425654,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000137</remarks>"]
   BcdOSLoaderString_IMCHiveName = 570425655,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x21000138</remarks>"]
   BcdOSLoaderDevice_IMCDevice = 553648440,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000139</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerBaudrate = 620757305,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000140</remarks>"]
   BcdOSLoaderString_ManufacturingMode = 570425664,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x26000141</remarks>"]
   BcdOSLoaderBoolean_EventLoggingEnabled = 637534529,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x25000142</remarks>"]
   BcdOSLoaderInteger_VsmLaunchType = 620757314,
   #[doc = " <summary>\n Undocumented. Zero (0) indicates default, one (1) indicates that disabled and two (2) indicates strict mode.\n </summary>\n <remarks>0x25000144</remarks>"]
   BcdOSLoaderInteger_HypervisorEnforcedCodeIntegrity = 620757316,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x26000145</remarks>"]
   BcdOSLoaderBoolean_DtraceEnabled = 637534533,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x21000150</remarks>"]
   BcdOSLoaderDevice_SystemDataDevice = 553648464,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x21000151</remarks>"]
   BcdOSLoaderDevice_OsArcDevice = 553648465,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x21000153</remarks>"]
   BcdOSLoaderDevice_OsDataDevice = 553648467,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x21000154</remarks>"]
   BcdOSLoaderDevice_BspDevice = 553648468,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x21000155</remarks>"]
   BcdOSLoaderDevice_BspFilepath = 553648469,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000156</remarks>"]
   BcdOSLoaderString_KernelDebuggerNetHostIpv6 = 570425686,
   #[doc = " <summary>\n\n </summary>\n <remarks>0x22000161</remarks>"]
   BcdOSLoaderString_HypervisorDebuggerNetHostIpv6 = 570425697,
}
pub use self::_BcdOSLoaderElementTypes as BcdOSLoaderElementTypes;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_INFORMATION_CLASS {
   MemoryBasicInformation = 0,
   MemoryWorkingSetInformation = 1,
   MemoryMappedFilenameInformation = 2,
   MemoryRegionInformation = 3,
   MemoryWorkingSetExInformation = 4,
   MemorySharedCommitInformation = 5,
   MemoryImageInformation = 6,
   MemoryRegionInformationEx = 7,
   MemoryPrivilegedBasicInformation = 8,
   MemoryEnclaveImageInformation = 9,
   MemoryBasicInformationCapped = 10,
   MemoryPhysicalContiguityInformation = 11,
   MemoryBadInformation = 12,
   MemoryBadInformationAllProcesses = 13,
   MaxMemoryInfoClass = 14,
}
pub use self::_MEMORY_INFORMATION_CLASS as MEMORY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_WORKING_SET_BLOCK {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MEMORY_WORKING_SET_BLOCK {
   #[inline]
   pub fn Protection(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u64) }
   }
   #[inline]
   pub fn set_Protection(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub fn ShareCount(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_ShareCount(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn Shared(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Shared(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Node(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Node(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn VirtualPage(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
   }
   #[inline]
   pub fn set_VirtualPage(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 52u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Protection: ULONG_PTR,
      ShareCount: ULONG_PTR,
      Shared: ULONG_PTR,
      Node: ULONG_PTR,
      VirtualPage: ULONG_PTR,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 5u8, {
         let Protection: u64 = unsafe { ::core::mem::transmute(Protection) };
         Protection as u64
      });
      __bindgen_bitfield_unit.set(5usize, 3u8, {
         let ShareCount: u64 = unsafe { ::core::mem::transmute(ShareCount) };
         ShareCount as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let Shared: u64 = unsafe { ::core::mem::transmute(Shared) };
         Shared as u64
      });
      __bindgen_bitfield_unit.set(9usize, 3u8, {
         let Node: u64 = unsafe { ::core::mem::transmute(Node) };
         Node as u64
      });
      __bindgen_bitfield_unit.set(12usize, 52u8, {
         let VirtualPage: u64 = unsafe { ::core::mem::transmute(VirtualPage) };
         VirtualPage as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type MEMORY_WORKING_SET_BLOCK = _MEMORY_WORKING_SET_BLOCK;
pub type PMEMORY_WORKING_SET_BLOCK = *mut _MEMORY_WORKING_SET_BLOCK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_WORKING_SET_INFORMATION {
   pub NumberOfEntries: ULONG_PTR,
   pub WorkingSetInfo: [MEMORY_WORKING_SET_BLOCK; 1usize],
}
pub type MEMORY_WORKING_SET_INFORMATION = _MEMORY_WORKING_SET_INFORMATION;
pub type PMEMORY_WORKING_SET_INFORMATION = *mut _MEMORY_WORKING_SET_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_REGION_INFORMATION {
   pub AllocationBase: PVOID,
   pub AllocationProtect: ULONG,
   pub __bindgen_anon_1: _MEMORY_REGION_INFORMATION__bindgen_ty_1,
   pub RegionSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub PartitionId: ULONG_PTR,
   pub NodePreference: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_REGION_INFORMATION__bindgen_ty_1 {
   pub RegionType: ULONG,
   pub __bindgen_anon_1: _MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Private(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Private(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MappedDataFile(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedDataFile(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MappedImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MappedPageFile(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedPageFile(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MappedPhysical(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedPhysical(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DirectMapped(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DirectMapped(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SoftwareEnclave(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SoftwareEnclave(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn PageSize64K(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PageSize64K(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn PlaceholderReservation(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PlaceholderReservation(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MappedAwe(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedAwe(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MappedWriteWatch(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedWriteWatch(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn PageSizeLarge(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PageSizeLarge(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn PageSizeHuge(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PageSizeHuge(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 19u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Private: ULONG,
      MappedDataFile: ULONG,
      MappedImage: ULONG,
      MappedPageFile: ULONG,
      MappedPhysical: ULONG,
      DirectMapped: ULONG,
      SoftwareEnclave: ULONG,
      PageSize64K: ULONG,
      PlaceholderReservation: ULONG,
      MappedAwe: ULONG,
      MappedWriteWatch: ULONG,
      PageSizeLarge: ULONG,
      PageSizeHuge: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Private: u32 = unsafe { ::core::mem::transmute(Private) };
         Private as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let MappedDataFile: u32 = unsafe { ::core::mem::transmute(MappedDataFile) };
         MappedDataFile as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let MappedImage: u32 = unsafe { ::core::mem::transmute(MappedImage) };
         MappedImage as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let MappedPageFile: u32 = unsafe { ::core::mem::transmute(MappedPageFile) };
         MappedPageFile as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let MappedPhysical: u32 = unsafe { ::core::mem::transmute(MappedPhysical) };
         MappedPhysical as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let DirectMapped: u32 = unsafe { ::core::mem::transmute(DirectMapped) };
         DirectMapped as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let SoftwareEnclave: u32 = unsafe { ::core::mem::transmute(SoftwareEnclave) };
         SoftwareEnclave as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let PageSize64K: u32 = unsafe { ::core::mem::transmute(PageSize64K) };
         PageSize64K as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let PlaceholderReservation: u32 =
            unsafe { ::core::mem::transmute(PlaceholderReservation) };
         PlaceholderReservation as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let MappedAwe: u32 = unsafe { ::core::mem::transmute(MappedAwe) };
         MappedAwe as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let MappedWriteWatch: u32 = unsafe { ::core::mem::transmute(MappedWriteWatch) };
         MappedWriteWatch as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let PageSizeLarge: u32 = unsafe { ::core::mem::transmute(PageSizeLarge) };
         PageSizeLarge as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let PageSizeHuge: u32 = unsafe { ::core::mem::transmute(PageSizeHuge) };
         PageSizeHuge as u64
      });
      __bindgen_bitfield_unit.set(13usize, 19u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MEMORY_REGION_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_REGION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_REGION_INFORMATION = _MEMORY_REGION_INFORMATION;
pub type PMEMORY_REGION_INFORMATION = *mut _MEMORY_REGION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_WORKING_SET_EX_LOCATION {
   MemoryLocationInvalid = 0,
   MemoryLocationResident = 1,
   MemoryLocationPagefile = 2,
   MemoryLocationReserved = 3,
}
pub use self::_MEMORY_WORKING_SET_EX_LOCATION as MEMORY_WORKING_SET_EX_LOCATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_WORKING_SET_EX_BLOCK {
   pub __bindgen_anon_1: _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1 {
   pub __bindgen_anon_1: _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_1,
   pub Invalid: _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Valid(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Valid(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ShareCount(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_ShareCount(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn Win32Protection(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 11u8) as u64) }
   }
   #[inline]
   pub fn set_Win32Protection(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 11u8, val as u64)
      }
   }
   #[inline]
   pub fn Shared(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Shared(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Node(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u64) }
   }
   #[inline]
   pub fn set_Node(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub fn Locked(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Locked(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LargePage(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_LargePage(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Priority(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Priority(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(27usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn SharedOriginal(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_SharedOriginal(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(30usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Bad(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Bad(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Win32GraphicsProtection(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u64) }
   }
   #[inline]
   pub fn set_Win32GraphicsProtection(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(32usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedUlong(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 28u8) as u64) }
   }
   #[inline]
   pub fn set_ReservedUlong(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(36usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Valid: ULONG_PTR,
      ShareCount: ULONG_PTR,
      Win32Protection: ULONG_PTR,
      Shared: ULONG_PTR,
      Node: ULONG_PTR,
      Locked: ULONG_PTR,
      LargePage: ULONG_PTR,
      Priority: ULONG_PTR,
      Reserved: ULONG_PTR,
      SharedOriginal: ULONG_PTR,
      Bad: ULONG_PTR,
      Win32GraphicsProtection: ULONG_PTR,
      ReservedUlong: ULONG_PTR,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Valid: u64 = unsafe { ::core::mem::transmute(Valid) };
         Valid as u64
      });
      __bindgen_bitfield_unit.set(1usize, 3u8, {
         let ShareCount: u64 = unsafe { ::core::mem::transmute(ShareCount) };
         ShareCount as u64
      });
      __bindgen_bitfield_unit.set(4usize, 11u8, {
         let Win32Protection: u64 = unsafe { ::core::mem::transmute(Win32Protection) };
         Win32Protection as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let Shared: u64 = unsafe { ::core::mem::transmute(Shared) };
         Shared as u64
      });
      __bindgen_bitfield_unit.set(16usize, 6u8, {
         let Node: u64 = unsafe { ::core::mem::transmute(Node) };
         Node as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let Locked: u64 = unsafe { ::core::mem::transmute(Locked) };
         Locked as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let LargePage: u64 = unsafe { ::core::mem::transmute(LargePage) };
         LargePage as u64
      });
      __bindgen_bitfield_unit.set(24usize, 3u8, {
         let Priority: u64 = unsafe { ::core::mem::transmute(Priority) };
         Priority as u64
      });
      __bindgen_bitfield_unit.set(27usize, 3u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(30usize, 1u8, {
         let SharedOriginal: u64 = unsafe { ::core::mem::transmute(SharedOriginal) };
         SharedOriginal as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let Bad: u64 = unsafe { ::core::mem::transmute(Bad) };
         Bad as u64
      });
      __bindgen_bitfield_unit.set(32usize, 4u8, {
         let Win32GraphicsProtection: u64 =
            unsafe { ::core::mem::transmute(Win32GraphicsProtection) };
         Win32GraphicsProtection as u64
      });
      __bindgen_bitfield_unit.set(36usize, 28u8, {
         let ReservedUlong: u64 = unsafe { ::core::mem::transmute(ReservedUlong) };
         ReservedUlong as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_2 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_2 {
   #[inline]
   pub fn Valid(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Valid(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved0(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 14u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved0(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 14u8, val as u64)
      }
   }
   #[inline]
   pub fn Shared(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Shared(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved1(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub fn PageTable(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_PageTable(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Location(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u64) }
   }
   #[inline]
   pub fn set_Location(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn Priority(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Priority(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn ModifiedList(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_ModifiedList(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(27usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved2(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved2(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn SharedOriginal(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_SharedOriginal(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(30usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Bad(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Bad(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedUlong(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
   }
   #[inline]
   pub fn set_ReservedUlong(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(32usize, 32u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Valid: ULONG_PTR,
      Reserved0: ULONG_PTR,
      Shared: ULONG_PTR,
      Reserved1: ULONG_PTR,
      PageTable: ULONG_PTR,
      Location: ULONG_PTR,
      Priority: ULONG_PTR,
      ModifiedList: ULONG_PTR,
      Reserved2: ULONG_PTR,
      SharedOriginal: ULONG_PTR,
      Bad: ULONG_PTR,
      ReservedUlong: ULONG_PTR,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Valid: u64 = unsafe { ::core::mem::transmute(Valid) };
         Valid as u64
      });
      __bindgen_bitfield_unit.set(1usize, 14u8, {
         let Reserved0: u64 = unsafe { ::core::mem::transmute(Reserved0) };
         Reserved0 as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let Shared: u64 = unsafe { ::core::mem::transmute(Shared) };
         Shared as u64
      });
      __bindgen_bitfield_unit.set(16usize, 5u8, {
         let Reserved1: u64 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let PageTable: u64 = unsafe { ::core::mem::transmute(PageTable) };
         PageTable as u64
      });
      __bindgen_bitfield_unit.set(22usize, 2u8, {
         let Location: u64 = unsafe { ::core::mem::transmute(Location) };
         Location as u64
      });
      __bindgen_bitfield_unit.set(24usize, 3u8, {
         let Priority: u64 = unsafe { ::core::mem::transmute(Priority) };
         Priority as u64
      });
      __bindgen_bitfield_unit.set(27usize, 1u8, {
         let ModifiedList: u64 = unsafe { ::core::mem::transmute(ModifiedList) };
         ModifiedList as u64
      });
      __bindgen_bitfield_unit.set(28usize, 2u8, {
         let Reserved2: u64 = unsafe { ::core::mem::transmute(Reserved2) };
         Reserved2 as u64
      });
      __bindgen_bitfield_unit.set(30usize, 1u8, {
         let SharedOriginal: u64 = unsafe { ::core::mem::transmute(SharedOriginal) };
         SharedOriginal as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let Bad: u64 = unsafe { ::core::mem::transmute(Bad) };
         Bad as u64
      });
      __bindgen_bitfield_unit.set(32usize, 32u8, {
         let ReservedUlong: u64 = unsafe { ::core::mem::transmute(ReservedUlong) };
         ReservedUlong as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_WORKING_SET_EX_BLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_WORKING_SET_EX_BLOCK = _MEMORY_WORKING_SET_EX_BLOCK;
pub type PMEMORY_WORKING_SET_EX_BLOCK = *mut _MEMORY_WORKING_SET_EX_BLOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_WORKING_SET_EX_INFORMATION {
   pub VirtualAddress: PVOID,
   pub u1: _MEMORY_WORKING_SET_EX_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_WORKING_SET_EX_INFORMATION__bindgen_ty_1 {
   pub VirtualAttributes: MEMORY_WORKING_SET_EX_BLOCK,
   pub Long: ULONG_PTR,
}
impl Default for _MEMORY_WORKING_SET_EX_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_WORKING_SET_EX_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_WORKING_SET_EX_INFORMATION = _MEMORY_WORKING_SET_EX_INFORMATION;
pub type PMEMORY_WORKING_SET_EX_INFORMATION = *mut _MEMORY_WORKING_SET_EX_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_SHARED_COMMIT_INFORMATION {
   pub CommitSize: SIZE_T,
}
pub type MEMORY_SHARED_COMMIT_INFORMATION = _MEMORY_SHARED_COMMIT_INFORMATION;
pub type PMEMORY_SHARED_COMMIT_INFORMATION = *mut _MEMORY_SHARED_COMMIT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_IMAGE_INFORMATION {
   pub ImageBase: PVOID,
   pub SizeOfImage: SIZE_T,
   pub __bindgen_anon_1: _MEMORY_IMAGE_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_IMAGE_INFORMATION__bindgen_ty_1 {
   pub ImageFlags: ULONG,
   pub __bindgen_anon_1: _MEMORY_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MEMORY_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ImagePartialMap(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImagePartialMap(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageNotExecutable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageNotExecutable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageSigningLevel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ImageSigningLevel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 26u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ImagePartialMap: ULONG,
      ImageNotExecutable: ULONG,
      ImageSigningLevel: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ImagePartialMap: u32 = unsafe { ::core::mem::transmute(ImagePartialMap) };
         ImagePartialMap as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ImageNotExecutable: u32 = unsafe { ::core::mem::transmute(ImageNotExecutable) };
         ImageNotExecutable as u64
      });
      __bindgen_bitfield_unit.set(2usize, 4u8, {
         let ImageSigningLevel: u32 = unsafe { ::core::mem::transmute(ImageSigningLevel) };
         ImageSigningLevel as u64
      });
      __bindgen_bitfield_unit.set(6usize, 26u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MEMORY_IMAGE_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_IMAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_IMAGE_INFORMATION = _MEMORY_IMAGE_INFORMATION;
pub type PMEMORY_IMAGE_INFORMATION = *mut _MEMORY_IMAGE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_ENCLAVE_IMAGE_INFORMATION {
   pub ImageInfo: MEMORY_IMAGE_INFORMATION,
   pub UniqueID: [UCHAR; 32usize],
   pub AuthorID: [UCHAR; 32usize],
}
impl Default for _MEMORY_ENCLAVE_IMAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_ENCLAVE_IMAGE_INFORMATION = _MEMORY_ENCLAVE_IMAGE_INFORMATION;
pub type PMEMORY_ENCLAVE_IMAGE_INFORMATION = *mut _MEMORY_ENCLAVE_IMAGE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE {
   MemoryNotContiguous = 0,
   MemoryAlignedAndContiguous = 1,
   MemoryNotResident = 2,
   MemoryNotEligibleToMakeContiguous = 3,
   MemoryContiguityStateMax = 4,
}
pub use self::_MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE as MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION {
   pub __bindgen_anon_1: _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub AllInformation: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn State(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_State(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(State: ULONG, Reserved: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let State: u32 = unsafe { ::core::mem::transmute(State) };
         State as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION = _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION;
pub type PMEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION =
   *mut _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PHYSICAL_CONTIGUITY_INFORMATION {
   pub VirtualAddress: PVOID,
   pub Size: ULONG_PTR,
   pub ContiguityUnitSize: ULONG_PTR,
   pub Flags: ULONG,
   pub ContiguityUnitInformation: PMEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION,
}
impl Default for _MEMORY_PHYSICAL_CONTIGUITY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_PHYSICAL_CONTIGUITY_INFORMATION = _MEMORY_PHYSICAL_CONTIGUITY_INFORMATION;
pub type PMEMORY_PHYSICAL_CONTIGUITY_INFORMATION = *mut _MEMORY_PHYSICAL_CONTIGUITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_FRAME_INFORMATION {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MEMORY_FRAME_INFORMATION {
   #[inline]
   pub fn UseDescription(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u64) }
   }
   #[inline]
   pub fn set_UseDescription(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn ListDescription(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_ListDescription(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn Cold(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Cold(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Pinned(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Pinned(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DontUse(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_DontUse(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub fn Priority(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Priority(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(57usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn NonTradeable(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_NonTradeable(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(60usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(61usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      UseDescription: ULONGLONG,
      ListDescription: ULONGLONG,
      Cold: ULONGLONG,
      Pinned: ULONGLONG,
      DontUse: ULONGLONG,
      Priority: ULONGLONG,
      NonTradeable: ULONGLONG,
      Reserved: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let UseDescription: u64 = unsafe { ::core::mem::transmute(UseDescription) };
         UseDescription as u64
      });
      __bindgen_bitfield_unit.set(4usize, 3u8, {
         let ListDescription: u64 = unsafe { ::core::mem::transmute(ListDescription) };
         ListDescription as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let Cold: u64 = unsafe { ::core::mem::transmute(Cold) };
         Cold as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let Pinned: u64 = unsafe { ::core::mem::transmute(Pinned) };
         Pinned as u64
      });
      __bindgen_bitfield_unit.set(9usize, 48u8, {
         let DontUse: u64 = unsafe { ::core::mem::transmute(DontUse) };
         DontUse as u64
      });
      __bindgen_bitfield_unit.set(57usize, 3u8, {
         let Priority: u64 = unsafe { ::core::mem::transmute(Priority) };
         Priority as u64
      });
      __bindgen_bitfield_unit.set(60usize, 1u8, {
         let NonTradeable: u64 = unsafe { ::core::mem::transmute(NonTradeable) };
         NonTradeable as u64
      });
      __bindgen_bitfield_unit.set(61usize, 3u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type MEMORY_FRAME_INFORMATION = _MEMORY_FRAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILEOFFSET_INFORMATION {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _FILEOFFSET_INFORMATION {
   #[inline]
   pub fn DontUse(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u64) }
   }
   #[inline]
   pub fn set_DontUse(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 9u8, val as u64)
      }
   }
   #[inline]
   pub fn Offset(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_Offset(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 7u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(57usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DontUse: ULONGLONG,
      Offset: ULONGLONG,
      Reserved: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 9u8, {
         let DontUse: u64 = unsafe { ::core::mem::transmute(DontUse) };
         DontUse as u64
      });
      __bindgen_bitfield_unit.set(9usize, 48u8, {
         let Offset: u64 = unsafe { ::core::mem::transmute(Offset) };
         Offset as u64
      });
      __bindgen_bitfield_unit.set(57usize, 7u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type FILEOFFSET_INFORMATION = _FILEOFFSET_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PAGEDIR_INFORMATION {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _PAGEDIR_INFORMATION {
   #[inline]
   pub fn DontUse(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u64) }
   }
   #[inline]
   pub fn set_DontUse(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 9u8, val as u64)
      }
   }
   #[inline]
   pub fn PageDirectoryBase(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_PageDirectoryBase(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 7u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(57usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DontUse: ULONGLONG,
      PageDirectoryBase: ULONGLONG,
      Reserved: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 9u8, {
         let DontUse: u64 = unsafe { ::core::mem::transmute(DontUse) };
         DontUse as u64
      });
      __bindgen_bitfield_unit.set(9usize, 48u8, {
         let PageDirectoryBase: u64 = unsafe { ::core::mem::transmute(PageDirectoryBase) };
         PageDirectoryBase as u64
      });
      __bindgen_bitfield_unit.set(57usize, 7u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PAGEDIR_INFORMATION = _PAGEDIR_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _UNIQUE_PROCESS_INFORMATION {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _UNIQUE_PROCESS_INFORMATION {
   #[inline]
   pub fn DontUse(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u64) }
   }
   #[inline]
   pub fn set_DontUse(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 9u8, val as u64)
      }
   }
   #[inline]
   pub fn UniqueProcessKey(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_UniqueProcessKey(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 7u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(57usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DontUse: ULONGLONG,
      UniqueProcessKey: ULONGLONG,
      Reserved: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 9u8, {
         let DontUse: u64 = unsafe { ::core::mem::transmute(DontUse) };
         DontUse as u64
      });
      __bindgen_bitfield_unit.set(9usize, 48u8, {
         let UniqueProcessKey: u64 = unsafe { ::core::mem::transmute(UniqueProcessKey) };
         UniqueProcessKey as u64
      });
      __bindgen_bitfield_unit.set(57usize, 7u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type UNIQUE_PROCESS_INFORMATION = _UNIQUE_PROCESS_INFORMATION;
pub type PUNIQUE_PROCESS_INFORMATION = *mut _UNIQUE_PROCESS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPFN_IDENTITY {
   pub u1: _MMPFN_IDENTITY__bindgen_ty_1,
   pub PageFrameIndex: ULONG_PTR,
   pub u2: _MMPFN_IDENTITY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN_IDENTITY__bindgen_ty_1 {
   pub e1: MEMORY_FRAME_INFORMATION,
   pub e2: FILEOFFSET_INFORMATION,
   pub e3: PAGEDIR_INFORMATION,
   pub e4: UNIQUE_PROCESS_INFORMATION,
}
impl Default for _MMPFN_IDENTITY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN_IDENTITY__bindgen_ty_2 {
   pub e1: _MMPFN_IDENTITY__bindgen_ty_2__bindgen_ty_1,
   pub e2: _MMPFN_IDENTITY__bindgen_ty_2__bindgen_ty_2,
   pub FileObject: ULONG_PTR,
   pub UniqueFileObjectKey: ULONG_PTR,
   pub ProtoPteAddress: ULONG_PTR,
   pub VirtualAddress: ULONG_PTR,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFN_IDENTITY__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 7usize],
}
impl _MMPFN_IDENTITY__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn Image(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Image(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Mismatch(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Mismatch(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Image: ULONG_PTR,
      Mismatch: ULONG_PTR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Image: u64 = unsafe { ::core::mem::transmute(Image) };
         Image as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let Mismatch: u64 = unsafe { ::core::mem::transmute(Mismatch) };
         Mismatch as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFN_IDENTITY__bindgen_ty_2__bindgen_ty_2 {
   pub CombinedPage: ULONG_PTR,
}
impl Default for _MMPFN_IDENTITY__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MMPFN_IDENTITY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MMPFN_IDENTITY = _MMPFN_IDENTITY;
pub type PMMPFN_IDENTITY = *mut _MMPFN_IDENTITY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFN_MEMSNAP_INFORMATION {
   pub InitialPageFrameIndex: ULONG_PTR,
   pub Count: ULONG_PTR,
}
pub type MMPFN_MEMSNAP_INFORMATION = _MMPFN_MEMSNAP_INFORMATION;
pub type PMMPFN_MEMSNAP_INFORMATION = *mut _MMPFN_MEMSNAP_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECTION_INFORMATION_CLASS {
   SectionBasicInformation = 0,
   SectionImageInformation = 1,
   SectionRelocationInformation = 2,
   SectionOriginalBaseInformation = 3,
   SectionInternalImageInformation = 4,
   MaxSectionInfoClass = 5,
}
pub use self::_SECTION_INFORMATION_CLASS as SECTION_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SECTION_BASIC_INFORMATION {
   pub BaseAddress: PVOID,
   pub AllocationAttributes: ULONG,
   pub MaximumSize: LARGE_INTEGER,
}
impl Default for _SECTION_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SECTION_BASIC_INFORMATION = _SECTION_BASIC_INFORMATION;
pub type PSECTION_BASIC_INFORMATION = *mut _SECTION_BASIC_INFORMATION;
#[repr(C)]
pub struct _SECTION_IMAGE_INFORMATION {
   pub TransferAddress: PVOID,
   pub ZeroBits: ULONG,
   pub MaximumStackSize: SIZE_T,
   pub CommittedStackSize: SIZE_T,
   pub SubSystemType: ULONG,
   pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_1,
   pub __bindgen_anon_2: _SECTION_IMAGE_INFORMATION__bindgen_ty_2,
   pub ImageCharacteristics: USHORT,
   pub DllCharacteristics: USHORT,
   pub Machine: USHORT,
   pub ImageContainsCode: BOOLEAN,
   pub __bindgen_anon_3: _SECTION_IMAGE_INFORMATION__bindgen_ty_3,
   pub LoaderFlags: ULONG,
   pub ImageFileSize: ULONG,
   pub CheckSum: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub SubSystemVersion: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub SubSystemMinorVersion: USHORT,
   pub SubSystemMajorVersion: USHORT,
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_2 {
   pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_2__bindgen_ty_1,
   pub OperatingSystemVersion: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   pub MajorOperatingSystemVersion: USHORT,
   pub MinorOperatingSystemVersion: USHORT,
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_3 {
   pub ImageFlags: UCHAR,
   pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_3__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _SECTION_IMAGE_INFORMATION__bindgen_ty_3__bindgen_ty_1 {
   #[inline]
   pub fn ComPlusNativeReady(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ComPlusNativeReady(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ComPlusILOnly(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ComPlusILOnly(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageDynamicallyRelocated(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ImageDynamicallyRelocated(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageMappedFlat(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ImageMappedFlat(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn BaseBelow4gb(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_BaseBelow4gb(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ComPlusPrefer32bit(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ComPlusPrefer32bit(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ComPlusNativeReady: UCHAR,
      ComPlusILOnly: UCHAR,
      ImageDynamicallyRelocated: UCHAR,
      ImageMappedFlat: UCHAR,
      BaseBelow4gb: UCHAR,
      ComPlusPrefer32bit: UCHAR,
      Reserved: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ComPlusNativeReady: u8 = unsafe { ::core::mem::transmute(ComPlusNativeReady) };
         ComPlusNativeReady as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ComPlusILOnly: u8 = unsafe { ::core::mem::transmute(ComPlusILOnly) };
         ComPlusILOnly as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ImageDynamicallyRelocated: u8 =
            unsafe { ::core::mem::transmute(ImageDynamicallyRelocated) };
         ImageDynamicallyRelocated as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ImageMappedFlat: u8 = unsafe { ::core::mem::transmute(ImageMappedFlat) };
         ImageMappedFlat as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let BaseBelow4gb: u8 = unsafe { ::core::mem::transmute(BaseBelow4gb) };
         BaseBelow4gb as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let ComPlusPrefer32bit: u8 = unsafe { ::core::mem::transmute(ComPlusPrefer32bit) };
         ComPlusPrefer32bit as u64
      });
      __bindgen_bitfield_unit.set(6usize, 2u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SECTION_IMAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SECTION_IMAGE_INFORMATION = _SECTION_IMAGE_INFORMATION;
pub type PSECTION_IMAGE_INFORMATION = *mut _SECTION_IMAGE_INFORMATION;
#[repr(C)]
pub struct _SECTION_INTERNAL_IMAGE_INFORMATION {
   pub SectionInformation: SECTION_IMAGE_INFORMATION,
   pub __bindgen_anon_1: _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1 {
   pub ExtendedFlags: ULONG,
   pub __bindgen_anon_1: _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ImageExportSuppressionEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageExportSuppressionEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageCetShadowStacksReady(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetShadowStacksReady(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageXfgEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageXfgEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageCetShadowStacksStrictMode(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetShadowStacksStrictMode(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageCetSetContextIpValidationRelaxedMode(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetSetContextIpValidationRelaxedMode(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageCetDynamicApisAllowInProc(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetDynamicApisAllowInProc(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageCetDowngradeReserved1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetDowngradeReserved1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageCetDowngradeReserved2(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetDowngradeReserved2(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ImageExportSuppressionEnabled: ULONG,
      ImageCetShadowStacksReady: ULONG,
      ImageXfgEnabled: ULONG,
      ImageCetShadowStacksStrictMode: ULONG,
      ImageCetSetContextIpValidationRelaxedMode: ULONG,
      ImageCetDynamicApisAllowInProc: ULONG,
      ImageCetDowngradeReserved1: ULONG,
      ImageCetDowngradeReserved2: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ImageExportSuppressionEnabled: u32 =
            unsafe { ::core::mem::transmute(ImageExportSuppressionEnabled) };
         ImageExportSuppressionEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ImageCetShadowStacksReady: u32 =
            unsafe { ::core::mem::transmute(ImageCetShadowStacksReady) };
         ImageCetShadowStacksReady as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ImageXfgEnabled: u32 = unsafe { ::core::mem::transmute(ImageXfgEnabled) };
         ImageXfgEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ImageCetShadowStacksStrictMode: u32 =
            unsafe { ::core::mem::transmute(ImageCetShadowStacksStrictMode) };
         ImageCetShadowStacksStrictMode as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let ImageCetSetContextIpValidationRelaxedMode: u32 =
            unsafe { ::core::mem::transmute(ImageCetSetContextIpValidationRelaxedMode) };
         ImageCetSetContextIpValidationRelaxedMode as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let ImageCetDynamicApisAllowInProc: u32 =
            unsafe { ::core::mem::transmute(ImageCetDynamicApisAllowInProc) };
         ImageCetDynamicApisAllowInProc as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let ImageCetDowngradeReserved1: u32 =
            unsafe { ::core::mem::transmute(ImageCetDowngradeReserved1) };
         ImageCetDowngradeReserved1 as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let ImageCetDowngradeReserved2: u32 =
            unsafe { ::core::mem::transmute(ImageCetDowngradeReserved2) };
         ImageCetDowngradeReserved2 as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SECTION_INTERNAL_IMAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SECTION_INTERNAL_IMAGE_INFORMATION = _SECTION_INTERNAL_IMAGE_INFORMATION;
pub type PSECTION_INTERNAL_IMAGE_INFORMATION = *mut _SECTION_INTERNAL_IMAGE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECTION_INHERIT {
   ViewShare = 1,
   ViewUnmap = 2,
}
pub use self::_SECTION_INHERIT as SECTION_INHERIT;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _VIRTUAL_MEMORY_INFORMATION_CLASS {
   VmPrefetchInformation = 0,
   VmPagePriorityInformation = 1,
   VmCfgCallTargetInformation = 2,
   VmPageDirtyStateInformation = 3,
   VmImageHotPatchInformation = 4,
   VmPhysicalContiguityInformation = 5,
   VmVirtualMachinePrepopulateInformation = 6,
   VmRemoveFromWorkingSetInformation = 7,
   MaxVmInfoClass = 8,
}
pub use self::_VIRTUAL_MEMORY_INFORMATION_CLASS as VIRTUAL_MEMORY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_RANGE_ENTRY {
   pub VirtualAddress: PVOID,
   pub NumberOfBytes: SIZE_T,
}
impl Default for _MEMORY_RANGE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_RANGE_ENTRY = _MEMORY_RANGE_ENTRY;
pub type PMEMORY_RANGE_ENTRY = *mut _MEMORY_RANGE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CFG_CALL_TARGET_LIST_INFORMATION {
   pub NumberOfEntries: ULONG,
   pub Reserved: ULONG,
   pub NumberOfEntriesProcessed: PULONG,
   pub CallTargetInfo: PCFG_CALL_TARGET_INFO,
   pub Section: PVOID,
   pub FileOffset: ULONGLONG,
}
impl Default for _CFG_CALL_TARGET_LIST_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CFG_CALL_TARGET_LIST_INFORMATION = _CFG_CALL_TARGET_LIST_INFORMATION;
pub type PCFG_CALL_TARGET_LIST_INFORMATION = *mut _CFG_CALL_TARGET_LIST_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PARTITION_INFORMATION_CLASS {
   SystemMemoryPartitionInformation = 0,
   SystemMemoryPartitionMoveMemory = 1,
   SystemMemoryPartitionAddPagefile = 2,
   SystemMemoryPartitionCombineMemory = 3,
   SystemMemoryPartitionInitialAddMemory = 4,
   SystemMemoryPartitionGetMemoryEvents = 5,
   SystemMemoryPartitionSetAttributes = 6,
   SystemMemoryPartitionNodeInformation = 7,
   SystemMemoryPartitionCreateLargePages = 8,
   SystemMemoryPartitionDedicatedMemoryInformation = 9,
   SystemMemoryPartitionOpenDedicatedMemory = 10,
   SystemMemoryPartitionMemoryChargeAttributes = 11,
   SystemMemoryPartitionClearAttributes = 12,
   SystemMemoryPartitionSetMemoryThresholds = 13,
   SystemMemoryPartitionMax = 14,
}
pub use self::_PARTITION_INFORMATION_CLASS as PARTITION_INFORMATION_CLASS;
pub type PPARTITION_INFORMATION_CLASS = *mut _PARTITION_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION {
   pub Flags: ULONG,
   pub NumaNode: ULONG,
   pub Channel: ULONG,
   pub NumberOfNumaNodes: ULONG,
   pub ResidentAvailablePages: ULONG_PTR,
   pub CommittedPages: ULONG_PTR,
   pub CommitLimit: ULONG_PTR,
   pub PeakCommitment: ULONG_PTR,
   pub TotalNumberOfPages: ULONG_PTR,
   pub AvailablePages: ULONG_PTR,
   pub ZeroPages: ULONG_PTR,
   pub FreePages: ULONG_PTR,
   pub StandbyPages: ULONG_PTR,
   pub StandbyPageCountByPriority: [ULONG_PTR; 8usize],
   pub RepurposedPagesByPriority: [ULONG_PTR; 8usize],
   pub MaximumCommitLimit: ULONG_PTR,
   pub Reserved: ULONG_PTR,
   pub PartitionId: ULONG,
}
pub type MEMORY_PARTITION_CONFIGURATION_INFORMATION = _MEMORY_PARTITION_CONFIGURATION_INFORMATION;
pub type PMEMORY_PARTITION_CONFIGURATION_INFORMATION =
   *mut _MEMORY_PARTITION_CONFIGURATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PARTITION_TRANSFER_INFORMATION {
   pub NumberOfPages: ULONG_PTR,
   pub NumaNode: ULONG,
   pub Flags: ULONG,
}
pub type MEMORY_PARTITION_TRANSFER_INFORMATION = _MEMORY_PARTITION_TRANSFER_INFORMATION;
pub type PMEMORY_PARTITION_TRANSFER_INFORMATION = *mut _MEMORY_PARTITION_TRANSFER_INFORMATION;
#[repr(C)]
pub struct _MEMORY_PARTITION_PAGEFILE_INFORMATION {
   pub PageFileName: UNICODE_STRING,
   pub MinimumSize: LARGE_INTEGER,
   pub MaximumSize: LARGE_INTEGER,
   pub Flags: ULONG,
}
impl Default for _MEMORY_PARTITION_PAGEFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_PARTITION_PAGEFILE_INFORMATION = _MEMORY_PARTITION_PAGEFILE_INFORMATION;
pub type PMEMORY_PARTITION_PAGEFILE_INFORMATION = *mut _MEMORY_PARTITION_PAGEFILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION {
   pub StopHandle: HANDLE,
   pub Flags: ULONG,
   pub TotalNumberOfPages: ULONG_PTR,
}
impl Default for _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_PARTITION_PAGE_COMBINE_INFORMATION = _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION;
pub type PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION =
   *mut _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PARTITION_PAGE_RANGE {
   pub StartPage: ULONG_PTR,
   pub NumberOfPages: ULONG_PTR,
}
pub type MEMORY_PARTITION_PAGE_RANGE = _MEMORY_PARTITION_PAGE_RANGE;
pub type PMEMORY_PARTITION_PAGE_RANGE = *mut _MEMORY_PARTITION_PAGE_RANGE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION {
   pub Flags: ULONG,
   pub NumberOfRanges: ULONG,
   pub NumberOfPagesAdded: ULONG_PTR,
   pub PartitionRanges: [MEMORY_PARTITION_PAGE_RANGE; 1usize],
}
pub type MEMORY_PARTITION_INITIAL_ADD_INFORMATION = _MEMORY_PARTITION_INITIAL_ADD_INFORMATION;
pub type PMEMORY_PARTITION_INITIAL_ADD_INFORMATION = *mut _MEMORY_PARTITION_INITIAL_ADD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION {
   pub Flags: _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1,
   pub HandleAttributes: ULONG,
   pub DesiredAccess: ULONG,
   pub LowCommitCondition: HANDLE,
   pub HighCommitCondition: HANDLE,
   pub MaximumCommitCondition: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub AllFlags: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn CommitEvents(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CommitEvents(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(CommitEvents: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let CommitEvents: u32 = unsafe { ::core::mem::transmute(CommitEvents) };
         CommitEvents as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION = _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION;
pub type PMEMORY_PARTITION_MEMORY_EVENTS_INFORMATION =
   *mut _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _OBJECT_INFORMATION_CLASS {
   ObjectBasicInformation = 0,
   ObjectNameInformation = 1,
   ObjectTypeInformation = 2,
   ObjectTypesInformation = 3,
   ObjectHandleFlagInformation = 4,
   ObjectSessionInformation = 5,
   ObjectSessionObjectInformation = 6,
   MaxObjectInfoClass = 7,
}
pub use self::_OBJECT_INFORMATION_CLASS as OBJECT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_BASIC_INFORMATION {
   pub Attributes: ULONG,
   pub GrantedAccess: ACCESS_MASK,
   pub HandleCount: ULONG,
   pub PointerCount: ULONG,
   pub PagedPoolCharge: ULONG,
   pub NonPagedPoolCharge: ULONG,
   pub Reserved: [ULONG; 3usize],
   pub NameInfoSize: ULONG,
   pub TypeInfoSize: ULONG,
   pub SecurityDescriptorSize: ULONG,
   pub CreationTime: LARGE_INTEGER,
}
impl Default for _OBJECT_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_BASIC_INFORMATION = _OBJECT_BASIC_INFORMATION;
pub type POBJECT_BASIC_INFORMATION = *mut _OBJECT_BASIC_INFORMATION;
#[repr(C)]
pub struct _OBJECT_NAME_INFORMATION {
   pub Name: UNICODE_STRING,
}
impl Default for _OBJECT_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_NAME_INFORMATION = _OBJECT_NAME_INFORMATION;
pub type POBJECT_NAME_INFORMATION = *mut _OBJECT_NAME_INFORMATION;
#[repr(C)]
pub struct _OBJECT_TYPE_INFORMATION {
   pub TypeName: UNICODE_STRING,
   pub TotalNumberOfObjects: ULONG,
   pub TotalNumberOfHandles: ULONG,
   pub TotalPagedPoolUsage: ULONG,
   pub TotalNonPagedPoolUsage: ULONG,
   pub TotalNamePoolUsage: ULONG,
   pub TotalHandleTableUsage: ULONG,
   pub HighWaterNumberOfObjects: ULONG,
   pub HighWaterNumberOfHandles: ULONG,
   pub HighWaterPagedPoolUsage: ULONG,
   pub HighWaterNonPagedPoolUsage: ULONG,
   pub HighWaterNamePoolUsage: ULONG,
   pub HighWaterHandleTableUsage: ULONG,
   pub InvalidAttributes: ULONG,
   pub GenericMapping: GENERIC_MAPPING,
   pub ValidAccessMask: ULONG,
   pub SecurityRequired: BOOLEAN,
   pub MaintainHandleCount: BOOLEAN,
   pub TypeIndex: UCHAR,
   pub ReservedByte: CHAR,
   pub PoolType: ULONG,
   pub DefaultPagedPoolCharge: ULONG,
   pub DefaultNonPagedPoolCharge: ULONG,
}
impl Default for _OBJECT_TYPE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_TYPE_INFORMATION = _OBJECT_TYPE_INFORMATION;
pub type POBJECT_TYPE_INFORMATION = *mut _OBJECT_TYPE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_TYPES_INFORMATION {
   pub NumberOfTypes: ULONG,
}
pub type OBJECT_TYPES_INFORMATION = _OBJECT_TYPES_INFORMATION;
pub type POBJECT_TYPES_INFORMATION = *mut _OBJECT_TYPES_INFORMATION;
#[repr(C)]
pub struct _OBJECT_HANDLE_FLAG_INFORMATION {
   pub Inherit: BOOLEAN,
   pub ProtectFromClose: BOOLEAN,
}
impl Default for _OBJECT_HANDLE_FLAG_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_HANDLE_FLAG_INFORMATION = _OBJECT_HANDLE_FLAG_INFORMATION;
pub type POBJECT_HANDLE_FLAG_INFORMATION = *mut _OBJECT_HANDLE_FLAG_INFORMATION;
#[repr(C)]
pub struct _OBJECT_DIRECTORY_INFORMATION {
   pub Name: UNICODE_STRING,
   pub TypeName: UNICODE_STRING,
}
impl Default for _OBJECT_DIRECTORY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_DIRECTORY_INFORMATION = _OBJECT_DIRECTORY_INFORMATION;
pub type POBJECT_DIRECTORY_INFORMATION = *mut _OBJECT_DIRECTORY_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BOUNDARY_ENTRY_TYPE {
   OBNS_Invalid = 0,
   OBNS_Name = 1,
   OBNS_SID = 2,
   OBNS_IL = 3,
}
pub use self::_BOUNDARY_ENTRY_TYPE as BOUNDARY_ENTRY_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_BOUNDARY_ENTRY {
   pub EntryType: BOUNDARY_ENTRY_TYPE,
   pub EntrySize: ULONG,
}
impl Default for _OBJECT_BOUNDARY_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_BOUNDARY_ENTRY = _OBJECT_BOUNDARY_ENTRY;
pub type POBJECT_BOUNDARY_ENTRY = *mut _OBJECT_BOUNDARY_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_BOUNDARY_DESCRIPTOR {
   pub Version: ULONG,
   pub Items: ULONG,
   pub TotalSize: ULONG,
   pub __bindgen_anon_1: _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn AddAppContainerSid(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AddAppContainerSid(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      AddAppContainerSid: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let AddAppContainerSid: u32 = unsafe { ::core::mem::transmute(AddAppContainerSid) };
         AddAppContainerSid as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _OBJECT_BOUNDARY_DESCRIPTOR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_BOUNDARY_DESCRIPTOR = _OBJECT_BOUNDARY_DESCRIPTOR;
pub type POBJECT_BOUNDARY_DESCRIPTOR = *mut _OBJECT_BOUNDARY_DESCRIPTOR;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYMBOLIC_LINK_INFO_CLASS {
   SymbolicLinkGlobalInformation = 1,
   SymbolicLinkAccessMask = 2,
   MaxnSymbolicLinkInfoClass = 3,
}
pub use self::_SYMBOLIC_LINK_INFO_CLASS as SYMBOLIC_LINK_INFO_CLASS;
pub type GDI_HANDLE_BUFFER = [ULONG; 60usize];
pub type GDI_HANDLE_BUFFER32 = [ULONG; 34usize];
pub type GDI_HANDLE_BUFFER64 = [ULONG; 60usize];
#[repr(C)]
pub struct _PEB_LDR_DATA {
   pub Length: ULONG,
   pub Initialized: BOOLEAN,
   pub SsHandle: HANDLE,
   pub InLoadOrderModuleList: LIST_ENTRY,
   pub InMemoryOrderModuleList: LIST_ENTRY,
   pub InInitializationOrderModuleList: LIST_ENTRY,
   pub EntryInProgress: PVOID,
   pub ShutdownInProgress: BOOLEAN,
   pub ShutdownThreadId: HANDLE,
}
impl Default for _PEB_LDR_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEB_LDR_DATA = _PEB_LDR_DATA;
pub type PPEB_LDR_DATA = *mut _PEB_LDR_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INITIAL_TEB {
   pub OldInitialTeb: _INITIAL_TEB__bindgen_ty_1,
   pub StackBase: PVOID,
   pub StackLimit: PVOID,
   pub StackAllocationBase: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INITIAL_TEB__bindgen_ty_1 {
   pub OldStackBase: PVOID,
   pub OldStackLimit: PVOID,
}
impl Default for _INITIAL_TEB__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _INITIAL_TEB {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type INITIAL_TEB = _INITIAL_TEB;
pub type PINITIAL_TEB = *mut _INITIAL_TEB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_PROCESS {
   pub Wow64: PVOID,
}
impl Default for _WOW64_PROCESS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WOW64_PROCESS = _WOW64_PROCESS;
pub type PWOW64_PROCESS = *mut _WOW64_PROCESS;
pub type PRTL_USER_PROCESS_PARAMETERS = *mut _RTL_USER_PROCESS_PARAMETERS;
pub type PSILO_USER_SHARED_DATA = *mut _SILO_USER_SHARED_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_SECOND_DATA {
   _unused: [u8; 0],
}
pub type PLEAP_SECOND_DATA = *mut _LEAP_SECOND_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA {
   pub Magic: ULONG,
   pub HeaderSize: ULONG,
   pub FormatVersion: ULONG,
   pub TotalSize: ULONG,
   pub DefaultTocOffset: ULONG,
   pub ExtendedTocOffset: ULONG,
   pub AssemblyRosterOffset: ULONG,
   pub Flags: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA = _ACTIVATION_CONTEXT_DATA;
pub type PACTIVATION_CONTEXT_DATA = *mut _ACTIVATION_CONTEXT_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_TOC_HEADER {
   pub HeaderSize: ULONG,
   pub EntryCount: ULONG,
   pub FirstEntryOffset: ULONG,
   pub Flags: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_TOC_HEADER = _ACTIVATION_CONTEXT_DATA_TOC_HEADER;
pub type PACTIVATION_CONTEXT_DATA_TOC_HEADER = *mut _ACTIVATION_CONTEXT_DATA_TOC_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_TOC_ENTRY {
   pub Id: ULONG,
   pub Offset: ULONG,
   pub Length: ULONG,
   pub Format: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_TOC_ENTRY = _ACTIVATION_CONTEXT_DATA_TOC_ENTRY;
pub type PACTIVATION_CONTEXT_DATA_TOC_ENTRY = *mut _ACTIVATION_CONTEXT_DATA_TOC_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER {
   pub HeaderSize: ULONG,
   pub EntryCount: ULONG,
   pub FirstEntryOffset: ULONG,
   pub Flags: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER = _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER;
pub type PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER =
   *mut _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY {
   pub ExtensionGuid: GUID,
   pub TocOffset: ULONG,
   pub Length: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY = _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY;
pub type PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY =
   *mut _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER {
   pub HeaderSize: ULONG,
   pub HashAlgorithm: ULONG,
   pub EntryCount: ULONG,
   pub FirstEntryOffset: ULONG,
   pub AssemblyInformationSectionOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER =
   _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER;
pub type PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER =
   *mut _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY {
   pub Flags: ULONG,
   pub PseudoKey: ULONG,
   pub AssemblyNameOffset: ULONG,
   pub AssemblyNameLength: ULONG,
   pub AssemblyInformationOffset: ULONG,
   pub AssemblyInformationLength: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY =
   _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY;
pub type PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY =
   *mut _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STRING_SECTION_HEADER {
   pub Magic: ULONG,
   pub HeaderSize: ULONG,
   pub FormatVersion: ULONG,
   pub DataFormatVersion: ULONG,
   pub Flags: ULONG,
   pub ElementCount: ULONG,
   pub ElementListOffset: ULONG,
   pub HashAlgorithm: ULONG,
   pub SearchStructureOffset: ULONG,
   pub UserDataOffset: ULONG,
   pub UserDataSize: ULONG,
}
pub type ACTIVATION_CONTEXT_STRING_SECTION_HEADER = _ACTIVATION_CONTEXT_STRING_SECTION_HEADER;
pub type PACTIVATION_CONTEXT_STRING_SECTION_HEADER = *mut _ACTIVATION_CONTEXT_STRING_SECTION_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STRING_SECTION_ENTRY {
   pub PseudoKey: ULONG,
   pub KeyOffset: ULONG,
   pub KeyLength: ULONG,
   pub Offset: ULONG,
   pub Length: ULONG,
   pub AssemblyRosterIndex: ULONG,
}
pub type ACTIVATION_CONTEXT_STRING_SECTION_ENTRY = _ACTIVATION_CONTEXT_STRING_SECTION_ENTRY;
pub type PACTIVATION_CONTEXT_STRING_SECTION_ENTRY = *mut _ACTIVATION_CONTEXT_STRING_SECTION_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE {
   pub BucketTableEntryCount: ULONG,
   pub BucketTableOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE =
   _ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE;
pub type PACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE =
   *mut _ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET {
   pub ChainCount: ULONG,
   pub ChainOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET =
   _ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET;
pub type PACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET =
   *mut _ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_GUID_SECTION_HEADER {
   pub Magic: ULONG,
   pub HeaderSize: ULONG,
   pub FormatVersion: ULONG,
   pub DataFormatVersion: ULONG,
   pub Flags: ULONG,
   pub ElementCount: ULONG,
   pub ElementListOffset: ULONG,
   pub SearchStructureOffset: ULONG,
   pub UserDataOffset: ULONG,
   pub UserDataSize: ULONG,
}
pub type ACTIVATION_CONTEXT_GUID_SECTION_HEADER = _ACTIVATION_CONTEXT_GUID_SECTION_HEADER;
pub type PACTIVATION_CONTEXT_GUID_SECTION_HEADER = *mut _ACTIVATION_CONTEXT_GUID_SECTION_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_GUID_SECTION_ENTRY {
   pub Guid: GUID,
   pub Offset: ULONG,
   pub Length: ULONG,
   pub AssemblyRosterIndex: ULONG,
}
pub type ACTIVATION_CONTEXT_GUID_SECTION_ENTRY = _ACTIVATION_CONTEXT_GUID_SECTION_ENTRY;
pub type PACTIVATION_CONTEXT_GUID_SECTION_ENTRY = *mut _ACTIVATION_CONTEXT_GUID_SECTION_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE {
   pub BucketTableEntryCount: ULONG,
   pub BucketTableOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE = _ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE;
pub type PACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE =
   *mut _ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET {
   pub ChainCount: ULONG,
   pub ChainOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET = _ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET;
pub type PACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET =
   *mut _ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub EncodedAssemblyIdentityLength: ULONG,
   pub EncodedAssemblyIdentityOffset: ULONG,
   pub ManifestPathType: ULONG,
   pub ManifestPathLength: ULONG,
   pub ManifestPathOffset: ULONG,
   pub ManifestLastWriteTime: LARGE_INTEGER,
   pub PolicyPathType: ULONG,
   pub PolicyPathLength: ULONG,
   pub PolicyPathOffset: ULONG,
   pub PolicyLastWriteTime: LARGE_INTEGER,
   pub MetadataSatelliteRosterIndex: ULONG,
   pub Unused2: ULONG,
   pub ManifestVersionMajor: ULONG,
   pub ManifestVersionMinor: ULONG,
   pub PolicyVersionMajor: ULONG,
   pub PolicyVersionMinor: ULONG,
   pub AssemblyDirectoryNameLength: ULONG,
   pub AssemblyDirectoryNameOffset: ULONG,
   pub NumOfFilesInAssembly: ULONG,
   pub LanguageLength: ULONG,
   pub LanguageOffset: ULONG,
   pub RunLevel: ACTCTX_REQUESTED_RUN_LEVEL,
   pub UiAccess: ULONG,
}
impl Default for _ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION =
   _ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION;
pub type PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION =
   *mut _ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub PolicyCoherencyGuid: GUID,
   pub PolicyOverrideGuid: GUID,
   pub ApplicationDirectoryPathType: ULONG,
   pub ApplicationDirectoryLength: ULONG,
   pub ApplicationDirectoryOffset: ULONG,
   pub ResourceName: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION =
   _ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION;
pub type PACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION =
   *mut _ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub TotalPathLength: ULONG,
   pub PathSegmentCount: ULONG,
   pub PathSegmentOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION = _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION = *mut _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT {
   pub Length: ULONG,
   pub Offset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT =
   _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT;
pub type PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT =
   *mut _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub VersionSpecificClassNameLength: ULONG,
   pub VersionSpecificClassNameOffset: ULONG,
   pub DllNameLength: ULONG,
   pub DllNameOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION =
   _ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION =
   *mut _ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub ThreadingModel: ULONG,
   pub ReferenceClsid: GUID,
   pub ConfiguredClsid: GUID,
   pub ImplementedClsid: GUID,
   pub TypeLibraryId: GUID,
   pub ModuleLength: ULONG,
   pub ModuleOffset: ULONG,
   pub ProgIdLength: ULONG,
   pub ProgIdOffset: ULONG,
   pub ShimDataLength: ULONG,
   pub ShimDataOffset: ULONG,
   pub MiscStatusDefault: ULONG,
   pub MiscStatusContent: ULONG,
   pub MiscStatusThumbnail: ULONG,
   pub MiscStatusIcon: ULONG,
   pub MiscStatusDocPrint: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION =
   _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION =
   *mut _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub Type: ULONG,
   pub ModuleLength: ULONG,
   pub ModuleOffset: ULONG,
   pub TypeLength: ULONG,
   pub TypeOffset: ULONG,
   pub ShimVersionLength: ULONG,
   pub ShimVersionOffset: ULONG,
   pub DataLength: ULONG,
   pub DataOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM =
   _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM;
pub type PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM =
   *mut _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub ProxyStubClsid32: GUID,
   pub NumMethods: ULONG,
   pub TypeLibraryId: GUID,
   pub BaseInterface: GUID,
   pub NameLength: ULONG,
   pub NameOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION =
   _ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION =
   *mut _ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION {
   pub Major: USHORT,
   pub Minor: USHORT,
}
pub type ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION =
   _ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION;
pub type PACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION =
   *mut _ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub NameLength: ULONG,
   pub NameOffset: ULONG,
   pub ResourceId: USHORT,
   pub LibraryFlags: USHORT,
   pub HelpDirLength: ULONG,
   pub HelpDirOffset: ULONG,
   pub Version: ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION,
}
pub type ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION =
   _ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION =
   *mut _ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub ConfiguredClsidOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION =
   _ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION =
   *mut _ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_CLR_SURROGATE {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub SurrogateIdent: GUID,
   pub VersionOffset: ULONG,
   pub VersionLength: ULONG,
   pub TypeNameOffset: ULONG,
   pub TypeNameLength: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_CLR_SURROGATE = _ACTIVATION_CONTEXT_DATA_CLR_SURROGATE;
pub type PACTIVATION_CONTEXT_DATA_CLR_SURROGATE = *mut _ACTIVATION_CONTEXT_DATA_CLR_SURROGATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub SettingNamespaceLength: ULONG,
   pub SettingNamespaceOffset: ULONG,
   pub SettingNameLength: ULONG,
   pub SettingNameOffset: ULONG,
   pub SettingValueLength: ULONG,
   pub SettingValueOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS =
   _ACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS;
pub type PACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS =
   *mut _ACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPATIBILITY_CONTEXT_ELEMENT_LEGACY {
   pub Id: GUID,
   pub Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE,
}
impl Default for _COMPATIBILITY_CONTEXT_ELEMENT_LEGACY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COMPATIBILITY_CONTEXT_ELEMENT_LEGACY = _COMPATIBILITY_CONTEXT_ELEMENT_LEGACY;
pub type PCOMPATIBILITY_CONTEXT_ELEMENT_LEGACY = *mut _COMPATIBILITY_CONTEXT_ELEMENT_LEGACY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY {
   pub ElementCount: DWORD,
   pub Elements: [COMPATIBILITY_CONTEXT_ELEMENT_LEGACY; 1usize],
}
impl Default for _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY =
   _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY;
pub type PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY =
   *mut _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY;
#[repr(C)]
pub struct _ASSEMBLY_STORAGE_MAP_ENTRY {
   pub Flags: ULONG,
   pub DosPath: UNICODE_STRING,
   pub Handle: HANDLE,
}
impl Default for _ASSEMBLY_STORAGE_MAP_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ASSEMBLY_STORAGE_MAP_ENTRY = _ASSEMBLY_STORAGE_MAP_ENTRY;
pub type PASSEMBLY_STORAGE_MAP_ENTRY = *mut _ASSEMBLY_STORAGE_MAP_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ASSEMBLY_STORAGE_MAP {
   pub Flags: ULONG,
   pub AssemblyCount: ULONG,
   pub AssemblyArray: *mut PASSEMBLY_STORAGE_MAP_ENTRY,
}
impl Default for _ASSEMBLY_STORAGE_MAP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ASSEMBLY_STORAGE_MAP = _ASSEMBLY_STORAGE_MAP;
pub type PASSEMBLY_STORAGE_MAP = *mut _ASSEMBLY_STORAGE_MAP;
pub type PACTIVATION_CONTEXT_NOTIFY_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      NotificationType: ULONG,
      ActivationContext: PACTIVATION_CONTEXT,
      ActivationContextData: PACTIVATION_CONTEXT_DATA,
      NotificationContext: PVOID,
      NotificationData: PVOID,
      DisableThisNotification: PBOOLEAN,
   ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT {
   pub RefCount: LONG,
   pub Flags: ULONG,
   pub ActivationContextData: PACTIVATION_CONTEXT_DATA,
   pub NotificationRoutine: PACTIVATION_CONTEXT_NOTIFY_ROUTINE,
   pub NotificationContext: PVOID,
   pub SentNotifications: [ULONG; 8usize],
   pub DisabledNotifications: [ULONG; 8usize],
   pub StorageMap: ASSEMBLY_STORAGE_MAP,
   pub InlineStorageMapEntries: [PASSEMBLY_STORAGE_MAP_ENTRY; 32usize],
}
impl Default for _ACTIVATION_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ACTIVATION_CONTEXT = _ACTIVATION_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
   pub Previous: *mut _RTL_ACTIVATION_CONTEXT_STACK_FRAME,
   pub ActivationContext: PACTIVATION_CONTEXT,
   pub Flags: ULONG,
}
impl Default for _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_ACTIVATION_CONTEXT_STACK_FRAME = _RTL_ACTIVATION_CONTEXT_STACK_FRAME;
pub type PRTL_ACTIVATION_CONTEXT_STACK_FRAME = *mut _RTL_ACTIVATION_CONTEXT_STACK_FRAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STACK {
   pub ActiveFrame: PRTL_ACTIVATION_CONTEXT_STACK_FRAME,
   pub FrameListCache: LIST_ENTRY,
   pub Flags: ULONG,
   pub NextCookieSequenceNumber: ULONG,
   pub StackId: ULONG,
}
impl Default for _ACTIVATION_CONTEXT_STACK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ACTIVATION_CONTEXT_STACK = _ACTIVATION_CONTEXT_STACK;
pub type PACTIVATION_CONTEXT_STACK = *mut _ACTIVATION_CONTEXT_STACK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _API_SET_NAMESPACE {
   pub Version: ULONG,
   pub Size: ULONG,
   pub Flags: ULONG,
   pub Count: ULONG,
   pub EntryOffset: ULONG,
   pub HashOffset: ULONG,
   pub HashFactor: ULONG,
}
pub type API_SET_NAMESPACE = _API_SET_NAMESPACE;
pub type PAPI_SET_NAMESPACE = *mut _API_SET_NAMESPACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _API_SET_HASH_ENTRY {
   pub Hash: ULONG,
   pub Index: ULONG,
}
pub type API_SET_HASH_ENTRY = _API_SET_HASH_ENTRY;
pub type PAPI_SET_HASH_ENTRY = *mut _API_SET_HASH_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _API_SET_NAMESPACE_ENTRY {
   pub Flags: ULONG,
   pub NameOffset: ULONG,
   pub NameLength: ULONG,
   pub HashedLength: ULONG,
   pub ValueOffset: ULONG,
   pub ValueCount: ULONG,
}
pub type API_SET_NAMESPACE_ENTRY = _API_SET_NAMESPACE_ENTRY;
pub type PAPI_SET_NAMESPACE_ENTRY = *mut _API_SET_NAMESPACE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _API_SET_VALUE_ENTRY {
   pub Flags: ULONG,
   pub NameOffset: ULONG,
   pub NameLength: ULONG,
   pub ValueOffset: ULONG,
   pub ValueLength: ULONG,
}
pub type API_SET_VALUE_ENTRY = _API_SET_VALUE_ENTRY;
pub type PAPI_SET_VALUE_ENTRY = *mut _API_SET_VALUE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TELEMETRY_COVERAGE_HEADER {
   pub MajorVersion: UCHAR,
   pub MinorVersion: UCHAR,
   pub __bindgen_anon_1: _TELEMETRY_COVERAGE_HEADER__bindgen_ty_1,
   pub HashTableEntries: ULONG,
   pub HashIndexMask: ULONG,
   pub TableUpdateVersion: ULONG,
   pub TableSizeInBytes: ULONG,
   pub LastResetTick: ULONG,
   pub ResetRound: ULONG,
   pub Reserved2: ULONG,
   pub RecordedCount: ULONG,
   pub Reserved3: [ULONG; 4usize],
   pub HashTable: [ULONG; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TELEMETRY_COVERAGE_HEADER__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TELEMETRY_COVERAGE_HEADER__bindgen_ty_1 {
   #[inline]
   pub fn TracingEnabled(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_TracingEnabled(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved1(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 15u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      TracingEnabled: USHORT,
      Reserved1: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let TracingEnabled: u16 = unsafe { ::core::mem::transmute(TracingEnabled) };
         TracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 15u8, {
         let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type TELEMETRY_COVERAGE_HEADER = _TELEMETRY_COVERAGE_HEADER;
pub type PTELEMETRY_COVERAGE_HEADER = *mut _TELEMETRY_COVERAGE_HEADER;
#[repr(C)]
pub struct _PEB {
   pub InheritedAddressSpace: BOOLEAN,
   pub ReadImageFileExecOptions: BOOLEAN,
   pub BeingDebugged: BOOLEAN,
   pub __bindgen_anon_1: _PEB__bindgen_ty_1,
   pub Mutant: HANDLE,
   pub ImageBaseAddress: PVOID,
   pub Ldr: PPEB_LDR_DATA,
   pub ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
   pub SubSystemData: PVOID,
   pub ProcessHeap: PVOID,
   pub FastPebLock: PRTL_CRITICAL_SECTION,
   pub AtlThunkSListPtr: PSLIST_HEADER,
   pub IFEOKey: PVOID,
   pub __bindgen_anon_2: _PEB__bindgen_ty_2,
   pub __bindgen_anon_3: _PEB__bindgen_ty_3,
   pub SystemReserved: ULONG,
   pub AtlThunkSListPtr32: ULONG,
   pub ApiSetMap: PAPI_SET_NAMESPACE,
   pub TlsExpansionCounter: ULONG,
   pub TlsBitmap: PRTL_BITMAP,
   pub TlsBitmapBits: [ULONG; 2usize],
   pub ReadOnlySharedMemoryBase: PVOID,
   pub SharedData: PSILO_USER_SHARED_DATA,
   pub ReadOnlyStaticServerData: *mut PVOID,
   pub AnsiCodePageData: PVOID,
   pub OemCodePageData: PVOID,
   pub UnicodeCaseTableData: PVOID,
   pub NumberOfProcessors: ULONG,
   pub NtGlobalFlag: ULONG,
   pub CriticalSectionTimeout: ULARGE_INTEGER,
   pub HeapSegmentReserve: SIZE_T,
   pub HeapSegmentCommit: SIZE_T,
   pub HeapDeCommitTotalFreeThreshold: SIZE_T,
   pub HeapDeCommitFreeBlockThreshold: SIZE_T,
   pub NumberOfHeaps: ULONG,
   pub MaximumNumberOfHeaps: ULONG,
   pub ProcessHeaps: *mut PVOID,
   pub GdiSharedHandleTable: PVOID,
   pub ProcessStarterHelper: PVOID,
   pub GdiDCAttributeList: ULONG,
   pub LoaderLock: PRTL_CRITICAL_SECTION,
   pub OSMajorVersion: ULONG,
   pub OSMinorVersion: ULONG,
   pub OSBuildNumber: USHORT,
   pub OSCSDVersion: USHORT,
   pub OSPlatformId: ULONG,
   pub ImageSubsystem: ULONG,
   pub ImageSubsystemMajorVersion: ULONG,
   pub ImageSubsystemMinorVersion: ULONG,
   pub ActiveProcessAffinityMask: KAFFINITY,
   pub GdiHandleBuffer: GDI_HANDLE_BUFFER,
   pub PostProcessInitRoutine: PVOID,
   pub TlsExpansionBitmap: PRTL_BITMAP,
   pub TlsExpansionBitmapBits: [ULONG; 32usize],
   pub SessionId: ULONG,
   pub AppCompatFlags: ULARGE_INTEGER,
   pub AppCompatFlagsUser: ULARGE_INTEGER,
   pub pShimData: PVOID,
   pub AppCompatInfo: PVOID,
   pub CSDVersion: UNICODE_STRING,
   pub ActivationContextData: PACTIVATION_CONTEXT_DATA,
   pub ProcessAssemblyStorageMap: PASSEMBLY_STORAGE_MAP,
   pub SystemDefaultActivationContextData: PACTIVATION_CONTEXT_DATA,
   pub SystemAssemblyStorageMap: PASSEMBLY_STORAGE_MAP,
   pub MinimumStackCommit: SIZE_T,
   pub SparePointers: [PVOID; 2usize],
   pub PatchLoaderData: PVOID,
   pub ChpeV2ProcessInfo: PVOID,
   pub AppModelFeatureState: ULONG,
   pub SpareUlongs: [ULONG; 2usize],
   pub ActiveCodePage: USHORT,
   pub OemCodePage: USHORT,
   pub UseCaseMapping: USHORT,
   pub UnusedNlsField: USHORT,
   pub WerRegistrationData: PVOID,
   pub WerShipAssertPtr: PVOID,
   pub __bindgen_anon_4: _PEB__bindgen_ty_4,
   pub pImageHeaderHash: PVOID,
   pub __bindgen_anon_5: _PEB__bindgen_ty_5,
   pub CsrServerReadOnlySharedMemoryBase: ULONGLONG,
   pub TppWorkerpListLock: PRTL_CRITICAL_SECTION,
   pub TppWorkerpList: LIST_ENTRY,
   pub WaitOnAddressHashTable: [PVOID; 128usize],
   pub TelemetryCoverageHeader: PTELEMETRY_COVERAGE_HEADER,
   pub CloudFileFlags: ULONG,
   pub CloudFileDiagFlags: ULONG,
   pub PlaceholderCompatibilityMode: CHAR,
   pub PlaceholderCompatibilityModeReserved: [CHAR; 7usize],
   pub LeapSecondData: PLEAP_SECOND_DATA,
   pub __bindgen_anon_6: _PEB__bindgen_ty_6,
   pub NtGlobalFlag2: ULONG,
   pub ExtendedFeatureDisableMask: ULONGLONG,
}
#[repr(C)]
pub union _PEB__bindgen_ty_1 {
   pub BitField: ::core::mem::ManuallyDrop<BOOLEAN>,
   pub __bindgen_anon_1: ::core::mem::ManuallyDrop<_PEB__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
pub struct _PEB__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _PEB__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PEB__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ImageUsesLargePages(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ImageUsesLargePages(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsProtectedProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsProtectedProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsImageDynamicallyRelocated(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsImageDynamicallyRelocated(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SkipPatchingUser32Forwarders(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SkipPatchingUser32Forwarders(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsPackagedProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsPackagedProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsAppContainer(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsAppContainer(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsProtectedProcessLight(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsProtectedProcessLight(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsLongPathAwareProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsLongPathAwareProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ImageUsesLargePages: BOOLEAN,
      IsProtectedProcess: BOOLEAN,
      IsImageDynamicallyRelocated: BOOLEAN,
      SkipPatchingUser32Forwarders: BOOLEAN,
      IsPackagedProcess: BOOLEAN,
      IsAppContainer: BOOLEAN,
      IsProtectedProcessLight: BOOLEAN,
      IsLongPathAwareProcess: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ImageUsesLargePages: u8 = unsafe { ::core::mem::transmute(ImageUsesLargePages) };
         ImageUsesLargePages as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsProtectedProcess: u8 = unsafe { ::core::mem::transmute(IsProtectedProcess) };
         IsProtectedProcess as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IsImageDynamicallyRelocated: u8 =
            unsafe { ::core::mem::transmute(IsImageDynamicallyRelocated) };
         IsImageDynamicallyRelocated as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SkipPatchingUser32Forwarders: u8 =
            unsafe { ::core::mem::transmute(SkipPatchingUser32Forwarders) };
         SkipPatchingUser32Forwarders as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let IsPackagedProcess: u8 = unsafe { ::core::mem::transmute(IsPackagedProcess) };
         IsPackagedProcess as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let IsAppContainer: u8 = unsafe { ::core::mem::transmute(IsAppContainer) };
         IsAppContainer as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let IsProtectedProcessLight: u8 =
            unsafe { ::core::mem::transmute(IsProtectedProcessLight) };
         IsProtectedProcessLight as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let IsLongPathAwareProcess: u8 = unsafe { ::core::mem::transmute(IsLongPathAwareProcess) };
         IsLongPathAwareProcess as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_2 {
   pub CrossProcessFlags: ULONG,
   pub __bindgen_anon_1: _PEB__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn ProcessInJob(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessInJob(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessInitializing(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessInitializing(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessUsingVEH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingVEH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessUsingVCH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingVCH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessUsingFTH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingFTH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessPreviouslyThrottled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessPreviouslyThrottled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessCurrentlyThrottled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessCurrentlyThrottled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessImagesHotPatched(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessImagesHotPatched(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedBits0(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedBits0(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ProcessInJob: ULONG,
      ProcessInitializing: ULONG,
      ProcessUsingVEH: ULONG,
      ProcessUsingVCH: ULONG,
      ProcessUsingFTH: ULONG,
      ProcessPreviouslyThrottled: ULONG,
      ProcessCurrentlyThrottled: ULONG,
      ProcessImagesHotPatched: ULONG,
      ReservedBits0: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ProcessInJob: u32 = unsafe { ::core::mem::transmute(ProcessInJob) };
         ProcessInJob as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ProcessInitializing: u32 = unsafe { ::core::mem::transmute(ProcessInitializing) };
         ProcessInitializing as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ProcessUsingVEH: u32 = unsafe { ::core::mem::transmute(ProcessUsingVEH) };
         ProcessUsingVEH as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ProcessUsingVCH: u32 = unsafe { ::core::mem::transmute(ProcessUsingVCH) };
         ProcessUsingVCH as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let ProcessUsingFTH: u32 = unsafe { ::core::mem::transmute(ProcessUsingFTH) };
         ProcessUsingFTH as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let ProcessPreviouslyThrottled: u32 =
            unsafe { ::core::mem::transmute(ProcessPreviouslyThrottled) };
         ProcessPreviouslyThrottled as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let ProcessCurrentlyThrottled: u32 =
            unsafe { ::core::mem::transmute(ProcessCurrentlyThrottled) };
         ProcessCurrentlyThrottled as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let ProcessImagesHotPatched: u32 =
            unsafe { ::core::mem::transmute(ProcessImagesHotPatched) };
         ProcessImagesHotPatched as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let ReservedBits0: u32 = unsafe { ::core::mem::transmute(ReservedBits0) };
         ReservedBits0 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_3 {
   pub KernelCallbackTable: PVOID,
   pub UserSharedInfoPtr: PVOID,
}
impl Default for _PEB__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_4 {
   pub pContextData: PVOID,
   pub pUnused: PVOID,
   pub EcCodeBitMap: PVOID,
}
impl Default for _PEB__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_5 {
   pub TracingFlags: ULONG,
   pub __bindgen_anon_1: _PEB__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB__bindgen_ty_5__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB__bindgen_ty_5__bindgen_ty_1 {
   #[inline]
   pub fn HeapTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HeapTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CritSecTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CritSecTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LibLoaderTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LibLoaderTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareTracingBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_SpareTracingBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      HeapTracingEnabled: ULONG,
      CritSecTracingEnabled: ULONG,
      LibLoaderTracingEnabled: ULONG,
      SpareTracingBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let HeapTracingEnabled: u32 = unsafe { ::core::mem::transmute(HeapTracingEnabled) };
         HeapTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let CritSecTracingEnabled: u32 = unsafe { ::core::mem::transmute(CritSecTracingEnabled) };
         CritSecTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let LibLoaderTracingEnabled: u32 =
            unsafe { ::core::mem::transmute(LibLoaderTracingEnabled) };
         LibLoaderTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let SpareTracingBits: u32 = unsafe { ::core::mem::transmute(SpareTracingBits) };
         SpareTracingBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_6 {
   pub LeapSecondFlags: ULONG,
   pub __bindgen_anon_1: _PEB__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB__bindgen_ty_6__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB__bindgen_ty_6__bindgen_ty_1 {
   #[inline]
   pub fn SixtySecondEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SixtySecondEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SixtySecondEnabled: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SixtySecondEnabled: u32 = unsafe { ::core::mem::transmute(SixtySecondEnabled) };
         SixtySecondEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB__bindgen_ty_6 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PEB {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEB = _PEB;
pub type PPEB = *mut _PEB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDI_TEB_BATCH {
   pub Offset: ULONG,
   pub HDC: ULONG_PTR,
   pub Buffer: [ULONG; 310usize],
}
impl Default for _GDI_TEB_BATCH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GDI_TEB_BATCH = _GDI_TEB_BATCH;
pub type PGDI_TEB_BATCH = *mut _GDI_TEB_BATCH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB_ACTIVE_FRAME_CONTEXT {
   pub Flags: ULONG,
   pub FrameName: PSTR,
}
impl Default for _TEB_ACTIVE_FRAME_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TEB_ACTIVE_FRAME_CONTEXT = _TEB_ACTIVE_FRAME_CONTEXT;
pub type PTEB_ACTIVE_FRAME_CONTEXT = *mut _TEB_ACTIVE_FRAME_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB_ACTIVE_FRAME_CONTEXT_EX {
   pub BasicContext: TEB_ACTIVE_FRAME_CONTEXT,
   pub SourceLocation: PSTR,
}
impl Default for _TEB_ACTIVE_FRAME_CONTEXT_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TEB_ACTIVE_FRAME_CONTEXT_EX = _TEB_ACTIVE_FRAME_CONTEXT_EX;
pub type PTEB_ACTIVE_FRAME_CONTEXT_EX = *mut _TEB_ACTIVE_FRAME_CONTEXT_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB_ACTIVE_FRAME {
   pub Flags: ULONG,
   pub Previous: *mut _TEB_ACTIVE_FRAME,
   pub Context: PTEB_ACTIVE_FRAME_CONTEXT,
}
impl Default for _TEB_ACTIVE_FRAME {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TEB_ACTIVE_FRAME = _TEB_ACTIVE_FRAME;
pub type PTEB_ACTIVE_FRAME = *mut _TEB_ACTIVE_FRAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB_ACTIVE_FRAME_EX {
   pub BasicFrame: TEB_ACTIVE_FRAME,
   pub ExtensionIdentifier: PVOID,
}
impl Default for _TEB_ACTIVE_FRAME_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TEB_ACTIVE_FRAME_EX = _TEB_ACTIVE_FRAME_EX;
pub type PTEB_ACTIVE_FRAME_EX = *mut _TEB_ACTIVE_FRAME_EX;
#[repr(C)]
pub struct _TEB {
   pub NtTib: NT_TIB,
   pub EnvironmentPointer: PVOID,
   pub ClientId: CLIENT_ID,
   pub ActiveRpcHandle: PVOID,
   pub ThreadLocalStoragePointer: PVOID,
   pub ProcessEnvironmentBlock: PPEB,
   pub LastErrorValue: ULONG,
   pub CountOfOwnedCriticalSections: ULONG,
   pub CsrClientThread: PVOID,
   pub Win32ThreadInfo: PVOID,
   pub User32Reserved: [ULONG; 26usize],
   pub UserReserved: [ULONG; 5usize],
   pub WOW32Reserved: PVOID,
   pub CurrentLocale: LCID,
   pub FpSoftwareStatusRegister: ULONG,
   pub ReservedForDebuggerInstrumentation: [PVOID; 16usize],
   pub SystemReserved1: [PVOID; 30usize],
   pub PlaceholderCompatibilityMode: CHAR,
   pub PlaceholderHydrationAlwaysExplicit: BOOLEAN,
   pub PlaceholderReserved: [CHAR; 10usize],
   pub ProxiedProcessId: ULONG,
   pub ActivationStack: ACTIVATION_CONTEXT_STACK,
   pub WorkingOnBehalfTicket: [UCHAR; 8usize],
   pub ExceptionCode: NTSTATUS,
   pub ActivationContextStackPointer: PACTIVATION_CONTEXT_STACK,
   pub InstrumentationCallbackSp: ULONG_PTR,
   pub InstrumentationCallbackPreviousPc: ULONG_PTR,
   pub InstrumentationCallbackPreviousSp: ULONG_PTR,
   pub TxFsContext: ULONG,
   pub InstrumentationCallbackDisabled: BOOLEAN,
   pub UnalignedLoadStoreExceptions: BOOLEAN,
   pub GdiTebBatch: GDI_TEB_BATCH,
   pub RealClientId: CLIENT_ID,
   pub GdiCachedProcessHandle: HANDLE,
   pub GdiClientPID: ULONG,
   pub GdiClientTID: ULONG,
   pub GdiThreadLocalInfo: PVOID,
   pub Win32ClientInfo: [ULONG_PTR; 62usize],
   pub glDispatchTable: [PVOID; 233usize],
   pub glReserved1: [ULONG_PTR; 29usize],
   pub glReserved2: PVOID,
   pub glSectionInfo: PVOID,
   pub glSection: PVOID,
   pub glTable: PVOID,
   pub glCurrentRC: PVOID,
   pub glContext: PVOID,
   pub LastStatusValue: NTSTATUS,
   pub StaticUnicodeString: UNICODE_STRING,
   pub StaticUnicodeBuffer: [WCHAR; 261usize],
   pub DeallocationStack: PVOID,
   pub TlsSlots: [PVOID; 64usize],
   pub TlsLinks: LIST_ENTRY,
   pub Vdm: PVOID,
   pub ReservedForNtRpc: PVOID,
   pub DbgSsReserved: [PVOID; 2usize],
   pub HardErrorMode: ULONG,
   pub Instrumentation: [PVOID; 11usize],
   pub ActivityId: GUID,
   pub SubProcessTag: PVOID,
   pub PerflibData: PVOID,
   pub EtwTraceData: PVOID,
   pub WinSockData: PVOID,
   pub GdiBatchCount: ULONG,
   pub __bindgen_anon_1: _TEB__bindgen_ty_1,
   pub GuaranteedStackBytes: ULONG,
   pub ReservedForPerf: PVOID,
   pub ReservedForOle: PVOID,
   pub WaitingOnLoaderLock: ULONG,
   pub SavedPriorityState: PVOID,
   pub ReservedForCodeCoverage: ULONG_PTR,
   pub ThreadPoolData: PVOID,
   pub TlsExpansionSlots: *mut PVOID,
   pub DeallocationBStore: PVOID,
   pub BStoreLimit: PVOID,
   pub MuiGeneration: ULONG,
   pub IsImpersonating: ULONG,
   pub NlsCache: PVOID,
   pub pShimData: PVOID,
   pub HeapData: ULONG,
   pub CurrentTransactionHandle: HANDLE,
   pub ActiveFrame: PTEB_ACTIVE_FRAME,
   pub FlsData: PVOID,
   pub PreferredLanguages: PVOID,
   pub UserPrefLanguages: PVOID,
   pub MergedPrefLanguages: PVOID,
   pub MuiImpersonation: ULONG,
   pub __bindgen_anon_2: _TEB__bindgen_ty_2,
   pub __bindgen_anon_3: _TEB__bindgen_ty_3,
   pub TxnScopeEnterCallback: PVOID,
   pub TxnScopeExitCallback: PVOID,
   pub TxnScopeContext: PVOID,
   pub LockCount: ULONG,
   pub WowTebOffset: LONG,
   pub ResourceRetValue: PVOID,
   pub ReservedForWdf: PVOID,
   pub ReservedForCrt: ULONGLONG,
   pub EffectiveContainerId: GUID,
   pub LastSleepCounter: ULONGLONG,
   pub SpinCallCount: ULONG,
   pub ExtendedFeatureDisableMask: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_1 {
   pub CurrentIdealProcessor: PROCESSOR_NUMBER,
   pub IdealProcessorValue: ULONG,
   pub __bindgen_anon_1: _TEB__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB__bindgen_ty_1__bindgen_ty_1 {
   pub ReservedPad0: UCHAR,
   pub ReservedPad1: UCHAR,
   pub ReservedPad2: UCHAR,
   pub IdealProcessor: UCHAR,
}
impl Default for _TEB__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_2 {
   pub CrossTebFlags: USHORT,
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _TEB__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _TEB__bindgen_ty_2 {
   #[inline]
   pub fn SpareCrossTebBits(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
   }
   #[inline]
   pub fn set_SpareCrossTebBits(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(SpareCrossTebBits: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 16u8, {
         let SpareCrossTebBits: u16 = unsafe { ::core::mem::transmute(SpareCrossTebBits) };
         SpareCrossTebBits as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_3 {
   pub SameTebFlags: USHORT,
   pub __bindgen_anon_1: _TEB__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB__bindgen_ty_3__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TEB__bindgen_ty_3__bindgen_ty_1 {
   #[inline]
   pub fn SafeThunkCall(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SafeThunkCall(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InDebugPrint(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_InDebugPrint(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HasFiberData(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_HasFiberData(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SkipThreadAttach(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SkipThreadAttach(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn WerInShipAssertCode(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_WerInShipAssertCode(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn RanProcessInit(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_RanProcessInit(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ClonedThread(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_ClonedThread(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SuppressDebugMsg(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SuppressDebugMsg(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DisableUserStackWalk(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_DisableUserStackWalk(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn RtlExceptionAttached(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_RtlExceptionAttached(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InitialThread(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_InitialThread(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SessionAware(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SessionAware(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LoadOwner(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_LoadOwner(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LoaderWorker(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_LoaderWorker(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SkipLoaderInit(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SkipLoaderInit(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SkipFileAPIBrokering(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SkipFileAPIBrokering(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SafeThunkCall: USHORT,
      InDebugPrint: USHORT,
      HasFiberData: USHORT,
      SkipThreadAttach: USHORT,
      WerInShipAssertCode: USHORT,
      RanProcessInit: USHORT,
      ClonedThread: USHORT,
      SuppressDebugMsg: USHORT,
      DisableUserStackWalk: USHORT,
      RtlExceptionAttached: USHORT,
      InitialThread: USHORT,
      SessionAware: USHORT,
      LoadOwner: USHORT,
      LoaderWorker: USHORT,
      SkipLoaderInit: USHORT,
      SkipFileAPIBrokering: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SafeThunkCall: u16 = unsafe { ::core::mem::transmute(SafeThunkCall) };
         SafeThunkCall as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let InDebugPrint: u16 = unsafe { ::core::mem::transmute(InDebugPrint) };
         InDebugPrint as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let HasFiberData: u16 = unsafe { ::core::mem::transmute(HasFiberData) };
         HasFiberData as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SkipThreadAttach: u16 = unsafe { ::core::mem::transmute(SkipThreadAttach) };
         SkipThreadAttach as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let WerInShipAssertCode: u16 = unsafe { ::core::mem::transmute(WerInShipAssertCode) };
         WerInShipAssertCode as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let RanProcessInit: u16 = unsafe { ::core::mem::transmute(RanProcessInit) };
         RanProcessInit as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let ClonedThread: u16 = unsafe { ::core::mem::transmute(ClonedThread) };
         ClonedThread as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let SuppressDebugMsg: u16 = unsafe { ::core::mem::transmute(SuppressDebugMsg) };
         SuppressDebugMsg as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let DisableUserStackWalk: u16 = unsafe { ::core::mem::transmute(DisableUserStackWalk) };
         DisableUserStackWalk as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let RtlExceptionAttached: u16 = unsafe { ::core::mem::transmute(RtlExceptionAttached) };
         RtlExceptionAttached as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let InitialThread: u16 = unsafe { ::core::mem::transmute(InitialThread) };
         InitialThread as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let SessionAware: u16 = unsafe { ::core::mem::transmute(SessionAware) };
         SessionAware as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let LoadOwner: u16 = unsafe { ::core::mem::transmute(LoadOwner) };
         LoadOwner as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let LoaderWorker: u16 = unsafe { ::core::mem::transmute(LoaderWorker) };
         LoaderWorker as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let SkipLoaderInit: u16 = unsafe { ::core::mem::transmute(SkipLoaderInit) };
         SkipLoaderInit as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let SkipFileAPIBrokering: u16 = unsafe { ::core::mem::transmute(SkipFileAPIBrokering) };
         SkipFileAPIBrokering as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _TEB__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TEB {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TEB = _TEB;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESSINFOCLASS {
   ProcessBasicInformation = 0,
   ProcessQuotaLimits = 1,
   ProcessIoCounters = 2,
   ProcessVmCounters = 3,
   ProcessTimes = 4,
   ProcessBasePriority = 5,
   ProcessRaisePriority = 6,
   ProcessDebugPort = 7,
   ProcessExceptionPort = 8,
   ProcessAccessToken = 9,
   ProcessLdtInformation = 10,
   ProcessLdtSize = 11,
   ProcessDefaultHardErrorMode = 12,
   ProcessIoPortHandlers = 13,
   ProcessPooledUsageAndLimits = 14,
   ProcessWorkingSetWatch = 15,
   ProcessUserModeIOPL = 16,
   ProcessEnableAlignmentFaultFixup = 17,
   ProcessPriorityClass = 18,
   ProcessWx86Information = 19,
   ProcessHandleCount = 20,
   ProcessAffinityMask = 21,
   ProcessPriorityBoost = 22,
   ProcessDeviceMap = 23,
   ProcessSessionInformation = 24,
   ProcessForegroundInformation = 25,
   ProcessWow64Information = 26,
   ProcessImageFileName = 27,
   ProcessLUIDDeviceMapsEnabled = 28,
   ProcessBreakOnTermination = 29,
   ProcessDebugObjectHandle = 30,
   ProcessDebugFlags = 31,
   ProcessHandleTracing = 32,
   ProcessIoPriority = 33,
   ProcessExecuteFlags = 34,
   ProcessTlsInformation = 35,
   ProcessCookie = 36,
   ProcessImageInformation = 37,
   ProcessCycleTime = 38,
   ProcessPagePriority = 39,
   ProcessInstrumentationCallback = 40,
   ProcessThreadStackAllocation = 41,
   ProcessWorkingSetWatchEx = 42,
   ProcessImageFileNameWin32 = 43,
   ProcessImageFileMapping = 44,
   ProcessAffinityUpdateMode = 45,
   ProcessMemoryAllocationMode = 46,
   ProcessGroupInformation = 47,
   ProcessTokenVirtualizationEnabled = 48,
   ProcessConsoleHostProcess = 49,
   ProcessWindowInformation = 50,
   ProcessHandleInformation = 51,
   ProcessMitigationPolicy = 52,
   ProcessDynamicFunctionTableInformation = 53,
   ProcessHandleCheckingMode = 54,
   ProcessKeepAliveCount = 55,
   ProcessRevokeFileHandles = 56,
   ProcessWorkingSetControl = 57,
   ProcessHandleTable = 58,
   ProcessCheckStackExtentsMode = 59,
   ProcessCommandLineInformation = 60,
   ProcessProtectionInformation = 61,
   ProcessMemoryExhaustion = 62,
   ProcessFaultInformation = 63,
   ProcessTelemetryIdInformation = 64,
   ProcessCommitReleaseInformation = 65,
   ProcessDefaultCpuSetsInformation = 66,
   ProcessAllowedCpuSetsInformation = 67,
   ProcessSubsystemProcess = 68,
   ProcessJobMemoryInformation = 69,
   ProcessInPrivate = 70,
   ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
   ProcessIumChallengeResponse = 72,
   ProcessChildProcessInformation = 73,
   ProcessHighGraphicsPriorityInformation = 74,
   ProcessSubsystemInformation = 75,
   ProcessEnergyValues = 76,
   ProcessPowerThrottlingState = 77,
   ProcessReserved3Information = 78,
   ProcessWin32kSyscallFilterInformation = 79,
   ProcessDisableSystemAllowedCpuSets = 80,
   ProcessWakeInformation = 81,
   ProcessEnergyTrackingState = 82,
   ProcessManageWritesToExecutableMemory = 83,
   ProcessCaptureTrustletLiveDump = 84,
   ProcessTelemetryCoverage = 85,
   ProcessEnclaveInformation = 86,
   ProcessEnableReadWriteVmLogging = 87,
   ProcessUptimeInformation = 88,
   ProcessImageSection = 89,
   ProcessDebugAuthInformation = 90,
   ProcessSystemResourceManagement = 91,
   ProcessSequenceNumber = 92,
   ProcessLoaderDetour = 93,
   ProcessSecurityDomainInformation = 94,
   ProcessCombineSecurityDomainsInformation = 95,
   ProcessEnableLogging = 96,
   ProcessLeapSecondInformation = 97,
   ProcessFiberShadowStackAllocation = 98,
   ProcessFreeFiberShadowStackAllocation = 99,
   ProcessAltSystemCallInformation = 100,
   ProcessDynamicEHContinuationTargets = 101,
   ProcessDynamicEnforcedCetCompatibleRanges = 102,
   ProcessCreateStateChange = 103,
   ProcessApplyStateChange = 104,
   ProcessEnableOptionalXStateFeatures = 105,
   ProcessAltPrefetchParam = 106,
   ProcessAssignCpuPartitions = 107,
   ProcessPriorityClassEx = 108,
   ProcessMembershipInformation = 109,
   ProcessEffectiveIoPriority = 110,
   ProcessEffectivePagePriority = 111,
   MaxProcessInfoClass = 112,
}
pub use self::_PROCESSINFOCLASS as PROCESSINFOCLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _THREADINFOCLASS {
   ThreadBasicInformation = 0,
   ThreadTimes = 1,
   ThreadPriority = 2,
   ThreadBasePriority = 3,
   ThreadAffinityMask = 4,
   ThreadImpersonationToken = 5,
   ThreadDescriptorTableEntry = 6,
   ThreadEnableAlignmentFaultFixup = 7,
   ThreadEventPair = 8,
   ThreadQuerySetWin32StartAddress = 9,
   ThreadZeroTlsCell = 10,
   ThreadPerformanceCount = 11,
   ThreadAmILastThread = 12,
   ThreadIdealProcessor = 13,
   ThreadPriorityBoost = 14,
   ThreadSetTlsArrayAddress = 15,
   ThreadIsIoPending = 16,
   ThreadHideFromDebugger = 17,
   ThreadBreakOnTermination = 18,
   ThreadSwitchLegacyState = 19,
   ThreadIsTerminated = 20,
   ThreadLastSystemCall = 21,
   ThreadIoPriority = 22,
   ThreadCycleTime = 23,
   ThreadPagePriority = 24,
   ThreadActualBasePriority = 25,
   ThreadTebInformation = 26,
   ThreadCSwitchMon = 27,
   ThreadCSwitchPmu = 28,
   ThreadWow64Context = 29,
   ThreadGroupInformation = 30,
   ThreadUmsInformation = 31,
   ThreadCounterProfiling = 32,
   ThreadIdealProcessorEx = 33,
   ThreadCpuAccountingInformation = 34,
   ThreadSuspendCount = 35,
   ThreadHeterogeneousCpuPolicy = 36,
   ThreadContainerId = 37,
   ThreadNameInformation = 38,
   ThreadSelectedCpuSets = 39,
   ThreadSystemThreadInformation = 40,
   ThreadActualGroupAffinity = 41,
   ThreadDynamicCodePolicyInfo = 42,
   ThreadExplicitCaseSensitivity = 43,
   ThreadWorkOnBehalfTicket = 44,
   ThreadSubsystemInformation = 45,
   ThreadDbgkWerReportActive = 46,
   ThreadAttachContainer = 47,
   ThreadManageWritesToExecutableMemory = 48,
   ThreadPowerThrottlingState = 49,
   ThreadWorkloadClass = 50,
   ThreadCreateStateChange = 51,
   ThreadApplyStateChange = 52,
   ThreadStrongerBadHandleChecks = 53,
   ThreadEffectiveIoPriority = 54,
   ThreadEffectivePagePriority = 55,
   MaxThreadInfoClass = 56,
}
pub use self::_THREADINFOCLASS as THREADINFOCLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PAGE_PRIORITY_INFORMATION {
   pub PagePriority: ULONG,
}
pub type PAGE_PRIORITY_INFORMATION = _PAGE_PRIORITY_INFORMATION;
pub type PPAGE_PRIORITY_INFORMATION = *mut _PAGE_PRIORITY_INFORMATION;
#[repr(C)]
pub struct _PROCESS_BASIC_INFORMATION {
   pub ExitStatus: NTSTATUS,
   pub PebBaseAddress: PPEB,
   pub AffinityMask: KAFFINITY,
   pub BasePriority: KPRIORITY,
   pub UniqueProcessId: HANDLE,
   pub InheritedFromUniqueProcessId: HANDLE,
}
impl Default for _PROCESS_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_BASIC_INFORMATION = _PROCESS_BASIC_INFORMATION;
pub type PPROCESS_BASIC_INFORMATION = *mut _PROCESS_BASIC_INFORMATION;
#[repr(C)]
pub struct _PROCESS_EXTENDED_BASIC_INFORMATION {
   pub Size: SIZE_T,
   pub BasicInfo: PROCESS_BASIC_INFORMATION,
   pub __bindgen_anon_1: _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn IsProtectedProcess(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsProtectedProcess(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsWow64Process(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsWow64Process(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsProcessDeleting(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsProcessDeleting(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsCrossSessionCreate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsCrossSessionCreate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsFrozen(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsFrozen(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsBackground(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsBackground(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsStronglyNamed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsStronglyNamed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsSecureProcess(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSecureProcess(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsSubsystemProcess(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSubsystemProcess(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
   }
   #[inline]
   pub fn set_SpareBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 23u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsProtectedProcess: ULONG,
      IsWow64Process: ULONG,
      IsProcessDeleting: ULONG,
      IsCrossSessionCreate: ULONG,
      IsFrozen: ULONG,
      IsBackground: ULONG,
      IsStronglyNamed: ULONG,
      IsSecureProcess: ULONG,
      IsSubsystemProcess: ULONG,
      SpareBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsProtectedProcess: u32 = unsafe { ::core::mem::transmute(IsProtectedProcess) };
         IsProtectedProcess as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsWow64Process: u32 = unsafe { ::core::mem::transmute(IsWow64Process) };
         IsWow64Process as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IsProcessDeleting: u32 = unsafe { ::core::mem::transmute(IsProcessDeleting) };
         IsProcessDeleting as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let IsCrossSessionCreate: u32 = unsafe { ::core::mem::transmute(IsCrossSessionCreate) };
         IsCrossSessionCreate as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let IsFrozen: u32 = unsafe { ::core::mem::transmute(IsFrozen) };
         IsFrozen as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let IsBackground: u32 = unsafe { ::core::mem::transmute(IsBackground) };
         IsBackground as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let IsStronglyNamed: u32 = unsafe { ::core::mem::transmute(IsStronglyNamed) };
         IsStronglyNamed as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let IsSecureProcess: u32 = unsafe { ::core::mem::transmute(IsSecureProcess) };
         IsSecureProcess as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let IsSubsystemProcess: u32 = unsafe { ::core::mem::transmute(IsSubsystemProcess) };
         IsSubsystemProcess as u64
      });
      __bindgen_bitfield_unit.set(9usize, 23u8, {
         let SpareBits: u32 = unsafe { ::core::mem::transmute(SpareBits) };
         SpareBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_EXTENDED_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_EXTENDED_BASIC_INFORMATION = _PROCESS_EXTENDED_BASIC_INFORMATION;
pub type PPROCESS_EXTENDED_BASIC_INFORMATION = *mut _PROCESS_EXTENDED_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VM_COUNTERS {
   pub PeakVirtualSize: SIZE_T,
   pub VirtualSize: SIZE_T,
   pub PageFaultCount: ULONG,
   pub PeakWorkingSetSize: SIZE_T,
   pub WorkingSetSize: SIZE_T,
   pub QuotaPeakPagedPoolUsage: SIZE_T,
   pub QuotaPagedPoolUsage: SIZE_T,
   pub QuotaPeakNonPagedPoolUsage: SIZE_T,
   pub QuotaNonPagedPoolUsage: SIZE_T,
   pub PagefileUsage: SIZE_T,
   pub PeakPagefileUsage: SIZE_T,
}
pub type VM_COUNTERS = _VM_COUNTERS;
pub type PVM_COUNTERS = *mut _VM_COUNTERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VM_COUNTERS_EX {
   pub PeakVirtualSize: SIZE_T,
   pub VirtualSize: SIZE_T,
   pub PageFaultCount: ULONG,
   pub PeakWorkingSetSize: SIZE_T,
   pub WorkingSetSize: SIZE_T,
   pub QuotaPeakPagedPoolUsage: SIZE_T,
   pub QuotaPagedPoolUsage: SIZE_T,
   pub QuotaPeakNonPagedPoolUsage: SIZE_T,
   pub QuotaNonPagedPoolUsage: SIZE_T,
   pub PagefileUsage: SIZE_T,
   pub PeakPagefileUsage: SIZE_T,
   pub PrivateUsage: SIZE_T,
}
pub type VM_COUNTERS_EX = _VM_COUNTERS_EX;
pub type PVM_COUNTERS_EX = *mut _VM_COUNTERS_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VM_COUNTERS_EX2 {
   pub CountersEx: VM_COUNTERS_EX,
   pub PrivateWorkingSetSize: SIZE_T,
   pub SharedCommitUsage: SIZE_T,
}
pub type VM_COUNTERS_EX2 = _VM_COUNTERS_EX2;
pub type PVM_COUNTERS_EX2 = *mut _VM_COUNTERS_EX2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KERNEL_USER_TIMES {
   pub CreateTime: LARGE_INTEGER,
   pub ExitTime: LARGE_INTEGER,
   pub KernelTime: LARGE_INTEGER,
   pub UserTime: LARGE_INTEGER,
}
impl Default for _KERNEL_USER_TIMES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KERNEL_USER_TIMES = _KERNEL_USER_TIMES;
pub type PKERNEL_USER_TIMES = *mut _KERNEL_USER_TIMES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POOLED_USAGE_AND_LIMITS {
   pub PeakPagedPoolUsage: SIZE_T,
   pub PagedPoolUsage: SIZE_T,
   pub PagedPoolLimit: SIZE_T,
   pub PeakNonPagedPoolUsage: SIZE_T,
   pub NonPagedPoolUsage: SIZE_T,
   pub NonPagedPoolLimit: SIZE_T,
   pub PeakPagefileUsage: SIZE_T,
   pub PagefileUsage: SIZE_T,
   pub PagefileLimit: SIZE_T,
}
pub type POOLED_USAGE_AND_LIMITS = _POOLED_USAGE_AND_LIMITS;
pub type PPOOLED_USAGE_AND_LIMITS = *mut _POOLED_USAGE_AND_LIMITS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_EXCEPTION_PORT {
   pub ExceptionPortHandle: HANDLE,
   pub StateFlags: ULONG,
}
impl Default for _PROCESS_EXCEPTION_PORT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_EXCEPTION_PORT = _PROCESS_EXCEPTION_PORT;
pub type PPROCESS_EXCEPTION_PORT = *mut _PROCESS_EXCEPTION_PORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_ACCESS_TOKEN {
   pub Token: HANDLE,
   pub Thread: HANDLE,
}
impl Default for _PROCESS_ACCESS_TOKEN {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_ACCESS_TOKEN = _PROCESS_ACCESS_TOKEN;
pub type PPROCESS_ACCESS_TOKEN = *mut _PROCESS_ACCESS_TOKEN;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_LDT_INFORMATION {
   pub Start: ULONG,
   pub Length: ULONG,
   pub LdtEntries: [LDT_ENTRY; 1usize],
}
impl Default for _PROCESS_LDT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_LDT_INFORMATION = _PROCESS_LDT_INFORMATION;
pub type PPROCESS_LDT_INFORMATION = *mut _PROCESS_LDT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_LDT_SIZE {
   pub Length: ULONG,
}
pub type PROCESS_LDT_SIZE = _PROCESS_LDT_SIZE;
pub type PPROCESS_LDT_SIZE = *mut _PROCESS_LDT_SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_WS_WATCH_INFORMATION {
   pub FaultingPc: PVOID,
   pub FaultingVa: PVOID,
}
impl Default for _PROCESS_WS_WATCH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_WS_WATCH_INFORMATION = _PROCESS_WS_WATCH_INFORMATION;
pub type PPROCESS_WS_WATCH_INFORMATION = *mut _PROCESS_WS_WATCH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_WS_WATCH_INFORMATION_EX {
   pub BasicInfo: PROCESS_WS_WATCH_INFORMATION,
   pub FaultingThreadId: ULONG_PTR,
   pub Flags: ULONG_PTR,
}
impl Default for _PROCESS_WS_WATCH_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_WS_WATCH_INFORMATION_EX = _PROCESS_WS_WATCH_INFORMATION_EX;
pub type PPROCESS_WS_WATCH_INFORMATION_EX = *mut _PROCESS_WS_WATCH_INFORMATION_EX;
#[repr(C)]
pub struct _PROCESS_PRIORITY_CLASS {
   pub Foreground: BOOLEAN,
   pub PriorityClass: UCHAR,
}
impl Default for _PROCESS_PRIORITY_CLASS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_PRIORITY_CLASS = _PROCESS_PRIORITY_CLASS;
pub type PPROCESS_PRIORITY_CLASS = *mut _PROCESS_PRIORITY_CLASS;
#[repr(C)]
pub struct _PROCESS_PRIORITY_CLASS_EX {
   pub __bindgen_anon_1: _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1,
   pub PriorityClass: UCHAR,
   pub Foreground: BOOLEAN,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1 {
   pub __bindgen_anon_1: _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1__bindgen_ty_1,
   pub AllFlags: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: u8,
}
impl _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ForegroundValid(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_ForegroundValid(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn PriorityClassValid(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_PriorityClassValid(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ForegroundValid: USHORT,
      PriorityClassValid: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ForegroundValid: u16 = unsafe { ::core::mem::transmute(ForegroundValid) };
         ForegroundValid as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let PriorityClassValid: u16 = unsafe { ::core::mem::transmute(PriorityClassValid) };
         PriorityClassValid as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_PRIORITY_CLASS_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_PRIORITY_CLASS_EX = _PROCESS_PRIORITY_CLASS_EX;
pub type PPROCESS_PRIORITY_CLASS_EX = *mut _PROCESS_PRIORITY_CLASS_EX;
#[repr(C)]
pub struct _PROCESS_FOREGROUND_BACKGROUND {
   pub Foreground: BOOLEAN,
}
impl Default for _PROCESS_FOREGROUND_BACKGROUND {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_FOREGROUND_BACKGROUND = _PROCESS_FOREGROUND_BACKGROUND;
pub type PPROCESS_FOREGROUND_BACKGROUND = *mut _PROCESS_FOREGROUND_BACKGROUND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION {
   pub __bindgen_anon_1: _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1 {
   pub Set: _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub Query: _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub DirectoryHandle: HANDLE,
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
   pub DriveMap: ULONG,
   pub DriveType: [UCHAR; 32usize],
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_DEVICEMAP_INFORMATION = _PROCESS_DEVICEMAP_INFORMATION;
pub type PPROCESS_DEVICEMAP_INFORMATION = *mut _PROCESS_DEVICEMAP_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX {
   pub __bindgen_anon_1: _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1,
   pub Flags: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1 {
   pub Set: _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1,
   pub Query: _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   pub DirectoryHandle: HANDLE,
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2 {
   pub DriveMap: ULONG,
   pub DriveType: [UCHAR; 32usize],
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_DEVICEMAP_INFORMATION_EX = _PROCESS_DEVICEMAP_INFORMATION_EX;
pub type PPROCESS_DEVICEMAP_INFORMATION_EX = *mut _PROCESS_DEVICEMAP_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_SESSION_INFORMATION {
   pub SessionId: ULONG,
}
pub type PROCESS_SESSION_INFORMATION = _PROCESS_SESSION_INFORMATION;
pub type PPROCESS_SESSION_INFORMATION = *mut _PROCESS_SESSION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_ENABLE {
   pub Flags: ULONG,
}
pub type PROCESS_HANDLE_TRACING_ENABLE = _PROCESS_HANDLE_TRACING_ENABLE;
pub type PPROCESS_HANDLE_TRACING_ENABLE = *mut _PROCESS_HANDLE_TRACING_ENABLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_ENABLE_EX {
   pub Flags: ULONG,
   pub TotalSlots: ULONG,
}
pub type PROCESS_HANDLE_TRACING_ENABLE_EX = _PROCESS_HANDLE_TRACING_ENABLE_EX;
pub type PPROCESS_HANDLE_TRACING_ENABLE_EX = *mut _PROCESS_HANDLE_TRACING_ENABLE_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_ENTRY {
   pub Handle: HANDLE,
   pub ClientId: CLIENT_ID,
   pub Type: ULONG,
   pub Stacks: [PVOID; 16usize],
}
impl Default for _PROCESS_HANDLE_TRACING_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_HANDLE_TRACING_ENTRY = _PROCESS_HANDLE_TRACING_ENTRY;
pub type PPROCESS_HANDLE_TRACING_ENTRY = *mut _PROCESS_HANDLE_TRACING_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_QUERY {
   pub Handle: HANDLE,
   pub TotalTraces: ULONG,
   pub HandleTrace: [PROCESS_HANDLE_TRACING_ENTRY; 1usize],
}
impl Default for _PROCESS_HANDLE_TRACING_QUERY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_HANDLE_TRACING_QUERY = _PROCESS_HANDLE_TRACING_QUERY;
pub type PPROCESS_HANDLE_TRACING_QUERY = *mut _PROCESS_HANDLE_TRACING_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_TLS_INFORMATION {
   pub Flags: ULONG,
   pub NewTlsData: PVOID,
   pub OldTlsData: PVOID,
   pub ThreadId: HANDLE,
}
impl Default for _THREAD_TLS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_TLS_INFORMATION = _THREAD_TLS_INFORMATION;
pub type PTHREAD_TLS_INFORMATION = *mut _THREAD_TLS_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_TLS_INFORMATION_TYPE {
   ProcessTlsReplaceIndex = 0,
   ProcessTlsReplaceVector = 1,
   MaxProcessTlsOperation = 2,
}
pub use self::_PROCESS_TLS_INFORMATION_TYPE as PROCESS_TLS_INFORMATION_TYPE;
pub type PPROCESS_TLS_INFORMATION_TYPE = *mut _PROCESS_TLS_INFORMATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_TLS_INFORMATION {
   pub Flags: ULONG,
   pub OperationType: ULONG,
   pub ThreadDataCount: ULONG,
   pub TlsIndex: ULONG,
   pub PreviousCount: ULONG,
   pub ThreadData: [THREAD_TLS_INFORMATION; 1usize],
}
impl Default for _PROCESS_TLS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_TLS_INFORMATION = _PROCESS_TLS_INFORMATION;
pub type PPROCESS_TLS_INFORMATION = *mut _PROCESS_TLS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION {
   pub Version: ULONG,
   pub Reserved: ULONG,
   pub Callback: PVOID,
}
impl Default for _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION =
   _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;
pub type PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION =
   *mut _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_STACK_ALLOCATION_INFORMATION {
   pub ReserveSize: SIZE_T,
   pub ZeroBits: SIZE_T,
   pub StackBase: PVOID,
}
impl Default for _PROCESS_STACK_ALLOCATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_STACK_ALLOCATION_INFORMATION = _PROCESS_STACK_ALLOCATION_INFORMATION;
pub type PPROCESS_STACK_ALLOCATION_INFORMATION = *mut _PROCESS_STACK_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_STACK_ALLOCATION_INFORMATION_EX {
   pub PreferredNode: ULONG,
   pub Reserved0: ULONG,
   pub Reserved1: ULONG,
   pub Reserved2: ULONG,
   pub AllocInfo: PROCESS_STACK_ALLOCATION_INFORMATION,
}
impl Default for _PROCESS_STACK_ALLOCATION_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_STACK_ALLOCATION_INFORMATION_EX = _PROCESS_STACK_ALLOCATION_INFORMATION_EX;
pub type PPROCESS_STACK_ALLOCATION_INFORMATION_EX = *mut _PROCESS_STACK_ALLOCATION_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_AFFINITY_UPDATE_MODE {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PROCESS_AFFINITY_UPDATE_MODE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_AFFINITY_UPDATE_MODE__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_AFFINITY_UPDATE_MODE__bindgen_ty_1 {
   #[inline]
   pub fn EnableAutoUpdate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableAutoUpdate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Permanent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Permanent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableAutoUpdate: ULONG,
      Permanent: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableAutoUpdate: u32 = unsafe { ::core::mem::transmute(EnableAutoUpdate) };
         EnableAutoUpdate as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let Permanent: u32 = unsafe { ::core::mem::transmute(Permanent) };
         Permanent as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_AFFINITY_UPDATE_MODE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_AFFINITY_UPDATE_MODE = _PROCESS_AFFINITY_UPDATE_MODE;
pub type PPROCESS_AFFINITY_UPDATE_MODE = *mut _PROCESS_AFFINITY_UPDATE_MODE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MEMORY_ALLOCATION_MODE {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PROCESS_MEMORY_ALLOCATION_MODE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MEMORY_ALLOCATION_MODE__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MEMORY_ALLOCATION_MODE__bindgen_ty_1 {
   #[inline]
   pub fn TopDown(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_TopDown(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(TopDown: ULONG, Reserved: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let TopDown: u32 = unsafe { ::core::mem::transmute(TopDown) };
         TopDown as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MEMORY_ALLOCATION_MODE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MEMORY_ALLOCATION_MODE = _PROCESS_MEMORY_ALLOCATION_MODE;
pub type PPROCESS_MEMORY_ALLOCATION_MODE = *mut _PROCESS_MEMORY_ALLOCATION_MODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_HANDLE_INFORMATION {
   pub HandleCount: ULONG,
   pub HandleCountHighWatermark: ULONG,
}
pub type PROCESS_HANDLE_INFORMATION = _PROCESS_HANDLE_INFORMATION;
pub type PPROCESS_HANDLE_INFORMATION = *mut _PROCESS_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_CYCLE_TIME_INFORMATION {
   pub AccumulatedCycles: ULONGLONG,
   pub CurrentCycleCount: ULONGLONG,
}
pub type PROCESS_CYCLE_TIME_INFORMATION = _PROCESS_CYCLE_TIME_INFORMATION;
pub type PPROCESS_CYCLE_TIME_INFORMATION = *mut _PROCESS_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_WINDOW_INFORMATION {
   pub WindowFlags: ULONG,
   pub WindowTitleLength: USHORT,
   pub WindowTitle: [WCHAR; 1usize],
}
pub type PROCESS_WINDOW_INFORMATION = _PROCESS_WINDOW_INFORMATION;
pub type PPROCESS_WINDOW_INFORMATION = *mut _PROCESS_WINDOW_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_TABLE_ENTRY_INFO {
   pub HandleValue: HANDLE,
   pub HandleCount: ULONG_PTR,
   pub PointerCount: ULONG_PTR,
   pub GrantedAccess: ULONG,
   pub ObjectTypeIndex: ULONG,
   pub HandleAttributes: ULONG,
   pub Reserved: ULONG,
}
impl Default for _PROCESS_HANDLE_TABLE_ENTRY_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_HANDLE_TABLE_ENTRY_INFO = _PROCESS_HANDLE_TABLE_ENTRY_INFO;
pub type PPROCESS_HANDLE_TABLE_ENTRY_INFO = *mut _PROCESS_HANDLE_TABLE_ENTRY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION {
   pub NumberOfHandles: ULONG_PTR,
   pub Reserved: ULONG_PTR,
   pub Handles: [PROCESS_HANDLE_TABLE_ENTRY_INFO; 1usize],
}
impl Default for _PROCESS_HANDLE_SNAPSHOT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_HANDLE_SNAPSHOT_INFORMATION = _PROCESS_HANDLE_SNAPSHOT_INFORMATION;
pub type PPROCESS_HANDLE_SNAPSHOT_INFORMATION = *mut _PROCESS_HANDLE_SNAPSHOT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_POLICY_INFORMATION {
   pub Policy: PROCESS_MITIGATION_POLICY,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_POLICY_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_POLICY_INFORMATION__bindgen_ty_1 {
   pub ASLRPolicy: PROCESS_MITIGATION_ASLR_POLICY,
   pub StrictHandleCheckPolicy: PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY,
   pub SystemCallDisablePolicy: PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY,
   pub ExtensionPointDisablePolicy: PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY,
   pub DynamicCodePolicy: PROCESS_MITIGATION_DYNAMIC_CODE_POLICY,
   pub ControlFlowGuardPolicy: PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY,
   pub SignaturePolicy: PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY,
   pub FontDisablePolicy: PROCESS_MITIGATION_FONT_DISABLE_POLICY,
   pub ImageLoadPolicy: PROCESS_MITIGATION_IMAGE_LOAD_POLICY,
   pub SystemCallFilterPolicy: PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY,
   pub PayloadRestrictionPolicy: PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY,
   pub ChildProcessPolicy: PROCESS_MITIGATION_CHILD_PROCESS_POLICY,
   pub SideChannelIsolationPolicy: PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY,
   pub UserShadowStackPolicy: PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY,
   pub RedirectionTrustPolicy: PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY,
   pub UserPointerAuthPolicy: PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY,
   pub SEHOPPolicy: PROCESS_MITIGATION_SEHOP_POLICY,
}
impl Default for _PROCESS_MITIGATION_POLICY_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_POLICY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_POLICY_INFORMATION = _PROCESS_MITIGATION_POLICY_INFORMATION;
pub type PPROCESS_MITIGATION_POLICY_INFORMATION = *mut _PROCESS_MITIGATION_POLICY_INFORMATION;
#[repr(C)]
pub struct _PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION {
   pub DynamicFunctionTable: *mut _DYNAMIC_FUNCTION_TABLE,
   pub Remove: BOOLEAN,
}
impl Default for _PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION = _PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION;
pub type PPROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION =
   *mut _PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_KEEPALIVE_COUNT_INFORMATION {
   pub WakeCount: ULONG,
   pub NoWakeCount: ULONG,
}
pub type PROCESS_KEEPALIVE_COUNT_INFORMATION = _PROCESS_KEEPALIVE_COUNT_INFORMATION;
pub type PPROCESS_KEEPALIVE_COUNT_INFORMATION = *mut _PROCESS_KEEPALIVE_COUNT_INFORMATION;
#[repr(C)]
pub struct _PROCESS_REVOKE_FILE_HANDLES_INFORMATION {
   pub TargetDevicePath: UNICODE_STRING,
}
impl Default for _PROCESS_REVOKE_FILE_HANDLES_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_REVOKE_FILE_HANDLES_INFORMATION = _PROCESS_REVOKE_FILE_HANDLES_INFORMATION;
pub type PPROCESS_REVOKE_FILE_HANDLES_INFORMATION = *mut _PROCESS_REVOKE_FILE_HANDLES_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_WORKING_SET_OPERATION {
   ProcessWorkingSetSwap = 0,
   ProcessWorkingSetEmpty = 1,
   ProcessWorkingSetOperationMax = 2,
}
pub use self::_PROCESS_WORKING_SET_OPERATION as PROCESS_WORKING_SET_OPERATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_WORKING_SET_CONTROL {
   pub Version: ULONG,
   pub Operation: PROCESS_WORKING_SET_OPERATION,
   pub Flags: ULONG,
}
impl Default for _PROCESS_WORKING_SET_CONTROL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_WORKING_SET_CONTROL = _PROCESS_WORKING_SET_CONTROL;
pub type PPROCESS_WORKING_SET_CONTROL = *mut _PROCESS_WORKING_SET_CONTROL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_PROTECTED_TYPE {
   PsProtectedTypeNone = 0,
   PsProtectedTypeProtectedLight = 1,
   PsProtectedTypeProtected = 2,
   PsProtectedTypeMax = 3,
}
pub use self::_PS_PROTECTED_TYPE as PS_PROTECTED_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_PROTECTED_SIGNER {
   PsProtectedSignerNone = 0,
   PsProtectedSignerAuthenticode = 1,
   PsProtectedSignerCodeGen = 2,
   PsProtectedSignerAntimalware = 3,
   PsProtectedSignerLsa = 4,
   PsProtectedSignerWindows = 5,
   PsProtectedSignerWinTcb = 6,
   PsProtectedSignerWinSystem = 7,
   PsProtectedSignerApp = 8,
   PsProtectedSignerMax = 9,
}
pub use self::_PS_PROTECTED_SIGNER as PS_PROTECTED_SIGNER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_PROTECTION {
   pub __bindgen_anon_1: _PS_PROTECTION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_PROTECTION__bindgen_ty_1 {
   pub Level: UCHAR,
   pub __bindgen_anon_1: _PS_PROTECTION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_PROTECTION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PS_PROTECTION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Type(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn Audit(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Audit(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Signer(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_Signer(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Type: UCHAR,
      Audit: UCHAR,
      Signer: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 3u8, {
         let Type: u8 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let Audit: u8 = unsafe { ::core::mem::transmute(Audit) };
         Audit as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let Signer: u8 = unsafe { ::core::mem::transmute(Signer) };
         Signer as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PS_PROTECTION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_PROTECTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_PROTECTION = _PS_PROTECTION;
pub type PPS_PROTECTION = *mut _PS_PROTECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_FAULT_INFORMATION {
   pub FaultFlags: ULONG,
   pub AdditionalInfo: ULONG,
}
pub type PROCESS_FAULT_INFORMATION = _PROCESS_FAULT_INFORMATION;
pub type PPROCESS_FAULT_INFORMATION = *mut _PROCESS_FAULT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_TELEMETRY_ID_INFORMATION {
   pub HeaderSize: ULONG,
   pub ProcessId: ULONG,
   pub ProcessStartKey: ULONGLONG,
   pub CreateTime: ULONGLONG,
   pub CreateInterruptTime: ULONGLONG,
   pub CreateUnbiasedInterruptTime: ULONGLONG,
   pub ProcessSequenceNumber: ULONGLONG,
   pub SessionCreateTime: ULONGLONG,
   pub SessionId: ULONG,
   pub BootId: ULONG,
   pub ImageChecksum: ULONG,
   pub ImageTimeDateStamp: ULONG,
   pub UserSidOffset: ULONG,
   pub ImagePathOffset: ULONG,
   pub PackageNameOffset: ULONG,
   pub RelativeAppNameOffset: ULONG,
   pub CommandLineOffset: ULONG,
}
pub type PROCESS_TELEMETRY_ID_INFORMATION = _PROCESS_TELEMETRY_ID_INFORMATION;
pub type PPROCESS_TELEMETRY_ID_INFORMATION = *mut _PROCESS_TELEMETRY_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_COMMIT_RELEASE_INFORMATION {
   pub Version: ULONG,
   pub __bindgen_anon_1: _PROCESS_COMMIT_RELEASE_INFORMATION__bindgen_ty_1,
   pub CommitDebt: SIZE_T,
   pub CommittedMemResetSize: SIZE_T,
   pub RepurposedMemResetSize: SIZE_T,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_COMMIT_RELEASE_INFORMATION__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_COMMIT_RELEASE_INFORMATION__bindgen_ty_1 {
   #[inline]
   pub fn Eligible(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Eligible(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReleaseRepurposedMemResetCommit(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReleaseRepurposedMemResetCommit(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ForceReleaseMemResetCommit(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ForceReleaseMemResetCommit(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Eligible: ULONG,
      ReleaseRepurposedMemResetCommit: ULONG,
      ForceReleaseMemResetCommit: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Eligible: u32 = unsafe { ::core::mem::transmute(Eligible) };
         Eligible as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ReleaseRepurposedMemResetCommit: u32 =
            unsafe { ::core::mem::transmute(ReleaseRepurposedMemResetCommit) };
         ReleaseRepurposedMemResetCommit as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ForceReleaseMemResetCommit: u32 =
            unsafe { ::core::mem::transmute(ForceReleaseMemResetCommit) };
         ForceReleaseMemResetCommit as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PROCESS_COMMIT_RELEASE_INFORMATION = _PROCESS_COMMIT_RELEASE_INFORMATION;
pub type PPROCESS_COMMIT_RELEASE_INFORMATION = *mut _PROCESS_COMMIT_RELEASE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_JOB_MEMORY_INFO {
   pub SharedCommitUsage: ULONGLONG,
   pub PrivateCommitUsage: ULONGLONG,
   pub PeakPrivateCommitUsage: ULONGLONG,
   pub PrivateCommitLimit: ULONGLONG,
   pub TotalCommitLimit: ULONGLONG,
}
pub type PROCESS_JOB_MEMORY_INFO = _PROCESS_JOB_MEMORY_INFO;
pub type PPROCESS_JOB_MEMORY_INFO = *mut _PROCESS_JOB_MEMORY_INFO;
#[repr(C)]
pub struct _PROCESS_CHILD_PROCESS_INFORMATION {
   pub ProhibitChildProcesses: BOOLEAN,
   pub AlwaysAllowSecureChildProcess: BOOLEAN,
   pub AuditProhibitChildProcesses: BOOLEAN,
}
impl Default for _PROCESS_CHILD_PROCESS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_CHILD_PROCESS_INFORMATION = _PROCESS_CHILD_PROCESS_INFORMATION;
pub type PPROCESS_CHILD_PROCESS_INFORMATION = *mut _PROCESS_CHILD_PROCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_THROTTLING_PROCESS_STATE {
   pub Version: ULONG,
   pub ControlMask: ULONG,
   pub StateMask: ULONG,
}
pub type POWER_THROTTLING_PROCESS_STATE = _POWER_THROTTLING_PROCESS_STATE;
pub type PPOWER_THROTTLING_PROCESS_STATE = *mut _POWER_THROTTLING_PROCESS_STATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WIN32K_SYSCALL_FILTER {
   pub FilterState: ULONG,
   pub FilterSet: ULONG,
}
pub type WIN32K_SYSCALL_FILTER = _WIN32K_SYSCALL_FILTER;
pub type PWIN32K_SYSCALL_FILTER = *mut _WIN32K_SYSCALL_FILTER;
pub type PJOBOBJECT_WAKE_FILTER = *mut _JOBOBJECT_WAKE_FILTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_WAKE_INFORMATION {
   pub NotificationChannel: ULONGLONG,
   pub WakeCounters: [ULONG; 7usize],
   pub WakeFilter: PJOBOBJECT_WAKE_FILTER,
}
impl Default for _PROCESS_WAKE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_WAKE_INFORMATION = _PROCESS_WAKE_INFORMATION;
pub type PPROCESS_WAKE_INFORMATION = *mut _PROCESS_WAKE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_ENERGY_TRACKING_STATE {
   pub StateUpdateMask: ULONG,
   pub StateDesiredValue: ULONG,
   pub StateSequence: ULONG,
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: u16,
   pub Tag: [WCHAR; 64usize],
}
impl Default for _PROCESS_ENERGY_TRACKING_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PROCESS_ENERGY_TRACKING_STATE {
   #[inline]
   pub fn UpdateTag(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UpdateTag(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(UpdateTag: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let UpdateTag: u32 = unsafe { ::core::mem::transmute(UpdateTag) };
         UpdateTag as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PROCESS_ENERGY_TRACKING_STATE = _PROCESS_ENERGY_TRACKING_STATE;
pub type PPROCESS_ENERGY_TRACKING_STATE = *mut _PROCESS_ENERGY_TRACKING_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MANAGE_WRITES_TO_EXECUTABLE_MEMORY {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub KernelWriteToExecutableSignal: PVOID,
}
impl Default for _MANAGE_WRITES_TO_EXECUTABLE_MEMORY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _MANAGE_WRITES_TO_EXECUTABLE_MEMORY {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessEnableWriteExceptions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessEnableWriteExceptions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ThreadAllowWrites(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ThreadAllowWrites(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 22u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      ProcessEnableWriteExceptions: ULONG,
      ThreadAllowWrites: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let ProcessEnableWriteExceptions: u32 =
            unsafe { ::core::mem::transmute(ProcessEnableWriteExceptions) };
         ProcessEnableWriteExceptions as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let ThreadAllowWrites: u32 = unsafe { ::core::mem::transmute(ThreadAllowWrites) };
         ThreadAllowWrites as u64
      });
      __bindgen_bitfield_unit.set(10usize, 22u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type MANAGE_WRITES_TO_EXECUTABLE_MEMORY = _MANAGE_WRITES_TO_EXECUTABLE_MEMORY;
pub type PMANAGE_WRITES_TO_EXECUTABLE_MEMORY = *mut _MANAGE_WRITES_TO_EXECUTABLE_MEMORY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_THROTTLING_THREAD_STATE {
   pub Version: ULONG,
   pub ControlMask: ULONG,
   pub StateMask: ULONG,
}
pub type POWER_THROTTLING_THREAD_STATE = _POWER_THROTTLING_THREAD_STATE;
pub type PPOWER_THROTTLING_THREAD_STATE = *mut _POWER_THROTTLING_THREAD_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_READWRITEVM_LOGGING_INFORMATION {
   pub Flags: UCHAR,
   pub __bindgen_anon_1: _PROCESS_READWRITEVM_LOGGING_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_READWRITEVM_LOGGING_INFORMATION__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PROCESS_READWRITEVM_LOGGING_INFORMATION__bindgen_ty_1 {
   #[inline]
   pub fn EnableReadVmLogging(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_EnableReadVmLogging(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableWriteVmLogging(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_EnableWriteVmLogging(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Unused(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
   }
   #[inline]
   pub fn set_Unused(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableReadVmLogging: UCHAR,
      EnableWriteVmLogging: UCHAR,
      Unused: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableReadVmLogging: u8 = unsafe { ::core::mem::transmute(EnableReadVmLogging) };
         EnableReadVmLogging as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let EnableWriteVmLogging: u8 = unsafe { ::core::mem::transmute(EnableWriteVmLogging) };
         EnableWriteVmLogging as u64
      });
      __bindgen_bitfield_unit.set(2usize, 6u8, {
         let Unused: u8 = unsafe { ::core::mem::transmute(Unused) };
         Unused as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_READWRITEVM_LOGGING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_READWRITEVM_LOGGING_INFORMATION = _PROCESS_READWRITEVM_LOGGING_INFORMATION;
pub type PPROCESS_READWRITEVM_LOGGING_INFORMATION = *mut _PROCESS_READWRITEVM_LOGGING_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_UPTIME_INFORMATION {
   pub QueryInterruptTime: ULONGLONG,
   pub QueryUnbiasedTime: ULONGLONG,
   pub EndInterruptTime: ULONGLONG,
   pub TimeSinceCreation: ULONGLONG,
   pub Uptime: ULONGLONG,
   pub SuspendedTime: ULONGLONG,
   pub __bindgen_anon_1: _PROCESS_UPTIME_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_UPTIME_INFORMATION__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
   pub __bindgen_padding_0: u16,
}
impl _PROCESS_UPTIME_INFORMATION__bindgen_ty_1 {
   #[inline]
   pub fn HangCount(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_HangCount(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn GhostCount(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_GhostCount(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn Crashed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Crashed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Terminated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Terminated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      HangCount: ULONG,
      GhostCount: ULONG,
      Crashed: ULONG,
      Terminated: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let HangCount: u32 = unsafe { ::core::mem::transmute(HangCount) };
         HangCount as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let GhostCount: u32 = unsafe { ::core::mem::transmute(GhostCount) };
         GhostCount as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let Crashed: u32 = unsafe { ::core::mem::transmute(Crashed) };
         Crashed as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let Terminated: u32 = unsafe { ::core::mem::transmute(Terminated) };
         Terminated as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PROCESS_UPTIME_INFORMATION = _PROCESS_UPTIME_INFORMATION;
pub type PPROCESS_UPTIME_INFORMATION = *mut _PROCESS_UPTIME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_SYSTEM_RESOURCE_MANAGEMENT {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PROCESS_SYSTEM_RESOURCE_MANAGEMENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_SYSTEM_RESOURCE_MANAGEMENT__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_SYSTEM_RESOURCE_MANAGEMENT__bindgen_ty_1 {
   #[inline]
   pub fn Foreground(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Foreground(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Foreground: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Foreground: u32 = unsafe { ::core::mem::transmute(Foreground) };
         Foreground as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_SYSTEM_RESOURCE_MANAGEMENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_SYSTEM_RESOURCE_MANAGEMENT = _PROCESS_SYSTEM_RESOURCE_MANAGEMENT;
pub type PPROCESS_SYSTEM_RESOURCE_MANAGEMENT = *mut _PROCESS_SYSTEM_RESOURCE_MANAGEMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_SECURITY_DOMAIN_INFORMATION {
   pub SecurityDomain: ULONGLONG,
}
pub type PROCESS_SECURITY_DOMAIN_INFORMATION = _PROCESS_SECURITY_DOMAIN_INFORMATION;
pub type PPROCESS_SECURITY_DOMAIN_INFORMATION = *mut _PROCESS_SECURITY_DOMAIN_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION {
   pub ProcessHandle: HANDLE,
}
impl Default for _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION =
   _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION;
pub type PPROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION =
   *mut _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_LOGGING_INFORMATION {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PROCESS_LOGGING_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_LOGGING_INFORMATION__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_LOGGING_INFORMATION__bindgen_ty_1 {
   #[inline]
   pub fn EnableReadVmLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableReadVmLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableWriteVmLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableWriteVmLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableProcessSuspendResumeLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableProcessSuspendResumeLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableThreadSuspendResumeLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableThreadSuspendResumeLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableLocalExecProtectVmLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableLocalExecProtectVmLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableRemoteExecProtectVmLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableRemoteExecProtectVmLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 26u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableReadVmLogging: ULONG,
      EnableWriteVmLogging: ULONG,
      EnableProcessSuspendResumeLogging: ULONG,
      EnableThreadSuspendResumeLogging: ULONG,
      EnableLocalExecProtectVmLogging: ULONG,
      EnableRemoteExecProtectVmLogging: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableReadVmLogging: u32 = unsafe { ::core::mem::transmute(EnableReadVmLogging) };
         EnableReadVmLogging as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let EnableWriteVmLogging: u32 = unsafe { ::core::mem::transmute(EnableWriteVmLogging) };
         EnableWriteVmLogging as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let EnableProcessSuspendResumeLogging: u32 =
            unsafe { ::core::mem::transmute(EnableProcessSuspendResumeLogging) };
         EnableProcessSuspendResumeLogging as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let EnableThreadSuspendResumeLogging: u32 =
            unsafe { ::core::mem::transmute(EnableThreadSuspendResumeLogging) };
         EnableThreadSuspendResumeLogging as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let EnableLocalExecProtectVmLogging: u32 =
            unsafe { ::core::mem::transmute(EnableLocalExecProtectVmLogging) };
         EnableLocalExecProtectVmLogging as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let EnableRemoteExecProtectVmLogging: u32 =
            unsafe { ::core::mem::transmute(EnableRemoteExecProtectVmLogging) };
         EnableRemoteExecProtectVmLogging as u64
      });
      __bindgen_bitfield_unit.set(6usize, 26u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_LOGGING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_LOGGING_INFORMATION = _PROCESS_LOGGING_INFORMATION;
pub type PPROCESS_LOGGING_INFORMATION = *mut _PROCESS_LOGGING_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_LEAP_SECOND_INFORMATION {
   pub Flags: ULONG,
   pub Reserved: ULONG,
}
pub type PROCESS_LEAP_SECOND_INFORMATION = _PROCESS_LEAP_SECOND_INFORMATION;
pub type PPROCESS_LEAP_SECOND_INFORMATION = *mut _PROCESS_LEAP_SECOND_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION {
   pub ReserveSize: ULONGLONG,
   pub CommitSize: ULONGLONG,
   pub PreferredNode: ULONG,
   pub Reserved: ULONG,
   pub Ssp: PVOID,
}
impl Default for _PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION =
   _PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;
pub type PPROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION =
   *mut _PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION {
   pub Ssp: PVOID,
}
impl Default for _PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION =
   _PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;
pub type PPROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION =
   *mut _PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_SYSCALL_PROVIDER_INFORMATION {
   pub ProviderId: GUID,
   pub Level: UCHAR,
}
pub type PROCESS_SYSCALL_PROVIDER_INFORMATION = _PROCESS_SYSCALL_PROVIDER_INFORMATION;
pub type PPROCESS_SYSCALL_PROVIDER_INFORMATION = *mut _PROCESS_SYSCALL_PROVIDER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MEMBERSHIP_INFORMATION {
   pub ServerSiloId: ULONG,
}
pub type PROCESS_MEMBERSHIP_INFORMATION = _PROCESS_MEMBERSHIP_INFORMATION;
pub type PPROCESS_MEMBERSHIP_INFORMATION = *mut _PROCESS_MEMBERSHIP_INFORMATION;
#[repr(C)]
pub struct _THREAD_BASIC_INFORMATION {
   pub ExitStatus: NTSTATUS,
   pub TebBaseAddress: PTEB,
   pub ClientId: CLIENT_ID,
   pub AffinityMask: KAFFINITY,
   pub Priority: KPRIORITY,
   pub BasePriority: KPRIORITY,
}
impl Default for _THREAD_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_BASIC_INFORMATION = _THREAD_BASIC_INFORMATION;
pub type PTHREAD_BASIC_INFORMATION = *mut _THREAD_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_LAST_SYSCALL_INFORMATION {
   pub FirstArgument: PVOID,
   pub SystemCallNumber: USHORT,
   pub Pad: [USHORT; 1usize],
   pub WaitTime: ULONG64,
}
impl Default for _THREAD_LAST_SYSCALL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_LAST_SYSCALL_INFORMATION = _THREAD_LAST_SYSCALL_INFORMATION;
pub type PTHREAD_LAST_SYSCALL_INFORMATION = *mut _THREAD_LAST_SYSCALL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _THREAD_CYCLE_TIME_INFORMATION {
   pub AccumulatedCycles: ULONGLONG,
   pub CurrentCycleCount: ULONGLONG,
}
pub type THREAD_CYCLE_TIME_INFORMATION = _THREAD_CYCLE_TIME_INFORMATION;
pub type PTHREAD_CYCLE_TIME_INFORMATION = *mut _THREAD_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_TEB_INFORMATION {
   pub TebInformation: PVOID,
   pub TebOffset: ULONG,
   pub BytesToRead: ULONG,
}
impl Default for _THREAD_TEB_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_TEB_INFORMATION = _THREAD_TEB_INFORMATION;
pub type PTHREAD_TEB_INFORMATION = *mut _THREAD_TEB_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COUNTER_READING {
   pub Type: HARDWARE_COUNTER_TYPE,
   pub Index: ULONG,
   pub Start: ULONG64,
   pub Total: ULONG64,
}
impl Default for _COUNTER_READING {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COUNTER_READING = _COUNTER_READING;
pub type PCOUNTER_READING = *mut _COUNTER_READING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_PERFORMANCE_DATA {
   pub Size: USHORT,
   pub Version: USHORT,
   pub ProcessorNumber: PROCESSOR_NUMBER,
   pub ContextSwitches: ULONG,
   pub HwCountersCount: ULONG,
   pub UpdateCount: ULONG64,
   pub WaitReasonBitMap: ULONG64,
   pub HardwareCounters: ULONG64,
   pub CycleTime: COUNTER_READING,
   pub HwCounters: [COUNTER_READING; 16usize],
}
impl Default for _THREAD_PERFORMANCE_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_PERFORMANCE_DATA = _THREAD_PERFORMANCE_DATA;
pub type PTHREAD_PERFORMANCE_DATA = *mut _THREAD_PERFORMANCE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_PROFILING_INFORMATION {
   pub HardwareCounters: ULONG64,
   pub Flags: ULONG,
   pub Enable: ULONG,
   pub PerformanceData: PTHREAD_PERFORMANCE_DATA,
}
impl Default for _THREAD_PROFILING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_PROFILING_INFORMATION = _THREAD_PROFILING_INFORMATION;
pub type PTHREAD_PROFILING_INFORMATION = *mut _THREAD_PROFILING_INFORMATION;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _RTL_UMS_CONTEXT {
   pub Link: SINGLE_LIST_ENTRY,
   pub __bindgen_padding_0: u64,
   pub Context: CONTEXT,
   pub Teb: PVOID,
   pub UserContext: PVOID,
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub Flags: LONG,
   pub _bitfield_align_2: [u64; 0],
   pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize]>,
   pub ContextLock: ULONG64,
   pub PrimaryUmsContext: *mut _RTL_UMS_CONTEXT,
   pub SwitchCount: ULONG,
   pub KernelYieldCount: ULONG,
   pub MixedYieldCount: ULONG,
   pub YieldCount: ULONG,
}
impl Default for _RTL_UMS_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _RTL_UMS_CONTEXT {
   #[inline]
   pub fn ScheduledThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ScheduledThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Suspended(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Suspended(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VolatileContext(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VolatileContext(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Terminated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Terminated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DebugActive(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DebugActive(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn RunningOnSelfThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RunningOnSelfThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DenyRunningOnSelfThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DenyRunningOnSelfThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ScheduledThread: ULONG,
      Suspended: ULONG,
      VolatileContext: ULONG,
      Terminated: ULONG,
      DebugActive: ULONG,
      RunningOnSelfThread: ULONG,
      DenyRunningOnSelfThread: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ScheduledThread: u32 = unsafe { ::core::mem::transmute(ScheduledThread) };
         ScheduledThread as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let Suspended: u32 = unsafe { ::core::mem::transmute(Suspended) };
         Suspended as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let VolatileContext: u32 = unsafe { ::core::mem::transmute(VolatileContext) };
         VolatileContext as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let Terminated: u32 = unsafe { ::core::mem::transmute(Terminated) };
         Terminated as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let DebugActive: u32 = unsafe { ::core::mem::transmute(DebugActive) };
         DebugActive as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let RunningOnSelfThread: u32 = unsafe { ::core::mem::transmute(RunningOnSelfThread) };
         RunningOnSelfThread as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let DenyRunningOnSelfThread: u32 =
            unsafe { ::core::mem::transmute(DenyRunningOnSelfThread) };
         DenyRunningOnSelfThread as u64
      });
      __bindgen_bitfield_unit
   }
   #[inline]
   pub fn KernelUpdateLock(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u64) }
   }
   #[inline]
   pub fn set_KernelUpdateLock(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_2.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn PrimaryClientID(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 62u8) as u64) }
   }
   #[inline]
   pub fn set_PrimaryClientID(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_2.set(2usize, 62u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_2(
      KernelUpdateLock: ULONG64,
      PrimaryClientID: ULONG64,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let KernelUpdateLock: u64 = unsafe { ::core::mem::transmute(KernelUpdateLock) };
         KernelUpdateLock as u64
      });
      __bindgen_bitfield_unit.set(2usize, 62u8, {
         let PrimaryClientID: u64 = unsafe { ::core::mem::transmute(PrimaryClientID) };
         PrimaryClientID as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type RTL_UMS_CONTEXT = _RTL_UMS_CONTEXT;
pub type PRTL_UMS_CONTEXT = *mut _RTL_UMS_CONTEXT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _THREAD_UMS_INFORMATION_COMMAND {
   UmsInformationCommandInvalid = 0,
   UmsInformationCommandAttach = 1,
   UmsInformationCommandDetach = 2,
   UmsInformationCommandQuery = 3,
}
pub use self::_THREAD_UMS_INFORMATION_COMMAND as THREAD_UMS_INFORMATION_COMMAND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_UMS_COMPLETION_LIST {
   pub ThreadListHead: PSINGLE_LIST_ENTRY,
   pub CompletionEvent: PVOID,
   pub CompletionFlags: ULONG,
   pub InternalListHead: SINGLE_LIST_ENTRY,
}
impl Default for _RTL_UMS_COMPLETION_LIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_UMS_COMPLETION_LIST = _RTL_UMS_COMPLETION_LIST;
pub type PRTL_UMS_COMPLETION_LIST = *mut _RTL_UMS_COMPLETION_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _THREAD_UMS_INFORMATION {
   pub Command: THREAD_UMS_INFORMATION_COMMAND,
   pub CompletionList: PRTL_UMS_COMPLETION_LIST,
   pub UmsContext: PRTL_UMS_CONTEXT,
   pub __bindgen_anon_1: _THREAD_UMS_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _THREAD_UMS_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _THREAD_UMS_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _THREAD_UMS_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _THREAD_UMS_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn IsUmsSchedulerThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsUmsSchedulerThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsUmsWorkerThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsUmsWorkerThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_SpareBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsUmsSchedulerThread: ULONG,
      IsUmsWorkerThread: ULONG,
      SpareBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsUmsSchedulerThread: u32 = unsafe { ::core::mem::transmute(IsUmsSchedulerThread) };
         IsUmsSchedulerThread as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsUmsWorkerThread: u32 = unsafe { ::core::mem::transmute(IsUmsWorkerThread) };
         IsUmsWorkerThread as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let SpareBits: u32 = unsafe { ::core::mem::transmute(SpareBits) };
         SpareBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _THREAD_UMS_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _THREAD_UMS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_UMS_INFORMATION = _THREAD_UMS_INFORMATION;
pub type PTHREAD_UMS_INFORMATION = *mut _THREAD_UMS_INFORMATION;
#[repr(C)]
pub struct _THREAD_NAME_INFORMATION {
   pub ThreadName: UNICODE_STRING,
}
impl Default for _THREAD_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_NAME_INFORMATION = _THREAD_NAME_INFORMATION;
pub type PTHREAD_NAME_INFORMATION = *mut _THREAD_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_WORK_ON_BEHALF_TICKET {
   pub ThreadId: ULONG,
   pub ThreadCreationTimeLow: ULONG,
}
pub type ALPC_WORK_ON_BEHALF_TICKET = _ALPC_WORK_ON_BEHALF_TICKET;
pub type PALPC_WORK_ON_BEHALF_TICKET = *mut _ALPC_WORK_ON_BEHALF_TICKET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_WORK_ON_BEHALF_TICKET_EX {
   pub Ticket: ALPC_WORK_ON_BEHALF_TICKET,
   pub __bindgen_anon_1: _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1,
   pub Reserved2: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn CurrentThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CurrentThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      CurrentThread: ULONG,
      Reserved1: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let CurrentThread: u32 = unsafe { ::core::mem::transmute(CurrentThread) };
         CurrentThread as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_WORK_ON_BEHALF_TICKET_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_WORK_ON_BEHALF_TICKET_EX = _RTL_WORK_ON_BEHALF_TICKET_EX;
pub type PRTL_WORK_ON_BEHALF_TICKET_EX = *mut _RTL_WORK_ON_BEHALF_TICKET_EX;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SUBSYSTEM_INFORMATION_TYPE {
   SubsystemInformationTypeWin32 = 0,
   SubsystemInformationTypeWSL = 1,
   MaxSubsystemInformationType = 2,
}
pub use self::_SUBSYSTEM_INFORMATION_TYPE as SUBSYSTEM_INFORMATION_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _THREAD_WORKLOAD_CLASS {
   ThreadWorkloadClassDefault = 0,
   ThreadWorkloadClassGraphics = 1,
   MaxThreadWorkloadClass = 2,
}
pub use self::_THREAD_WORKLOAD_CLASS as THREAD_WORKLOAD_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_STATE_CHANGE_TYPE {
   ProcessStateChangeSuspend = 0,
   ProcessStateChangeResume = 1,
   ProcessStateChangeMax = 2,
}
pub use self::_PROCESS_STATE_CHANGE_TYPE as PROCESS_STATE_CHANGE_TYPE;
pub type PPROCESS_STATE_CHANGE_TYPE = *mut _PROCESS_STATE_CHANGE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _THREAD_STATE_CHANGE_TYPE {
   ThreadStateChangeSuspend = 0,
   ThreadStateChangeResume = 1,
   ThreadStateChangeMax = 2,
}
pub use self::_THREAD_STATE_CHANGE_TYPE as THREAD_STATE_CHANGE_TYPE;
pub type PTHREAD_STATE_CHANGE_TYPE = *mut _THREAD_STATE_CHANGE_TYPE;
pub type PPS_APC_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(ApcArgument1: PVOID, ApcArgument2: PVOID, ApcArgument3: PVOID),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_THREAD_ATTRIBUTE {
   pub Attribute: ULONG_PTR,
   pub Size: SIZE_T,
   pub Value: ULONG_PTR,
}
pub type PROC_THREAD_ATTRIBUTE = _PROC_THREAD_ATTRIBUTE;
pub type PPROC_THREAD_ATTRIBUTE = *mut _PROC_THREAD_ATTRIBUTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_THREAD_ATTRIBUTE_LIST {
   pub PresentFlags: ULONG,
   pub AttributeCount: ULONG,
   pub LastAttribute: ULONG,
   pub SpareUlong0: ULONG,
   pub ExtendedFlagsAttribute: PPROC_THREAD_ATTRIBUTE,
   pub Attributes: [PROC_THREAD_ATTRIBUTE; 1usize],
}
impl Default for _PROC_THREAD_ATTRIBUTE_LIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROC_THREAD_ATTRIBUTE_LIST = _PROC_THREAD_ATTRIBUTE_LIST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS {
   SeSafeOpenExperienceNone = 0,
   SeSafeOpenExperienceCalled = 1,
   SeSafeOpenExperienceAppRepCalled = 2,
   SeSafeOpenExperiencePromptDisplayed = 4,
   SeSafeOpenExperienceUAC = 8,
   SeSafeOpenExperienceUninstaller = 16,
   SeSafeOpenExperienceIgnoreUnknownOrBad = 32,
   SeSafeOpenExperienceDefenderTrustedInstaller = 64,
   SeSafeOpenExperienceMOTWPresent = 128,
   SeSafeOpenExperienceElevatedNoPropagation = 256,
}
pub use self::_SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS as SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_SAFE_OPEN_PROMPT_RESULTS {
   pub Results: SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS,
   pub Path: [WCHAR; 260usize],
}
impl Default for _SE_SAFE_OPEN_PROMPT_RESULTS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SE_SAFE_OPEN_PROMPT_RESULTS = _SE_SAFE_OPEN_PROMPT_RESULTS;
pub type PSE_SAFE_OPEN_PROMPT_RESULTS = *mut _SE_SAFE_OPEN_PROMPT_RESULTS;
#[repr(C)]
pub struct _PROC_THREAD_BNOISOLATION_ATTRIBUTE {
   pub IsolationEnabled: BOOL,
   pub IsolationPrefix: [WCHAR; 136usize],
}
impl Default for _PROC_THREAD_BNOISOLATION_ATTRIBUTE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROC_THREAD_BNOISOLATION_ATTRIBUTE = _PROC_THREAD_BNOISOLATION_ATTRIBUTE;
pub type PPROC_THREAD_BNOISOLATION_ATTRIBUTE = *mut _PROC_THREAD_BNOISOLATION_ATTRIBUTE;
#[repr(C)]
pub struct _ISOLATION_MANIFEST_PROPERTIES {
   pub InstancePath: UNICODE_STRING,
   pub FriendlyName: UNICODE_STRING,
   pub Description: UNICODE_STRING,
   pub Level: ULONG_PTR,
}
impl Default for _ISOLATION_MANIFEST_PROPERTIES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ISOLATION_MANIFEST_PROPERTIES = _ISOLATION_MANIFEST_PROPERTIES;
pub type PISOLATION_MANIFEST_PROPERTIES = *mut _ISOLATION_MANIFEST_PROPERTIES;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_ATTRIBUTE_NUM {
   PsAttributeParentProcess = 0,
   PsAttributeDebugObject = 1,
   PsAttributeToken = 2,
   PsAttributeClientId = 3,
   PsAttributeTebAddress = 4,
   PsAttributeImageName = 5,
   PsAttributeImageInfo = 6,
   PsAttributeMemoryReserve = 7,
   PsAttributePriorityClass = 8,
   PsAttributeErrorMode = 9,
   PsAttributeStdHandleInfo = 10,
   PsAttributeHandleList = 11,
   PsAttributeGroupAffinity = 12,
   PsAttributePreferredNode = 13,
   PsAttributeIdealProcessor = 14,
   PsAttributeUmsThread = 15,
   PsAttributeMitigationOptions = 16,
   PsAttributeProtectionLevel = 17,
   PsAttributeSecureProcess = 18,
   PsAttributeJobList = 19,
   PsAttributeChildProcessPolicy = 20,
   PsAttributeAllApplicationPackagesPolicy = 21,
   PsAttributeWin32kFilter = 22,
   PsAttributeSafeOpenPromptOriginClaim = 23,
   PsAttributeBnoIsolation = 24,
   PsAttributeDesktopAppPolicy = 25,
   PsAttributeChpe = 26,
   PsAttributeMitigationAuditOptions = 27,
   PsAttributeMachineType = 28,
   PsAttributeComponentFilter = 29,
   PsAttributeEnableOptionalXStateFeatures = 30,
   PsAttributeMax = 31,
}
pub use self::_PS_ATTRIBUTE_NUM as PS_ATTRIBUTE_NUM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_ATTRIBUTE {
   pub Attribute: ULONG_PTR,
   pub Size: SIZE_T,
   pub __bindgen_anon_1: _PS_ATTRIBUTE__bindgen_ty_1,
   pub ReturnLength: PSIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_ATTRIBUTE__bindgen_ty_1 {
   pub Value: ULONG_PTR,
   pub ValuePtr: PVOID,
}
impl Default for _PS_ATTRIBUTE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_ATTRIBUTE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_ATTRIBUTE = _PS_ATTRIBUTE;
pub type PPS_ATTRIBUTE = *mut _PS_ATTRIBUTE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_ATTRIBUTE_LIST {
   pub TotalLength: SIZE_T,
   pub Attributes: [PS_ATTRIBUTE; 1usize],
}
impl Default for _PS_ATTRIBUTE_LIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_ATTRIBUTE_LIST = _PS_ATTRIBUTE_LIST;
pub type PPS_ATTRIBUTE_LIST = *mut _PS_ATTRIBUTE_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_MEMORY_RESERVE {
   pub ReserveAddress: PVOID,
   pub ReserveSize: SIZE_T,
}
impl Default for _PS_MEMORY_RESERVE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_MEMORY_RESERVE = _PS_MEMORY_RESERVE;
pub type PPS_MEMORY_RESERVE = *mut _PS_MEMORY_RESERVE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_STD_HANDLE_STATE {
   PsNeverDuplicate = 0,
   PsRequestDuplicate = 1,
   PsAlwaysDuplicate = 2,
   PsMaxStdHandleStates = 3,
}
pub use self::_PS_STD_HANDLE_STATE as PS_STD_HANDLE_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_STD_HANDLE_INFO {
   pub __bindgen_anon_1: _PS_STD_HANDLE_INFO__bindgen_ty_1,
   pub StdHandleSubsystemType: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_STD_HANDLE_INFO__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PS_STD_HANDLE_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_STD_HANDLE_INFO__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _PS_STD_HANDLE_INFO__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn StdHandleState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_StdHandleState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn PseudoHandleMask(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
   }
   #[inline]
   pub fn set_PseudoHandleMask(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      StdHandleState: ULONG,
      PseudoHandleMask: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let StdHandleState: u32 = unsafe { ::core::mem::transmute(StdHandleState) };
         StdHandleState as u64
      });
      __bindgen_bitfield_unit.set(2usize, 3u8, {
         let PseudoHandleMask: u32 = unsafe { ::core::mem::transmute(PseudoHandleMask) };
         PseudoHandleMask as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PS_STD_HANDLE_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_STD_HANDLE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_STD_HANDLE_INFO = _PS_STD_HANDLE_INFO;
pub type PPS_STD_HANDLE_INFO = *mut _PS_STD_HANDLE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub AccessRights: UCHAR,
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
   #[inline]
   pub fn Trustlet(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Trustlet(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Ntos(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Ntos(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn WriteHandle(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_WriteHandle(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReadHandle(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ReadHandle(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Trustlet: UCHAR,
      Ntos: UCHAR,
      WriteHandle: UCHAR,
      ReadHandle: UCHAR,
      Reserved: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Trustlet: u8 = unsafe { ::core::mem::transmute(Trustlet) };
         Trustlet as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let Ntos: u8 = unsafe { ::core::mem::transmute(Ntos) };
         Ntos as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let WriteHandle: u8 = unsafe { ::core::mem::transmute(WriteHandle) };
         WriteHandle as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ReadHandle: u8 = unsafe { ::core::mem::transmute(ReadHandle) };
         ReadHandle as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS = _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS;
pub type PPS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS = *mut _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_TYPE {
   pub __bindgen_anon_1: _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1 {
   pub __bindgen_anon_1: _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1__bindgen_ty_1,
   pub AttributeType: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1__bindgen_ty_1 {
   pub Version: UCHAR,
   pub DataCount: UCHAR,
   pub SemanticType: UCHAR,
   pub AccessRights: PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS,
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_TYPE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_TRUSTLET_ATTRIBUTE_TYPE = _PS_TRUSTLET_ATTRIBUTE_TYPE;
pub type PPS_TRUSTLET_ATTRIBUTE_TYPE = *mut _PS_TRUSTLET_ATTRIBUTE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_HEADER {
   pub AttributeType: PS_TRUSTLET_ATTRIBUTE_TYPE,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PS_TRUSTLET_ATTRIBUTE_HEADER {
   #[inline]
   pub fn InstanceNumber(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_InstanceNumber(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      InstanceNumber: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let InstanceNumber: u32 = unsafe { ::core::mem::transmute(InstanceNumber) };
         InstanceNumber as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PS_TRUSTLET_ATTRIBUTE_HEADER = _PS_TRUSTLET_ATTRIBUTE_HEADER;
pub type PPS_TRUSTLET_ATTRIBUTE_HEADER = *mut _PS_TRUSTLET_ATTRIBUTE_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_DATA {
   pub Header: PS_TRUSTLET_ATTRIBUTE_HEADER,
   pub Data: [ULONGLONG; 1usize],
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_TRUSTLET_ATTRIBUTE_DATA = _PS_TRUSTLET_ATTRIBUTE_DATA;
pub type PPS_TRUSTLET_ATTRIBUTE_DATA = *mut _PS_TRUSTLET_ATTRIBUTE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_CREATE_ATTRIBUTES {
   pub TrustletIdentity: ULONGLONG,
   pub Attributes: [PS_TRUSTLET_ATTRIBUTE_DATA; 1usize],
}
impl Default for _PS_TRUSTLET_CREATE_ATTRIBUTES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_TRUSTLET_CREATE_ATTRIBUTES = _PS_TRUSTLET_CREATE_ATTRIBUTES;
pub type PPS_TRUSTLET_CREATE_ATTRIBUTES = *mut _PS_TRUSTLET_CREATE_ATTRIBUTES;
#[repr(C)]
pub struct _PS_BNO_ISOLATION_PARAMETERS {
   pub IsolationPrefix: UNICODE_STRING,
   pub HandleCount: ULONG,
   pub Handles: *mut PVOID,
   pub IsolationEnabled: BOOLEAN,
}
impl Default for _PS_BNO_ISOLATION_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_BNO_ISOLATION_PARAMETERS = _PS_BNO_ISOLATION_PARAMETERS;
pub type PPS_BNO_ISOLATION_PARAMETERS = *mut _PS_BNO_ISOLATION_PARAMETERS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_MITIGATION_OPTION {
   PS_MITIGATION_OPTION_NX = 0,
   PS_MITIGATION_OPTION_SEHOP = 1,
   PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES = 2,
   PS_MITIGATION_OPTION_HEAP_TERMINATE = 3,
   PS_MITIGATION_OPTION_BOTTOM_UP_ASLR = 4,
   PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR = 5,
   PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS = 6,
   PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE = 7,
   PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE = 8,
   PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE = 9,
   PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD = 10,
   PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES = 11,
   PS_MITIGATION_OPTION_FONT_DISABLE = 12,
   PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE = 13,
   PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL = 14,
   PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32 = 15,
   PS_MITIGATION_OPTION_RETURN_FLOW_GUARD = 16,
   PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY = 17,
   PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD = 18,
   PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT = 19,
   PS_MITIGATION_OPTION_ROP_STACKPIVOT = 20,
   PS_MITIGATION_OPTION_ROP_CALLER_CHECK = 21,
   PS_MITIGATION_OPTION_ROP_SIMEXEC = 22,
   PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER = 23,
   PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS = 24,
   PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION = 25,
   PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER = 26,
   PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION = 27,
   PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION = 28,
   PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE = 29,
   PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY = 30,
   PS_MITIGATION_OPTION_CET_USER_SHADOW_STACKS = 31,
   PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION = 32,
   PS_MITIGATION_OPTION_BLOCK_NON_CET_BINARIES = 33,
   PS_MITIGATION_OPTION_CET_DYNAMIC_APIS_OUT_OF_PROC_ONLY = 34,
   PS_MITIGATION_OPTION_REDIRECTION_TRUST = 35,
   PS_MITIGATION_OPTION_RESTRICT_CORE_SHARING = 36,
}
pub use self::_PS_MITIGATION_OPTION as PS_MITIGATION_OPTION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_CREATE_STATE {
   PsCreateInitialState = 0,
   PsCreateFailOnFileOpen = 1,
   PsCreateFailOnSectionCreate = 2,
   PsCreateFailExeFormat = 3,
   PsCreateFailMachineMismatch = 4,
   PsCreateFailExeName = 5,
   PsCreateSuccess = 6,
   PsCreateMaximumStates = 7,
}
pub use self::_PS_CREATE_STATE as PS_CREATE_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_CREATE_INFO {
   pub Size: SIZE_T,
   pub State: PS_CREATE_STATE,
   pub __bindgen_anon_1: _PS_CREATE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_CREATE_INFO__bindgen_ty_1 {
   pub InitState: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1,
   pub FailSection: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_2,
   pub ExeFormat: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_3,
   pub ExeName: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_4,
   pub SuccessState: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1 {
   pub __bindgen_anon_1: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
   pub AdditionalFileAccess: ACCESS_MASK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
   pub InitFlags: ULONG,
   pub __bindgen_anon_1: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn WriteOutputOnExit(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_WriteOutputOnExit(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DetectManifest(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_DetectManifest(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IFEOSkipDebugger(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IFEOSkipDebugger(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IFEODoNotPropagateKeyState(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IFEODoNotPropagateKeyState(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareBits1(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_SpareBits1(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareBits2(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
   }
   #[inline]
   pub fn set_SpareBits2(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn ProhibitedImageCharacteristics(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u16) }
   }
   #[inline]
   pub fn set_ProhibitedImageCharacteristics(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      WriteOutputOnExit: UCHAR,
      DetectManifest: UCHAR,
      IFEOSkipDebugger: UCHAR,
      IFEODoNotPropagateKeyState: UCHAR,
      SpareBits1: UCHAR,
      SpareBits2: UCHAR,
      ProhibitedImageCharacteristics: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let WriteOutputOnExit: u8 = unsafe { ::core::mem::transmute(WriteOutputOnExit) };
         WriteOutputOnExit as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let DetectManifest: u8 = unsafe { ::core::mem::transmute(DetectManifest) };
         DetectManifest as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IFEOSkipDebugger: u8 = unsafe { ::core::mem::transmute(IFEOSkipDebugger) };
         IFEOSkipDebugger as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let IFEODoNotPropagateKeyState: u8 =
            unsafe { ::core::mem::transmute(IFEODoNotPropagateKeyState) };
         IFEODoNotPropagateKeyState as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let SpareBits1: u8 = unsafe { ::core::mem::transmute(SpareBits1) };
         SpareBits1 as u64
      });
      __bindgen_bitfield_unit.set(8usize, 8u8, {
         let SpareBits2: u8 = unsafe { ::core::mem::transmute(SpareBits2) };
         SpareBits2 as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let ProhibitedImageCharacteristics: u16 =
            unsafe { ::core::mem::transmute(ProhibitedImageCharacteristics) };
         ProhibitedImageCharacteristics as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_2 {
   pub FileHandle: HANDLE,
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_3 {
   pub DllCharacteristics: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_4 {
   pub IFEOKey: HANDLE,
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5 {
   pub __bindgen_anon_1: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
   pub FileHandle: HANDLE,
   pub SectionHandle: HANDLE,
   pub UserProcessParametersNative: ULONGLONG,
   pub UserProcessParametersWow64: ULONG,
   pub CurrentParameterFlags: ULONG,
   pub PebAddressNative: ULONGLONG,
   pub PebAddressWow64: ULONG,
   pub ManifestAddress: ULONGLONG,
   pub ManifestSize: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
   pub OutputFlags: ULONG,
   pub __bindgen_anon_1: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ProtectedProcess(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ProtectedProcess(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AddressSpaceOverride(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_AddressSpaceOverride(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DevOverrideEnabled(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_DevOverrideEnabled(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ManifestDetected(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ManifestDetected(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProtectedProcessLight(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ProtectedProcessLight(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareBits1(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
   }
   #[inline]
   pub fn set_SpareBits1(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareBits2(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
   }
   #[inline]
   pub fn set_SpareBits2(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareBits3(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u16) }
   }
   #[inline]
   pub fn set_SpareBits3(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ProtectedProcess: UCHAR,
      AddressSpaceOverride: UCHAR,
      DevOverrideEnabled: UCHAR,
      ManifestDetected: UCHAR,
      ProtectedProcessLight: UCHAR,
      SpareBits1: UCHAR,
      SpareBits2: UCHAR,
      SpareBits3: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ProtectedProcess: u8 = unsafe { ::core::mem::transmute(ProtectedProcess) };
         ProtectedProcess as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AddressSpaceOverride: u8 = unsafe { ::core::mem::transmute(AddressSpaceOverride) };
         AddressSpaceOverride as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let DevOverrideEnabled: u8 = unsafe { ::core::mem::transmute(DevOverrideEnabled) };
         DevOverrideEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ManifestDetected: u8 = unsafe { ::core::mem::transmute(ManifestDetected) };
         ManifestDetected as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let ProtectedProcessLight: u8 = unsafe { ::core::mem::transmute(ProtectedProcessLight) };
         ProtectedProcessLight as u64
      });
      __bindgen_bitfield_unit.set(5usize, 3u8, {
         let SpareBits1: u8 = unsafe { ::core::mem::transmute(SpareBits1) };
         SpareBits1 as u64
      });
      __bindgen_bitfield_unit.set(8usize, 8u8, {
         let SpareBits2: u8 = unsafe { ::core::mem::transmute(SpareBits2) };
         SpareBits2 as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let SpareBits3: u16 = unsafe { ::core::mem::transmute(SpareBits3) };
         SpareBits3 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_CREATE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_CREATE_INFO = _PS_CREATE_INFO;
pub type PPS_CREATE_INFO = *mut _PS_CREATE_INFO;
pub type PUSER_THREAD_START_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(ThreadParameter: PVOID) -> NTSTATUS>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2 {
   pub BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
   pub IoInfo: IO_COUNTERS,
   pub ProcessMemoryLimit: SIZE_T,
   pub JobMemoryLimit: SIZE_T,
   pub PeakProcessMemoryUsed: SIZE_T,
   pub PeakJobMemoryUsed: SIZE_T,
   pub JobTotalMemoryLimit: SIZE_T,
}
impl Default for _JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2 = _JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2;
pub type PJOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2 = *mut _JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION {
   pub BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
   pub IoInfo: IO_COUNTERS,
   pub DiskIoInfo: PROCESS_DISK_COUNTERS,
   pub ContextSwitches: ULONG64,
   pub TotalCycleTime: LARGE_INTEGER,
   pub ReadyTime: ULONG64,
   pub EnergyValues: PROCESS_ENERGY_VALUES,
}
impl Default for _JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION = _JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION =
   *mut _JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_WAKE_INFORMATION {
   pub NotificationChannel: HANDLE,
   pub WakeCounters: [ULONG64; 7usize],
}
impl Default for _JOBOBJECT_WAKE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_WAKE_INFORMATION = _JOBOBJECT_WAKE_INFORMATION;
pub type PJOBOBJECT_WAKE_INFORMATION = *mut _JOBOBJECT_WAKE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_WAKE_INFORMATION_V1 {
   pub NotificationChannel: HANDLE,
   pub WakeCounters: [ULONG64; 4usize],
}
impl Default for _JOBOBJECT_WAKE_INFORMATION_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_WAKE_INFORMATION_V1 = _JOBOBJECT_WAKE_INFORMATION_V1;
pub type PJOBOBJECT_WAKE_INFORMATION_V1 = *mut _JOBOBJECT_WAKE_INFORMATION_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_INTERFERENCE_INFORMATION {
   pub Count: ULONG64,
}
pub type JOBOBJECT_INTERFERENCE_INFORMATION = _JOBOBJECT_INTERFERENCE_INFORMATION;
pub type PJOBOBJECT_INTERFERENCE_INFORMATION = *mut _JOBOBJECT_INTERFERENCE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_WAKE_FILTER {
   pub HighEdgeFilter: ULONG,
   pub LowEdgeFilter: ULONG,
}
pub type JOBOBJECT_WAKE_FILTER = _JOBOBJECT_WAKE_FILTER;
#[repr(C)]
pub struct _JOBOBJECT_FREEZE_INFORMATION {
   pub __bindgen_anon_1: _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1,
   pub Freeze: BOOLEAN,
   pub Swap: BOOLEAN,
   pub Reserved0: [UCHAR; 2usize],
   pub WakeFilter: JOBOBJECT_WAKE_FILTER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn FreezeOperation(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FreezeOperation(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn FilterOperation(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FilterOperation(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SwapOperation(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SwapOperation(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      FreezeOperation: ULONG,
      FilterOperation: ULONG,
      SwapOperation: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let FreezeOperation: u32 = unsafe { ::core::mem::transmute(FreezeOperation) };
         FreezeOperation as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let FilterOperation: u32 = unsafe { ::core::mem::transmute(FilterOperation) };
         FilterOperation as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let SwapOperation: u32 = unsafe { ::core::mem::transmute(SwapOperation) };
         SwapOperation as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _JOBOBJECT_FREEZE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_FREEZE_INFORMATION = _JOBOBJECT_FREEZE_INFORMATION;
pub type PJOBOBJECT_FREEZE_INFORMATION = *mut _JOBOBJECT_FREEZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_CONTAINER_IDENTIFIER_V2 {
   pub ContainerId: GUID,
   pub ContainerTelemetryId: GUID,
   pub JobId: ULONG,
}
pub type JOBOBJECT_CONTAINER_IDENTIFIER_V2 = _JOBOBJECT_CONTAINER_IDENTIFIER_V2;
pub type PJOBOBJECT_CONTAINER_IDENTIFIER_V2 = *mut _JOBOBJECT_CONTAINER_IDENTIFIER_V2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_MEMORY_USAGE_INFORMATION {
   pub JobMemory: ULONG64,
   pub PeakJobMemoryUsed: ULONG64,
}
pub type JOBOBJECT_MEMORY_USAGE_INFORMATION = _JOBOBJECT_MEMORY_USAGE_INFORMATION;
pub type PJOBOBJECT_MEMORY_USAGE_INFORMATION = *mut _JOBOBJECT_MEMORY_USAGE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_MEMORY_USAGE_INFORMATION_V2 {
   pub BasicInfo: JOBOBJECT_MEMORY_USAGE_INFORMATION,
   pub JobSharedMemory: ULONG64,
   pub Reserved: [ULONG64; 2usize],
}
pub type JOBOBJECT_MEMORY_USAGE_INFORMATION_V2 = _JOBOBJECT_MEMORY_USAGE_INFORMATION_V2;
pub type PJOBOBJECT_MEMORY_USAGE_INFORMATION_V2 = *mut _JOBOBJECT_MEMORY_USAGE_INFORMATION_V2;
#[repr(C)]
pub struct _SILO_USER_SHARED_DATA {
   pub ServiceSessionId: ULONG,
   pub ActiveConsoleId: ULONG,
   pub ConsoleSessionForegroundProcessId: LONGLONG,
   pub NtProductType: NT_PRODUCT_TYPE,
   pub SuiteMask: ULONG,
   pub SharedUserSessionId: ULONG,
   pub IsMultiSessionSku: BOOLEAN,
   pub NtSystemRoot: [WCHAR; 260usize],
   pub UserModeGlobalLogger: [USHORT; 16usize],
   pub TimeZoneId: ULONG,
   pub TimeZoneBiasStamp: LONG,
   pub TimeZoneBias: KSYSTEM_TIME,
   pub TimeZoneBiasEffectiveStart: LARGE_INTEGER,
   pub TimeZoneBiasEffectiveEnd: LARGE_INTEGER,
}
impl Default for _SILO_USER_SHARED_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SILO_USER_SHARED_DATA = _SILO_USER_SHARED_DATA;
#[repr(C)]
pub struct _SILOOBJECT_ROOT_DIRECTORY {
   pub __bindgen_anon_1: _SILOOBJECT_ROOT_DIRECTORY__bindgen_ty_1,
}
#[repr(C)]
pub union _SILOOBJECT_ROOT_DIRECTORY__bindgen_ty_1 {
   pub ControlFlags: ::core::mem::ManuallyDrop<ULONG>,
   pub Path: ::core::mem::ManuallyDrop<UNICODE_STRING>,
}
impl Default for _SILOOBJECT_ROOT_DIRECTORY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SILOOBJECT_ROOT_DIRECTORY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SILOOBJECT_ROOT_DIRECTORY = _SILOOBJECT_ROOT_DIRECTORY;
pub type PSILOOBJECT_ROOT_DIRECTORY = *mut _SILOOBJECT_ROOT_DIRECTORY;
#[repr(C)]
pub struct _SERVERSILO_INIT_INFORMATION {
   pub DeleteEvent: HANDLE,
   pub IsDownlevelContainer: BOOLEAN,
}
impl Default for _SERVERSILO_INIT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SERVERSILO_INIT_INFORMATION = _SERVERSILO_INIT_INFORMATION;
pub type PSERVERSILO_INIT_INFORMATION = *mut _SERVERSILO_INIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_ENERGY_TRACKING_STATE {
   pub Value: ULONG64,
   pub UpdateMask: ULONG,
   pub DesiredState: ULONG,
}
pub type JOBOBJECT_ENERGY_TRACKING_STATE = _JOBOBJECT_ENERGY_TRACKING_STATE;
pub type PJOBOBJECT_ENERGY_TRACKING_STATE = *mut _JOBOBJECT_ENERGY_TRACKING_STATE;
impl _JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS {
   pub const JOBOBJECT_IO_PRIORITY_LIMIT_VALID_FLAGS: _JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS =
      _JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS::JOBOBJECT_IO_PRIORITY_LIMIT_ENABLE;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS {
   JOBOBJECT_IO_PRIORITY_LIMIT_ENABLE = 1,
}
pub use self::_JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS as JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_IO_PRIORITY_LIMIT {
   pub Flags: JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS,
   pub Priority: ULONG,
}
impl Default for _JOBOBJECT_IO_PRIORITY_LIMIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_IO_PRIORITY_LIMIT = _JOBOBJECT_IO_PRIORITY_LIMIT;
pub type PJOBOBJECT_IO_PRIORITY_LIMIT = *mut _JOBOBJECT_IO_PRIORITY_LIMIT;
impl _JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS {
   pub const JOBOBJECT_PAGE_PRIORITY_LIMIT_VALID_FLAGS: _JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS =
      _JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS::JOBOBJECT_PAGE_PRIORITY_LIMIT_ENABLE;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS {
   JOBOBJECT_PAGE_PRIORITY_LIMIT_ENABLE = 1,
}
pub use self::_JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS as JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_PAGE_PRIORITY_LIMIT {
   pub Flags: JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS,
   pub Priority: ULONG,
}
impl Default for _JOBOBJECT_PAGE_PRIORITY_LIMIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_PAGE_PRIORITY_LIMIT = _JOBOBJECT_PAGE_PRIORITY_LIMIT;
pub type PJOBOBJECT_PAGE_PRIORITY_LIMIT = *mut _JOBOBJECT_PAGE_PRIORITY_LIMIT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_RESERVE_TYPE {
   MemoryReserveUserApc = 0,
   MemoryReserveIoCompletion = 1,
   MemoryReserveTypeMax = 2,
}
pub use self::_MEMORY_RESERVE_TYPE as MEMORY_RESERVE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTPSS_MEMORY_BULK_INFORMATION {
   pub QueryFlags: ULONG,
   pub NumberOfEntries: ULONG,
   pub NextValidAddress: PVOID,
}
impl Default for _NTPSS_MEMORY_BULK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type NTPSS_MEMORY_BULK_INFORMATION = _NTPSS_MEMORY_BULK_INFORMATION;
pub type PNTPSS_MEMORY_BULK_INFORMATION = *mut _NTPSS_MEMORY_BULK_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PNP_VETO_TYPE {
   PNP_VetoTypeUnknown = 0,
   PNP_VetoLegacyDevice = 1,
   PNP_VetoPendingClose = 2,
   PNP_VetoWindowsApp = 3,
   PNP_VetoWindowsService = 4,
   PNP_VetoOutstandingOpen = 5,
   PNP_VetoDevice = 6,
   PNP_VetoDriver = 7,
   PNP_VetoIllegalDeviceRequest = 8,
   PNP_VetoInsufficientPower = 9,
   PNP_VetoNonDisableable = 10,
   PNP_VetoLegacyDriver = 11,
   PNP_VetoInsufficientRights = 12,
   PNP_VetoAlreadyRemoved = 13,
}
pub use self::_PNP_VETO_TYPE as PNP_VETO_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGKM_EXCEPTION {
   pub ExceptionRecord: EXCEPTION_RECORD,
   pub FirstChance: ULONG,
}
impl Default for _DBGKM_EXCEPTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_EXCEPTION = _DBGKM_EXCEPTION;
pub type PDBGKM_EXCEPTION = *mut _DBGKM_EXCEPTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGKM_CREATE_THREAD {
   pub SubSystemKey: ULONG,
   pub StartAddress: PVOID,
}
impl Default for _DBGKM_CREATE_THREAD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_CREATE_THREAD = _DBGKM_CREATE_THREAD;
pub type PDBGKM_CREATE_THREAD = *mut _DBGKM_CREATE_THREAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGKM_CREATE_PROCESS {
   pub SubSystemKey: ULONG,
   pub FileHandle: HANDLE,
   pub BaseOfImage: PVOID,
   pub DebugInfoFileOffset: ULONG,
   pub DebugInfoSize: ULONG,
   pub InitialThread: DBGKM_CREATE_THREAD,
}
impl Default for _DBGKM_CREATE_PROCESS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_CREATE_PROCESS = _DBGKM_CREATE_PROCESS;
pub type PDBGKM_CREATE_PROCESS = *mut _DBGKM_CREATE_PROCESS;
#[repr(C)]
pub struct _DBGKM_EXIT_THREAD {
   pub ExitStatus: NTSTATUS,
}
impl Default for _DBGKM_EXIT_THREAD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_EXIT_THREAD = _DBGKM_EXIT_THREAD;
pub type PDBGKM_EXIT_THREAD = *mut _DBGKM_EXIT_THREAD;
#[repr(C)]
pub struct _DBGKM_EXIT_PROCESS {
   pub ExitStatus: NTSTATUS,
}
impl Default for _DBGKM_EXIT_PROCESS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_EXIT_PROCESS = _DBGKM_EXIT_PROCESS;
pub type PDBGKM_EXIT_PROCESS = *mut _DBGKM_EXIT_PROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGKM_LOAD_DLL {
   pub FileHandle: HANDLE,
   pub BaseOfDll: PVOID,
   pub DebugInfoFileOffset: ULONG,
   pub DebugInfoSize: ULONG,
   pub NamePointer: PVOID,
}
impl Default for _DBGKM_LOAD_DLL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_LOAD_DLL = _DBGKM_LOAD_DLL;
pub type PDBGKM_LOAD_DLL = *mut _DBGKM_LOAD_DLL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGKM_UNLOAD_DLL {
   pub BaseAddress: PVOID,
}
impl Default for _DBGKM_UNLOAD_DLL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_UNLOAD_DLL = _DBGKM_UNLOAD_DLL;
pub type PDBGKM_UNLOAD_DLL = *mut _DBGKM_UNLOAD_DLL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DBG_STATE {
   DbgIdle = 0,
   DbgReplyPending = 1,
   DbgCreateThreadStateChange = 2,
   DbgCreateProcessStateChange = 3,
   DbgExitThreadStateChange = 4,
   DbgExitProcessStateChange = 5,
   DbgExceptionStateChange = 6,
   DbgBreakpointStateChange = 7,
   DbgSingleStepStateChange = 8,
   DbgLoadDllStateChange = 9,
   DbgUnloadDllStateChange = 10,
}
pub use self::_DBG_STATE as DBG_STATE;
pub type PDBG_STATE = *mut _DBG_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGUI_CREATE_THREAD {
   pub HandleToThread: HANDLE,
   pub NewThread: DBGKM_CREATE_THREAD,
}
impl Default for _DBGUI_CREATE_THREAD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGUI_CREATE_THREAD = _DBGUI_CREATE_THREAD;
pub type PDBGUI_CREATE_THREAD = *mut _DBGUI_CREATE_THREAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGUI_CREATE_PROCESS {
   pub HandleToProcess: HANDLE,
   pub HandleToThread: HANDLE,
   pub NewProcess: DBGKM_CREATE_PROCESS,
}
impl Default for _DBGUI_CREATE_PROCESS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGUI_CREATE_PROCESS = _DBGUI_CREATE_PROCESS;
pub type PDBGUI_CREATE_PROCESS = *mut _DBGUI_CREATE_PROCESS;
#[repr(C)]
pub struct _DBGUI_WAIT_STATE_CHANGE {
   pub NewState: DBG_STATE,
   pub AppClientId: CLIENT_ID,
   pub StateInfo: _DBGUI_WAIT_STATE_CHANGE__bindgen_ty_1,
}
#[repr(C)]
pub union _DBGUI_WAIT_STATE_CHANGE__bindgen_ty_1 {
   pub Exception: ::core::mem::ManuallyDrop<DBGKM_EXCEPTION>,
   pub CreateThread: ::core::mem::ManuallyDrop<DBGUI_CREATE_THREAD>,
   pub CreateProcessInfo: ::core::mem::ManuallyDrop<DBGUI_CREATE_PROCESS>,
   pub ExitThread: ::core::mem::ManuallyDrop<DBGKM_EXIT_THREAD>,
   pub ExitProcess: ::core::mem::ManuallyDrop<DBGKM_EXIT_PROCESS>,
   pub LoadDll: ::core::mem::ManuallyDrop<DBGKM_LOAD_DLL>,
   pub UnloadDll: ::core::mem::ManuallyDrop<DBGKM_UNLOAD_DLL>,
}
impl Default for _DBGUI_WAIT_STATE_CHANGE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _DBGUI_WAIT_STATE_CHANGE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGUI_WAIT_STATE_CHANGE = _DBGUI_WAIT_STATE_CHANGE;
pub type PDBGUI_WAIT_STATE_CHANGE = *mut _DBGUI_WAIT_STATE_CHANGE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEBUGOBJECTINFOCLASS {
   DebugObjectUnusedInformation = 0,
   DebugObjectKillProcessOnExitInformation = 1,
   MaxDebugObjectInfoClass = 2,
}
pub use self::_DEBUGOBJECTINFOCLASS as DEBUGOBJECTINFOCLASS;
pub type PDEBUGOBJECTINFOCLASS = *mut _DEBUGOBJECTINFOCLASS;
pub type PENABLECALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      SourceId: LPCGUID,
      IsEnabled: ULONG,
      Level: UCHAR,
      MatchAnyKeyword: ULONGLONG,
      MatchAllKeyword: ULONGLONG,
      FilterData: PEVENT_FILTER_DESCRIPTOR,
      CallbackContext: PVOID,
   ),
>;
pub type REGHANDLE = ULONGLONG;
pub type PREGHANDLE = *mut ULONGLONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXTENDED_CREATE_INFORMATION {
   pub ExtendedCreateFlags: LONGLONG,
   pub EaBuffer: PVOID,
   pub EaLength: ULONG,
}
impl Default for _EXTENDED_CREATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EXTENDED_CREATE_INFORMATION = _EXTENDED_CREATE_INFORMATION;
pub type PEXTENDED_CREATE_INFORMATION = *mut _EXTENDED_CREATE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXTENDED_CREATE_INFORMATION_32 {
   pub ExtendedCreateFlags: LONGLONG,
   pub EaBuffer: u32,
   pub EaLength: ULONG,
}
impl Default for _EXTENDED_CREATE_INFORMATION_32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EXTENDED_CREATE_INFORMATION_32 = _EXTENDED_CREATE_INFORMATION_32;
pub type PEXTENDED_CREATE_INFORMATION_32 = *mut _EXTENDED_CREATE_INFORMATION_32;
#[repr(C)]
pub struct _IO_STATUS_BLOCK {
   pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
   pub Information: ULONG_PTR,
}
#[repr(C)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
   pub Status: ::core::mem::ManuallyDrop<NTSTATUS>,
   pub Pointer: ::core::mem::ManuallyDrop<PVOID>,
}
impl Default for _IO_STATUS_BLOCK__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IO_STATUS_BLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_APC_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK, Reserved: ULONG),
>;
#[repr(C)]
pub struct _FILE_IO_COMPLETION_INFORMATION {
   pub KeyContext: PVOID,
   pub ApcContext: PVOID,
   pub IoStatusBlock: IO_STATUS_BLOCK,
}
impl Default for _FILE_IO_COMPLETION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_IO_COMPLETION_INFORMATION = _FILE_IO_COMPLETION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_INFORMATION_CLASS {
   FileDirectoryInformation = 1,
   FileFullDirectoryInformation = 2,
   FileBothDirectoryInformation = 3,
   FileBasicInformation = 4,
   FileStandardInformation = 5,
   FileInternalInformation = 6,
   FileEaInformation = 7,
   FileAccessInformation = 8,
   FileNameInformation = 9,
   FileRenameInformation = 10,
   FileLinkInformation = 11,
   FileNamesInformation = 12,
   FileDispositionInformation = 13,
   FilePositionInformation = 14,
   FileFullEaInformation = 15,
   FileModeInformation = 16,
   FileAlignmentInformation = 17,
   FileAllInformation = 18,
   FileAllocationInformation = 19,
   FileEndOfFileInformation = 20,
   FileAlternateNameInformation = 21,
   FileStreamInformation = 22,
   FilePipeInformation = 23,
   FilePipeLocalInformation = 24,
   FilePipeRemoteInformation = 25,
   FileMailslotQueryInformation = 26,
   FileMailslotSetInformation = 27,
   FileCompressionInformation = 28,
   FileObjectIdInformation = 29,
   FileCompletionInformation = 30,
   FileMoveClusterInformation = 31,
   FileQuotaInformation = 32,
   FileReparsePointInformation = 33,
   FileNetworkOpenInformation = 34,
   FileAttributeTagInformation = 35,
   FileTrackingInformation = 36,
   FileIdBothDirectoryInformation = 37,
   FileIdFullDirectoryInformation = 38,
   FileValidDataLengthInformation = 39,
   FileShortNameInformation = 40,
   FileIoCompletionNotificationInformation = 41,
   FileIoStatusBlockRangeInformation = 42,
   FileIoPriorityHintInformation = 43,
   FileSfioReserveInformation = 44,
   FileSfioVolumeInformation = 45,
   FileHardLinkInformation = 46,
   FileProcessIdsUsingFileInformation = 47,
   FileNormalizedNameInformation = 48,
   FileNetworkPhysicalNameInformation = 49,
   FileIdGlobalTxDirectoryInformation = 50,
   FileIsRemoteDeviceInformation = 51,
   FileUnusedInformation = 52,
   FileNumaNodeInformation = 53,
   FileStandardLinkInformation = 54,
   FileRemoteProtocolInformation = 55,
   FileRenameInformationBypassAccessCheck = 56,
   FileLinkInformationBypassAccessCheck = 57,
   FileVolumeNameInformation = 58,
   FileIdInformation = 59,
   FileIdExtdDirectoryInformation = 60,
   FileReplaceCompletionInformation = 61,
   FileHardLinkFullIdInformation = 62,
   FileIdExtdBothDirectoryInformation = 63,
   FileDispositionInformationEx = 64,
   FileRenameInformationEx = 65,
   FileRenameInformationExBypassAccessCheck = 66,
   FileDesiredStorageClassInformation = 67,
   FileStatInformation = 68,
   FileMemoryPartitionInformation = 69,
   FileStatLxInformation = 70,
   FileCaseSensitiveInformation = 71,
   FileLinkInformationEx = 72,
   FileLinkInformationExBypassAccessCheck = 73,
   FileStorageReserveIdInformation = 74,
   FileCaseSensitiveInformationForceAccessCheck = 75,
   FileKnownFolderInformation = 76,
   FileStatBasicInformation = 77,
   FileId64ExtdDirectoryInformation = 78,
   FileId64ExtdBothDirectoryInformation = 79,
   FileIdAllExtdDirectoryInformation = 80,
   FileIdAllExtdBothDirectoryInformation = 81,
   FileMaximumInformation = 82,
}
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
pub type PFILE_INFORMATION_CLASS = *mut _FILE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub FileAttributes: ULONG,
}
impl Default for _FILE_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_BASIC_INFORMATION = _FILE_BASIC_INFORMATION;
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
pub struct _FILE_STANDARD_INFORMATION {
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub NumberOfLinks: ULONG,
   pub DeletePending: BOOLEAN,
   pub Directory: BOOLEAN,
}
impl Default for _FILE_STANDARD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STANDARD_INFORMATION = _FILE_STANDARD_INFORMATION;
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
pub struct _FILE_STANDARD_INFORMATION_EX {
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub NumberOfLinks: ULONG,
   pub DeletePending: BOOLEAN,
   pub Directory: BOOLEAN,
   pub AlternateStream: BOOLEAN,
   pub MetadataAttribute: BOOLEAN,
}
impl Default for _FILE_STANDARD_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STANDARD_INFORMATION_EX = _FILE_STANDARD_INFORMATION_EX;
pub type PFILE_STANDARD_INFORMATION_EX = *mut _FILE_STANDARD_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_INTERNAL_INFORMATION {
   pub __bindgen_anon_1: _FILE_INTERNAL_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_INTERNAL_INFORMATION__bindgen_ty_1 {
   pub IndexNumber: LARGE_INTEGER,
   pub __bindgen_anon_1: _FILE_INTERNAL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_INTERNAL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _FILE_INTERNAL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn MftRecordIndex(&self) -> LONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_MftRecordIndex(&mut self, val: LONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub fn SequenceNumber(&self) -> LONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
   }
   #[inline]
   pub fn set_SequenceNumber(&mut self, val: LONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(48usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      MftRecordIndex: LONGLONG,
      SequenceNumber: LONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 48u8, {
         let MftRecordIndex: u64 = unsafe { ::core::mem::transmute(MftRecordIndex) };
         MftRecordIndex as u64
      });
      __bindgen_bitfield_unit.set(48usize, 16u8, {
         let SequenceNumber: u64 = unsafe { ::core::mem::transmute(SequenceNumber) };
         SequenceNumber as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _FILE_INTERNAL_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_INTERNAL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_INTERNAL_INFORMATION = _FILE_INTERNAL_INFORMATION;
pub type PFILE_INTERNAL_INFORMATION = *mut _FILE_INTERNAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_EA_INFORMATION {
   pub EaSize: ULONG,
}
pub type FILE_EA_INFORMATION = _FILE_EA_INFORMATION;
pub type PFILE_EA_INFORMATION = *mut _FILE_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_ACCESS_INFORMATION {
   pub AccessFlags: ACCESS_MASK,
}
pub type FILE_ACCESS_INFORMATION = _FILE_ACCESS_INFORMATION;
pub type PFILE_ACCESS_INFORMATION = *mut _FILE_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_POSITION_INFORMATION {
   pub CurrentByteOffset: LARGE_INTEGER,
}
impl Default for _FILE_POSITION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_POSITION_INFORMATION = _FILE_POSITION_INFORMATION;
pub type PFILE_POSITION_INFORMATION = *mut _FILE_POSITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_MODE_INFORMATION {
   pub Mode: ULONG,
}
pub type FILE_MODE_INFORMATION = _FILE_MODE_INFORMATION;
pub type PFILE_MODE_INFORMATION = *mut _FILE_MODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_ALIGNMENT_INFORMATION {
   pub AlignmentRequirement: ULONG,
}
pub type FILE_ALIGNMENT_INFORMATION = _FILE_ALIGNMENT_INFORMATION;
pub type PFILE_ALIGNMENT_INFORMATION = *mut _FILE_ALIGNMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_NAME_INFORMATION {
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type FILE_NAME_INFORMATION = _FILE_NAME_INFORMATION;
pub type PFILE_NAME_INFORMATION = *mut _FILE_NAME_INFORMATION;
#[repr(C)]
pub struct _FILE_ALL_INFORMATION {
   pub BasicInformation: FILE_BASIC_INFORMATION,
   pub StandardInformation: FILE_STANDARD_INFORMATION,
   pub InternalInformation: FILE_INTERNAL_INFORMATION,
   pub EaInformation: FILE_EA_INFORMATION,
   pub AccessInformation: FILE_ACCESS_INFORMATION,
   pub PositionInformation: FILE_POSITION_INFORMATION,
   pub ModeInformation: FILE_MODE_INFORMATION,
   pub AlignmentInformation: FILE_ALIGNMENT_INFORMATION,
   pub NameInformation: FILE_NAME_INFORMATION,
}
impl Default for _FILE_ALL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ALL_INFORMATION = _FILE_ALL_INFORMATION;
pub type PFILE_ALL_INFORMATION = *mut _FILE_ALL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub FileAttributes: ULONG,
}
impl Default for _FILE_NETWORK_OPEN_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_NETWORK_OPEN_INFORMATION = _FILE_NETWORK_OPEN_INFORMATION;
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_ATTRIBUTE_TAG_INFORMATION {
   pub FileAttributes: ULONG,
   pub ReparseTag: ULONG,
}
pub type FILE_ATTRIBUTE_TAG_INFORMATION = _FILE_ATTRIBUTE_TAG_INFORMATION;
pub type PFILE_ATTRIBUTE_TAG_INFORMATION = *mut _FILE_ATTRIBUTE_TAG_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATION_INFORMATION {
   pub AllocationSize: LARGE_INTEGER,
}
impl Default for _FILE_ALLOCATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ALLOCATION_INFORMATION = _FILE_ALLOCATION_INFORMATION;
pub type PFILE_ALLOCATION_INFORMATION = *mut _FILE_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_COMPRESSION_INFORMATION {
   pub CompressedFileSize: LARGE_INTEGER,
   pub CompressionFormat: USHORT,
   pub CompressionUnitShift: UCHAR,
   pub ChunkShift: UCHAR,
   pub ClusterShift: UCHAR,
   pub Reserved: [UCHAR; 3usize],
}
impl Default for _FILE_COMPRESSION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_COMPRESSION_INFORMATION = _FILE_COMPRESSION_INFORMATION;
pub type PFILE_COMPRESSION_INFORMATION = *mut _FILE_COMPRESSION_INFORMATION;
#[repr(C)]
pub struct _FILE_DISPOSITION_INFORMATION {
   pub DeleteFileA: BOOLEAN,
}
impl Default for _FILE_DISPOSITION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_DISPOSITION_INFORMATION = _FILE_DISPOSITION_INFORMATION;
pub type PFILE_DISPOSITION_INFORMATION = *mut _FILE_DISPOSITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFORMATION {
   pub EndOfFile: LARGE_INTEGER,
}
impl Default for _FILE_END_OF_FILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_END_OF_FILE_INFORMATION = _FILE_END_OF_FILE_INFORMATION;
pub type PFILE_END_OF_FILE_INFORMATION = *mut _FILE_END_OF_FILE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFORMATION_EX {
   pub EndOfFile: LARGE_INTEGER,
   pub PagingFileSizeInMM: LARGE_INTEGER,
   pub PagingFileMaxSize: LARGE_INTEGER,
   pub Flags: ULONG,
}
impl Default for _FILE_END_OF_FILE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_END_OF_FILE_INFORMATION_EX = _FILE_END_OF_FILE_INFORMATION_EX;
pub type PFILE_END_OF_FILE_INFORMATION_EX = *mut _FILE_END_OF_FILE_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_VALID_DATA_LENGTH_INFORMATION {
   pub ValidDataLength: LARGE_INTEGER,
}
impl Default for _FILE_VALID_DATA_LENGTH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_VALID_DATA_LENGTH_INFORMATION = _FILE_VALID_DATA_LENGTH_INFORMATION;
pub type PFILE_VALID_DATA_LENGTH_INFORMATION = *mut _FILE_VALID_DATA_LENGTH_INFORMATION;
#[repr(C)]
pub struct _FILE_LINK_INFORMATION {
   pub ReplaceIfExists: BOOLEAN,
   pub RootDirectory: HANDLE,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_LINK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_LINK_INFORMATION = _FILE_LINK_INFORMATION;
pub type PFILE_LINK_INFORMATION = *mut _FILE_LINK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LINK_INFORMATION_EX {
   pub Flags: ULONG,
   pub RootDirectory: HANDLE,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_LINK_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_LINK_INFORMATION_EX = _FILE_LINK_INFORMATION_EX;
pub type PFILE_LINK_INFORMATION_EX = *mut _FILE_LINK_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MOVE_CLUSTER_INFORMATION {
   pub ClusterCount: ULONG,
   pub RootDirectory: HANDLE,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_MOVE_CLUSTER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_MOVE_CLUSTER_INFORMATION = _FILE_MOVE_CLUSTER_INFORMATION;
pub type PFILE_MOVE_CLUSTER_INFORMATION = *mut _FILE_MOVE_CLUSTER_INFORMATION;
#[repr(C)]
pub struct _FILE_RENAME_INFORMATION {
   pub ReplaceIfExists: BOOLEAN,
   pub RootDirectory: HANDLE,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_RENAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_RENAME_INFORMATION = _FILE_RENAME_INFORMATION;
pub type PFILE_RENAME_INFORMATION = *mut _FILE_RENAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_RENAME_INFORMATION_EX {
   pub Flags: ULONG,
   pub RootDirectory: HANDLE,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_RENAME_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_RENAME_INFORMATION_EX = _FILE_RENAME_INFORMATION_EX;
pub type PFILE_RENAME_INFORMATION_EX = *mut _FILE_RENAME_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STREAM_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub StreamNameLength: ULONG,
   pub StreamSize: LARGE_INTEGER,
   pub StreamAllocationSize: LARGE_INTEGER,
   pub StreamName: [WCHAR; 1usize],
}
impl Default for _FILE_STREAM_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STREAM_INFORMATION = _FILE_STREAM_INFORMATION;
pub type PFILE_STREAM_INFORMATION = *mut _FILE_STREAM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_TRACKING_INFORMATION {
   pub DestinationFile: HANDLE,
   pub ObjectInformationLength: ULONG,
   pub ObjectInformation: [CHAR; 1usize],
}
impl Default for _FILE_TRACKING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_TRACKING_INFORMATION = _FILE_TRACKING_INFORMATION;
pub type PFILE_TRACKING_INFORMATION = *mut _FILE_TRACKING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_COMPLETION_INFORMATION {
   pub Port: HANDLE,
   pub Key: PVOID,
}
impl Default for _FILE_COMPLETION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_COMPLETION_INFORMATION = _FILE_COMPLETION_INFORMATION;
pub type PFILE_COMPLETION_INFORMATION = *mut _FILE_COMPLETION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_INFORMATION {
   pub ReadMode: ULONG,
   pub CompletionMode: ULONG,
}
pub type FILE_PIPE_INFORMATION = _FILE_PIPE_INFORMATION;
pub type PFILE_PIPE_INFORMATION = *mut _FILE_PIPE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_LOCAL_INFORMATION {
   pub NamedPipeType: ULONG,
   pub NamedPipeConfiguration: ULONG,
   pub MaximumInstances: ULONG,
   pub CurrentInstances: ULONG,
   pub InboundQuota: ULONG,
   pub ReadDataAvailable: ULONG,
   pub OutboundQuota: ULONG,
   pub WriteQuotaAvailable: ULONG,
   pub NamedPipeState: ULONG,
   pub NamedPipeEnd: ULONG,
}
pub type FILE_PIPE_LOCAL_INFORMATION = _FILE_PIPE_LOCAL_INFORMATION;
pub type PFILE_PIPE_LOCAL_INFORMATION = *mut _FILE_PIPE_LOCAL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_PIPE_REMOTE_INFORMATION {
   pub CollectDataTime: LARGE_INTEGER,
   pub MaximumCollectionCount: ULONG,
}
impl Default for _FILE_PIPE_REMOTE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_REMOTE_INFORMATION = _FILE_PIPE_REMOTE_INFORMATION;
pub type PFILE_PIPE_REMOTE_INFORMATION = *mut _FILE_PIPE_REMOTE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MAILSLOT_QUERY_INFORMATION {
   pub MaximumMessageSize: ULONG,
   pub MailslotQuota: ULONG,
   pub NextMessageSize: ULONG,
   pub MessagesAvailable: ULONG,
   pub ReadTimeout: LARGE_INTEGER,
}
impl Default for _FILE_MAILSLOT_QUERY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_MAILSLOT_QUERY_INFORMATION = _FILE_MAILSLOT_QUERY_INFORMATION;
pub type PFILE_MAILSLOT_QUERY_INFORMATION = *mut _FILE_MAILSLOT_QUERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MAILSLOT_SET_INFORMATION {
   pub ReadTimeout: PLARGE_INTEGER,
}
impl Default for _FILE_MAILSLOT_SET_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_MAILSLOT_SET_INFORMATION = _FILE_MAILSLOT_SET_INFORMATION;
pub type PFILE_MAILSLOT_SET_INFORMATION = *mut _FILE_MAILSLOT_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_REPARSE_POINT_INFORMATION {
   pub FileReference: LONGLONG,
   pub Tag: ULONG,
}
pub type FILE_REPARSE_POINT_INFORMATION = _FILE_REPARSE_POINT_INFORMATION;
pub type PFILE_REPARSE_POINT_INFORMATION = *mut _FILE_REPARSE_POINT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_LINK_ENTRY_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub ParentFileId: LONGLONG,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type FILE_LINK_ENTRY_INFORMATION = _FILE_LINK_ENTRY_INFORMATION;
pub type PFILE_LINK_ENTRY_INFORMATION = *mut _FILE_LINK_ENTRY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_LINKS_INFORMATION {
   pub BytesNeeded: ULONG,
   pub EntriesReturned: ULONG,
   pub Entry: FILE_LINK_ENTRY_INFORMATION,
}
pub type FILE_LINKS_INFORMATION = _FILE_LINKS_INFORMATION;
pub type PFILE_LINKS_INFORMATION = *mut _FILE_LINKS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type FILE_NETWORK_PHYSICAL_NAME_INFORMATION = _FILE_NETWORK_PHYSICAL_NAME_INFORMATION;
pub type PFILE_NETWORK_PHYSICAL_NAME_INFORMATION = *mut _FILE_NETWORK_PHYSICAL_NAME_INFORMATION;
#[repr(C)]
pub struct _FILE_STANDARD_LINK_INFORMATION {
   pub NumberOfAccessibleLinks: ULONG,
   pub TotalNumberOfLinks: ULONG,
   pub DeletePending: BOOLEAN,
   pub Directory: BOOLEAN,
}
impl Default for _FILE_STANDARD_LINK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STANDARD_LINK_INFORMATION = _FILE_STANDARD_LINK_INFORMATION;
pub type PFILE_STANDARD_LINK_INFORMATION = *mut _FILE_STANDARD_LINK_INFORMATION;
#[repr(C)]
pub struct _FILE_SFIO_RESERVE_INFORMATION {
   pub RequestsPerPeriod: ULONG,
   pub Period: ULONG,
   pub RetryFailures: BOOLEAN,
   pub Discardable: BOOLEAN,
   pub RequestSize: ULONG,
   pub NumOutstandingRequests: ULONG,
}
impl Default for _FILE_SFIO_RESERVE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_SFIO_RESERVE_INFORMATION = _FILE_SFIO_RESERVE_INFORMATION;
pub type PFILE_SFIO_RESERVE_INFORMATION = *mut _FILE_SFIO_RESERVE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_SFIO_VOLUME_INFORMATION {
   pub MaximumRequestsPerPeriod: ULONG,
   pub MinimumPeriod: ULONG,
   pub MinimumTransferSize: ULONG,
}
pub type FILE_SFIO_VOLUME_INFORMATION = _FILE_SFIO_VOLUME_INFORMATION;
pub type PFILE_SFIO_VOLUME_INFORMATION = *mut _FILE_SFIO_VOLUME_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_PRIORITY_HINT {
   IoPriorityVeryLow = 0,
   IoPriorityLow = 1,
   IoPriorityNormal = 2,
   IoPriorityHigh = 3,
   IoPriorityCritical = 4,
   MaxIoPriorityTypes = 5,
}
pub use self::_IO_PRIORITY_HINT as IO_PRIORITY_HINT;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IO_PRIORITY_HINT_INFORMATION {
   pub PriorityHint: IO_PRIORITY_HINT,
}
impl Default for _FILE_IO_PRIORITY_HINT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_IO_PRIORITY_HINT_INFORMATION = _FILE_IO_PRIORITY_HINT_INFORMATION;
pub type PFILE_IO_PRIORITY_HINT_INFORMATION = *mut _FILE_IO_PRIORITY_HINT_INFORMATION;
#[repr(C)]
pub struct _FILE_IO_PRIORITY_HINT_INFORMATION_EX {
   pub PriorityHint: IO_PRIORITY_HINT,
   pub BoostOutstanding: BOOLEAN,
}
impl Default for _FILE_IO_PRIORITY_HINT_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_IO_PRIORITY_HINT_INFORMATION_EX = _FILE_IO_PRIORITY_HINT_INFORMATION_EX;
pub type PFILE_IO_PRIORITY_HINT_INFORMATION_EX = *mut _FILE_IO_PRIORITY_HINT_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION {
   pub Flags: ULONG,
}
pub type FILE_IO_COMPLETION_NOTIFICATION_INFORMATION = _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
pub type PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION =
   *mut _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION {
   pub NumberOfProcessIdsInList: ULONG,
   pub ProcessIdList: [ULONG_PTR; 1usize],
}
pub type FILE_PROCESS_IDS_USING_FILE_INFORMATION = _FILE_PROCESS_IDS_USING_FILE_INFORMATION;
pub type PFILE_PROCESS_IDS_USING_FILE_INFORMATION = *mut _FILE_PROCESS_IDS_USING_FILE_INFORMATION;
#[repr(C)]
pub struct _FILE_IS_REMOTE_DEVICE_INFORMATION {
   pub IsRemote: BOOLEAN,
}
impl Default for _FILE_IS_REMOTE_DEVICE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_IS_REMOTE_DEVICE_INFORMATION = _FILE_IS_REMOTE_DEVICE_INFORMATION;
pub type PFILE_IS_REMOTE_DEVICE_INFORMATION = *mut _FILE_IS_REMOTE_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_NUMA_NODE_INFORMATION {
   pub NodeNumber: USHORT,
}
pub type FILE_NUMA_NODE_INFORMATION = _FILE_NUMA_NODE_INFORMATION;
pub type PFILE_NUMA_NODE_INFORMATION = *mut _FILE_NUMA_NODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
   pub IoStatusBlockRange: PUCHAR,
   pub Length: ULONG,
}
impl Default for _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_IOSTATUSBLOCK_RANGE_INFORMATION = _FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
pub type PFILE_IOSTATUSBLOCK_RANGE_INFORMATION = *mut _FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION {
   pub StructureVersion: USHORT,
   pub StructureSize: USHORT,
   pub Protocol: ULONG,
   pub ProtocolMajorVersion: USHORT,
   pub ProtocolMinorVersion: USHORT,
   pub ProtocolRevision: USHORT,
   pub Reserved: USHORT,
   pub Flags: ULONG,
   pub GenericReserved: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_1,
   pub ProtocolSpecific: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_1 {
   pub Reserved: [ULONG; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2 {
   pub Smb2: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1,
   pub Reserved: [ULONG; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   pub Server: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
   pub Share: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
   pub Capabilities: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
   pub Capabilities: ULONG,
   pub ShareFlags: ULONG,
   pub ShareType: UCHAR,
   pub Reserved0: [UCHAR; 3usize],
   pub Reserved1: ULONG,
}
impl Default for _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_REMOTE_PROTOCOL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_REMOTE_PROTOCOL_INFORMATION = _FILE_REMOTE_PROTOCOL_INFORMATION;
pub type PFILE_REMOTE_PROTOCOL_INFORMATION = *mut _FILE_REMOTE_PROTOCOL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_INTEGRITY_STREAM_INFORMATION {
   pub ChecksumAlgorithm: USHORT,
   pub ChecksumChunkShift: UCHAR,
   pub ClusterShift: UCHAR,
   pub Flags: ULONG,
}
pub type FILE_INTEGRITY_STREAM_INFORMATION = _FILE_INTEGRITY_STREAM_INFORMATION;
pub type PFILE_INTEGRITY_STREAM_INFORMATION = *mut _FILE_INTEGRITY_STREAM_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_VOLUME_NAME_INFORMATION {
   pub DeviceNameLength: ULONG,
   pub DeviceName: [WCHAR; 1usize],
}
pub type FILE_VOLUME_NAME_INFORMATION = _FILE_VOLUME_NAME_INFORMATION;
pub type PFILE_VOLUME_NAME_INFORMATION = *mut _FILE_VOLUME_NAME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_INFORMATION {
   pub VolumeSerialNumber: ULONGLONG,
   pub __bindgen_anon_1: _FILE_ID_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_ID_INFORMATION__bindgen_ty_1 {
   pub FileId: FILE_ID_128,
   pub __bindgen_anon_1: _FILE_ID_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_ID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl _FILE_ID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn FileIdLowPart(&self) -> LONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 64u8) as u64) }
   }
   #[inline]
   pub fn set_FileIdLowPart(&mut self, val: LONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 64u8, val as u64)
      }
   }
   #[inline]
   pub fn FileIdHighPart(&self) -> LONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 64u8) as u64) }
   }
   #[inline]
   pub fn set_FileIdHighPart(&mut self, val: LONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(64usize, 64u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      FileIdLowPart: LONGLONG,
      FileIdHighPart: LONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 64u8, {
         let FileIdLowPart: u64 = unsafe { ::core::mem::transmute(FileIdLowPart) };
         FileIdLowPart as u64
      });
      __bindgen_bitfield_unit.set(64usize, 64u8, {
         let FileIdHighPart: u64 = unsafe { ::core::mem::transmute(FileIdHighPart) };
         FileIdHighPart as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _FILE_ID_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_ID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_INFORMATION = _FILE_ID_INFORMATION;
pub type PFILE_ID_INFORMATION = *mut _FILE_ID_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_EXTD_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ReparsePointTag: ULONG,
   pub FileId: FILE_ID_128,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_EXTD_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_EXTD_DIR_INFORMATION = _FILE_ID_EXTD_DIR_INFORMATION;
pub type PFILE_ID_EXTD_DIR_INFORMATION = *mut _FILE_ID_EXTD_DIR_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_LINK_ENTRY_FULL_ID_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub ParentFileId: FILE_ID_128,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type FILE_LINK_ENTRY_FULL_ID_INFORMATION = _FILE_LINK_ENTRY_FULL_ID_INFORMATION;
pub type PFILE_LINK_ENTRY_FULL_ID_INFORMATION = *mut _FILE_LINK_ENTRY_FULL_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_LINKS_FULL_ID_INFORMATION {
   pub BytesNeeded: ULONG,
   pub EntriesReturned: ULONG,
   pub Entry: FILE_LINK_ENTRY_FULL_ID_INFORMATION,
}
pub type FILE_LINKS_FULL_ID_INFORMATION = _FILE_LINKS_FULL_ID_INFORMATION;
pub type PFILE_LINKS_FULL_ID_INFORMATION = *mut _FILE_LINKS_FULL_ID_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_EXTD_BOTH_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ReparsePointTag: ULONG,
   pub FileId: FILE_ID_128,
   pub ShortNameLength: CCHAR,
   pub ShortName: [WCHAR; 12usize],
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_EXTD_BOTH_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_EXTD_BOTH_DIR_INFORMATION = _FILE_ID_EXTD_BOTH_DIR_INFORMATION;
pub type PFILE_ID_EXTD_BOTH_DIR_INFORMATION = *mut _FILE_ID_EXTD_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STAT_INFORMATION {
   pub FileId: LARGE_INTEGER,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub ReparseTag: ULONG,
   pub NumberOfLinks: ULONG,
   pub EffectiveAccess: ACCESS_MASK,
}
impl Default for _FILE_STAT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STAT_INFORMATION = _FILE_STAT_INFORMATION;
pub type PFILE_STAT_INFORMATION = *mut _FILE_STAT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MEMORY_PARTITION_INFORMATION {
   pub OwnerPartitionHandle: HANDLE,
   pub Flags: _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub AllFlags: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub NoCrossPartitionAccess: UCHAR,
   pub Spare: [UCHAR; 3usize],
}
impl Default for _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_MEMORY_PARTITION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_MEMORY_PARTITION_INFORMATION = _FILE_MEMORY_PARTITION_INFORMATION;
pub type PFILE_MEMORY_PARTITION_INFORMATION = *mut _FILE_MEMORY_PARTITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STAT_LX_INFORMATION {
   pub FileId: LARGE_INTEGER,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub ReparseTag: ULONG,
   pub NumberOfLinks: ULONG,
   pub EffectiveAccess: ACCESS_MASK,
   pub LxFlags: ULONG,
   pub LxUid: ULONG,
   pub LxGid: ULONG,
   pub LxMode: ULONG,
   pub LxDeviceIdMajor: ULONG,
   pub LxDeviceIdMinor: ULONG,
}
impl Default for _FILE_STAT_LX_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STAT_LX_INFORMATION = _FILE_STAT_LX_INFORMATION;
pub type PFILE_STAT_LX_INFORMATION = *mut _FILE_STAT_LX_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_RESERVE_ID_INFORMATION {
   pub StorageReserveId: STORAGE_RESERVE_ID,
}
impl Default for _FILE_STORAGE_RESERVE_ID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STORAGE_RESERVE_ID_INFORMATION = _FILE_STORAGE_RESERVE_ID_INFORMATION;
pub type PFILE_STORAGE_RESERVE_ID_INFORMATION = *mut _FILE_STORAGE_RESERVE_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_CASE_SENSITIVE_INFORMATION {
   pub Flags: ULONG,
}
pub type FILE_CASE_SENSITIVE_INFORMATION = _FILE_CASE_SENSITIVE_INFORMATION;
pub type PFILE_CASE_SENSITIVE_INFORMATION = *mut _FILE_CASE_SENSITIVE_INFORMATION;
impl _FILE_KNOWN_FOLDER_TYPE {
   pub const KnownFolderMax: _FILE_KNOWN_FOLDER_TYPE = _FILE_KNOWN_FOLDER_TYPE::KnownFolderOther;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_KNOWN_FOLDER_TYPE {
   KnownFolderNone = 0,
   KnownFolderDesktop = 1,
   KnownFolderDocuments = 2,
   KnownFolderDownloads = 3,
   KnownFolderMusic = 4,
   KnownFolderPictures = 5,
   KnownFolderVideos = 6,
   KnownFolderOther = 7,
}
pub use self::_FILE_KNOWN_FOLDER_TYPE as FILE_KNOWN_FOLDER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_KNOWN_FOLDER_INFORMATION {
   pub Type: FILE_KNOWN_FOLDER_TYPE,
}
impl Default for _FILE_KNOWN_FOLDER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_KNOWN_FOLDER_INFORMATION = _FILE_KNOWN_FOLDER_INFORMATION;
pub type PFILE_KNOWN_FOLDER_INFORMATION = *mut _FILE_KNOWN_FOLDER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_DIRECTORY_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_DIRECTORY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_DIRECTORY_INFORMATION = _FILE_DIRECTORY_INFORMATION;
pub type PFILE_DIRECTORY_INFORMATION = *mut _FILE_DIRECTORY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FULL_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_FULL_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FULL_DIR_INFORMATION = _FILE_FULL_DIR_INFORMATION;
pub type PFILE_FULL_DIR_INFORMATION = *mut _FILE_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_FULL_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub FileId: LARGE_INTEGER,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_FULL_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_FULL_DIR_INFORMATION = _FILE_ID_FULL_DIR_INFORMATION;
pub type PFILE_ID_FULL_DIR_INFORMATION = *mut _FILE_ID_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BOTH_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ShortNameLength: CCHAR,
   pub ShortName: [WCHAR; 12usize],
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_BOTH_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_BOTH_DIR_INFORMATION = _FILE_BOTH_DIR_INFORMATION;
pub type PFILE_BOTH_DIR_INFORMATION = *mut _FILE_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_BOTH_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ShortNameLength: CCHAR,
   pub ShortName: [WCHAR; 12usize],
   pub FileId: LARGE_INTEGER,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_BOTH_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_BOTH_DIR_INFORMATION = _FILE_ID_BOTH_DIR_INFORMATION;
pub type PFILE_ID_BOTH_DIR_INFORMATION = *mut _FILE_ID_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_NAMES_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type FILE_NAMES_INFORMATION = _FILE_NAMES_INFORMATION;
pub type PFILE_NAMES_INFORMATION = *mut _FILE_NAMES_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub FileId: LARGE_INTEGER,
   pub LockingTransactionId: GUID,
   pub TxInfoFlags: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_GLOBAL_TX_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_GLOBAL_TX_DIR_INFORMATION = _FILE_ID_GLOBAL_TX_DIR_INFORMATION;
pub type PFILE_ID_GLOBAL_TX_DIR_INFORMATION = *mut _FILE_ID_GLOBAL_TX_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION {
   pub FileReference: LONGLONG,
   pub ObjectId: [UCHAR; 16usize],
   pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_OBJECTID_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub ExtendedInfo: [UCHAR; 48usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub BirthVolumeId: [UCHAR; 16usize],
   pub BirthObjectId: [UCHAR; 16usize],
   pub DomainId: [UCHAR; 16usize],
}
impl Default for _FILE_OBJECTID_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_OBJECTID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_OBJECTID_INFORMATION = _FILE_OBJECTID_INFORMATION;
pub type PFILE_OBJECTID_INFORMATION = *mut _FILE_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_DIRECTORY_NEXT_INFORMATION {
   pub NextEntryOffset: ULONG,
}
pub type FILE_DIRECTORY_NEXT_INFORMATION = _FILE_DIRECTORY_NEXT_INFORMATION;
pub type PFILE_DIRECTORY_NEXT_INFORMATION = *mut _FILE_DIRECTORY_NEXT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FULL_EA_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub Flags: UCHAR,
   pub EaNameLength: UCHAR,
   pub EaValueLength: USHORT,
   pub EaName: [CHAR; 1usize],
}
pub type FILE_FULL_EA_INFORMATION = _FILE_FULL_EA_INFORMATION;
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_GET_EA_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub EaNameLength: UCHAR,
   pub EaName: [CHAR; 1usize],
}
pub type FILE_GET_EA_INFORMATION = _FILE_GET_EA_INFORMATION;
pub type PFILE_GET_EA_INFORMATION = *mut _FILE_GET_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_GET_QUOTA_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub SidLength: ULONG,
   pub Sid: SID,
}
pub type FILE_GET_QUOTA_INFORMATION = _FILE_GET_QUOTA_INFORMATION;
pub type PFILE_GET_QUOTA_INFORMATION = *mut _FILE_GET_QUOTA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_QUOTA_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub SidLength: ULONG,
   pub ChangeTime: LARGE_INTEGER,
   pub QuotaUsed: LARGE_INTEGER,
   pub QuotaThreshold: LARGE_INTEGER,
   pub QuotaLimit: LARGE_INTEGER,
   pub Sid: SID,
}
impl Default for _FILE_QUOTA_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_QUOTA_INFORMATION = _FILE_QUOTA_INFORMATION;
pub type PFILE_QUOTA_INFORMATION = *mut _FILE_QUOTA_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FSINFOCLASS {
   FileFsVolumeInformation = 1,
   FileFsLabelInformation = 2,
   FileFsSizeInformation = 3,
   FileFsDeviceInformation = 4,
   FileFsAttributeInformation = 5,
   FileFsControlInformation = 6,
   FileFsFullSizeInformation = 7,
   FileFsObjectIdInformation = 8,
   FileFsDriverPathInformation = 9,
   FileFsVolumeFlagsInformation = 10,
   FileFsSectorSizeInformation = 11,
   FileFsDataCopyInformation = 12,
   FileFsMetadataSizeInformation = 13,
   FileFsFullSizeInformationEx = 14,
   FileFsGuidInformation = 15,
   FileFsMaximumInformation = 16,
}
pub use self::_FSINFOCLASS as FSINFOCLASS;
pub type PFSINFOCLASS = *mut _FSINFOCLASS;
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
#[repr(C)]
pub struct _FILE_FS_VOLUME_INFORMATION {
   pub VolumeCreationTime: LARGE_INTEGER,
   pub VolumeSerialNumber: ULONG,
   pub VolumeLabelLength: ULONG,
   pub SupportsObjects: BOOLEAN,
   pub VolumeLabel: [WCHAR; 1usize],
}
impl Default for _FILE_FS_VOLUME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_VOLUME_INFORMATION = _FILE_FS_VOLUME_INFORMATION;
pub type PFILE_FS_VOLUME_INFORMATION = *mut _FILE_FS_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_LABEL_INFORMATION {
   pub VolumeLabelLength: ULONG,
   pub VolumeLabel: [WCHAR; 1usize],
}
pub type FILE_FS_LABEL_INFORMATION = _FILE_FS_LABEL_INFORMATION;
pub type PFILE_FS_LABEL_INFORMATION = *mut _FILE_FS_LABEL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_SIZE_INFORMATION {
   pub TotalAllocationUnits: LARGE_INTEGER,
   pub AvailableAllocationUnits: LARGE_INTEGER,
   pub SectorsPerAllocationUnit: ULONG,
   pub BytesPerSector: ULONG,
}
impl Default for _FILE_FS_SIZE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_SIZE_INFORMATION = _FILE_FS_SIZE_INFORMATION;
pub type PFILE_FS_SIZE_INFORMATION = *mut _FILE_FS_SIZE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_CONTROL_INFORMATION {
   pub FreeSpaceStartFiltering: LARGE_INTEGER,
   pub FreeSpaceThreshold: LARGE_INTEGER,
   pub FreeSpaceStopFiltering: LARGE_INTEGER,
   pub DefaultQuotaThreshold: LARGE_INTEGER,
   pub DefaultQuotaLimit: LARGE_INTEGER,
   pub FileSystemControlFlags: ULONG,
}
impl Default for _FILE_FS_CONTROL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_CONTROL_INFORMATION = _FILE_FS_CONTROL_INFORMATION;
pub type PFILE_FS_CONTROL_INFORMATION = *mut _FILE_FS_CONTROL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION {
   pub TotalAllocationUnits: LARGE_INTEGER,
   pub CallerAvailableAllocationUnits: LARGE_INTEGER,
   pub ActualAvailableAllocationUnits: LARGE_INTEGER,
   pub SectorsPerAllocationUnit: ULONG,
   pub BytesPerSector: ULONG,
}
impl Default for _FILE_FS_FULL_SIZE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_FULL_SIZE_INFORMATION = _FILE_FS_FULL_SIZE_INFORMATION;
pub type PFILE_FS_FULL_SIZE_INFORMATION = *mut _FILE_FS_FULL_SIZE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_OBJECTID_INFORMATION {
   pub ObjectId: [UCHAR; 16usize],
   pub __bindgen_anon_1: _FILE_FS_OBJECTID_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_FS_OBJECTID_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _FILE_FS_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub ExtendedInfo: [UCHAR; 48usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub BirthVolumeId: [UCHAR; 16usize],
   pub BirthObjectId: [UCHAR; 16usize],
   pub DomainId: [UCHAR; 16usize],
}
impl Default for _FILE_FS_OBJECTID_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_FS_OBJECTID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_OBJECTID_INFORMATION = _FILE_FS_OBJECTID_INFORMATION;
pub type PFILE_FS_OBJECTID_INFORMATION = *mut _FILE_FS_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_DEVICE_INFORMATION {
   pub DeviceType: DWORD,
   pub Characteristics: ULONG,
}
pub type FILE_FS_DEVICE_INFORMATION = _FILE_FS_DEVICE_INFORMATION;
pub type PFILE_FS_DEVICE_INFORMATION = *mut _FILE_FS_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_ATTRIBUTE_INFORMATION {
   pub FileSystemAttributes: ULONG,
   pub MaximumComponentNameLength: LONG,
   pub FileSystemNameLength: ULONG,
   pub FileSystemName: [WCHAR; 1usize],
}
pub type FILE_FS_ATTRIBUTE_INFORMATION = _FILE_FS_ATTRIBUTE_INFORMATION;
pub type PFILE_FS_ATTRIBUTE_INFORMATION = *mut _FILE_FS_ATTRIBUTE_INFORMATION;
#[repr(C)]
pub struct _FILE_FS_DRIVER_PATH_INFORMATION {
   pub DriverInPath: BOOLEAN,
   pub DriverNameLength: ULONG,
   pub DriverName: [WCHAR; 1usize],
}
impl Default for _FILE_FS_DRIVER_PATH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_DRIVER_PATH_INFORMATION = _FILE_FS_DRIVER_PATH_INFORMATION;
pub type PFILE_FS_DRIVER_PATH_INFORMATION = *mut _FILE_FS_DRIVER_PATH_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_VOLUME_FLAGS_INFORMATION {
   pub Flags: ULONG,
}
pub type FILE_FS_VOLUME_FLAGS_INFORMATION = _FILE_FS_VOLUME_FLAGS_INFORMATION;
pub type PFILE_FS_VOLUME_FLAGS_INFORMATION = *mut _FILE_FS_VOLUME_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_SECTOR_SIZE_INFORMATION {
   pub LogicalBytesPerSector: ULONG,
   pub PhysicalBytesPerSectorForAtomicity: ULONG,
   pub PhysicalBytesPerSectorForPerformance: ULONG,
   pub FileSystemEffectivePhysicalBytesPerSectorForAtomicity: ULONG,
   pub Flags: ULONG,
   pub ByteOffsetForSectorAlignment: ULONG,
   pub ByteOffsetForPartitionAlignment: ULONG,
}
pub type FILE_FS_SECTOR_SIZE_INFORMATION = _FILE_FS_SECTOR_SIZE_INFORMATION;
pub type PFILE_FS_SECTOR_SIZE_INFORMATION = *mut _FILE_FS_SECTOR_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_DATA_COPY_INFORMATION {
   pub NumberOfCopies: ULONG,
}
pub type FILE_FS_DATA_COPY_INFORMATION = _FILE_FS_DATA_COPY_INFORMATION;
pub type PFILE_FS_DATA_COPY_INFORMATION = *mut _FILE_FS_DATA_COPY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_METADATA_SIZE_INFORMATION {
   pub TotalMetadataAllocationUnits: LARGE_INTEGER,
   pub SectorsPerAllocationUnit: ULONG,
   pub BytesPerSector: ULONG,
}
impl Default for _FILE_FS_METADATA_SIZE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_METADATA_SIZE_INFORMATION = _FILE_FS_METADATA_SIZE_INFORMATION;
pub type PFILE_FS_METADATA_SIZE_INFORMATION = *mut _FILE_FS_METADATA_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION_EX {
   pub ActualTotalAllocationUnits: ULONGLONG,
   pub ActualAvailableAllocationUnits: ULONGLONG,
   pub ActualPoolUnavailableAllocationUnits: ULONGLONG,
   pub CallerTotalAllocationUnits: ULONGLONG,
   pub CallerAvailableAllocationUnits: ULONGLONG,
   pub CallerPoolUnavailableAllocationUnits: ULONGLONG,
   pub UsedAllocationUnits: ULONGLONG,
   pub TotalReservedAllocationUnits: ULONGLONG,
   pub VolumeStorageReserveAllocationUnits: ULONGLONG,
   pub AvailableCommittedAllocationUnits: ULONGLONG,
   pub PoolAvailableAllocationUnits: ULONGLONG,
   pub SectorsPerAllocationUnit: ULONG,
   pub BytesPerSector: ULONG,
}
pub type FILE_FS_FULL_SIZE_INFORMATION_EX = _FILE_FS_FULL_SIZE_INFORMATION_EX;
pub type PFILE_FS_FULL_SIZE_INFORMATION_EX = *mut _FILE_FS_FULL_SIZE_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_GUID_INFORMATION {
   pub FsGuid: GUID,
}
pub type FILE_FS_GUID_INFORMATION = _FILE_FS_GUID_INFORMATION;
pub type PFILE_FS_GUID_INFORMATION = *mut _FILE_FS_GUID_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DIRECTORY_NOTIFY_INFORMATION_CLASS {
   DirectoryNotifyInformation = 1,
   DirectoryNotifyExtendedInformation = 2,
   DirectoryNotifyFullInformation = 3,
   DirectoryNotifyMaximumInformation = 4,
}
pub use self::_DIRECTORY_NOTIFY_INFORMATION_CLASS as DIRECTORY_NOTIFY_INFORMATION_CLASS;
pub type PDIRECTORY_NOTIFY_INFORMATION_CLASS = *mut _DIRECTORY_NOTIFY_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_COMPLETION_INFORMATION_CLASS {
   IoCompletionBasicInformation = 0,
}
pub use self::_IO_COMPLETION_INFORMATION_CLASS as IO_COMPLETION_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_COMPLETION_BASIC_INFORMATION {
   pub Depth: LONG,
}
pub type IO_COMPLETION_BASIC_INFORMATION = _IO_COMPLETION_BASIC_INFORMATION;
pub type PIO_COMPLETION_BASIC_INFORMATION = *mut _IO_COMPLETION_BASIC_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_SESSION_EVENT {
   IoSessionEventIgnore = 0,
   IoSessionEventCreated = 1,
   IoSessionEventTerminated = 2,
   IoSessionEventConnected = 3,
   IoSessionEventDisconnected = 4,
   IoSessionEventLogon = 5,
   IoSessionEventLogoff = 6,
   IoSessionEventMax = 7,
}
pub use self::_IO_SESSION_EVENT as IO_SESSION_EVENT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_SESSION_STATE {
   IoSessionStateCreated = 1,
   IoSessionStateInitialized = 2,
   IoSessionStateConnected = 3,
   IoSessionStateDisconnected = 4,
   IoSessionStateDisconnectedLoggedOn = 5,
   IoSessionStateLoggedOn = 6,
   IoSessionStateLoggedOff = 7,
   IoSessionStateTerminated = 8,
   IoSessionStateMax = 9,
}
pub use self::_IO_SESSION_STATE as IO_SESSION_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _INTERFACE_TYPE {
   InterfaceTypeUndefined = -1,
   Internal = 0,
   Isa = 1,
   Eisa = 2,
   MicroChannel = 3,
   TurboChannel = 4,
   PCIBus = 5,
   VMEBus = 6,
   NuBus = 7,
   PCMCIABus = 8,
   CBus = 9,
   MPIBus = 10,
   MPSABus = 11,
   ProcessorInternal = 12,
   InternalPowerBus = 13,
   PNPISABus = 14,
   PNPBus = 15,
   Vmcs = 16,
   ACPIBus = 17,
   MaximumInterfaceType = 18,
}
pub use self::_INTERFACE_TYPE as INTERFACE_TYPE;
pub type PINTERFACE_TYPE = *mut _INTERFACE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DMA_WIDTH {
   Width8Bits = 0,
   Width16Bits = 1,
   Width32Bits = 2,
   Width64Bits = 3,
   WidthNoWrap = 4,
   MaximumDmaWidth = 5,
}
pub use self::_DMA_WIDTH as DMA_WIDTH;
pub type PDMA_WIDTH = *mut _DMA_WIDTH;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DMA_SPEED {
   Compatible = 0,
   TypeA = 1,
   TypeB = 2,
   TypeC = 3,
   TypeF = 4,
   MaximumDmaSpeed = 5,
}
pub use self::_DMA_SPEED as DMA_SPEED;
pub type PDMA_SPEED = *mut _DMA_SPEED;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BUS_DATA_TYPE {
   ConfigurationSpaceUndefined = -1,
   Cmos = 0,
   EisaConfiguration = 1,
   Pos = 2,
   CbusConfiguration = 3,
   PCIConfiguration = 4,
   VMEConfiguration = 5,
   NuBusConfiguration = 6,
   PCMCIAConfiguration = 7,
   MPIConfiguration = 8,
   MPSAConfiguration = 9,
   PNPISAConfiguration = 10,
   SgiInternalConfiguration = 11,
   MaximumBusDataType = 12,
}
pub use self::_BUS_DATA_TYPE as BUS_DATA_TYPE;
pub type PBUS_DATA_TYPE = *mut _BUS_DATA_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER {
   pub ReparseTag: ULONG,
   pub ReparseDataLength: USHORT,
   pub Reserved: USHORT,
   pub __bindgen_anon_1: _REPARSE_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _REPARSE_DATA_BUFFER__bindgen_ty_1 {
   pub SymbolicLinkReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1,
   pub MountPointReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2,
   pub AppExecLinkReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3,
   pub GenericReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1 {
   pub SubstituteNameOffset: USHORT,
   pub SubstituteNameLength: USHORT,
   pub PrintNameOffset: USHORT,
   pub PrintNameLength: USHORT,
   pub Flags: ULONG,
   pub PathBuffer: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2 {
   pub SubstituteNameOffset: USHORT,
   pub SubstituteNameLength: USHORT,
   pub PrintNameOffset: USHORT,
   pub PrintNameLength: USHORT,
   pub PathBuffer: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3 {
   pub StringCount: ULONG,
   pub StringList: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4 {
   pub DataBuffer: [UCHAR; 1usize],
}
impl Default for _REPARSE_DATA_BUFFER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _REPARSE_DATA_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type REPARSE_DATA_BUFFER = _REPARSE_DATA_BUFFER;
pub type PREPARSE_DATA_BUFFER = *mut _REPARSE_DATA_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER_EX {
   pub Flags: ULONG,
   pub ExistingReparseTag: ULONG,
   pub ExistingReparseGuid: GUID,
   pub Reserved: ULONGLONG,
   pub __bindgen_anon_1: _REPARSE_DATA_BUFFER_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _REPARSE_DATA_BUFFER_EX__bindgen_ty_1 {
   pub ReparseDataBuffer: REPARSE_DATA_BUFFER,
   pub ReparseGuidDataBuffer: REPARSE_GUID_DATA_BUFFER,
}
impl Default for _REPARSE_DATA_BUFFER_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _REPARSE_DATA_BUFFER_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type REPARSE_DATA_BUFFER_EX = _REPARSE_DATA_BUFFER_EX;
pub type PREPARSE_DATA_BUFFER_EX = *mut _REPARSE_DATA_BUFFER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_ASSIGN_EVENT_BUFFER {
   pub EventHandle: HANDLE,
   pub KeyValue: ULONG,
}
impl Default for _FILE_PIPE_ASSIGN_EVENT_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_ASSIGN_EVENT_BUFFER = _FILE_PIPE_ASSIGN_EVENT_BUFFER;
pub type PFILE_PIPE_ASSIGN_EVENT_BUFFER = *mut _FILE_PIPE_ASSIGN_EVENT_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_PEEK_BUFFER {
   pub NamedPipeState: ULONG,
   pub ReadDataAvailable: ULONG,
   pub NumberOfMessages: ULONG,
   pub MessageLength: ULONG,
   pub Data: [CHAR; 1usize],
}
pub type FILE_PIPE_PEEK_BUFFER = _FILE_PIPE_PEEK_BUFFER;
pub type PFILE_PIPE_PEEK_BUFFER = *mut _FILE_PIPE_PEEK_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_EVENT_BUFFER {
   pub NamedPipeState: ULONG,
   pub EntryType: ULONG,
   pub ByteCount: ULONG,
   pub KeyValue: ULONG,
   pub NumberRequests: ULONG,
}
pub type FILE_PIPE_EVENT_BUFFER = _FILE_PIPE_EVENT_BUFFER;
pub type PFILE_PIPE_EVENT_BUFFER = *mut _FILE_PIPE_EVENT_BUFFER;
#[repr(C)]
pub struct _FILE_PIPE_WAIT_FOR_BUFFER {
   pub Timeout: LARGE_INTEGER,
   pub NameLength: ULONG,
   pub TimeoutSpecified: BOOLEAN,
   pub Name: [WCHAR; 1usize],
}
impl Default for _FILE_PIPE_WAIT_FOR_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_WAIT_FOR_BUFFER = _FILE_PIPE_WAIT_FOR_BUFFER;
pub type PFILE_PIPE_WAIT_FOR_BUFFER = *mut _FILE_PIPE_WAIT_FOR_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_CLIENT_PROCESS_BUFFER {
   pub ClientSession: PVOID,
   pub ClientProcess: PVOID,
}
impl Default for _FILE_PIPE_CLIENT_PROCESS_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_CLIENT_PROCESS_BUFFER = _FILE_PIPE_CLIENT_PROCESS_BUFFER;
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER = *mut _FILE_PIPE_CLIENT_PROCESS_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
   pub ClientSession: ULONGLONG,
   pub ClientProcess: PVOID,
}
impl Default for _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 = _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2;
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER_V2 = *mut _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
   pub ClientSession: PVOID,
   pub ClientProcess: PVOID,
   pub ClientComputerNameLength: USHORT,
   pub ClientComputerBuffer: [WCHAR; 16usize],
}
impl Default for _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_CLIENT_PROCESS_BUFFER_EX = _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX;
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX = *mut _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_SILO_ARRIVAL_INPUT {
   pub JobHandle: HANDLE,
}
impl Default for _FILE_PIPE_SILO_ARRIVAL_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_SILO_ARRIVAL_INPUT = _FILE_PIPE_SILO_ARRIVAL_INPUT;
pub type PFILE_PIPE_SILO_ARRIVAL_INPUT = *mut _FILE_PIPE_SILO_ARRIVAL_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_CREATE_SYMLINK_INPUT {
   pub NameOffset: USHORT,
   pub NameLength: USHORT,
   pub SubstituteNameOffset: USHORT,
   pub SubstituteNameLength: USHORT,
   pub Flags: ULONG,
}
pub type FILE_PIPE_CREATE_SYMLINK_INPUT = _FILE_PIPE_CREATE_SYMLINK_INPUT;
pub type PFILE_PIPE_CREATE_SYMLINK_INPUT = *mut _FILE_PIPE_CREATE_SYMLINK_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_DELETE_SYMLINK_INPUT {
   pub NameOffset: USHORT,
   pub NameLength: USHORT,
}
pub type FILE_PIPE_DELETE_SYMLINK_INPUT = _FILE_PIPE_DELETE_SYMLINK_INPUT;
pub type PFILE_PIPE_DELETE_SYMLINK_INPUT = *mut _FILE_PIPE_DELETE_SYMLINK_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_MAILSLOT_PEEK_BUFFER {
   pub ReadDataAvailable: ULONG,
   pub NumberOfMessages: ULONG,
   pub MessageLength: ULONG,
}
pub type FILE_MAILSLOT_PEEK_BUFFER = _FILE_MAILSLOT_PEEK_BUFFER;
pub type PFILE_MAILSLOT_PEEK_BUFFER = *mut _FILE_MAILSLOT_PEEK_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_CREATE_POINT_INPUT {
   pub SymbolicLinkNameOffset: USHORT,
   pub SymbolicLinkNameLength: USHORT,
   pub DeviceNameOffset: USHORT,
   pub DeviceNameLength: USHORT,
}
pub type MOUNTMGR_CREATE_POINT_INPUT = _MOUNTMGR_CREATE_POINT_INPUT;
pub type PMOUNTMGR_CREATE_POINT_INPUT = *mut _MOUNTMGR_CREATE_POINT_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_MOUNT_POINT {
   pub SymbolicLinkNameOffset: ULONG,
   pub SymbolicLinkNameLength: USHORT,
   pub Reserved1: USHORT,
   pub UniqueIdOffset: ULONG,
   pub UniqueIdLength: USHORT,
   pub Reserved2: USHORT,
   pub DeviceNameOffset: ULONG,
   pub DeviceNameLength: USHORT,
   pub Reserved3: USHORT,
}
pub type MOUNTMGR_MOUNT_POINT = _MOUNTMGR_MOUNT_POINT;
pub type PMOUNTMGR_MOUNT_POINT = *mut _MOUNTMGR_MOUNT_POINT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_MOUNT_POINTS {
   pub Size: ULONG,
   pub NumberOfMountPoints: ULONG,
   pub MountPoints: [MOUNTMGR_MOUNT_POINT; 1usize],
}
pub type MOUNTMGR_MOUNT_POINTS = _MOUNTMGR_MOUNT_POINTS;
pub type PMOUNTMGR_MOUNT_POINTS = *mut _MOUNTMGR_MOUNT_POINTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_DRIVE_LETTER_TARGET {
   pub DeviceNameLength: USHORT,
   pub DeviceName: [WCHAR; 1usize],
}
pub type MOUNTMGR_DRIVE_LETTER_TARGET = _MOUNTMGR_DRIVE_LETTER_TARGET;
pub type PMOUNTMGR_DRIVE_LETTER_TARGET = *mut _MOUNTMGR_DRIVE_LETTER_TARGET;
#[repr(C)]
pub struct _MOUNTMGR_DRIVE_LETTER_INFORMATION {
   pub DriveLetterWasAssigned: BOOLEAN,
   pub CurrentDriveLetter: UCHAR,
}
impl Default for _MOUNTMGR_DRIVE_LETTER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MOUNTMGR_DRIVE_LETTER_INFORMATION = _MOUNTMGR_DRIVE_LETTER_INFORMATION;
pub type PMOUNTMGR_DRIVE_LETTER_INFORMATION = *mut _MOUNTMGR_DRIVE_LETTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_VOLUME_MOUNT_POINT {
   pub SourceVolumeNameOffset: USHORT,
   pub SourceVolumeNameLength: USHORT,
   pub TargetVolumeNameOffset: USHORT,
   pub TargetVolumeNameLength: USHORT,
}
pub type MOUNTMGR_VOLUME_MOUNT_POINT = _MOUNTMGR_VOLUME_MOUNT_POINT;
pub type PMOUNTMGR_VOLUME_MOUNT_POINT = *mut _MOUNTMGR_VOLUME_MOUNT_POINT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_CHANGE_NOTIFY_INFO {
   pub EpicNumber: ULONG,
}
pub type MOUNTMGR_CHANGE_NOTIFY_INFO = _MOUNTMGR_CHANGE_NOTIFY_INFO;
pub type PMOUNTMGR_CHANGE_NOTIFY_INFO = *mut _MOUNTMGR_CHANGE_NOTIFY_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_TARGET_NAME {
   pub DeviceNameLength: USHORT,
   pub DeviceName: [WCHAR; 1usize],
}
pub type MOUNTMGR_TARGET_NAME = _MOUNTMGR_TARGET_NAME;
pub type PMOUNTMGR_TARGET_NAME = *mut _MOUNTMGR_TARGET_NAME;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MOUNTMGR_AUTO_MOUNT_STATE {
   Disabled = 0,
   Enabled = 1,
}
pub use self::_MOUNTMGR_AUTO_MOUNT_STATE as MOUNTMGR_AUTO_MOUNT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOUNTMGR_QUERY_AUTO_MOUNT {
   pub CurrentState: MOUNTMGR_AUTO_MOUNT_STATE,
}
impl Default for _MOUNTMGR_QUERY_AUTO_MOUNT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MOUNTMGR_QUERY_AUTO_MOUNT = _MOUNTMGR_QUERY_AUTO_MOUNT;
pub type PMOUNTMGR_QUERY_AUTO_MOUNT = *mut _MOUNTMGR_QUERY_AUTO_MOUNT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOUNTMGR_SET_AUTO_MOUNT {
   pub NewState: MOUNTMGR_AUTO_MOUNT_STATE,
}
impl Default for _MOUNTMGR_SET_AUTO_MOUNT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MOUNTMGR_SET_AUTO_MOUNT = _MOUNTMGR_SET_AUTO_MOUNT;
pub type PMOUNTMGR_SET_AUTO_MOUNT = *mut _MOUNTMGR_SET_AUTO_MOUNT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOUNTMGR_SILO_ARRIVAL_INPUT {
   pub JobHandle: HANDLE,
}
impl Default for _MOUNTMGR_SILO_ARRIVAL_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MOUNTMGR_SILO_ARRIVAL_INPUT = _MOUNTMGR_SILO_ARRIVAL_INPUT;
pub type PMOUNTMGR_SILO_ARRIVAL_INPUT = *mut _MOUNTMGR_SILO_ARRIVAL_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTDEV_NAME {
   pub NameLength: USHORT,
   pub Name: [WCHAR; 1usize],
}
pub type MOUNTDEV_NAME = _MOUNTDEV_NAME;
pub type PMOUNTDEV_NAME = *mut _MOUNTDEV_NAME;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_VOLUME_PATHS {
   pub MultiSzLength: ULONG,
   pub MultiSz: [WCHAR; 1usize],
}
pub type MOUNTMGR_VOLUME_PATHS = _MOUNTMGR_VOLUME_PATHS;
pub type PMOUNTMGR_VOLUME_PATHS = *mut _MOUNTMGR_VOLUME_PATHS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FS_FILTER_SECTION_SYNC_TYPE {
   SyncTypeOther = 0,
   SyncTypeCreateSection = 1,
}
pub use self::_FS_FILTER_SECTION_SYNC_TYPE as FS_FILTER_SECTION_SYNC_TYPE;
pub type PFS_FILTER_SECTION_SYNC_TYPE = *mut _FS_FILTER_SECTION_SYNC_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CREATE_FILE_TYPE {
   CreateFileTypeNone = 0,
   CreateFileTypeNamedPipe = 1,
   CreateFileTypeMailslot = 2,
}
pub use self::_CREATE_FILE_TYPE as CREATE_FILE_TYPE;
#[repr(C)]
pub struct _NAMED_PIPE_CREATE_PARAMETERS {
   pub NamedPipeType: ULONG,
   pub ReadMode: ULONG,
   pub CompletionMode: ULONG,
   pub MaximumInstances: ULONG,
   pub InboundQuota: ULONG,
   pub OutboundQuota: ULONG,
   pub DefaultTimeout: LARGE_INTEGER,
   pub TimeoutSpecified: BOOLEAN,
}
impl Default for _NAMED_PIPE_CREATE_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type NAMED_PIPE_CREATE_PARAMETERS = _NAMED_PIPE_CREATE_PARAMETERS;
pub type PNAMED_PIPE_CREATE_PARAMETERS = *mut _NAMED_PIPE_CREATE_PARAMETERS;
#[repr(C)]
pub struct _MAILSLOT_CREATE_PARAMETERS {
   pub MailslotQuota: ULONG,
   pub MaximumMessageSize: ULONG,
   pub ReadTimeout: LARGE_INTEGER,
   pub TimeoutSpecified: BOOLEAN,
}
impl Default for _MAILSLOT_CREATE_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MAILSLOT_CREATE_PARAMETERS = _MAILSLOT_CREATE_PARAMETERS;
pub type PMAILSLOT_CREATE_PARAMETERS = *mut _MAILSLOT_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OPLOCK_KEY_ECP_CONTEXT {
   pub OplockKey: GUID,
   pub Reserved: ULONG,
}
pub type OPLOCK_KEY_ECP_CONTEXT = _OPLOCK_KEY_ECP_CONTEXT;
pub type POPLOCK_KEY_ECP_CONTEXT = *mut _OPLOCK_KEY_ECP_CONTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OPLOCK_KEY_CONTEXT {
   pub Version: USHORT,
   pub Flags: USHORT,
   pub ParentOplockKey: GUID,
   pub TargetOplockKey: GUID,
   pub Reserved: ULONG,
}
pub type OPLOCK_KEY_CONTEXT = _OPLOCK_KEY_CONTEXT;
pub type POPLOCK_KEY_CONTEXT = *mut _OPLOCK_KEY_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PORT_MESSAGE {
   pub u1: _PORT_MESSAGE__bindgen_ty_1,
   pub u2: _PORT_MESSAGE__bindgen_ty_2,
   pub __bindgen_anon_1: _PORT_MESSAGE__bindgen_ty_3,
   pub MessageId: ULONG,
   pub __bindgen_anon_2: _PORT_MESSAGE__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_1 {
   pub s1: _PORT_MESSAGE__bindgen_ty_1__bindgen_ty_1,
   pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
   pub DataLength: CSHORT,
   pub TotalLength: CSHORT,
}
impl Default for _PORT_MESSAGE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_2 {
   pub s2: _PORT_MESSAGE__bindgen_ty_2__bindgen_ty_1,
   pub ZeroInit: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_MESSAGE__bindgen_ty_2__bindgen_ty_1 {
   pub Type: CSHORT,
   pub DataInfoOffset: CSHORT,
}
impl Default for _PORT_MESSAGE__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_3 {
   pub ClientId: CLIENT_ID,
   pub DoNotUseThisField: f64,
}
impl Default for _PORT_MESSAGE__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_4 {
   pub ClientViewSize: SIZE_T,
   pub CallbackId: ULONG,
}
impl Default for _PORT_MESSAGE__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PORT_MESSAGE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PORT_MESSAGE = _PORT_MESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_DATA_ENTRY {
   pub Base: PVOID,
   pub Size: ULONG,
}
impl Default for _PORT_DATA_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PORT_DATA_ENTRY = _PORT_DATA_ENTRY;
pub type PPORT_DATA_ENTRY = *mut _PORT_DATA_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_DATA_INFORMATION {
   pub CountDataEntries: ULONG,
   pub DataEntries: [PORT_DATA_ENTRY; 1usize],
}
impl Default for _PORT_DATA_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PORT_DATA_INFORMATION = _PORT_DATA_INFORMATION;
pub type PPORT_DATA_INFORMATION = *mut _PORT_DATA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LPC_CLIENT_DIED_MSG {
   pub PortMsg: PORT_MESSAGE,
   pub CreateTime: LARGE_INTEGER,
}
impl Default for _LPC_CLIENT_DIED_MSG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LPC_CLIENT_DIED_MSG = _LPC_CLIENT_DIED_MSG;
pub type PLPC_CLIENT_DIED_MSG = *mut _LPC_CLIENT_DIED_MSG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_VIEW {
   pub Length: ULONG,
   pub SectionHandle: HANDLE,
   pub SectionOffset: ULONG,
   pub ViewSize: SIZE_T,
   pub ViewBase: PVOID,
   pub ViewRemoteBase: PVOID,
}
impl Default for _PORT_VIEW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PORT_VIEW = _PORT_VIEW;
pub type PPORT_VIEW = *mut _PORT_VIEW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REMOTE_PORT_VIEW {
   pub Length: ULONG,
   pub ViewSize: SIZE_T,
   pub ViewBase: PVOID,
}
impl Default for _REMOTE_PORT_VIEW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type REMOTE_PORT_VIEW = _REMOTE_PORT_VIEW;
pub type PREMOTE_PORT_VIEW = *mut _REMOTE_PORT_VIEW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PORT_MESSAGE64 {
   pub u1: _PORT_MESSAGE64__bindgen_ty_1,
   pub u2: _PORT_MESSAGE64__bindgen_ty_2,
   pub __bindgen_anon_1: _PORT_MESSAGE64__bindgen_ty_3,
   pub MessageId: ULONG,
   pub __bindgen_anon_2: _PORT_MESSAGE64__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE64__bindgen_ty_1 {
   pub s1: _PORT_MESSAGE64__bindgen_ty_1__bindgen_ty_1,
   pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_MESSAGE64__bindgen_ty_1__bindgen_ty_1 {
   pub DataLength: CSHORT,
   pub TotalLength: CSHORT,
}
impl Default for _PORT_MESSAGE64__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE64__bindgen_ty_2 {
   pub s2: _PORT_MESSAGE64__bindgen_ty_2__bindgen_ty_1,
   pub ZeroInit: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_MESSAGE64__bindgen_ty_2__bindgen_ty_1 {
   pub Type: CSHORT,
   pub DataInfoOffset: CSHORT,
}
impl Default for _PORT_MESSAGE64__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE64__bindgen_ty_3 {
   pub ClientId: CLIENT_ID64,
   pub DoNotUseThisField: f64,
}
impl Default for _PORT_MESSAGE64__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE64__bindgen_ty_4 {
   pub ClientViewSize: ULONGLONG,
   pub CallbackId: ULONG,
}
impl Default for _PORT_MESSAGE64__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PORT_MESSAGE64 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PORT_MESSAGE64 = _PORT_MESSAGE64;
pub type PPORT_MESSAGE64 = *mut _PORT_MESSAGE64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LPC_CLIENT_DIED_MSG64 {
   pub PortMsg: PORT_MESSAGE64,
   pub CreateTime: LARGE_INTEGER,
}
impl Default for _LPC_CLIENT_DIED_MSG64 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LPC_CLIENT_DIED_MSG64 = _LPC_CLIENT_DIED_MSG64;
pub type PLPC_CLIENT_DIED_MSG64 = *mut _LPC_CLIENT_DIED_MSG64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_VIEW64 {
   pub Length: ULONG,
   pub SectionHandle: ULONGLONG,
   pub SectionOffset: ULONG,
   pub ViewSize: ULONGLONG,
   pub ViewBase: ULONGLONG,
   pub ViewRemoteBase: ULONGLONG,
}
pub type PORT_VIEW64 = _PORT_VIEW64;
pub type PPORT_VIEW64 = *mut _PORT_VIEW64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REMOTE_PORT_VIEW64 {
   pub Length: ULONG,
   pub ViewSize: ULONGLONG,
   pub ViewBase: ULONGLONG,
}
pub type REMOTE_PORT_VIEW64 = _REMOTE_PORT_VIEW64;
pub type PREMOTE_PORT_VIEW64 = *mut _REMOTE_PORT_VIEW64;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PORT_INFORMATION_CLASS {
   PortBasicInformation = 0,
   PortDumpInformation = 1,
}
pub use self::_PORT_INFORMATION_CLASS as PORT_INFORMATION_CLASS;
pub type ALPC_HANDLE = HANDLE;
pub type PALPC_HANDLE = *mut HANDLE;
#[repr(C)]
pub struct _ALPC_PORT_ATTRIBUTES {
   pub Flags: ULONG,
   pub SecurityQos: SECURITY_QUALITY_OF_SERVICE,
   pub MaxMessageLength: SIZE_T,
   pub MemoryBandwidth: SIZE_T,
   pub MaxPoolUsage: SIZE_T,
   pub MaxSectionSize: SIZE_T,
   pub MaxViewSize: SIZE_T,
   pub MaxTotalSectionSize: SIZE_T,
   pub DupObjectTypes: ULONG,
   pub Reserved: ULONG,
}
impl Default for _ALPC_PORT_ATTRIBUTES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_PORT_ATTRIBUTES = _ALPC_PORT_ATTRIBUTES;
pub type PALPC_PORT_ATTRIBUTES = *mut _ALPC_PORT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_MESSAGE_ATTRIBUTES {
   pub AllocatedAttributes: ULONG,
   pub ValidAttributes: ULONG,
}
pub type ALPC_MESSAGE_ATTRIBUTES = _ALPC_MESSAGE_ATTRIBUTES;
pub type PALPC_MESSAGE_ATTRIBUTES = *mut _ALPC_MESSAGE_ATTRIBUTES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_STATE {
   pub u1: _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1 {
   pub s1: _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1,
   pub Value: ULONG64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Head(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u64) }
   }
   #[inline]
   pub fn set_Head(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn Tail(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u64) }
   }
   #[inline]
   pub fn set_Tail(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub fn ActiveThreadCount(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
   }
   #[inline]
   pub fn set_ActiveThreadCount(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(48usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Head: ULONG64,
      Tail: ULONG64,
      ActiveThreadCount: ULONG64,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 24u8, {
         let Head: u64 = unsafe { ::core::mem::transmute(Head) };
         Head as u64
      });
      __bindgen_bitfield_unit.set(24usize, 24u8, {
         let Tail: u64 = unsafe { ::core::mem::transmute(Tail) };
         Tail as u64
      });
      __bindgen_bitfield_unit.set(48usize, 16u8, {
         let ActiveThreadCount: u64 = unsafe { ::core::mem::transmute(ActiveThreadCount) };
         ActiveThreadCount as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ALPC_COMPLETION_LIST_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_COMPLETION_LIST_STATE = _ALPC_COMPLETION_LIST_STATE;
pub type PALPC_COMPLETION_LIST_STATE = *mut _ALPC_COMPLETION_LIST_STATE;
#[repr(C)]
#[repr(align(128))]
#[derive(Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_HEADER {
   pub StartMagic: ULONG64,
   pub TotalSize: ULONG,
   pub ListOffset: ULONG,
   pub ListSize: ULONG,
   pub BitmapOffset: ULONG,
   pub BitmapSize: ULONG,
   pub DataOffset: ULONG,
   pub DataSize: ULONG,
   pub AttributeFlags: ULONG,
   pub AttributeSize: ULONG,
   pub __bindgen_padding_0: [u64; 10usize],
   pub State: ALPC_COMPLETION_LIST_STATE,
   pub LastMessageId: ULONG,
   pub LastCallbackId: ULONG,
   pub __bindgen_padding_1: [u32; 28usize],
   pub PostCount: ULONG,
   pub __bindgen_padding_2: [u32; 31usize],
   pub ReturnCount: ULONG,
   pub __bindgen_padding_3: [u32; 31usize],
   pub LogSequenceNumber: ULONG,
   pub __bindgen_padding_4: [u64; 15usize],
   pub UserLock: RTL_SRWLOCK,
   pub EndMagic: ULONG64,
}
impl Default for _ALPC_COMPLETION_LIST_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_COMPLETION_LIST_HEADER = _ALPC_COMPLETION_LIST_HEADER;
pub type PALPC_COMPLETION_LIST_HEADER = *mut _ALPC_COMPLETION_LIST_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_CONTEXT_ATTR {
   pub PortContext: PVOID,
   pub MessageContext: PVOID,
   pub Sequence: ULONG,
   pub MessageId: ULONG,
   pub CallbackId: ULONG,
}
impl Default for _ALPC_CONTEXT_ATTR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_CONTEXT_ATTR = _ALPC_CONTEXT_ATTR;
pub type PALPC_CONTEXT_ATTR = *mut _ALPC_CONTEXT_ATTR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_HANDLE_ATTR32 {
   pub Flags: ULONG,
   pub Reserved0: ULONG,
   pub SameAccess: ULONG,
   pub SameAttributes: ULONG,
   pub Indirect: ULONG,
   pub Inherit: ULONG,
   pub Reserved1: ULONG,
   pub Handle: ULONG,
   pub ObjectType: ULONG,
   pub DesiredAccess: ULONG,
   pub GrantedAccess: ULONG,
}
pub type ALPC_HANDLE_ATTR32 = _ALPC_HANDLE_ATTR32;
pub type PALPC_HANDLE_ATTR32 = *mut _ALPC_HANDLE_ATTR32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_HANDLE_ATTR {
   pub Flags: ULONG,
   pub Reserved0: ULONG,
   pub SameAccess: ULONG,
   pub SameAttributes: ULONG,
   pub Indirect: ULONG,
   pub Inherit: ULONG,
   pub Reserved1: ULONG,
   pub Handle: HANDLE,
   pub HandleAttrArray: PALPC_HANDLE_ATTR32,
   pub ObjectType: ULONG,
   pub HandleCount: ULONG,
   pub DesiredAccess: ACCESS_MASK,
   pub GrantedAccess: ACCESS_MASK,
}
impl Default for _ALPC_HANDLE_ATTR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_HANDLE_ATTR = _ALPC_HANDLE_ATTR;
pub type PALPC_HANDLE_ATTR = *mut _ALPC_HANDLE_ATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_SECURITY_ATTR {
   pub Flags: ULONG,
   pub QoS: PSECURITY_QUALITY_OF_SERVICE,
   pub ContextHandle: ALPC_HANDLE,
}
impl Default for _ALPC_SECURITY_ATTR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_SECURITY_ATTR = _ALPC_SECURITY_ATTR;
pub type PALPC_SECURITY_ATTR = *mut _ALPC_SECURITY_ATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_DATA_VIEW_ATTR {
   pub Flags: ULONG,
   pub SectionHandle: ALPC_HANDLE,
   pub ViewBase: PVOID,
   pub ViewSize: SIZE_T,
}
impl Default for _ALPC_DATA_VIEW_ATTR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_DATA_VIEW_ATTR = _ALPC_DATA_VIEW_ATTR;
pub type PALPC_DATA_VIEW_ATTR = *mut _ALPC_DATA_VIEW_ATTR;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ALPC_PORT_INFORMATION_CLASS {
   AlpcBasicInformation = 0,
   AlpcPortInformation = 1,
   AlpcAssociateCompletionPortInformation = 2,
   AlpcConnectedSIDInformation = 3,
   AlpcServerInformation = 4,
   AlpcMessageZoneInformation = 5,
   AlpcRegisterCompletionListInformation = 6,
   AlpcUnregisterCompletionListInformation = 7,
   AlpcAdjustCompletionListConcurrencyCountInformation = 8,
   AlpcRegisterCallbackInformation = 9,
   AlpcCompletionListRundownInformation = 10,
   AlpcWaitForPortReferences = 11,
   AlpcServerSessionInformation = 12,
}
pub use self::_ALPC_PORT_INFORMATION_CLASS as ALPC_PORT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_BASIC_INFORMATION {
   pub Flags: ULONG,
   pub SequenceNo: ULONG,
   pub PortContext: PVOID,
}
impl Default for _ALPC_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_BASIC_INFORMATION = _ALPC_BASIC_INFORMATION;
pub type PALPC_BASIC_INFORMATION = *mut _ALPC_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_PORT_ASSOCIATE_COMPLETION_PORT {
   pub CompletionKey: PVOID,
   pub CompletionPort: HANDLE,
}
impl Default for _ALPC_PORT_ASSOCIATE_COMPLETION_PORT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_PORT_ASSOCIATE_COMPLETION_PORT = _ALPC_PORT_ASSOCIATE_COMPLETION_PORT;
pub type PALPC_PORT_ASSOCIATE_COMPLETION_PORT = *mut _ALPC_PORT_ASSOCIATE_COMPLETION_PORT;
#[repr(C)]
pub struct _ALPC_SERVER_INFORMATION {
   pub __bindgen_anon_1: _ALPC_SERVER_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
pub union _ALPC_SERVER_INFORMATION__bindgen_ty_1 {
   pub In: ::core::mem::ManuallyDrop<_ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_1>,
   pub Out: ::core::mem::ManuallyDrop<_ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_2>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub ThreadHandle: HANDLE,
}
impl Default for _ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
pub struct _ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
   pub ThreadBlocked: BOOLEAN,
   pub ConnectedProcessId: HANDLE,
   pub ConnectionPortName: UNICODE_STRING,
}
impl Default for _ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ALPC_SERVER_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ALPC_SERVER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_SERVER_INFORMATION = _ALPC_SERVER_INFORMATION;
pub type PALPC_SERVER_INFORMATION = *mut _ALPC_SERVER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_PORT_MESSAGE_ZONE_INFORMATION {
   pub Buffer: PVOID,
   pub Size: ULONG,
}
impl Default for _ALPC_PORT_MESSAGE_ZONE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_PORT_MESSAGE_ZONE_INFORMATION = _ALPC_PORT_MESSAGE_ZONE_INFORMATION;
pub type PALPC_PORT_MESSAGE_ZONE_INFORMATION = *mut _ALPC_PORT_MESSAGE_ZONE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_PORT_COMPLETION_LIST_INFORMATION {
   pub Buffer: PVOID,
   pub Size: ULONG,
   pub ConcurrencyCount: ULONG,
   pub AttributeFlags: ULONG,
}
impl Default for _ALPC_PORT_COMPLETION_LIST_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_PORT_COMPLETION_LIST_INFORMATION = _ALPC_PORT_COMPLETION_LIST_INFORMATION;
pub type PALPC_PORT_COMPLETION_LIST_INFORMATION = *mut _ALPC_PORT_COMPLETION_LIST_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_REGISTER_CALLBACK {
   pub CallbackObject: PVOID,
   pub CallbackContext: PVOID,
}
impl Default for _ALPC_REGISTER_CALLBACK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_REGISTER_CALLBACK = _ALPC_REGISTER_CALLBACK;
pub type PALPC_REGISTER_CALLBACK = *mut _ALPC_REGISTER_CALLBACK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_SERVER_SESSION_INFORMATION {
   pub SessionId: ULONG,
   pub ProcessId: ULONG,
}
pub type ALPC_SERVER_SESSION_INFORMATION = _ALPC_SERVER_SESSION_INFORMATION;
pub type PALPC_SERVER_SESSION_INFORMATION = *mut _ALPC_SERVER_SESSION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ALPC_MESSAGE_INFORMATION_CLASS {
   AlpcMessageSidInformation = 0,
   AlpcMessageTokenModifiedIdInformation = 1,
   AlpcMessageDirectStatusInformation = 2,
   AlpcMessageHandleInformation = 3,
   MaxAlpcMessageInfoClass = 4,
}
pub use self::_ALPC_MESSAGE_INFORMATION_CLASS as ALPC_MESSAGE_INFORMATION_CLASS;
pub type PALPC_MESSAGE_INFORMATION_CLASS = *mut _ALPC_MESSAGE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_MESSAGE_HANDLE_INFORMATION {
   pub Index: ULONG,
   pub Flags: ULONG,
   pub Handle: ULONG,
   pub ObjectType: ULONG,
   pub GrantedAccess: ACCESS_MASK,
}
pub type ALPC_MESSAGE_HANDLE_INFORMATION = _ALPC_MESSAGE_HANDLE_INFORMATION;
pub type PALPC_MESSAGE_HANDLE_INFORMATION = *mut _ALPC_MESSAGE_HANDLE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_BOOT_PHASE_ID {
   PfKernelInitPhase = 0,
   PfBootDriverInitPhase = 90,
   PfSystemDriverInitPhase = 120,
   PfSessionManagerInitPhase = 150,
   PfSMRegistryInitPhase = 180,
   PfVideoInitPhase = 210,
   PfPostVideoInitPhase = 240,
   PfBootAcceptedRegistryInitPhase = 270,
   PfUserShellReadyPhase = 300,
   PfMaxBootPhaseId = 900,
}
pub use self::_PF_BOOT_PHASE_ID as PF_BOOT_PHASE_ID;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_ENABLE_STATUS {
   PfSvNotSpecified = 0,
   PfSvEnabled = 1,
   PfSvDisabled = 2,
   PfSvMaxEnableStatus = 3,
}
pub use self::_PF_ENABLE_STATUS as PF_ENABLE_STATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_TRACE_LIMITS {
   pub MaxNumPages: ULONG,
   pub MaxNumSections: ULONG,
   pub TimerPeriod: LONGLONG,
}
pub type PF_TRACE_LIMITS = _PF_TRACE_LIMITS;
pub type PPF_TRACE_LIMITS = *mut _PF_TRACE_LIMITS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_SYSTEM_PREFETCH_PARAMETERS {
   pub EnableStatus: [PF_ENABLE_STATUS; 2usize],
   pub TraceLimits: [PF_TRACE_LIMITS; 2usize],
   pub MaxNumActiveTraces: ULONG,
   pub MaxNumSavedTraces: ULONG,
   pub RootDirPath: [WCHAR; 32usize],
   pub HostingApplicationList: [WCHAR; 128usize],
}
impl Default for _PF_SYSTEM_PREFETCH_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_SYSTEM_PREFETCH_PARAMETERS = _PF_SYSTEM_PREFETCH_PARAMETERS;
pub type PPF_SYSTEM_PREFETCH_PARAMETERS = *mut _PF_SYSTEM_PREFETCH_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_BOOT_CONTROL {
   pub Version: ULONG,
   pub DisableBootPrefetching: ULONG,
}
pub type PF_BOOT_CONTROL = _PF_BOOT_CONTROL;
pub type PPF_BOOT_CONTROL = *mut _PF_BOOT_CONTROL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PREFETCHER_INFORMATION_CLASS {
   PrefetcherRetrieveTrace = 1,
   PrefetcherSystemParameters = 2,
   PrefetcherBootPhase = 3,
   PrefetcherSpare1 = 4,
   PrefetcherBootControl = 5,
   PrefetcherScenarioPolicyControl = 6,
   PrefetcherSpare2 = 7,
   PrefetcherAppLaunchScenarioControl = 8,
   PrefetcherInformationMax = 9,
}
pub use self::_PREFETCHER_INFORMATION_CLASS as PREFETCHER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PREFETCHER_INFORMATION {
   pub Version: ULONG,
   pub Magic: ULONG,
   pub PrefetcherInformationClass: PREFETCHER_INFORMATION_CLASS,
   pub PrefetcherInformation: PVOID,
   pub PrefetcherInformationLength: ULONG,
}
impl Default for _PREFETCHER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PREFETCHER_INFORMATION = _PREFETCHER_INFORMATION;
pub type PPREFETCHER_INFORMATION = *mut _PREFETCHER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_SYSTEM_SUPERFETCH_PARAMETERS {
   pub EnabledComponents: ULONG,
   pub BootID: ULONG,
   pub SavedSectInfoTracesMax: ULONG,
   pub SavedPageAccessTracesMax: ULONG,
   pub ScenarioPrefetchTimeoutStandby: ULONG,
   pub ScenarioPrefetchTimeoutHibernate: ULONG,
   pub ScenarioPrefetchTimeoutHiberBoot: ULONG,
}
pub type PF_SYSTEM_SUPERFETCH_PARAMETERS = _PF_SYSTEM_SUPERFETCH_PARAMETERS;
pub type PPF_SYSTEM_SUPERFETCH_PARAMETERS = *mut _PF_SYSTEM_SUPERFETCH_PARAMETERS;
impl _PF_EVENT_TYPE {
   pub const PfEventTypeUtilization: _PF_EVENT_TYPE = _PF_EVENT_TYPE::PfEventTypeUnmap;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_EVENT_TYPE {
   PfEventTypeImageLoad = 0,
   PfEventTypeAppLaunch = 1,
   PfEventTypeStartTrace = 2,
   PfEventTypeEndTrace = 3,
   PfEventTypeTimestamp = 4,
   PfEventTypeOperation = 5,
   PfEventTypeRepurpose = 6,
   PfEventTypeForegroundProcess = 7,
   PfEventTypeTimeRange = 8,
   PfEventTypeUserInput = 9,
   PfEventTypeFileAccess = 10,
   PfEventTypeUnmap = 11,
   PfEventTypeMemInfo = 12,
   PfEventTypeFileDelete = 13,
   PfEventTypeAppExit = 14,
   PfEventTypeSystemTime = 15,
   PfEventTypePower = 16,
   PfEventTypeSessionChange = 17,
   PfEventTypeHardFaultTimeStamp = 18,
   PfEventTypeVirtualFree = 19,
   PfEventTypePerfInfo = 20,
   PfEventTypeProcessSnapshot = 21,
   PfEventTypeUserSnapshot = 22,
   PfEventTypeStreamSequenceNumber = 23,
   PfEventTypeFileTruncate = 24,
   PfEventTypeFileRename = 25,
   PfEventTypeFileCreate = 26,
   PfEventTypeAgCxContext = 27,
   PfEventTypePowerAction = 28,
   PfEventTypeHardFaultTS = 29,
   PfEventTypeRobustInfo = 30,
   PfEventTypeFileDefrag = 31,
   PfEventTypeMax = 32,
}
pub use self::_PF_EVENT_TYPE as PF_EVENT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_LOG_EVENT_DATA {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub EventData: PVOID,
}
impl Default for _PF_LOG_EVENT_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PF_LOG_EVENT_DATA {
   #[inline]
   pub fn EventType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
   }
   #[inline]
   pub fn set_EventType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub fn Flags(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_Flags(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn DataSize(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
   }
   #[inline]
   pub fn set_DataSize(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 25u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EventType: ULONG,
      Flags: ULONG,
      DataSize: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 5u8, {
         let EventType: u32 = unsafe { ::core::mem::transmute(EventType) };
         EventType as u64
      });
      __bindgen_bitfield_unit.set(5usize, 2u8, {
         let Flags: u32 = unsafe { ::core::mem::transmute(Flags) };
         Flags as u64
      });
      __bindgen_bitfield_unit.set(7usize, 25u8, {
         let DataSize: u32 = unsafe { ::core::mem::transmute(DataSize) };
         DataSize as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PF_LOG_EVENT_DATA = _PF_LOG_EVENT_DATA;
pub type PPF_LOG_EVENT_DATA = *mut _PF_LOG_EVENT_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_PFN_PRIO_REQUEST {
   pub Version: ULONG,
   pub RequestFlags: ULONG,
   pub PfnCount: ULONG_PTR,
   pub MemInfo: SYSTEM_MEMORY_LIST_INFORMATION,
   pub PageData: [MMPFN_IDENTITY; 256usize],
}
impl Default for _PF_PFN_PRIO_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_PFN_PRIO_REQUEST = _PF_PFN_PRIO_REQUEST;
pub type PPF_PFN_PRIO_REQUEST = *mut _PF_PFN_PRIO_REQUEST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PFS_PRIVATE_PAGE_SOURCE_TYPE {
   PfsPrivateSourceKernel = 0,
   PfsPrivateSourceSession = 1,
   PfsPrivateSourceProcess = 2,
   PfsPrivateSourceMax = 3,
}
pub use self::_PFS_PRIVATE_PAGE_SOURCE_TYPE as PFS_PRIVATE_PAGE_SOURCE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PFS_PRIVATE_PAGE_SOURCE {
   pub Type: PFS_PRIVATE_PAGE_SOURCE_TYPE,
   pub __bindgen_anon_1: _PFS_PRIVATE_PAGE_SOURCE__bindgen_ty_1,
   pub ImagePathHash: ULONG,
   pub UniqueProcessHash: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PFS_PRIVATE_PAGE_SOURCE__bindgen_ty_1 {
   pub SessionId: ULONG,
   pub ProcessId: ULONG,
}
impl Default for _PFS_PRIVATE_PAGE_SOURCE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PFS_PRIVATE_PAGE_SOURCE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PFS_PRIVATE_PAGE_SOURCE = _PFS_PRIVATE_PAGE_SOURCE;
pub type PPFS_PRIVATE_PAGE_SOURCE = *mut _PFS_PRIVATE_PAGE_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_PRIVSOURCE_INFO {
   pub DbInfo: PFS_PRIVATE_PAGE_SOURCE,
   pub EProcess: PVOID,
   pub WsPrivatePages: SIZE_T,
   pub TotalPrivatePages: SIZE_T,
   pub SessionID: ULONG,
   pub ImageName: [CHAR; 16usize],
   pub __bindgen_anon_1: _PF_PRIVSOURCE_INFO__bindgen_ty_1,
   pub WsTotalPages: ULONG_PTR,
   pub DeepFreezeTimeMs: ULONG,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PF_PRIVSOURCE_INFO__bindgen_ty_1 {
   pub WsSwapPages: ULONG_PTR,
   pub SessionPagedPoolPages: ULONG_PTR,
   pub StoreSizePages: ULONG_PTR,
}
impl Default for _PF_PRIVSOURCE_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PF_PRIVSOURCE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PF_PRIVSOURCE_INFO {
   #[inline]
   pub fn ModernApp(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ModernApp(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DeepFrozen(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DeepFrozen(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Foreground(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Foreground(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn PerProcessStore(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PerProcessStore(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ModernApp: ULONG,
      DeepFrozen: ULONG,
      Foreground: ULONG,
      PerProcessStore: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ModernApp: u32 = unsafe { ::core::mem::transmute(ModernApp) };
         ModernApp as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let DeepFrozen: u32 = unsafe { ::core::mem::transmute(DeepFrozen) };
         DeepFrozen as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let Foreground: u32 = unsafe { ::core::mem::transmute(Foreground) };
         Foreground as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let PerProcessStore: u32 = unsafe { ::core::mem::transmute(PerProcessStore) };
         PerProcessStore as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PF_PRIVSOURCE_INFO = _PF_PRIVSOURCE_INFO;
pub type PPF_PRIVSOURCE_INFO = *mut _PF_PRIVSOURCE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_PRIVSOURCE_QUERY_REQUEST {
   pub Version: ULONG,
   pub Flags: ULONG,
   pub InfoCount: ULONG,
   pub InfoArray: [PF_PRIVSOURCE_INFO; 1usize],
}
impl Default for _PF_PRIVSOURCE_QUERY_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_PRIVSOURCE_QUERY_REQUEST = _PF_PRIVSOURCE_QUERY_REQUEST;
pub type PPF_PRIVSOURCE_QUERY_REQUEST = *mut _PF_PRIVSOURCE_QUERY_REQUEST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_PHASED_SCENARIO_TYPE {
   PfScenarioTypeNone = 0,
   PfScenarioTypeStandby = 1,
   PfScenarioTypeHibernate = 2,
   PfScenarioTypeFUS = 3,
   PfScenarioTypeMax = 4,
}
pub use self::_PF_PHASED_SCENARIO_TYPE as PF_PHASED_SCENARIO_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_SCENARIO_PHASE_INFO {
   pub Version: ULONG,
   pub ScenType: PF_PHASED_SCENARIO_TYPE,
   pub PhaseId: ULONG,
   pub SequenceNumber: ULONG,
   pub Flags: ULONG,
   pub FUSUserId: ULONG,
}
impl Default for _PF_SCENARIO_PHASE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_SCENARIO_PHASE_INFO = _PF_SCENARIO_PHASE_INFO;
pub type PPF_SCENARIO_PHASE_INFO = *mut _PF_SCENARIO_PHASE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_MEMORY_LIST_NODE {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
   pub StandbyLowPageCount: ULONGLONG,
   pub StandbyMediumPageCount: ULONGLONG,
   pub StandbyHighPageCount: ULONGLONG,
   pub FreePageCount: ULONGLONG,
   pub ModifiedPageCount: ULONGLONG,
}
impl _PF_MEMORY_LIST_NODE {
   #[inline]
   pub fn Node(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
   }
   #[inline]
   pub fn set_Node(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 56u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Node: ULONGLONG, Spare: ULONGLONG) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Node: u64 = unsafe { ::core::mem::transmute(Node) };
         Node as u64
      });
      __bindgen_bitfield_unit.set(8usize, 56u8, {
         let Spare: u64 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PF_MEMORY_LIST_NODE = _PF_MEMORY_LIST_NODE;
pub type PPF_MEMORY_LIST_NODE = *mut _PF_MEMORY_LIST_NODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_ROBUST_PROCESS_ENTRY {
   pub ImagePathHash: ULONG,
   pub Pid: ULONG,
   pub Alignment: ULONG,
}
pub type PF_ROBUST_PROCESS_ENTRY = _PF_ROBUST_PROCESS_ENTRY;
pub type PPF_ROBUST_PROCESS_ENTRY = *mut _PF_ROBUST_PROCESS_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_ROBUST_FILE_ENTRY {
   pub FilePathHash: ULONG,
}
pub type PF_ROBUST_FILE_ENTRY = _PF_ROBUST_FILE_ENTRY;
pub type PPF_ROBUST_FILE_ENTRY = *mut _PF_ROBUST_FILE_ENTRY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_ROBUSTNESS_CONTROL_COMMAND {
   PfRpControlUpdate = 0,
   PfRpControlReset = 1,
   PfRpControlRobustAllStart = 2,
   PfRpControlRobustAllStop = 3,
   PfRpControlCommandMax = 4,
}
pub use self::_PF_ROBUSTNESS_CONTROL_COMMAND as PF_ROBUSTNESS_CONTROL_COMMAND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_ROBUSTNESS_CONTROL {
   pub Version: ULONG,
   pub Command: PF_ROBUSTNESS_CONTROL_COMMAND,
   pub DeprioProcessCount: ULONG,
   pub ExemptProcessCount: ULONG,
   pub DeprioFileCount: ULONG,
   pub ExemptFileCount: ULONG,
   pub ProcessEntries: [PF_ROBUST_PROCESS_ENTRY; 1usize],
   pub FileEntries: [PF_ROBUST_FILE_ENTRY; 1usize],
}
impl Default for _PF_ROBUSTNESS_CONTROL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_ROBUSTNESS_CONTROL = _PF_ROBUSTNESS_CONTROL;
pub type PPF_ROBUSTNESS_CONTROL = *mut _PF_ROBUSTNESS_CONTROL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_TIME_CONTROL {
   pub TimeAdjustment: LONG,
}
pub type PF_TIME_CONTROL = _PF_TIME_CONTROL;
pub type PPF_TIME_CONTROL = *mut _PF_TIME_CONTROL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_MEMORY_LIST_INFO {
   pub Version: ULONG,
   pub Size: ULONG,
   pub NodeCount: ULONG,
   pub Nodes: [PF_MEMORY_LIST_NODE; 1usize],
}
pub type PF_MEMORY_LIST_INFO = _PF_MEMORY_LIST_INFO;
pub type PPF_MEMORY_LIST_INFO = *mut _PF_MEMORY_LIST_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_PHYSICAL_MEMORY_RANGE {
   pub BasePfn: ULONG_PTR,
   pub PageCount: ULONG_PTR,
}
pub type PF_PHYSICAL_MEMORY_RANGE = _PF_PHYSICAL_MEMORY_RANGE;
pub type PPF_PHYSICAL_MEMORY_RANGE = *mut _PF_PHYSICAL_MEMORY_RANGE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_PHYSICAL_MEMORY_RANGE_INFO_V1 {
   pub Version: ULONG,
   pub RangeCount: ULONG,
   pub Ranges: [PF_PHYSICAL_MEMORY_RANGE; 1usize],
}
pub type PF_PHYSICAL_MEMORY_RANGE_INFO_V1 = _PF_PHYSICAL_MEMORY_RANGE_INFO_V1;
pub type PPF_PHYSICAL_MEMORY_RANGE_INFO_V1 = *mut _PF_PHYSICAL_MEMORY_RANGE_INFO_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_PHYSICAL_MEMORY_RANGE_INFO_V2 {
   pub Version: ULONG,
   pub Flags: ULONG,
   pub RangeCount: ULONG,
   pub Ranges: [PF_PHYSICAL_MEMORY_RANGE; 1usize],
}
pub type PF_PHYSICAL_MEMORY_RANGE_INFO_V2 = _PF_PHYSICAL_MEMORY_RANGE_INFO_V2;
pub type PPF_PHYSICAL_MEMORY_RANGE_INFO_V2 = *mut _PF_PHYSICAL_MEMORY_RANGE_INFO_V2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_REPURPOSED_BY_PREFETCH_INFO {
   pub Version: ULONG,
   pub RepurposedByPrefetch: SIZE_T,
}
pub type PF_REPURPOSED_BY_PREFETCH_INFO = _PF_REPURPOSED_BY_PREFETCH_INFO;
pub type PPF_REPURPOSED_BY_PREFETCH_INFO = *mut _PF_REPURPOSED_BY_PREFETCH_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_VIRTUAL_QUERY {
   pub Version: ULONG,
   pub __bindgen_anon_1: _PF_VIRTUAL_QUERY__bindgen_ty_1,
   pub QueryBuffer: PVOID,
   pub QueryBufferSize: SIZE_T,
   pub ProcessHandle: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PF_VIRTUAL_QUERY__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PF_VIRTUAL_QUERY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_VIRTUAL_QUERY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PF_VIRTUAL_QUERY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn FaultInPageTables(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FaultInPageTables(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReportPageTables(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReportPageTables(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      FaultInPageTables: ULONG,
      ReportPageTables: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let FaultInPageTables: u32 = unsafe { ::core::mem::transmute(FaultInPageTables) };
         FaultInPageTables as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ReportPageTables: u32 = unsafe { ::core::mem::transmute(ReportPageTables) };
         ReportPageTables as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PF_VIRTUAL_QUERY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PF_VIRTUAL_QUERY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_VIRTUAL_QUERY = _PF_VIRTUAL_QUERY;
pub type PPF_VIRTUAL_QUERY = *mut _PF_VIRTUAL_QUERY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_MIN_WS_AGE_RATE_CONTROL {
   pub Version: ULONG,
   pub SecondsToOldestAge: ULONG,
}
pub type PF_MIN_WS_AGE_RATE_CONTROL = _PF_MIN_WS_AGE_RATE_CONTROL;
pub type PPF_MIN_WS_AGE_RATE_CONTROL = *mut _PF_MIN_WS_AGE_RATE_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_DEPRIORITIZE_OLD_PAGES {
   pub Version: ULONG,
   pub ProcessHandle: HANDLE,
   pub __bindgen_anon_1: _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn TargetPriority(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_TargetPriority(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn TrimPages(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_TrimPages(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 26u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      TargetPriority: ULONG,
      TrimPages: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let TargetPriority: u32 = unsafe { ::core::mem::transmute(TargetPriority) };
         TargetPriority as u64
      });
      __bindgen_bitfield_unit.set(4usize, 2u8, {
         let TrimPages: u32 = unsafe { ::core::mem::transmute(TrimPages) };
         TrimPages as u64
      });
      __bindgen_bitfield_unit.set(6usize, 26u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PF_DEPRIORITIZE_OLD_PAGES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_DEPRIORITIZE_OLD_PAGES = _PF_DEPRIORITIZE_OLD_PAGES;
pub type PPF_DEPRIORITIZE_OLD_PAGES = *mut _PF_DEPRIORITIZE_OLD_PAGES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_GPU_UTILIZATION_INFO {
   pub Version: ULONG,
   pub SessionId: ULONG,
   pub GpuTime: ULONGLONG,
}
pub type PF_GPU_UTILIZATION_INFO = _PF_GPU_UTILIZATION_INFO;
pub type PPF_GPU_UTILIZATION_INFO = *mut _PF_GPU_UTILIZATION_INFO;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SUPERFETCH_INFORMATION_CLASS {
   SuperfetchRetrieveTrace = 1,
   SuperfetchSystemParameters = 2,
   SuperfetchLogEvent = 3,
   SuperfetchGenerateTrace = 4,
   SuperfetchPrefetch = 5,
   SuperfetchPfnQuery = 6,
   SuperfetchPfnSetPriority = 7,
   SuperfetchPrivSourceQuery = 8,
   SuperfetchSequenceNumberQuery = 9,
   SuperfetchScenarioPhase = 10,
   SuperfetchWorkerPriority = 11,
   SuperfetchScenarioQuery = 12,
   SuperfetchScenarioPrefetch = 13,
   SuperfetchRobustnessControl = 14,
   SuperfetchTimeControl = 15,
   SuperfetchMemoryListQuery = 16,
   SuperfetchMemoryRangesQuery = 17,
   SuperfetchTracingControl = 18,
   SuperfetchTrimWhileAgingControl = 19,
   SuperfetchRepurposedByPrefetch = 20,
   SuperfetchChannelPowerRequest = 21,
   SuperfetchMovePages = 22,
   SuperfetchVirtualQuery = 23,
   SuperfetchCombineStatsQuery = 24,
   SuperfetchSetMinWsAgeRate = 25,
   SuperfetchDeprioritizeOldPagesInWs = 26,
   SuperfetchFileExtentsQuery = 27,
   SuperfetchGpuUtilizationQuery = 28,
   SuperfetchPfnSet = 29,
   SuperfetchInformationMax = 30,
}
pub use self::_SUPERFETCH_INFORMATION_CLASS as SUPERFETCH_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SUPERFETCH_INFORMATION {
   pub Version: ULONG,
   pub Magic: ULONG,
   pub SuperfetchInformationClass: SUPERFETCH_INFORMATION_CLASS,
   pub SuperfetchInformation: PVOID,
   pub SuperfetchInformationLength: ULONG,
}
impl Default for _SUPERFETCH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SUPERFETCH_INFORMATION = _SUPERFETCH_INFORMATION;
pub type PSUPERFETCH_INFORMATION = *mut _SUPERFETCH_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PLUGPLAY_EVENT_CATEGORY {
   HardwareProfileChangeEvent = 0,
   TargetDeviceChangeEvent = 1,
   DeviceClassChangeEvent = 2,
   CustomDeviceEvent = 3,
   DeviceInstallEvent = 4,
   DeviceArrivalEvent = 5,
   PowerEvent = 6,
   VetoEvent = 7,
   BlockedDriverEvent = 8,
   InvalidIDEvent = 9,
   MaxPlugEventCategory = 10,
}
pub use self::_PLUGPLAY_EVENT_CATEGORY as PLUGPLAY_EVENT_CATEGORY;
pub type PPLUGPLAY_EVENT_CATEGORY = *mut _PLUGPLAY_EVENT_CATEGORY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK {
   pub EventGuid: GUID,
   pub EventCategory: PLUGPLAY_EVENT_CATEGORY,
   pub Result: PULONG,
   pub Flags: ULONG,
   pub TotalSize: ULONG,
   pub DeviceObject: PVOID,
   pub u: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1 {
   pub DeviceClass: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_1,
   pub TargetDevice: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_2,
   pub InstallDevice: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_3,
   pub CustomNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4,
   pub ProfileNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5,
   pub PowerNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_6,
   pub VetoNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7,
   pub BlockedDriverNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_8,
   pub InvalidIDNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_9,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
   pub ClassGuid: GUID,
   pub SymbolicLinkName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_2 {
   pub DeviceIds: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_3 {
   pub DeviceId: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4 {
   pub NotificationStructure: PVOID,
   pub DeviceIds: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5 {
   pub Notification: PVOID,
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_6 {
   pub NotificationCode: ULONG,
   pub NotificationData: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7 {
   pub VetoType: PNP_VETO_TYPE,
   pub DeviceIdVetoNameBuffer: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_8 {
   pub BlockedDriverGuid: GUID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_9 {
   pub ParentId: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PLUGPLAY_EVENT_BLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PLUGPLAY_EVENT_BLOCK = _PLUGPLAY_EVENT_BLOCK;
pub type PPLUGPLAY_EVENT_BLOCK = *mut _PLUGPLAY_EVENT_BLOCK;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PLUGPLAY_CONTROL_CLASS {
   PlugPlayControlEnumerateDevice = 0,
   PlugPlayControlRegisterNewDevice = 1,
   PlugPlayControlDeregisterDevice = 2,
   PlugPlayControlInitializeDevice = 3,
   PlugPlayControlStartDevice = 4,
   PlugPlayControlUnlockDevice = 5,
   PlugPlayControlQueryAndRemoveDevice = 6,
   PlugPlayControlUserResponse = 7,
   PlugPlayControlGenerateLegacyDevice = 8,
   PlugPlayControlGetInterfaceDeviceList = 9,
   PlugPlayControlProperty = 10,
   PlugPlayControlDeviceClassAssociation = 11,
   PlugPlayControlGetRelatedDevice = 12,
   PlugPlayControlGetInterfaceDeviceAlias = 13,
   PlugPlayControlDeviceStatus = 14,
   PlugPlayControlGetDeviceDepth = 15,
   PlugPlayControlQueryDeviceRelations = 16,
   PlugPlayControlTargetDeviceRelation = 17,
   PlugPlayControlQueryConflictList = 18,
   PlugPlayControlRetrieveDock = 19,
   PlugPlayControlResetDevice = 20,
   PlugPlayControlHaltDevice = 21,
   PlugPlayControlGetBlockedDriverList = 22,
   PlugPlayControlGetDeviceInterfaceEnabled = 23,
   MaxPlugPlayControl = 24,
}
pub use self::_PLUGPLAY_CONTROL_CLASS as PLUGPLAY_CONTROL_CLASS;
pub type PPLUGPLAY_CONTROL_CLASS = *mut _PLUGPLAY_CONTROL_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_RELATION_TYPE {
   BusRelations = 0,
   EjectionRelations = 1,
   PowerRelations = 2,
   RemovalRelations = 3,
   TargetDeviceRelation = 4,
   SingleBusRelations = 5,
   TransportRelations = 6,
}
pub use self::_DEVICE_RELATION_TYPE as DEVICE_RELATION_TYPE;
pub type PDEVICE_RELATION_TYPE = *mut _DEVICE_RELATION_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BUS_QUERY_ID_TYPE {
   BusQueryDeviceID = 0,
   BusQueryHardwareIDs = 1,
   BusQueryCompatibleIDs = 2,
   BusQueryInstanceID = 3,
   BusQueryDeviceSerialNumber = 4,
   BusQueryContainerID = 5,
}
pub use self::_BUS_QUERY_ID_TYPE as BUS_QUERY_ID_TYPE;
pub type PBUS_QUERY_ID_TYPE = *mut _BUS_QUERY_ID_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_TEXT_TYPE {
   DeviceTextDescription = 0,
   DeviceTextLocationInformation = 1,
}
pub use self::_DEVICE_TEXT_TYPE as DEVICE_TEXT_TYPE;
pub type PDEVICE_TEXT_TYPE = *mut _DEVICE_TEXT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_USAGE_NOTIFICATION_TYPE {
   DeviceUsageTypeUndefined = 0,
   DeviceUsageTypePaging = 1,
   DeviceUsageTypeHibernation = 2,
   DeviceUsageTypeDumpFile = 3,
   DeviceUsageTypeBoot = 4,
   DeviceUsageTypePostDisplay = 5,
   DeviceUsageTypeGuestAssigned = 6,
}
pub use self::_DEVICE_USAGE_NOTIFICATION_TYPE as DEVICE_USAGE_NOTIFICATION_TYPE;
pub type PDEVICE_USAGE_NOTIFICATION_TYPE = *mut _DEVICE_USAGE_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_POWER_INFORMATION {
   pub Number: ULONG,
   pub MaxMhz: ULONG,
   pub CurrentMhz: ULONG,
   pub MhzLimit: ULONG,
   pub MaxIdleState: ULONG,
   pub CurrentIdleState: ULONG,
}
pub type PROCESSOR_POWER_INFORMATION = _PROCESSOR_POWER_INFORMATION;
pub type PPROCESSOR_POWER_INFORMATION = *mut _PROCESSOR_POWER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POWER_INFORMATION {
   pub MaxIdlenessAllowed: ULONG,
   pub Idleness: ULONG,
   pub TimeRemaining: ULONG,
   pub CoolingMode: UCHAR,
}
pub type SYSTEM_POWER_INFORMATION = _SYSTEM_POWER_INFORMATION;
pub type PSYSTEM_POWER_INFORMATION = *mut _SYSTEM_POWER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_HIBERFILE_INFORMATION {
   pub NumberOfMcbPairs: ULONG,
   pub Mcb: [LARGE_INTEGER; 1usize],
}
impl Default for _SYSTEM_HIBERFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HIBERFILE_INFORMATION = _SYSTEM_HIBERFILE_INFORMATION;
pub type PSYSTEM_HIBERFILE_INFORMATION = *mut _SYSTEM_HIBERFILE_INFORMATION;
#[repr(C)]
pub struct _COUNTED_REASON_CONTEXT {
   pub Version: ULONG,
   pub Flags: ULONG,
   pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
pub union _COUNTED_REASON_CONTEXT__bindgen_ty_1 {
   pub __bindgen_anon_1:
      ::core::mem::ManuallyDrop<_COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>,
   pub SimpleString: ::core::mem::ManuallyDrop<UNICODE_STRING>,
}
#[repr(C)]
pub struct _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   pub ResourceFileName: UNICODE_STRING,
   pub ResourceReasonId: USHORT,
   pub StringCount: ULONG,
   pub ReasonStrings: PUNICODE_STRING,
}
impl Default for _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _COUNTED_REASON_CONTEXT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _COUNTED_REASON_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COUNTED_REASON_CONTEXT = _COUNTED_REASON_CONTEXT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_REQUEST_TYPE_INTERNAL {
   PowerRequestDisplayRequiredInternal = 0,
   PowerRequestSystemRequiredInternal = 1,
   PowerRequestAwayModeRequiredInternal = 2,
   PowerRequestExecutionRequiredInternal = 3,
   PowerRequestPerfBoostRequiredInternal = 4,
   PowerRequestActiveLockScreenInternal = 5,
   PowerRequestInternalInvalid = 6,
   PowerRequestInternalUnknown = 7,
   PowerRequestFullScreenVideoRequired = 8,
}
pub use self::_POWER_REQUEST_TYPE_INTERNAL as POWER_REQUEST_TYPE_INTERNAL;
#[repr(C)]
pub struct _POWER_REQUEST_ACTION {
   pub PowerRequestHandle: HANDLE,
   pub RequestType: POWER_REQUEST_TYPE_INTERNAL,
   pub SetAction: BOOLEAN,
   pub ProcessHandle: HANDLE,
}
impl Default for _POWER_REQUEST_ACTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_REQUEST_ACTION = _POWER_REQUEST_ACTION;
pub type PPOWER_REQUEST_ACTION = *mut _POWER_REQUEST_ACTION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_STATE {
   pub SystemState: SYSTEM_POWER_STATE,
   pub DeviceState: DEVICE_POWER_STATE,
}
impl Default for _POWER_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_STATE = _POWER_STATE;
pub type PPOWER_STATE = *mut _POWER_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_STATE_TYPE {
   SystemPowerState = 0,
   DevicePowerState = 1,
}
pub use self::_POWER_STATE_TYPE as POWER_STATE_TYPE;
pub type PPOWER_STATE_TYPE = *mut _POWER_STATE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT {
   pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
   pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
   pub ContextAsUlong: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Reserved1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn TargetSystemState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_TargetSystemState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn EffectiveSystemState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_EffectiveSystemState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn CurrentSystemState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_CurrentSystemState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn IgnoreHibernationPath(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IgnoreHibernationPath(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn PseudoTransition(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PseudoTransition(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn KernelSoftReboot(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KernelSoftReboot(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DirectedDripsTransition(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DirectedDripsTransition(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved2(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved2(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Reserved1: ULONG,
      TargetSystemState: ULONG,
      EffectiveSystemState: ULONG,
      CurrentSystemState: ULONG,
      IgnoreHibernationPath: ULONG,
      PseudoTransition: ULONG,
      KernelSoftReboot: ULONG,
      DirectedDripsTransition: ULONG,
      Reserved2: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit.set(8usize, 4u8, {
         let TargetSystemState: u32 = unsafe { ::core::mem::transmute(TargetSystemState) };
         TargetSystemState as u64
      });
      __bindgen_bitfield_unit.set(12usize, 4u8, {
         let EffectiveSystemState: u32 = unsafe { ::core::mem::transmute(EffectiveSystemState) };
         EffectiveSystemState as u64
      });
      __bindgen_bitfield_unit.set(16usize, 4u8, {
         let CurrentSystemState: u32 = unsafe { ::core::mem::transmute(CurrentSystemState) };
         CurrentSystemState as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let IgnoreHibernationPath: u32 = unsafe { ::core::mem::transmute(IgnoreHibernationPath) };
         IgnoreHibernationPath as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let PseudoTransition: u32 = unsafe { ::core::mem::transmute(PseudoTransition) };
         PseudoTransition as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let KernelSoftReboot: u32 = unsafe { ::core::mem::transmute(KernelSoftReboot) };
         KernelSoftReboot as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let DirectedDripsTransition: u32 =
            unsafe { ::core::mem::transmute(DirectedDripsTransition) };
         DirectedDripsTransition as u64
      });
      __bindgen_bitfield_unit.set(24usize, 8u8, {
         let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
         Reserved2 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_POWER_STATE_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POWER_STATE_CONTEXT = _SYSTEM_POWER_STATE_CONTEXT;
pub type PSYSTEM_POWER_STATE_CONTEXT = *mut _SYSTEM_POWER_STATE_CONTEXT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _REQUESTER_TYPE {
   KernelRequester = 0,
   UserProcessRequester = 1,
   UserSharedServiceRequester = 2,
}
pub use self::_REQUESTER_TYPE as REQUESTER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _COUNTED_REASON_CONTEXT_RELATIVE {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT_RELATIVE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _COUNTED_REASON_CONTEXT_RELATIVE__bindgen_ty_1 {
   pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT_RELATIVE__bindgen_ty_1__bindgen_ty_1,
   pub SimpleStringOffset: SIZE_T,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _COUNTED_REASON_CONTEXT_RELATIVE__bindgen_ty_1__bindgen_ty_1 {
   pub ResourceFileNameOffset: SIZE_T,
   pub ResourceReasonId: USHORT,
   pub StringCount: ULONG,
   pub SubstitutionStringsOffset: SIZE_T,
}
impl Default for _COUNTED_REASON_CONTEXT_RELATIVE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _COUNTED_REASON_CONTEXT_RELATIVE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COUNTED_REASON_CONTEXT_RELATIVE = _COUNTED_REASON_CONTEXT_RELATIVE;
pub type PCOUNTED_REASON_CONTEXT_RELATIVE = *mut _COUNTED_REASON_CONTEXT_RELATIVE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DIAGNOSTIC_BUFFER {
   pub Size: SIZE_T,
   pub CallerType: REQUESTER_TYPE,
   pub __bindgen_anon_1: _DIAGNOSTIC_BUFFER__bindgen_ty_1,
   pub ReasonOffset: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DIAGNOSTIC_BUFFER__bindgen_ty_1 {
   pub __bindgen_anon_1: _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_1,
   pub __bindgen_anon_2: _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_1 {
   pub ProcessImageNameOffset: SIZE_T,
   pub ProcessId: ULONG,
   pub ServiceTag: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_2 {
   pub DeviceDescriptionOffset: SIZE_T,
   pub DevicePathOffset: SIZE_T,
}
impl Default for _DIAGNOSTIC_BUFFER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _DIAGNOSTIC_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DIAGNOSTIC_BUFFER = _DIAGNOSTIC_BUFFER;
pub type PDIAGNOSTIC_BUFFER = *mut _DIAGNOSTIC_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WAKE_TIMER_INFO {
   pub OffsetToNext: SIZE_T,
   pub DueTime: ULARGE_INTEGER,
   pub Period: ULONG,
   pub ReasonContext: DIAGNOSTIC_BUFFER,
}
impl Default for _WAKE_TIMER_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WAKE_TIMER_INFO = _WAKE_TIMER_INFO;
pub type PWAKE_TIMER_INFO = *mut _WAKE_TIMER_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_PERF_CAP_HV {
   pub Version: ULONG,
   pub InitialApicId: ULONG,
   pub Ppc: ULONG,
   pub Tpc: ULONG,
   pub ThermalCap: ULONG,
}
pub type PROCESSOR_PERF_CAP_HV = _PROCESSOR_PERF_CAP_HV;
pub type PPROCESSOR_PERF_CAP_HV = *mut _PROCESSOR_PERF_CAP_HV;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PROCESSOR_IDLE_TIMES {
   pub StartTime: ULONG64,
   pub EndTime: ULONG64,
   pub Reserved: [ULONG; 4usize],
}
pub type PPROCESSOR_IDLE_TIMES = *mut PROCESSOR_IDLE_TIMES;
pub type PROCESSOR_IDLE_HANDLER = ::core::option::Option<
   unsafe extern "C" fn(Context: ULONG_PTR, IdleTimes: PPROCESSOR_IDLE_TIMES) -> NTSTATUS,
>;
pub type PPROCESSOR_IDLE_HANDLER = PROCESSOR_IDLE_HANDLER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_IDLE_STATE {
   pub StateType: UCHAR,
   pub StateFlags: ULONG,
   pub HardwareLatency: ULONG,
   pub Power: ULONG,
   pub Context: ULONG_PTR,
   pub Handler: PPROCESSOR_IDLE_HANDLER,
}
pub type PROCESSOR_IDLE_STATE = _PROCESSOR_IDLE_STATE;
pub type PPROCESSOR_IDLE_STATE = *mut _PROCESSOR_IDLE_STATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_IDLE_STATES {
   pub Size: ULONG,
   pub Revision: ULONG,
   pub Count: ULONG,
   pub Type: ULONG,
   pub TargetProcessors: KAFFINITY,
   pub State: [PROCESSOR_IDLE_STATE; 1usize],
}
pub type PROCESSOR_IDLE_STATES = _PROCESSOR_IDLE_STATES;
pub type PPROCESSOR_IDLE_STATES = *mut _PROCESSOR_IDLE_STATES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_LOAD {
   pub ProcessorNumber: PROCESSOR_NUMBER,
   pub BusyPercentage: UCHAR,
   pub FrequencyPercentage: UCHAR,
   pub Padding: USHORT,
}
pub type PROCESSOR_LOAD = _PROCESSOR_LOAD;
pub type PPROCESSOR_LOAD = *mut _PROCESSOR_LOAD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_CAP {
   pub Version: ULONG,
   pub ProcessorNumber: PROCESSOR_NUMBER,
   pub PlatformCap: ULONG,
   pub ThermalCap: ULONG,
   pub LimitReasons: ULONG,
}
pub type PROCESSOR_CAP = _PROCESSOR_CAP;
pub type PPROCESSOR_CAP = *mut _PROCESSOR_CAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_INFO {
   pub Count: ULONG,
   pub Offsets: [ULONG; 1usize],
}
pub type PO_WAKE_SOURCE_INFO = _PO_WAKE_SOURCE_INFO;
pub type PPO_WAKE_SOURCE_INFO = *mut _PO_WAKE_SOURCE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_HISTORY {
   pub Count: ULONG,
   pub Offsets: [ULONG; 1usize],
}
pub type PO_WAKE_SOURCE_HISTORY = _PO_WAKE_SOURCE_HISTORY;
pub type PPO_WAKE_SOURCE_HISTORY = *mut _PO_WAKE_SOURCE_HISTORY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_WAKE_SOURCE_TYPE {
   DeviceWakeSourceType = 0,
   FixedWakeSourceType = 1,
   TimerWakeSourceType = 2,
   TimerPresumedWakeSourceType = 3,
   InternalWakeSourceType = 4,
}
pub use self::_PO_WAKE_SOURCE_TYPE as PO_WAKE_SOURCE_TYPE;
pub type PPO_WAKE_SOURCE_TYPE = *mut _PO_WAKE_SOURCE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_INTERNAL_WAKE_SOURCE_TYPE {
   InternalWakeSourceDozeToHibernate = 0,
   InternalWakeSourcePredictedUserPresence = 1,
}
pub use self::_PO_INTERNAL_WAKE_SOURCE_TYPE as PO_INTERNAL_WAKE_SOURCE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_FIXED_WAKE_SOURCE_TYPE {
   FixedWakeSourcePowerButton = 0,
   FixedWakeSourceSleepButton = 1,
   FixedWakeSourceRtc = 2,
   FixedWakeSourceDozeToHibernate = 3,
}
pub use self::_PO_FIXED_WAKE_SOURCE_TYPE as PO_FIXED_WAKE_SOURCE_TYPE;
pub type PPO_FIXED_WAKE_SOURCE_TYPE = *mut _PO_FIXED_WAKE_SOURCE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_HEADER {
   pub Type: PO_WAKE_SOURCE_TYPE,
   pub Size: ULONG,
}
impl Default for _PO_WAKE_SOURCE_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PO_WAKE_SOURCE_HEADER = _PO_WAKE_SOURCE_HEADER;
pub type PPO_WAKE_SOURCE_HEADER = *mut _PO_WAKE_SOURCE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_DEVICE {
   pub Header: PO_WAKE_SOURCE_HEADER,
   pub InstancePath: [WCHAR; 1usize],
}
impl Default for _PO_WAKE_SOURCE_DEVICE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PO_WAKE_SOURCE_DEVICE = _PO_WAKE_SOURCE_DEVICE;
pub type PPO_WAKE_SOURCE_DEVICE = *mut _PO_WAKE_SOURCE_DEVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_FIXED {
   pub Header: PO_WAKE_SOURCE_HEADER,
   pub FixedWakeSourceType: PO_FIXED_WAKE_SOURCE_TYPE,
}
impl Default for _PO_WAKE_SOURCE_FIXED {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PO_WAKE_SOURCE_FIXED = _PO_WAKE_SOURCE_FIXED;
pub type PPO_WAKE_SOURCE_FIXED = *mut _PO_WAKE_SOURCE_FIXED;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_INTERNAL {
   pub Header: PO_WAKE_SOURCE_HEADER,
   pub InternalWakeSourceType: PO_INTERNAL_WAKE_SOURCE_TYPE,
}
impl Default for _PO_WAKE_SOURCE_INTERNAL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PO_WAKE_SOURCE_INTERNAL = _PO_WAKE_SOURCE_INTERNAL;
pub type PPO_WAKE_SOURCE_INTERNAL = *mut _PO_WAKE_SOURCE_INTERNAL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_WAKE_SOURCE_TIMER {
   pub Header: PO_WAKE_SOURCE_HEADER,
   pub Reason: DIAGNOSTIC_BUFFER,
}
impl Default for _PO_WAKE_SOURCE_TIMER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PO_WAKE_SOURCE_TIMER = _PO_WAKE_SOURCE_TIMER;
pub type PPO_WAKE_SOURCE_TIMER = *mut _PO_WAKE_SOURCE_TIMER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_REQUEST {
   pub __bindgen_anon_1: _POWER_REQUEST__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_REQUEST__bindgen_ty_1 {
   pub V1: _POWER_REQUEST__bindgen_ty_1__bindgen_ty_1,
   pub V2: _POWER_REQUEST__bindgen_ty_1__bindgen_ty_2,
   pub V3: _POWER_REQUEST__bindgen_ty_1__bindgen_ty_3,
   pub V4: _POWER_REQUEST__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_REQUEST__bindgen_ty_1__bindgen_ty_1 {
   pub SupportedRequestMask: ULONG,
   pub PowerRequestCount: [ULONG; 3usize],
   pub DiagnosticBuffer: DIAGNOSTIC_BUFFER,
}
impl Default for _POWER_REQUEST__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_REQUEST__bindgen_ty_1__bindgen_ty_2 {
   pub SupportedRequestMask: ULONG,
   pub PowerRequestCount: [ULONG; 9usize],
   pub DiagnosticBuffer: DIAGNOSTIC_BUFFER,
}
impl Default for _POWER_REQUEST__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_REQUEST__bindgen_ty_1__bindgen_ty_3 {
   pub SupportedRequestMask: ULONG,
   pub PowerRequestCount: [ULONG; 5usize],
   pub DiagnosticBuffer: DIAGNOSTIC_BUFFER,
}
impl Default for _POWER_REQUEST__bindgen_ty_1__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_REQUEST__bindgen_ty_1__bindgen_ty_4 {
   pub SupportedRequestMask: ULONG,
   pub PowerRequestCount: [ULONG; 6usize],
   pub DiagnosticBuffer: DIAGNOSTIC_BUFFER,
}
impl Default for _POWER_REQUEST__bindgen_ty_1__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _POWER_REQUEST__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _POWER_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_REQUEST = _POWER_REQUEST;
pub type PPOWER_REQUEST = *mut _POWER_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_REQUEST_LIST {
   pub Count: ULONG_PTR,
   pub PowerRequestOffsets: [ULONG_PTR; 1usize],
}
pub type POWER_REQUEST_LIST = _POWER_REQUEST_LIST;
pub type PPOWER_REQUEST_LIST = *mut _POWER_REQUEST_LIST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_STATE_HANDLER_TYPE {
   PowerStateSleeping1 = 0,
   PowerStateSleeping2 = 1,
   PowerStateSleeping3 = 2,
   PowerStateSleeping4 = 3,
   PowerStateShutdownOff = 4,
   PowerStateShutdownReset = 5,
   PowerStateSleeping4Firmware = 6,
   PowerStateMaximum = 7,
}
pub use self::_POWER_STATE_HANDLER_TYPE as POWER_STATE_HANDLER_TYPE;
pub type PPOWER_STATE_HANDLER_TYPE = *mut _POWER_STATE_HANDLER_TYPE;
pub type PENTER_STATE_SYSTEM_HANDLER =
   ::core::option::Option<unsafe extern "C" fn(SystemContext: PVOID) -> NTSTATUS>;
pub type PENTER_STATE_HANDLER = ::core::option::Option<
   unsafe extern "C" fn(
      Context: PVOID,
      SystemHandler: PENTER_STATE_SYSTEM_HANDLER,
      SystemContext: PVOID,
      NumberProcessors: LONG,
      Number: *mut LONG,
   ) -> NTSTATUS,
>;
#[repr(C)]
pub struct _POWER_STATE_HANDLER {
   pub Type: POWER_STATE_HANDLER_TYPE,
   pub RtcWake: BOOLEAN,
   pub Spare: [UCHAR; 3usize],
   pub Handler: PENTER_STATE_HANDLER,
   pub Context: PVOID,
}
impl Default for _POWER_STATE_HANDLER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_STATE_HANDLER = _POWER_STATE_HANDLER;
pub type PPOWER_STATE_HANDLER = *mut _POWER_STATE_HANDLER;
pub type PENTER_STATE_NOTIFY_HANDLER = ::core::option::Option<
   unsafe extern "C" fn(
      State: POWER_STATE_HANDLER_TYPE,
      Context: PVOID,
      Entering: BOOLEAN,
   ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_STATE_NOTIFY_HANDLER {
   pub Handler: PENTER_STATE_NOTIFY_HANDLER,
   pub Context: PVOID,
}
impl Default for _POWER_STATE_NOTIFY_HANDLER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_STATE_NOTIFY_HANDLER = _POWER_STATE_NOTIFY_HANDLER;
pub type PPOWER_STATE_NOTIFY_HANDLER = *mut _POWER_STATE_NOTIFY_HANDLER;
#[repr(C)]
pub struct _POWER_REQUEST_ACTION_INTERNAL {
   pub PowerRequestPointer: PVOID,
   pub RequestType: POWER_REQUEST_TYPE_INTERNAL,
   pub SetAction: BOOLEAN,
}
impl Default for _POWER_REQUEST_ACTION_INTERNAL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_REQUEST_ACTION_INTERNAL = _POWER_REQUEST_ACTION_INTERNAL;
pub type PPOWER_REQUEST_ACTION_INTERNAL = *mut _POWER_REQUEST_ACTION_INTERNAL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_INFORMATION_LEVEL_INTERNAL {
   PowerInternalAcpiInterfaceRegister = 0,
   PowerInternalS0LowPowerIdleInfo = 1,
   PowerInternalReapplyBrightnessSettings = 2,
   PowerInternalUserAbsencePrediction = 3,
   PowerInternalUserAbsencePredictionCapability = 4,
   PowerInternalPoProcessorLatencyHint = 5,
   PowerInternalStandbyNetworkRequest = 6,
   PowerInternalDirtyTransitionInformation = 7,
   PowerInternalSetBackgroundTaskState = 8,
   PowerInternalTtmOpenTerminal = 9,
   PowerInternalTtmCreateTerminal = 10,
   PowerInternalTtmEvacuateDevices = 11,
   PowerInternalTtmCreateTerminalEventQueue = 12,
   PowerInternalTtmGetTerminalEvent = 13,
   PowerInternalTtmSetDefaultDeviceAssignment = 14,
   PowerInternalTtmAssignDevice = 15,
   PowerInternalTtmSetDisplayState = 16,
   PowerInternalTtmSetDisplayTimeouts = 17,
   PowerInternalBootSessionStandbyActivationInformation = 18,
   PowerInternalSessionPowerState = 19,
   PowerInternalSessionTerminalInput = 20,
   PowerInternalSetWatchdog = 21,
   PowerInternalPhysicalPowerButtonPressInfoAtBoot = 22,
   PowerInternalExternalMonitorConnected = 23,
   PowerInternalHighPrecisionBrightnessSettings = 24,
   PowerInternalWinrtScreenToggle = 25,
   PowerInternalPpmQosDisable = 26,
   PowerInternalTransitionCheckpoint = 27,
   PowerInternalInputControllerState = 28,
   PowerInternalFirmwareResetReason = 29,
   PowerInternalPpmSchedulerQosSupport = 30,
   PowerInternalBootStatGet = 31,
   PowerInternalBootStatSet = 32,
   PowerInternalCallHasNotReturnedWatchdog = 33,
   PowerInternalBootStatCheckIntegrity = 34,
   PowerInternalBootStatRestoreDefaults = 35,
   PowerInternalHostEsStateUpdate = 36,
   PowerInternalGetPowerActionState = 37,
   PowerInternalBootStatUnlock = 38,
   PowerInternalWakeOnVoiceState = 39,
   PowerInternalDeepSleepBlock = 40,
   PowerInternalIsPoFxDevice = 41,
   PowerInternalPowerTransitionExtensionAtBoot = 42,
   PowerInternalProcessorBrandedFrequency = 43,
   PowerInternalTimeBrokerExpirationReason = 44,
   PowerInternalNotifyUserShutdownStatus = 45,
   PowerInternalPowerRequestTerminalCoreWindow = 46,
   PowerInternalProcessorIdleVeto = 47,
   PowerInternalPlatformIdleVeto = 48,
   PowerInternalIsLongPowerButtonBugcheckEnabled = 49,
   PowerInternalAutoChkCausedReboot = 50,
   PowerInternalSetWakeAlarmOverride = 51,
   PowerInternalDirectedFxAddTestDevice = 53,
   PowerInternalDirectedFxRemoveTestDevice = 54,
   PowerInternalDirectedFxSetMode = 56,
   PowerInternalRegisterPowerPlane = 57,
   PowerInternalSetDirectedDripsFlags = 58,
   PowerInternalClearDirectedDripsFlags = 59,
   PowerInternalRetrieveHiberFileResumeContext = 60,
   PowerInternalReadHiberFilePage = 61,
   PowerInternalLastBootSucceeded = 62,
   PowerInternalQuerySleepStudyHelperRoutineBlock = 63,
   PowerInternalDirectedDripsQueryCapabilities = 64,
   PowerInternalClearConstraints = 65,
   PowerInternalSoftParkVelocityEnabled = 66,
   PowerInternalQueryIntelPepCapabilities = 67,
   PowerInternalGetSystemIdleLoopEnablement = 68,
   PowerInternalGetVmPerfControlSupport = 69,
   PowerInternalGetVmPerfControlConfig = 70,
   PowerInternalSleepDetailedDiagUpdate = 71,
   PowerInternalProcessorClassFrequencyBandsStats = 72,
   PowerInternalHostGlobalUserPresenceStateUpdate = 73,
   PowerInternalCpuNodeIdleIntervalStats = 74,
   PowerInternalClassIdleIntervalStats = 75,
   PowerInternalCpuNodeConcurrencyStats = 76,
   PowerInternalClassConcurrencyStats = 77,
   PowerInternalQueryProcMeasurementCapabilities = 78,
   PowerInternalQueryProcMeasurementValues = 79,
   PowerInternalPrepareForSystemInitiatedReboot = 80,
   PowerInternalGetAdaptiveSessionState = 81,
   PowerInternalSetConsoleLockedState = 82,
   PowerInternalOverrideSystemInitiatedRebootState = 83,
   PowerInternalFanImpactStats = 84,
   PowerInternalFanRpmBuckets = 85,
   PowerInternalPowerBootAppDiagInfo = 86,
   PowerInternalUnregisterShutdownNotification = 87,
   PowerInternalManageTransitionStateRecord = 88,
   PowerInternalGetAcpiTimeAndAlarmCapabilities = 89,
   PowerInternalSuspendResumeRequest = 90,
   PowerInternalEnergyEstimationInfo = 91,
   PowerInformationInternalMaximum = 92,
}
pub use self::_POWER_INFORMATION_LEVEL_INTERNAL as POWER_INFORMATION_LEVEL_INTERNAL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_S0_DISCONNECTED_REASON {
   PoS0DisconnectedReasonNone = 0,
   PoS0DisconnectedReasonNonCompliantNic = 1,
   PoS0DisconnectedReasonSettingPolicy = 2,
   PoS0DisconnectedReasonEnforceDsPolicy = 3,
   PoS0DisconnectedReasonCsChecksFailed = 4,
   PoS0DisconnectedReasonSmartStandby = 5,
   PoS0DisconnectedReasonMaximum = 6,
}
pub use self::_POWER_S0_DISCONNECTED_REASON as POWER_S0_DISCONNECTED_REASON;
#[repr(C)]
pub struct _POWER_S0_LOW_POWER_IDLE_INFO {
   pub DisconnectedReason: POWER_S0_DISCONNECTED_REASON,
   pub CsDeviceCompliance: _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_1,
   pub Policy: _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_2,
}
#[repr(C)]
pub union _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub AsUCHAR: UCHAR,
}
impl Default for _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_1 {
   #[inline]
   pub fn Storage(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Storage(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn WiFi(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_WiFi(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Mbn(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Mbn(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Ethernet(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Ethernet(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Storage: BOOLEAN,
      WiFi: BOOLEAN,
      Mbn: BOOLEAN,
      Ethernet: BOOLEAN,
      Reserved: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Storage: u8 = unsafe { ::core::mem::transmute(Storage) };
         Storage as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let WiFi: u8 = unsafe { ::core::mem::transmute(WiFi) };
         WiFi as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let Mbn: u8 = unsafe { ::core::mem::transmute(Mbn) };
         Mbn as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let Ethernet: u8 = unsafe { ::core::mem::transmute(Ethernet) };
         Ethernet as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
pub union _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_2 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub AsUCHAR: UCHAR,
}
impl Default for _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_2 {
   #[inline]
   pub fn DisconnectInStandby(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_DisconnectInStandby(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnforceDs(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_EnforceDs(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DisconnectInStandby: BOOLEAN,
      EnforceDs: BOOLEAN,
      Reserved: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DisconnectInStandby: u8 = unsafe { ::core::mem::transmute(DisconnectInStandby) };
         DisconnectInStandby as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let EnforceDs: u8 = unsafe { ::core::mem::transmute(EnforceDs) };
         EnforceDs as u64
      });
      __bindgen_bitfield_unit.set(2usize, 6u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _POWER_S0_LOW_POWER_IDLE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_S0_LOW_POWER_IDLE_INFO = _POWER_S0_LOW_POWER_IDLE_INFO;
pub type PPOWER_S0_LOW_POWER_IDLE_INFO = *mut _POWER_S0_LOW_POWER_IDLE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_INFORMATION_INTERNAL_HEADER {
   pub InternalType: POWER_INFORMATION_LEVEL_INTERNAL,
   pub Version: ULONG,
}
impl Default for _POWER_INFORMATION_INTERNAL_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_INFORMATION_INTERNAL_HEADER = _POWER_INFORMATION_INTERNAL_HEADER;
pub type PPOWER_INFORMATION_INTERNAL_HEADER = *mut _POWER_INFORMATION_INTERNAL_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_USER_ABSENCE_PREDICTION {
   pub Header: POWER_INFORMATION_INTERNAL_HEADER,
   pub ReturnTime: LARGE_INTEGER,
}
impl Default for _POWER_USER_ABSENCE_PREDICTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_USER_ABSENCE_PREDICTION = _POWER_USER_ABSENCE_PREDICTION;
pub type PPOWER_USER_ABSENCE_PREDICTION = *mut _POWER_USER_ABSENCE_PREDICTION;
#[repr(C)]
pub struct _POWER_USER_ABSENCE_PREDICTION_CAPABILITY {
   pub AbsencePredictionCapability: BOOLEAN,
}
impl Default for _POWER_USER_ABSENCE_PREDICTION_CAPABILITY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_USER_ABSENCE_PREDICTION_CAPABILITY = _POWER_USER_ABSENCE_PREDICTION_CAPABILITY;
pub type PPOWER_USER_ABSENCE_PREDICTION_CAPABILITY = *mut _POWER_USER_ABSENCE_PREDICTION_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_PROCESSOR_LATENCY_HINT {
   pub PowerInformationInternalHeader: POWER_INFORMATION_INTERNAL_HEADER,
   pub Type: ULONG,
}
impl Default for _POWER_PROCESSOR_LATENCY_HINT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_PROCESSOR_LATENCY_HINT = _POWER_PROCESSOR_LATENCY_HINT;
pub type PPO_PROCESSOR_LATENCY_HINT = *mut _POWER_PROCESSOR_LATENCY_HINT;
#[repr(C)]
pub struct _POWER_STANDBY_NETWORK_REQUEST {
   pub PowerInformationInternalHeader: POWER_INFORMATION_INTERNAL_HEADER,
   pub Active: BOOLEAN,
}
impl Default for _POWER_STANDBY_NETWORK_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_STANDBY_NETWORK_REQUEST = _POWER_STANDBY_NETWORK_REQUEST;
pub type PPOWER_STANDBY_NETWORK_REQUEST = *mut _POWER_STANDBY_NETWORK_REQUEST;
#[repr(C)]
pub struct _POWER_SET_BACKGROUND_TASK_STATE {
   pub PowerInformationInternalHeader: POWER_INFORMATION_INTERNAL_HEADER,
   pub Engaged: BOOLEAN,
}
impl Default for _POWER_SET_BACKGROUND_TASK_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_SET_BACKGROUND_TASK_STATE = _POWER_SET_BACKGROUND_TASK_STATE;
pub type PPOWER_SET_BACKGROUND_TASK_STATE = *mut _POWER_SET_BACKGROUND_TASK_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO {
   pub StandbyTotalTime: ULONG,
   pub DripsTotalTime: ULONG,
   pub ActivatorClientTotalActiveTime: ULONG,
   pub PerActivatorClientTotalActiveTime: [ULONG; 98usize],
}
impl Default for _POWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO = _POWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO;
pub type PPOWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO =
   *mut _POWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO;
#[repr(C)]
pub struct _POWER_SESSION_POWER_STATE {
   pub Header: POWER_INFORMATION_INTERNAL_HEADER,
   pub SessionId: ULONG,
   pub On: BOOLEAN,
   pub IsConsole: BOOLEAN,
   pub RequestReason: POWER_MONITOR_REQUEST_REASON,
}
impl Default for _POWER_SESSION_POWER_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_SESSION_POWER_STATE = _POWER_SESSION_POWER_STATE;
pub type PPOWER_SESSION_POWER_STATE = *mut _POWER_SESSION_POWER_STATE;
#[repr(C)]
pub struct _POWER_INTERNAL_PROCESSOR_QOS_SUPPORT {
   pub QosSupportedAndConfigured: BOOLEAN,
   pub SchedulerDirectedPerfStatesSupported: BOOLEAN,
   pub QosGroupPolicyDisable: BOOLEAN,
}
impl Default for _POWER_INTERNAL_PROCESSOR_QOS_SUPPORT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_INTERNAL_PROCESSOR_QOS_SUPPORT = _POWER_INTERNAL_PROCESSOR_QOS_SUPPORT;
pub type PPOWER_INTERNAL_PROCESSOR_QOS_SUPPORT = *mut _POWER_INTERNAL_PROCESSOR_QOS_SUPPORT;
#[repr(C)]
pub struct _POWER_INTERNAL_HOST_ENERGY_SAVER_STATE {
   pub Header: POWER_INFORMATION_INTERNAL_HEADER,
   pub EsEnabledOnHost: BOOLEAN,
}
impl Default for _POWER_INTERNAL_HOST_ENERGY_SAVER_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_INTERNAL_HOST_ENERGY_SAVER_STATE = _POWER_INTERNAL_HOST_ENERGY_SAVER_STATE;
pub type PPOWER_INTERNAL_HOST_ENERGY_SAVER_STATE = *mut _POWER_INTERNAL_HOST_ENERGY_SAVER_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT {
   pub InternalType: POWER_INFORMATION_LEVEL_INTERNAL,
   pub ProcessorNumber: PROCESSOR_NUMBER,
}
impl Default for _POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT =
   _POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT;
pub type PPOWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT =
   *mut _POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_OUTPUT {
   pub Version: ULONG,
   pub NominalFrequency: ULONG,
}
pub type POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_OUTPUT =
   _POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_OUTPUT;
pub type PPOWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_OUTPUT =
   *mut _POWER_INTERNAL_PROCESSOR_BRANDED_FREQENCY_OUTPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_INTERNAL_BOOTAPP_DIAGNOSTIC {
   pub BootAppErrorDiagCode: ULONG,
   pub BootAppFailureStatus: ULONG,
}
pub type POWER_INTERNAL_BOOTAPP_DIAGNOSTIC = _POWER_INTERNAL_BOOTAPP_DIAGNOSTIC;
pub type PPOWER_INTERNAL_BOOTAPP_DIAGNOSTIC = *mut _POWER_INTERNAL_BOOTAPP_DIAGNOSTIC;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KEY_INFORMATION_CLASS {
   KeyBasicInformation = 0,
   KeyNodeInformation = 1,
   KeyFullInformation = 2,
   KeyNameInformation = 3,
   KeyCachedInformation = 4,
   KeyFlagsInformation = 5,
   KeyVirtualizationInformation = 6,
   KeyHandleTagsInformation = 7,
   KeyTrustInformation = 8,
   KeyLayerInformation = 9,
   MaxKeyInfoClass = 10,
}
pub use self::_KEY_INFORMATION_CLASS as KEY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_BASIC_INFORMATION {
   pub LastWriteTime: LARGE_INTEGER,
   pub TitleIndex: ULONG,
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
impl Default for _KEY_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_BASIC_INFORMATION = _KEY_BASIC_INFORMATION;
pub type PKEY_BASIC_INFORMATION = *mut _KEY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_NODE_INFORMATION {
   pub LastWriteTime: LARGE_INTEGER,
   pub TitleIndex: ULONG,
   pub ClassOffset: ULONG,
   pub ClassLength: ULONG,
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
impl Default for _KEY_NODE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_NODE_INFORMATION = _KEY_NODE_INFORMATION;
pub type PKEY_NODE_INFORMATION = *mut _KEY_NODE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_FULL_INFORMATION {
   pub LastWriteTime: LARGE_INTEGER,
   pub TitleIndex: ULONG,
   pub ClassOffset: ULONG,
   pub ClassLength: ULONG,
   pub SubKeys: ULONG,
   pub MaxNameLength: ULONG,
   pub MaxClassLength: ULONG,
   pub Values: ULONG,
   pub MaxValueNameLength: ULONG,
   pub MaxValueDataLength: ULONG,
   pub Class: [WCHAR; 1usize],
}
impl Default for _KEY_FULL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_FULL_INFORMATION = _KEY_FULL_INFORMATION;
pub type PKEY_FULL_INFORMATION = *mut _KEY_FULL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_NAME_INFORMATION {
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
pub type KEY_NAME_INFORMATION = _KEY_NAME_INFORMATION;
pub type PKEY_NAME_INFORMATION = *mut _KEY_NAME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_CACHED_INFORMATION {
   pub LastWriteTime: LARGE_INTEGER,
   pub TitleIndex: ULONG,
   pub SubKeys: ULONG,
   pub MaxNameLength: ULONG,
   pub Values: ULONG,
   pub MaxValueNameLength: ULONG,
   pub MaxValueDataLength: ULONG,
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
impl Default for _KEY_CACHED_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_CACHED_INFORMATION = _KEY_CACHED_INFORMATION;
pub type PKEY_CACHED_INFORMATION = *mut _KEY_CACHED_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_FLAGS_INFORMATION {
   pub Wow64Flags: ULONG,
   pub KeyFlags: ULONG,
   pub ControlFlags: ULONG,
}
pub type KEY_FLAGS_INFORMATION = _KEY_FLAGS_INFORMATION;
pub type PKEY_FLAGS_INFORMATION = *mut _KEY_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VIRTUALIZATION_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_VIRTUALIZATION_INFORMATION {
   #[inline]
   pub fn VirtualizationCandidate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualizationCandidate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VirtualizationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualizationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VirtualTarget(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualTarget(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VirtualStore(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualStore(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VirtualSource(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualSource(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      VirtualizationCandidate: ULONG,
      VirtualizationEnabled: ULONG,
      VirtualTarget: ULONG,
      VirtualStore: ULONG,
      VirtualSource: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let VirtualizationCandidate: u32 =
            unsafe { ::core::mem::transmute(VirtualizationCandidate) };
         VirtualizationCandidate as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let VirtualizationEnabled: u32 = unsafe { ::core::mem::transmute(VirtualizationEnabled) };
         VirtualizationEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let VirtualTarget: u32 = unsafe { ::core::mem::transmute(VirtualTarget) };
         VirtualTarget as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let VirtualStore: u32 = unsafe { ::core::mem::transmute(VirtualStore) };
         VirtualStore as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let VirtualSource: u32 = unsafe { ::core::mem::transmute(VirtualSource) };
         VirtualSource as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type KEY_VIRTUALIZATION_INFORMATION = _KEY_VIRTUALIZATION_INFORMATION;
pub type PKEY_VIRTUALIZATION_INFORMATION = *mut _KEY_VIRTUALIZATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_TRUST_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_TRUST_INFORMATION {
   #[inline]
   pub fn TrustedKey(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_TrustedKey(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      TrustedKey: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let TrustedKey: u32 = unsafe { ::core::mem::transmute(TrustedKey) };
         TrustedKey as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type KEY_TRUST_INFORMATION = _KEY_TRUST_INFORMATION;
pub type PKEY_TRUST_INFORMATION = *mut _KEY_TRUST_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_LAYER_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_LAYER_INFORMATION {
   #[inline]
   pub fn IsTombstone(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsTombstone(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsSupersedeLocal(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSupersedeLocal(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsSupersedeTree(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSupersedeTree(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ClassIsInherited(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ClassIsInherited(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsTombstone: ULONG,
      IsSupersedeLocal: ULONG,
      IsSupersedeTree: ULONG,
      ClassIsInherited: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsTombstone: u32 = unsafe { ::core::mem::transmute(IsTombstone) };
         IsTombstone as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsSupersedeLocal: u32 = unsafe { ::core::mem::transmute(IsSupersedeLocal) };
         IsSupersedeLocal as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IsSupersedeTree: u32 = unsafe { ::core::mem::transmute(IsSupersedeTree) };
         IsSupersedeTree as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ClassIsInherited: u32 = unsafe { ::core::mem::transmute(ClassIsInherited) };
         ClassIsInherited as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type KEY_LAYER_INFORMATION = _KEY_LAYER_INFORMATION;
pub type PKEY_LAYER_INFORMATION = *mut _KEY_LAYER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KEY_SET_INFORMATION_CLASS {
   KeyWriteTimeInformation = 0,
   KeyWow64FlagsInformation = 1,
   KeyControlFlagsInformation = 2,
   KeySetVirtualizationInformation = 3,
   KeySetDebugInformation = 4,
   KeySetHandleTagsInformation = 5,
   KeySetLayerInformation = 6,
   MaxKeySetInfoClass = 7,
}
pub use self::_KEY_SET_INFORMATION_CLASS as KEY_SET_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_WRITE_TIME_INFORMATION {
   pub LastWriteTime: LARGE_INTEGER,
}
impl Default for _KEY_WRITE_TIME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_WRITE_TIME_INFORMATION = _KEY_WRITE_TIME_INFORMATION;
pub type PKEY_WRITE_TIME_INFORMATION = *mut _KEY_WRITE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_WOW64_FLAGS_INFORMATION {
   pub UserFlags: ULONG,
}
pub type KEY_WOW64_FLAGS_INFORMATION = _KEY_WOW64_FLAGS_INFORMATION;
pub type PKEY_WOW64_FLAGS_INFORMATION = *mut _KEY_WOW64_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_HANDLE_TAGS_INFORMATION {
   pub HandleTags: ULONG,
}
pub type KEY_HANDLE_TAGS_INFORMATION = _KEY_HANDLE_TAGS_INFORMATION;
pub type PKEY_HANDLE_TAGS_INFORMATION = *mut _KEY_HANDLE_TAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_SET_LAYER_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_SET_LAYER_INFORMATION {
   #[inline]
   pub fn IsTombstone(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsTombstone(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsSupersedeLocal(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSupersedeLocal(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsSupersedeTree(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSupersedeTree(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ClassIsInherited(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ClassIsInherited(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsTombstone: ULONG,
      IsSupersedeLocal: ULONG,
      IsSupersedeTree: ULONG,
      ClassIsInherited: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsTombstone: u32 = unsafe { ::core::mem::transmute(IsTombstone) };
         IsTombstone as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsSupersedeLocal: u32 = unsafe { ::core::mem::transmute(IsSupersedeLocal) };
         IsSupersedeLocal as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IsSupersedeTree: u32 = unsafe { ::core::mem::transmute(IsSupersedeTree) };
         IsSupersedeTree as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ClassIsInherited: u32 = unsafe { ::core::mem::transmute(ClassIsInherited) };
         ClassIsInherited as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type KEY_SET_LAYER_INFORMATION = _KEY_SET_LAYER_INFORMATION;
pub type PKEY_SET_LAYER_INFORMATION = *mut _KEY_SET_LAYER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_CONTROL_FLAGS_INFORMATION {
   pub ControlFlags: ULONG,
}
pub type KEY_CONTROL_FLAGS_INFORMATION = _KEY_CONTROL_FLAGS_INFORMATION;
pub type PKEY_CONTROL_FLAGS_INFORMATION = *mut _KEY_CONTROL_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_SET_VIRTUALIZATION_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_SET_VIRTUALIZATION_INFORMATION {
   #[inline]
   pub fn VirtualTarget(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualTarget(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VirtualStore(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualStore(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VirtualSource(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualSource(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      VirtualTarget: ULONG,
      VirtualStore: ULONG,
      VirtualSource: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let VirtualTarget: u32 = unsafe { ::core::mem::transmute(VirtualTarget) };
         VirtualTarget as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let VirtualStore: u32 = unsafe { ::core::mem::transmute(VirtualStore) };
         VirtualStore as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let VirtualSource: u32 = unsafe { ::core::mem::transmute(VirtualSource) };
         VirtualSource as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type KEY_SET_VIRTUALIZATION_INFORMATION = _KEY_SET_VIRTUALIZATION_INFORMATION;
pub type PKEY_SET_VIRTUALIZATION_INFORMATION = *mut _KEY_SET_VIRTUALIZATION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KEY_VALUE_INFORMATION_CLASS {
   KeyValueBasicInformation = 0,
   KeyValueFullInformation = 1,
   KeyValuePartialInformation = 2,
   KeyValueFullInformationAlign64 = 3,
   KeyValuePartialInformationAlign64 = 4,
   KeyValueLayerInformation = 5,
   MaxKeyValueInfoClass = 6,
}
pub use self::_KEY_VALUE_INFORMATION_CLASS as KEY_VALUE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VALUE_BASIC_INFORMATION {
   pub TitleIndex: ULONG,
   pub Type: ULONG,
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
pub type KEY_VALUE_BASIC_INFORMATION = _KEY_VALUE_BASIC_INFORMATION;
pub type PKEY_VALUE_BASIC_INFORMATION = *mut _KEY_VALUE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VALUE_FULL_INFORMATION {
   pub TitleIndex: ULONG,
   pub Type: ULONG,
   pub DataOffset: ULONG,
   pub DataLength: ULONG,
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
pub type KEY_VALUE_FULL_INFORMATION = _KEY_VALUE_FULL_INFORMATION;
pub type PKEY_VALUE_FULL_INFORMATION = *mut _KEY_VALUE_FULL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VALUE_PARTIAL_INFORMATION {
   pub TitleIndex: ULONG,
   pub Type: ULONG,
   pub DataLength: ULONG,
   pub Data: [UCHAR; 1usize],
}
pub type KEY_VALUE_PARTIAL_INFORMATION = _KEY_VALUE_PARTIAL_INFORMATION;
pub type PKEY_VALUE_PARTIAL_INFORMATION = *mut _KEY_VALUE_PARTIAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
   pub Type: ULONG,
   pub DataLength: ULONG,
   pub Data: [UCHAR; 1usize],
}
pub type KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 = _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64;
pub type PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64 = *mut _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VALUE_LAYER_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_VALUE_LAYER_INFORMATION {
   #[inline]
   pub fn IsTombstone(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsTombstone(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsTombstone: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsTombstone: u32 = unsafe { ::core::mem::transmute(IsTombstone) };
         IsTombstone as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type KEY_VALUE_LAYER_INFORMATION = _KEY_VALUE_LAYER_INFORMATION;
pub type PKEY_VALUE_LAYER_INFORMATION = *mut _KEY_VALUE_LAYER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CM_EXTENDED_PARAMETER_TYPE {
   CmExtendedParameterInvalidType = 0,
   CmExtendedParameterTrustClassKey = 1,
   CmExtendedParameterEvent = 2,
   CmExtendedParameterFileAccessToken = 3,
   CmExtendedParameterMax = 4,
}
pub use self::_CM_EXTENDED_PARAMETER_TYPE as CM_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_EXTENDED_PARAMETER {
   pub __bindgen_anon_1: _CM_EXTENDED_PARAMETER__bindgen_ty_1,
   pub __bindgen_anon_2: _CM_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_EXTENDED_PARAMETER__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _CM_EXTENDED_PARAMETER__bindgen_ty_1 {
   #[inline]
   pub fn Type(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 56u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Type: ULONG64, Reserved: ULONG64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Type: u64 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(8usize, 56u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_EXTENDED_PARAMETER__bindgen_ty_2 {
   pub ULong64: ULONG64,
   pub Pointer: PVOID,
   pub Size: SIZE_T,
   pub Handle: HANDLE,
   pub ULong: ULONG,
   pub AccessMask: ACCESS_MASK,
}
impl Default for _CM_EXTENDED_PARAMETER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _CM_EXTENDED_PARAMETER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CM_EXTENDED_PARAMETER = _CM_EXTENDED_PARAMETER;
pub type PCM_EXTENDED_PARAMETER = *mut _CM_EXTENDED_PARAMETER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_ENTRY {
   pub ValueName: PUNICODE_STRING,
   pub DataLength: ULONG,
   pub DataOffset: ULONG,
   pub Type: ULONG,
}
impl Default for _KEY_VALUE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_VALUE_ENTRY = _KEY_VALUE_ENTRY;
pub type PKEY_VALUE_ENTRY = *mut _KEY_VALUE_ENTRY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _REG_ACTION {
   KeyAdded = 0,
   KeyRemoved = 1,
   KeyModified = 2,
}
pub use self::_REG_ACTION as REG_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_NOTIFY_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub Action: REG_ACTION,
   pub KeyLength: ULONG,
   pub Key: [WCHAR; 1usize],
}
impl Default for _REG_NOTIFY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type REG_NOTIFY_INFORMATION = _REG_NOTIFY_INFORMATION;
pub type PREG_NOTIFY_INFORMATION = *mut _REG_NOTIFY_INFORMATION;
#[repr(C)]
pub struct _KEY_PID_ARRAY {
   pub ProcessId: HANDLE,
   pub KeyName: UNICODE_STRING,
}
impl Default for _KEY_PID_ARRAY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_PID_ARRAY = _KEY_PID_ARRAY;
pub type PKEY_PID_ARRAY = *mut _KEY_PID_ARRAY;
#[repr(C)]
pub struct _KEY_OPEN_SUBKEYS_INFORMATION {
   pub Count: ULONG,
   pub KeyArray: [KEY_PID_ARRAY; 1usize],
}
impl Default for _KEY_OPEN_SUBKEYS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_OPEN_SUBKEYS_INFORMATION = _KEY_OPEN_SUBKEYS_INFORMATION;
pub type PKEY_OPEN_SUBKEYS_INFORMATION = *mut _KEY_OPEN_SUBKEYS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_INITIALIZE_JOB_FOR_VREG {
   pub Job: HANDLE,
}
impl Default for _VR_INITIALIZE_JOB_FOR_VREG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_INITIALIZE_JOB_FOR_VREG = _VR_INITIALIZE_JOB_FOR_VREG;
pub type PVR_INITIALIZE_JOB_FOR_VREG = *mut _VR_INITIALIZE_JOB_FOR_VREG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_LOAD_DIFFERENCING_HIVE {
   pub Job: HANDLE,
   pub NextLayerIsHost: ULONG,
   pub Flags: ULONG,
   pub LoadFlags: ULONG,
   pub KeyPathLength: WORD,
   pub HivePathLength: WORD,
   pub NextLayerKeyPathLength: WORD,
   pub FileAccessToken: HANDLE,
   pub Strings: [WCHAR; 1usize],
}
impl Default for _VR_LOAD_DIFFERENCING_HIVE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_LOAD_DIFFERENCING_HIVE = _VR_LOAD_DIFFERENCING_HIVE;
pub type PVR_LOAD_DIFFERENCING_HIVE = *mut _VR_LOAD_DIFFERENCING_HIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_CREATE_NAMESPACE_NODE {
   pub Job: HANDLE,
   pub ContainerPathLength: WORD,
   pub HostPathLength: WORD,
   pub Flags: ULONG,
   pub AccessMask: ACCESS_MASK,
   pub Strings: [WCHAR; 1usize],
}
impl Default for _VR_CREATE_NAMESPACE_NODE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_CREATE_NAMESPACE_NODE = _VR_CREATE_NAMESPACE_NODE;
pub type PVR_CREATE_NAMESPACE_NODE = *mut _VR_CREATE_NAMESPACE_NODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_MODIFY_FLAGS {
   pub Job: HANDLE,
   pub AddFlags: ULONG,
   pub RemoveFlags: ULONG,
}
impl Default for _VR_MODIFY_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_MODIFY_FLAGS = _VR_MODIFY_FLAGS;
pub type PVR_MODIFY_FLAGS = *mut _VR_MODIFY_FLAGS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NAMESPACE_NODE_DATA {
   pub AccessMask: ACCESS_MASK,
   pub ContainerPathLength: WORD,
   pub HostPathLength: WORD,
   pub Flags: ULONG,
   pub Strings: [WCHAR; 1usize],
}
pub type NAMESPACE_NODE_DATA = _NAMESPACE_NODE_DATA;
pub type PNAMESPACE_NODE_DATA = *mut _NAMESPACE_NODE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_CREATE_MULTIPLE_NAMESPACE_NODES {
   pub Job: HANDLE,
   pub NumNewKeys: ULONG,
   pub Keys: [NAMESPACE_NODE_DATA; 1usize],
}
impl Default for _VR_CREATE_MULTIPLE_NAMESPACE_NODES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_CREATE_MULTIPLE_NAMESPACE_NODES = _VR_CREATE_MULTIPLE_NAMESPACE_NODES;
pub type PVR_CREATE_MULTIPLE_NAMESPACE_NODES = *mut _VR_CREATE_MULTIPLE_NAMESPACE_NODES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_UNLOAD_DYNAMICALLY_LOADED_HIVES {
   pub Job: HANDLE,
}
impl Default for _VR_UNLOAD_DYNAMICALLY_LOADED_HIVES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_UNLOAD_DYNAMICALLY_LOADED_HIVES = _VR_UNLOAD_DYNAMICALLY_LOADED_HIVES;
pub type PVR_UNLOAD_DYNAMICALLY_LOADED_HIVES = *mut _VR_UNLOAD_DYNAMICALLY_LOADED_HIVES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_GET_VIRTUAL_ROOT {
   pub Job: HANDLE,
   pub Index: ULONG,
}
impl Default for _VR_GET_VIRTUAL_ROOT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_GET_VIRTUAL_ROOT = _VR_GET_VIRTUAL_ROOT;
pub type PVR_GET_VIRTUAL_ROOT = *mut _VR_GET_VIRTUAL_ROOT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_GET_VIRTUAL_ROOT_RESULT {
   pub Key: HANDLE,
}
impl Default for _VR_GET_VIRTUAL_ROOT_RESULT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_GET_VIRTUAL_ROOT_RESULT = _VR_GET_VIRTUAL_ROOT_RESULT;
pub type PVR_GET_VIRTUAL_ROOT_RESULT = *mut _VR_GET_VIRTUAL_ROOT_RESULT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_LOAD_DIFFERENCING_HIVE_FOR_HOST {
   pub LoadFlags: ULONG,
   pub Flags: ULONG,
   pub KeyPathLength: WORD,
   pub HivePathLength: WORD,
   pub NextLayerKeyPathLength: WORD,
   pub FileAccessToken: HANDLE,
   pub Strings: [WCHAR; 1usize],
}
impl Default for _VR_LOAD_DIFFERENCING_HIVE_FOR_HOST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_LOAD_DIFFERENCING_HIVE_FOR_HOST = _VR_LOAD_DIFFERENCING_HIVE_FOR_HOST;
pub type PVR_LOAD_DIFFERENCING_HIVE_FOR_HOST = *mut _VR_LOAD_DIFFERENCING_HIVE_FOR_HOST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VR_UNLOAD_DIFFERENCING_HIVE_FOR_HOST {
   pub Reserved: ULONG,
   pub TargetKeyPathLength: WORD,
   pub TargetKeyPath: [WCHAR; 1usize],
}
pub type VR_UNLOAD_DIFFERENCING_HIVE_FOR_HOST = _VR_UNLOAD_DIFFERENCING_HIVE_FOR_HOST;
pub type PVR_UNLOAD_DIFFERENCING_HIVE_FOR_HOST = *mut _VR_UNLOAD_DIFFERENCING_HIVE_FOR_HOST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TABLE_SEARCH_RESULT {
   TableEmptyTree = 0,
   TableFoundNode = 1,
   TableInsertAsLeft = 2,
   TableInsertAsRight = 3,
}
pub use self::_TABLE_SEARCH_RESULT as TABLE_SEARCH_RESULT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_GENERIC_COMPARE_RESULTS {
   GenericLessThan = 0,
   GenericGreaterThan = 1,
   GenericEqual = 2,
}
pub use self::_RTL_GENERIC_COMPARE_RESULTS as RTL_GENERIC_COMPARE_RESULTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_AVL_TABLE {
   _unused: [u8; 0],
}
pub type PRTL_AVL_COMPARE_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      Table: *mut _RTL_AVL_TABLE,
      FirstStruct: PVOID,
      SecondStruct: PVOID,
   ) -> RTL_GENERIC_COMPARE_RESULTS,
>;
pub type PRTL_AVL_ALLOCATE_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(Table: *mut _RTL_AVL_TABLE, ByteSize: CLONG) -> PVOID,
>;
pub type PRTL_AVL_FREE_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(Table: *mut _RTL_AVL_TABLE, Buffer: PVOID)>;
pub type PRTL_AVL_MATCH_FUNCTION = ::core::option::Option<
   unsafe extern "C" fn(Table: *mut _RTL_AVL_TABLE, UserData: PVOID, MatchData: PVOID) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BALANCED_LINKS {
   pub Parent: *mut _RTL_BALANCED_LINKS,
   pub LeftChild: *mut _RTL_BALANCED_LINKS,
   pub RightChild: *mut _RTL_BALANCED_LINKS,
   pub Balance: CHAR,
   pub Reserved: [UCHAR; 3usize],
}
impl Default for _RTL_BALANCED_LINKS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BALANCED_LINKS = _RTL_BALANCED_LINKS;
pub type PRTL_BALANCED_LINKS = *mut _RTL_BALANCED_LINKS;
pub type RTL_AVL_TABLE = _RTL_AVL_TABLE;
pub type PRTL_AVL_TABLE = *mut _RTL_AVL_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SPLAY_LINKS {
   pub Parent: *mut _RTL_SPLAY_LINKS,
   pub LeftChild: *mut _RTL_SPLAY_LINKS,
   pub RightChild: *mut _RTL_SPLAY_LINKS,
}
impl Default for _RTL_SPLAY_LINKS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SPLAY_LINKS = _RTL_SPLAY_LINKS;
pub type PRTL_SPLAY_LINKS = *mut _RTL_SPLAY_LINKS;
pub type PRTL_GENERIC_COMPARE_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      Table: *mut _RTL_GENERIC_TABLE,
      FirstStruct: PVOID,
      SecondStruct: PVOID,
   ) -> RTL_GENERIC_COMPARE_RESULTS,
>;
pub type PRTL_GENERIC_ALLOCATE_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(Table: *mut _RTL_GENERIC_TABLE, ByteSize: CLONG) -> PVOID,
>;
pub type PRTL_GENERIC_FREE_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(Table: *mut _RTL_GENERIC_TABLE, Buffer: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_GENERIC_TABLE {
   pub TableRoot: PRTL_SPLAY_LINKS,
   pub InsertOrderList: LIST_ENTRY,
   pub OrderedPointer: PLIST_ENTRY,
   pub WhichOrderedElement: ULONG,
   pub NumberGenericTableElements: ULONG,
   pub CompareRoutine: PRTL_GENERIC_COMPARE_ROUTINE,
   pub AllocateRoutine: PRTL_GENERIC_ALLOCATE_ROUTINE,
   pub FreeRoutine: PRTL_GENERIC_FREE_ROUTINE,
   pub TableContext: PVOID,
}
impl Default for _RTL_GENERIC_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_GENERIC_TABLE = _RTL_GENERIC_TABLE;
pub type PRTL_GENERIC_TABLE = *mut _RTL_GENERIC_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_RB_TREE {
   pub Root: PRTL_BALANCED_NODE,
   pub Min: PRTL_BALANCED_NODE,
}
impl Default for _RTL_RB_TREE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_RB_TREE = _RTL_RB_TREE;
pub type PRTL_RB_TREE = *mut _RTL_RB_TREE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENTRY {
   pub Linkage: LIST_ENTRY,
   pub Signature: ULONG_PTR,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DYNAMIC_HASH_TABLE_ENTRY = _RTL_DYNAMIC_HASH_TABLE_ENTRY;
pub type PRTL_DYNAMIC_HASH_TABLE_ENTRY = *mut _RTL_DYNAMIC_HASH_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
   pub ChainHead: PLIST_ENTRY,
   pub PrevLinkage: PLIST_ENTRY,
   pub Signature: ULONG_PTR,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DYNAMIC_HASH_TABLE_CONTEXT = _RTL_DYNAMIC_HASH_TABLE_CONTEXT;
pub type PRTL_DYNAMIC_HASH_TABLE_CONTEXT = *mut _RTL_DYNAMIC_HASH_TABLE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
   pub HashEntry: RTL_DYNAMIC_HASH_TABLE_ENTRY,
   pub ChainHead: PLIST_ENTRY,
   pub BucketIndex: ULONG,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DYNAMIC_HASH_TABLE_ENUMERATOR = _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR;
pub type PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR = *mut _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE {
   pub Flags: ULONG,
   pub Shift: ULONG,
   pub TableSize: ULONG,
   pub Pivot: ULONG,
   pub DivisorMask: ULONG,
   pub NumEntries: ULONG,
   pub NonEmptyBuckets: ULONG,
   pub NumEnumerators: ULONG,
   pub Directory: PVOID,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DYNAMIC_HASH_TABLE = _RTL_DYNAMIC_HASH_TABLE;
pub type PRTL_DYNAMIC_HASH_TABLE = *mut _RTL_DYNAMIC_HASH_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_RESOURCE {
   pub CriticalSection: RTL_CRITICAL_SECTION,
   pub SharedSemaphore: HANDLE,
   pub NumberOfWaitingShared: ULONG,
   pub ExclusiveSemaphore: HANDLE,
   pub NumberOfWaitingExclusive: ULONG,
   pub NumberOfActive: LONG,
   pub ExclusiveOwnerThread: HANDLE,
   pub Flags: ULONG,
   pub DebugInfo: PRTL_RESOURCE_DEBUG,
}
impl Default for _RTL_RESOURCE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_RESOURCE = _RTL_RESOURCE;
pub type PRTL_RESOURCE = *mut _RTL_RESOURCE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_NORM_FORM {
   NormOther = 0,
   NormC = 1,
   NormD = 2,
   NormKC = 5,
   NormKD = 6,
   NormIdna = 13,
   DisallowUnassigned = 256,
   NormCDisallowUnassigned = 257,
   NormDDisallowUnassigned = 258,
   NormKCDisallowUnassigned = 261,
   NormKDDisallowUnassigned = 262,
   NormIdnaDisallowUnassigned = 269,
}
pub use self::_RTL_NORM_FORM as RTL_NORM_FORM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PREFIX_TABLE_ENTRY {
   pub NodeTypeCode: CSHORT,
   pub NameLength: CSHORT,
   pub NextPrefixTree: *mut _PREFIX_TABLE_ENTRY,
   pub Links: RTL_SPLAY_LINKS,
   pub Prefix: PSTRING,
}
impl Default for _PREFIX_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PREFIX_TABLE_ENTRY = _PREFIX_TABLE_ENTRY;
pub type PPREFIX_TABLE_ENTRY = *mut _PREFIX_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PREFIX_TABLE {
   pub NodeTypeCode: CSHORT,
   pub NameLength: CSHORT,
   pub NextPrefixTree: PPREFIX_TABLE_ENTRY,
}
impl Default for _PREFIX_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PREFIX_TABLE = _PREFIX_TABLE;
pub type PPREFIX_TABLE = *mut _PREFIX_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_PREFIX_TABLE_ENTRY {
   pub NodeTypeCode: CSHORT,
   pub NameLength: CSHORT,
   pub NextPrefixTree: *mut _UNICODE_PREFIX_TABLE_ENTRY,
   pub CaseMatch: *mut _UNICODE_PREFIX_TABLE_ENTRY,
   pub Links: RTL_SPLAY_LINKS,
   pub Prefix: PUNICODE_STRING,
}
impl Default for _UNICODE_PREFIX_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type UNICODE_PREFIX_TABLE_ENTRY = _UNICODE_PREFIX_TABLE_ENTRY;
pub type PUNICODE_PREFIX_TABLE_ENTRY = *mut _UNICODE_PREFIX_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_PREFIX_TABLE {
   pub NodeTypeCode: CSHORT,
   pub NameLength: CSHORT,
   pub NextPrefixTree: PUNICODE_PREFIX_TABLE_ENTRY,
   pub LastNextEntry: PUNICODE_PREFIX_TABLE_ENTRY,
}
impl Default for _UNICODE_PREFIX_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type UNICODE_PREFIX_TABLE = _UNICODE_PREFIX_TABLE;
pub type PUNICODE_PREFIX_TABLE = *mut _UNICODE_PREFIX_TABLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _COMPRESSED_DATA_INFO {
   pub CompressionFormatAndEngine: USHORT,
   pub CompressionUnitShift: UCHAR,
   pub ChunkShift: UCHAR,
   pub ClusterShift: UCHAR,
   pub Reserved: UCHAR,
   pub NumberOfChunks: USHORT,
   pub CompressedChunkSizes: [ULONG; 1usize],
}
pub type COMPRESSED_DATA_INFO = _COMPRESSED_DATA_INFO;
pub type PCOMPRESSED_DATA_INFO = *mut _COMPRESSED_DATA_INFO;
#[repr(C)]
pub struct _CURDIR {
   pub DosPath: UNICODE_STRING,
   pub Handle: HANDLE,
}
impl Default for _CURDIR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CURDIR = _CURDIR;
pub type PCURDIR = *mut _CURDIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DRIVE_LETTER_CURDIR {
   pub Flags: USHORT,
   pub Length: USHORT,
   pub TimeStamp: ULONG,
   pub DosPath: STRING,
}
impl Default for _RTL_DRIVE_LETTER_CURDIR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DRIVE_LETTER_CURDIR = _RTL_DRIVE_LETTER_CURDIR;
pub type PRTL_DRIVE_LETTER_CURDIR = *mut _RTL_DRIVE_LETTER_CURDIR;
#[repr(C)]
pub struct _RTL_USER_PROCESS_PARAMETERS {
   pub MaximumLength: ULONG,
   pub Length: ULONG,
   pub Flags: ULONG,
   pub DebugFlags: ULONG,
   pub ConsoleHandle: HANDLE,
   pub ConsoleFlags: ULONG,
   pub StandardInput: HANDLE,
   pub StandardOutput: HANDLE,
   pub StandardError: HANDLE,
   pub CurrentDirectory: CURDIR,
   pub DllPath: UNICODE_STRING,
   pub ImagePathName: UNICODE_STRING,
   pub CommandLine: UNICODE_STRING,
   pub Environment: PVOID,
   pub StartingX: ULONG,
   pub StartingY: ULONG,
   pub CountX: ULONG,
   pub CountY: ULONG,
   pub CountCharsX: ULONG,
   pub CountCharsY: ULONG,
   pub FillAttribute: ULONG,
   pub WindowFlags: ULONG,
   pub ShowWindowFlags: ULONG,
   pub WindowTitle: UNICODE_STRING,
   pub DesktopInfo: UNICODE_STRING,
   pub ShellInfo: UNICODE_STRING,
   pub RuntimeData: UNICODE_STRING,
   pub CurrentDirectories: [RTL_DRIVE_LETTER_CURDIR; 32usize],
   pub EnvironmentSize: ULONG_PTR,
   pub EnvironmentVersion: ULONG_PTR,
   pub PackageDependencyData: PVOID,
   pub ProcessGroupId: ULONG,
   pub LoaderThreads: ULONG,
   pub RedirectionDllName: UNICODE_STRING,
   pub HeapPartitionName: UNICODE_STRING,
   pub DefaultThreadpoolCpuSetMasks: ULONG_PTR,
   pub DefaultThreadpoolCpuSetMaskCount: ULONG,
   pub DefaultThreadpoolThreadMaximum: ULONG,
   pub HeapMemoryTypeMask: ULONG,
}
impl Default for _RTL_USER_PROCESS_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_USER_PROCESS_PARAMETERS = _RTL_USER_PROCESS_PARAMETERS;
#[repr(C)]
pub struct _RTL_USER_PROCESS_INFORMATION {
   pub Length: ULONG,
   pub ProcessHandle: HANDLE,
   pub ThreadHandle: HANDLE,
   pub ClientId: CLIENT_ID,
   pub ImageInformation: SECTION_IMAGE_INFORMATION,
}
impl Default for _RTL_USER_PROCESS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_USER_PROCESS_INFORMATION = _RTL_USER_PROCESS_INFORMATION;
pub type PRTL_USER_PROCESS_INFORMATION = *mut _RTL_USER_PROCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_USER_PROCESS_EXTENDED_PARAMETERS {
   pub Version: USHORT,
   pub NodeNumber: USHORT,
   pub ProcessSecurityDescriptor: PSECURITY_DESCRIPTOR,
   pub ThreadSecurityDescriptor: PSECURITY_DESCRIPTOR,
   pub ParentProcess: HANDLE,
   pub DebugPort: HANDLE,
   pub TokenHandle: HANDLE,
   pub JobHandle: HANDLE,
}
impl Default for _RTL_USER_PROCESS_EXTENDED_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_USER_PROCESS_EXTENDED_PARAMETERS = _RTL_USER_PROCESS_EXTENDED_PARAMETERS;
pub type PRTL_USER_PROCESS_EXTENDED_PARAMETERS = *mut _RTL_USER_PROCESS_EXTENDED_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION {
   pub ReflectionProcessHandle: HANDLE,
   pub ReflectionThreadHandle: HANDLE,
   pub ReflectionClientId: CLIENT_ID,
}
impl Default for _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION =
   _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;
pub type PRTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION =
   *mut _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;
pub type PROCESS_REFLECTION_INFORMATION = RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;
pub type PPROCESS_REFLECTION_INFORMATION = *mut RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CONTEXT_CHUNK {
   pub Offset: LONG,
   pub Length: ULONG,
}
pub type CONTEXT_CHUNK = _CONTEXT_CHUNK;
pub type PCONTEXT_CHUNK = *mut _CONTEXT_CHUNK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CONTEXT_EX {
   pub All: CONTEXT_CHUNK,
   pub Legacy: CONTEXT_CHUNK,
   pub XState: CONTEXT_CHUNK,
   pub KernelCet: CONTEXT_CHUNK,
}
pub type CONTEXT_EX = _CONTEXT_EX;
pub type PCONTEXT_EX = *mut _CONTEXT_EX;
pub type PRTLP_UNHANDLED_EXCEPTION_FILTER =
   ::core::option::Option<unsafe extern "C" fn(ExceptionInfo: PEXCEPTION_POINTERS) -> ULONG>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FUNCTION_TABLE_TYPE {
   RF_SORTED = 0,
   RF_UNSORTED = 1,
   RF_CALLBACK = 2,
   RF_KERNEL_DYNAMIC = 3,
}
pub use self::_FUNCTION_TABLE_TYPE as FUNCTION_TABLE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DYNAMIC_FUNCTION_TABLE {
   pub ListEntry: LIST_ENTRY,
   pub FunctionTable: PRUNTIME_FUNCTION,
   pub TimeStamp: LARGE_INTEGER,
   pub MinimumAddress: ULONG64,
   pub MaximumAddress: ULONG64,
   pub BaseAddress: ULONG64,
   pub Callback: PGET_RUNTIME_FUNCTION_CALLBACK,
   pub Context: PVOID,
   pub OutOfProcessCallbackDll: PWSTR,
   pub Type: FUNCTION_TABLE_TYPE,
   pub EntryCount: ULONG,
   pub TreeNodeMin: RTL_BALANCED_NODE,
   pub TreeNodeMax: RTL_BALANCED_NODE,
}
impl Default for _DYNAMIC_FUNCTION_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DYNAMIC_FUNCTION_TABLE = _DYNAMIC_FUNCTION_TABLE;
pub type PDYNAMIC_FUNCTION_TABLE = *mut _DYNAMIC_FUNCTION_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_CURDIR_REF {
   pub ReferenceCount: LONG,
   pub DirectoryHandle: HANDLE,
}
impl Default for _RTLP_CURDIR_REF {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_CURDIR_REF = _RTLP_CURDIR_REF;
pub type PRTLP_CURDIR_REF = *mut _RTLP_CURDIR_REF;
#[repr(C)]
pub struct _RTL_RELATIVE_NAME_U {
   pub RelativeName: UNICODE_STRING,
   pub ContainingDirectory: HANDLE,
   pub CurDirRef: PRTLP_CURDIR_REF,
}
impl Default for _RTL_RELATIVE_NAME_U {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_RELATIVE_NAME_U = _RTL_RELATIVE_NAME_U;
pub type PRTL_RELATIVE_NAME_U = *mut _RTL_RELATIVE_NAME_U;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_PATH_TYPE {
   RtlPathTypeUnknown = 0,
   RtlPathTypeUncAbsolute = 1,
   RtlPathTypeDriveAbsolute = 2,
   RtlPathTypeDriveRelative = 3,
   RtlPathTypeRooted = 4,
   RtlPathTypeRelative = 5,
   RtlPathTypeLocalDevice = 6,
   RtlPathTypeRootLocalDevice = 7,
}
pub use self::_RTL_PATH_TYPE as RTL_PATH_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BUFFER {
   pub Buffer: PUCHAR,
   pub StaticBuffer: PUCHAR,
   pub Size: SIZE_T,
   pub StaticSize: SIZE_T,
}
impl Default for _RTL_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BUFFER = _RTL_BUFFER;
pub type PRTL_BUFFER = *mut _RTL_BUFFER;
#[repr(C)]
pub struct _RTL_UNICODE_STRING_BUFFER {
   pub String: UNICODE_STRING,
   pub ByteBuffer: RTL_BUFFER,
   pub MinimumStaticBufferForTerminalNul: [UCHAR; 2usize],
}
impl Default for _RTL_UNICODE_STRING_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_UNICODE_STRING_BUFFER = _RTL_UNICODE_STRING_BUFFER;
pub type PRTL_UNICODE_STRING_BUFFER = *mut _RTL_UNICODE_STRING_BUFFER;
#[repr(C)]
pub struct _GENERATE_NAME_CONTEXT {
   pub Checksum: USHORT,
   pub CheckSumInserted: BOOLEAN,
   pub NameLength: UCHAR,
   pub NameBuffer: [WCHAR; 8usize],
   pub ExtensionLength: ULONG,
   pub ExtensionBuffer: [WCHAR; 4usize],
   pub LastIndexValue: ULONG,
}
impl Default for _GENERATE_NAME_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GENERATE_NAME_CONTEXT = _GENERATE_NAME_CONTEXT;
pub type PGENERATE_NAME_CONTEXT = *mut _GENERATE_NAME_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_HEAP_ENTRY {
   pub Size: SIZE_T,
   pub Flags: USHORT,
   pub AllocatorBackTraceIndex: USHORT,
   pub u: _RTL_HEAP_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_HEAP_ENTRY__bindgen_ty_1 {
   pub s1: _RTL_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1,
   pub s2: _RTL_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub Settable: SIZE_T,
   pub Tag: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   pub CommittedSize: SIZE_T,
   pub FirstBlock: PVOID,
}
impl Default for _RTL_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_HEAP_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_HEAP_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_ENTRY = _RTL_HEAP_ENTRY;
pub type PRTL_HEAP_ENTRY = *mut _RTL_HEAP_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_HEAP_TAG {
   pub NumberOfAllocations: ULONG,
   pub NumberOfFrees: ULONG,
   pub BytesAllocated: SIZE_T,
   pub TagIndex: USHORT,
   pub CreatorBackTraceIndex: USHORT,
   pub TagName: [WCHAR; 24usize],
}
pub type RTL_HEAP_TAG = _RTL_HEAP_TAG;
pub type PRTL_HEAP_TAG = *mut _RTL_HEAP_TAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_INFORMATION_V1 {
   pub BaseAddress: PVOID,
   pub Flags: ULONG,
   pub EntryOverhead: USHORT,
   pub CreatorBackTraceIndex: USHORT,
   pub BytesAllocated: SIZE_T,
   pub BytesCommitted: SIZE_T,
   pub NumberOfTags: ULONG,
   pub NumberOfEntries: ULONG,
   pub NumberOfPseudoTags: ULONG,
   pub PseudoTagGranularity: ULONG,
   pub Reserved: [ULONG; 5usize],
   pub Tags: PRTL_HEAP_TAG,
   pub Entries: PRTL_HEAP_ENTRY,
}
impl Default for _RTL_HEAP_INFORMATION_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_INFORMATION_V1 = _RTL_HEAP_INFORMATION_V1;
pub type PRTL_HEAP_INFORMATION_V1 = *mut _RTL_HEAP_INFORMATION_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_INFORMATION_V2 {
   pub BaseAddress: PVOID,
   pub Flags: ULONG,
   pub EntryOverhead: USHORT,
   pub CreatorBackTraceIndex: USHORT,
   pub BytesAllocated: SIZE_T,
   pub BytesCommitted: SIZE_T,
   pub NumberOfTags: ULONG,
   pub NumberOfEntries: ULONG,
   pub NumberOfPseudoTags: ULONG,
   pub PseudoTagGranularity: ULONG,
   pub Reserved: [ULONG; 5usize],
   pub Tags: PRTL_HEAP_TAG,
   pub Entries: PRTL_HEAP_ENTRY,
   pub HeapTag: ULONG64,
}
impl Default for _RTL_HEAP_INFORMATION_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_INFORMATION_V2 = _RTL_HEAP_INFORMATION_V2;
pub type PRTL_HEAP_INFORMATION_V2 = *mut _RTL_HEAP_INFORMATION_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_HEAPS_V1 {
   pub NumberOfHeaps: ULONG,
   pub Heaps: [RTL_HEAP_INFORMATION_V1; 1usize],
}
impl Default for _RTL_PROCESS_HEAPS_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_HEAPS_V1 = _RTL_PROCESS_HEAPS_V1;
pub type PRTL_PROCESS_HEAPS_V1 = *mut _RTL_PROCESS_HEAPS_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_HEAPS_V2 {
   pub NumberOfHeaps: ULONG,
   pub Heaps: [RTL_HEAP_INFORMATION_V2; 1usize],
}
impl Default for _RTL_PROCESS_HEAPS_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_HEAPS_V2 = _RTL_PROCESS_HEAPS_V2;
pub type PRTL_PROCESS_HEAPS_V2 = *mut _RTL_PROCESS_HEAPS_V2;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_MEMORY_TYPE {
   MemoryTypePaged = 0,
   MemoryTypeNonPaged = 1,
   MemoryType64KPage = 2,
   MemoryTypeLargePage = 3,
   MemoryTypeHugePage = 4,
   MemoryTypeCustom = 5,
   MemoryTypeMax = 6,
}
pub use self::_RTL_MEMORY_TYPE as RTL_MEMORY_TYPE;
pub type PRTL_MEMORY_TYPE = *mut _RTL_MEMORY_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HEAP_MEMORY_INFO_CLASS {
   HeapMemoryBasicInformation = 0,
}
pub use self::_HEAP_MEMORY_INFO_CLASS as HEAP_MEMORY_INFO_CLASS;
pub type ALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      CallbackContext: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      AllocationType: ULONG,
      PageProtection: ULONG,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS,
>;
pub type PALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK = ALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK;
pub type FREE_VIRTUAL_MEMORY_EX_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      CallbackContext: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      FreeType: ULONG,
   ) -> NTSTATUS,
>;
pub type PFREE_VIRTUAL_MEMORY_EX_CALLBACK = FREE_VIRTUAL_MEMORY_EX_CALLBACK;
pub type QUERY_VIRTUAL_MEMORY_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      CallbackContext: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      MemoryInformationClass: HEAP_MEMORY_INFO_CLASS,
      MemoryInformation: PVOID,
      MemoryInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS,
>;
pub type PQUERY_VIRTUAL_MEMORY_CALLBACK = QUERY_VIRTUAL_MEMORY_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SEGMENT_HEAP_VA_CALLBACKS {
   pub CallbackContext: HANDLE,
   pub AllocateVirtualMemory: PALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK,
   pub FreeVirtualMemory: PFREE_VIRTUAL_MEMORY_EX_CALLBACK,
   pub QueryVirtualMemory: PQUERY_VIRTUAL_MEMORY_CALLBACK,
}
impl Default for _RTL_SEGMENT_HEAP_VA_CALLBACKS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SEGMENT_HEAP_VA_CALLBACKS = _RTL_SEGMENT_HEAP_VA_CALLBACKS;
pub type PRTL_SEGMENT_HEAP_VA_CALLBACKS = *mut _RTL_SEGMENT_HEAP_VA_CALLBACKS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_SEGMENT_HEAP_MEMORY_SOURCE {
   pub Flags: ULONG,
   pub MemoryTypeMask: ULONG,
   pub NumaNode: ULONG,
   pub __bindgen_anon_1: _RTL_SEGMENT_HEAP_MEMORY_SOURCE__bindgen_ty_1,
   pub Reserved: [SIZE_T; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_SEGMENT_HEAP_MEMORY_SOURCE__bindgen_ty_1 {
   pub PartitionHandle: HANDLE,
   pub Callbacks: *mut RTL_SEGMENT_HEAP_VA_CALLBACKS,
}
impl Default for _RTL_SEGMENT_HEAP_MEMORY_SOURCE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_SEGMENT_HEAP_MEMORY_SOURCE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SEGMENT_HEAP_MEMORY_SOURCE = _RTL_SEGMENT_HEAP_MEMORY_SOURCE;
pub type PRTL_SEGMENT_HEAP_MEMORY_SOURCE = *mut _RTL_SEGMENT_HEAP_MEMORY_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_SEGMENT_HEAP_PARAMETERS {
   pub Version: USHORT,
   pub Size: USHORT,
   pub Flags: ULONG,
   pub MemorySource: RTL_SEGMENT_HEAP_MEMORY_SOURCE,
   pub Reserved: [SIZE_T; 4usize],
}
impl Default for _RTL_SEGMENT_HEAP_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SEGMENT_HEAP_PARAMETERS = _RTL_SEGMENT_HEAP_PARAMETERS;
pub type PRTL_SEGMENT_HEAP_PARAMETERS = *mut _RTL_SEGMENT_HEAP_PARAMETERS;
pub type PRTL_HEAP_COMMIT_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(arg1: PVOID, arg2: *mut PVOID, arg3: PSIZE_T) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_HEAP_PARAMETERS {
   pub Length: ULONG,
   pub SegmentReserve: SIZE_T,
   pub SegmentCommit: SIZE_T,
   pub DeCommitFreeBlockThreshold: SIZE_T,
   pub DeCommitTotalFreeThreshold: SIZE_T,
   pub MaximumAllocationSize: SIZE_T,
   pub VirtualMemoryThreshold: SIZE_T,
   pub InitialCommit: SIZE_T,
   pub InitialReserve: SIZE_T,
   pub CommitRoutine: PRTL_HEAP_COMMIT_ROUTINE,
   pub Reserved: [SIZE_T; 2usize],
}
pub type RTL_HEAP_PARAMETERS = _RTL_HEAP_PARAMETERS;
pub type PRTL_HEAP_PARAMETERS = *mut _RTL_HEAP_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_HEAP_TAG_INFO {
   pub NumberOfAllocations: ULONG,
   pub NumberOfFrees: ULONG,
   pub BytesAllocated: SIZE_T,
}
pub type RTL_HEAP_TAG_INFO = _RTL_HEAP_TAG_INFO;
pub type PRTL_HEAP_TAG_INFO = *mut _RTL_HEAP_TAG_INFO;
pub type PRTL_ENUM_HEAPS_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: PVOID) -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_USAGE_ENTRY {
   pub Next: *mut _RTL_HEAP_USAGE_ENTRY,
   pub Address: PVOID,
   pub Size: SIZE_T,
   pub AllocatorBackTraceIndex: USHORT,
   pub TagIndex: USHORT,
}
impl Default for _RTL_HEAP_USAGE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_USAGE_ENTRY = _RTL_HEAP_USAGE_ENTRY;
pub type PRTL_HEAP_USAGE_ENTRY = *mut _RTL_HEAP_USAGE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_USAGE {
   pub Length: ULONG,
   pub BytesAllocated: SIZE_T,
   pub BytesCommitted: SIZE_T,
   pub BytesReserved: SIZE_T,
   pub BytesReservedMaximum: SIZE_T,
   pub Entries: PRTL_HEAP_USAGE_ENTRY,
   pub AddedEntries: PRTL_HEAP_USAGE_ENTRY,
   pub RemovedEntries: PRTL_HEAP_USAGE_ENTRY,
   pub Reserved: [ULONG_PTR; 8usize],
}
impl Default for _RTL_HEAP_USAGE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_USAGE = _RTL_HEAP_USAGE;
pub type PRTL_HEAP_USAGE = *mut _RTL_HEAP_USAGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_HEAP_WALK_ENTRY {
   pub DataAddress: PVOID,
   pub DataSize: SIZE_T,
   pub OverheadBytes: UCHAR,
   pub SegmentIndex: UCHAR,
   pub Flags: USHORT,
   pub __bindgen_anon_1: _RTL_HEAP_WALK_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_HEAP_WALK_ENTRY__bindgen_ty_1 {
   pub Block: _RTL_HEAP_WALK_ENTRY__bindgen_ty_1__bindgen_ty_1,
   pub Segment: _RTL_HEAP_WALK_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_HEAP_WALK_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub Settable: SIZE_T,
   pub TagIndex: USHORT,
   pub AllocatorBackTraceIndex: USHORT,
   pub Reserved: [ULONG; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_WALK_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   pub CommittedSize: ULONG,
   pub UnCommittedSize: ULONG,
   pub FirstEntry: PVOID,
   pub LastEntry: PVOID,
}
impl Default for _RTL_HEAP_WALK_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_HEAP_WALK_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_HEAP_WALK_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_WALK_ENTRY = _RTL_HEAP_WALK_ENTRY;
pub type PRTL_HEAP_WALK_ENTRY = *mut _RTL_HEAP_WALK_ENTRY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HEAP_COMPATIBILITY_MODE {
   HEAP_COMPATIBILITY_STANDARD = 0,
   HEAP_COMPATIBILITY_LAL = 1,
   HEAP_COMPATIBILITY_LFH = 2,
}
pub use self::_HEAP_COMPATIBILITY_MODE as HEAP_COMPATIBILITY_MODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTLP_TAG_INFO {
   pub Id: GUID,
   pub CurrentAllocatedBytes: ULONG_PTR,
}
pub type RTLP_TAG_INFO = _RTLP_TAG_INFO;
pub type PRTLP_TAG_INFO = *mut _RTLP_TAG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_HEAP_TAGGING_INFO {
   pub Version: USHORT,
   pub Flags: USHORT,
   pub ProcessHandle: PVOID,
   pub EntriesCount: ULONG_PTR,
   pub Entries: [RTLP_TAG_INFO; 1usize],
}
impl Default for _RTLP_HEAP_TAGGING_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_HEAP_TAGGING_INFO = _RTLP_HEAP_TAGGING_INFO;
pub type PRTLP_HEAP_TAGGING_INFO = *mut _RTLP_HEAP_TAGGING_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_HEAP_INFORMATION {
   pub ReserveSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub NumberOfHeaps: ULONG,
   pub FirstHeapInformationOffset: ULONG_PTR,
}
pub type PROCESS_HEAP_INFORMATION = _PROCESS_HEAP_INFORMATION;
pub type PPROCESS_HEAP_INFORMATION = *mut _PROCESS_HEAP_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_REGION_INFORMATION {
   pub Address: PVOID,
   pub ReserveSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub FirstRangeInformationOffset: ULONG_PTR,
   pub NextRegionInformationOffset: ULONG_PTR,
}
impl Default for _HEAP_REGION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_REGION_INFORMATION = _HEAP_REGION_INFORMATION;
pub type PHEAP_REGION_INFORMATION = *mut _HEAP_REGION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_RANGE_INFORMATION {
   pub Address: PVOID,
   pub Size: SIZE_T,
   pub Type: ULONG,
   pub Protection: ULONG,
   pub FirstBlockInformationOffset: ULONG_PTR,
   pub NextRangeInformationOffset: ULONG_PTR,
}
impl Default for _HEAP_RANGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_RANGE_INFORMATION = _HEAP_RANGE_INFORMATION;
pub type PHEAP_RANGE_INFORMATION = *mut _HEAP_RANGE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_BLOCK_INFORMATION {
   pub Address: PVOID,
   pub Flags: ULONG,
   pub DataSize: SIZE_T,
   pub OverheadSize: ULONG_PTR,
   pub NextBlockInformationOffset: ULONG_PTR,
}
impl Default for _HEAP_BLOCK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_BLOCK_INFORMATION = _HEAP_BLOCK_INFORMATION;
pub type PHEAP_BLOCK_INFORMATION = *mut _HEAP_BLOCK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_INFORMATION {
   pub Address: PVOID,
   pub Mode: ULONG,
   pub ReserveSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub FirstRegionInformationOffset: ULONG_PTR,
   pub NextHeapInformationOffset: ULONG_PTR,
}
impl Default for _HEAP_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_INFORMATION = _HEAP_INFORMATION;
pub type PHEAP_INFORMATION = *mut _HEAP_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION {
   pub SegmentReserveSize: SIZE_T,
   pub SegmentCommitSize: SIZE_T,
   pub SegmentCount: ULONG_PTR,
   pub AllocatedSize: SIZE_T,
   pub LargeAllocReserveSize: SIZE_T,
   pub LargeAllocCommitSize: SIZE_T,
}
pub type SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION =
   _SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION;
pub type PSEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION =
   *mut _SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_PERFORMANCE_COUNTERS_INFORMATION {
   pub Size: ULONG,
   pub Version: ULONG,
   pub HeapIndex: ULONG,
   pub LastHeapIndex: ULONG,
   pub BaseAddress: PVOID,
   pub ReserveSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub SegmentCount: ULONG,
   pub LargeUCRMemory: SIZE_T,
   pub UCRLength: ULONG,
   pub AllocatedSpace: SIZE_T,
   pub FreeSpace: SIZE_T,
   pub FreeListLength: ULONG,
   pub Contention: ULONG,
   pub VirtualBlocks: ULONG,
   pub CommitRate: ULONG,
   pub DecommitRate: ULONG,
   pub SegmentHeapPerfInformation: SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION,
}
impl Default for _HEAP_PERFORMANCE_COUNTERS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_PERFORMANCE_COUNTERS_INFORMATION = _HEAP_PERFORMANCE_COUNTERS_INFORMATION;
pub type PHEAP_PERFORMANCE_COUNTERS_INFORMATION = *mut _HEAP_PERFORMANCE_COUNTERS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_INFORMATION_ITEM {
   pub Level: ULONG,
   pub Size: SIZE_T,
   pub __bindgen_anon_1: _HEAP_INFORMATION_ITEM__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_INFORMATION_ITEM__bindgen_ty_1 {
   pub ProcessHeapInformation: PROCESS_HEAP_INFORMATION,
   pub HeapInformation: HEAP_INFORMATION,
   pub HeapRegionInformation: HEAP_REGION_INFORMATION,
   pub HeapRangeInformation: HEAP_RANGE_INFORMATION,
   pub HeapBlockInformation: HEAP_BLOCK_INFORMATION,
   pub HeapPerfInformation: HEAP_PERFORMANCE_COUNTERS_INFORMATION,
   pub DynamicStart: ULONG_PTR,
}
impl Default for _HEAP_INFORMATION_ITEM__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _HEAP_INFORMATION_ITEM {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_INFORMATION_ITEM = _HEAP_INFORMATION_ITEM;
pub type PHEAP_INFORMATION_ITEM = *mut _HEAP_INFORMATION_ITEM;
pub type PRTL_HEAP_EXTENDED_ENUMERATION_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(Information: PHEAP_INFORMATION_ITEM, Context: PVOID) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_EXTENDED_INFORMATION {
   pub ProcessHandle: HANDLE,
   pub HeapHandle: PVOID,
   pub Level: ULONG,
   pub CallbackRoutine: PRTL_HEAP_EXTENDED_ENUMERATION_ROUTINE,
   pub CallbackContext: PVOID,
   pub __bindgen_anon_1: _HEAP_EXTENDED_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_EXTENDED_INFORMATION__bindgen_ty_1 {
   pub ProcessHeapInformation: PROCESS_HEAP_INFORMATION,
   pub HeapInformation: HEAP_INFORMATION,
}
impl Default for _HEAP_EXTENDED_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _HEAP_EXTENDED_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_EXTENDED_INFORMATION = _HEAP_EXTENDED_INFORMATION;
pub type PHEAP_EXTENDED_INFORMATION = *mut _HEAP_EXTENDED_INFORMATION;
pub type RTL_HEAP_STACK_WRITE_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(Information: PVOID, Size: ULONG, Context: PVOID) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT {
   pub Count: ULONG,
   pub Total: ULONG,
   pub Flags: ULONG,
}
pub type RTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT = _RTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT;
pub type PRTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT = *mut _RTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER {
   pub Version: USHORT,
   pub PointerSize: USHORT,
   pub Heap: PVOID,
   pub TotalCommit: SIZE_T,
   pub TotalReserve: SIZE_T,
}
impl Default for _RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER = _RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER;
pub type PRTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER =
   *mut _RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION {
   pub Address: PVOID,
   pub Flags: ULONG,
   pub DataSize: SIZE_T,
}
impl Default for _RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION =
   _RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION;
pub type PRTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION =
   *mut _RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME {
   pub StackFrame: [PVOID; 8usize],
}
impl Default for _RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME =
   _RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME;
pub type PRTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME =
   *mut _RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_STACK_QUERY {
   pub Version: ULONG,
   pub ProcessHandle: HANDLE,
   pub WriteRoutine: RTL_HEAP_STACK_WRITE_ROUTINE,
   pub SerializationContext: PVOID,
   pub QueryLevel: UCHAR,
   pub Flags: UCHAR,
}
impl Default for _RTL_HEAP_STACK_QUERY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_STACK_QUERY = _RTL_HEAP_STACK_QUERY;
pub type PRTL_HEAP_STACK_QUERY = *mut _RTL_HEAP_STACK_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_STACK_CONTROL {
   pub Version: USHORT,
   pub Flags: USHORT,
   pub ProcessHandle: HANDLE,
}
impl Default for _RTL_HEAP_STACK_CONTROL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_STACK_CONTROL = _RTL_HEAP_STACK_CONTROL;
pub type PRTL_HEAP_STACK_CONTROL = *mut _RTL_HEAP_STACK_CONTROL;
pub type PRTL_HEAP_DEBUGGING_INTERCEPTOR_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      HeapHandle: PVOID,
      Action: ULONG,
      StackFramesToCapture: ULONG,
      StackTrace: *mut PVOID,
   ) -> NTSTATUS,
>;
pub type PRTL_HEAP_LEAK_ENUMERATION_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      Reserved: LONG,
      HeapHandle: PVOID,
      BaseAddress: PVOID,
      BlockSize: SIZE_T,
      StackTraceDepth: ULONG,
      StackTrace: *mut PVOID,
   ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_DEBUGGING_INFORMATION {
   pub InterceptorFunction: PRTL_HEAP_DEBUGGING_INTERCEPTOR_ROUTINE,
   pub InterceptorValue: USHORT,
   pub ExtendedOptions: ULONG,
   pub StackTraceDepth: ULONG,
   pub MinTotalBlockSize: SIZE_T,
   pub MaxTotalBlockSize: SIZE_T,
   pub HeapLeakEnumerationRoutine: PRTL_HEAP_LEAK_ENUMERATION_ROUTINE,
}
pub type HEAP_DEBUGGING_INFORMATION = _HEAP_DEBUGGING_INFORMATION;
pub type PHEAP_DEBUGGING_INFORMATION = *mut _HEAP_DEBUGGING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_MEMORY_ZONE_SEGMENT {
   pub NextSegment: *mut _RTL_MEMORY_ZONE_SEGMENT,
   pub Size: SIZE_T,
   pub Next: PVOID,
   pub Limit: PVOID,
}
impl Default for _RTL_MEMORY_ZONE_SEGMENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_MEMORY_ZONE_SEGMENT = _RTL_MEMORY_ZONE_SEGMENT;
pub type PRTL_MEMORY_ZONE_SEGMENT = *mut _RTL_MEMORY_ZONE_SEGMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_MEMORY_ZONE {
   pub Segment: RTL_MEMORY_ZONE_SEGMENT,
   pub Lock: RTL_SRWLOCK,
   pub LockCount: ULONG,
   pub FirstSegment: PRTL_MEMORY_ZONE_SEGMENT,
}
impl Default for _RTL_MEMORY_ZONE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_MEMORY_ZONE = _RTL_MEMORY_ZONE;
pub type PRTL_MEMORY_ZONE = *mut _RTL_MEMORY_ZONE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_PROCESS_VERIFIER_OPTIONS {
   pub SizeStruct: ULONG,
   pub Option: ULONG,
   pub OptionData: [UCHAR; 1usize],
}
pub type RTL_PROCESS_VERIFIER_OPTIONS = _RTL_PROCESS_VERIFIER_OPTIONS;
pub type PRTL_PROCESS_VERIFIER_OPTIONS = *mut _RTL_PROCESS_VERIFIER_OPTIONS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_DEBUG_INFORMATION {
   pub SectionHandleClient: HANDLE,
   pub ViewBaseClient: PVOID,
   pub ViewBaseTarget: PVOID,
   pub ViewBaseDelta: ULONG_PTR,
   pub EventPairClient: HANDLE,
   pub EventPairTarget: HANDLE,
   pub TargetProcessId: HANDLE,
   pub TargetThreadHandle: HANDLE,
   pub Flags: ULONG,
   pub OffsetFree: SIZE_T,
   pub CommitSize: SIZE_T,
   pub ViewSize: SIZE_T,
   pub __bindgen_anon_1: _RTL_DEBUG_INFORMATION__bindgen_ty_1,
   pub BackTraces: PRTL_PROCESS_BACKTRACES,
   pub Heaps: PVOID,
   pub Locks: PRTL_PROCESS_LOCKS,
   pub SpecificHeap: PVOID,
   pub TargetProcessHandle: HANDLE,
   pub VerifierOptions: PRTL_PROCESS_VERIFIER_OPTIONS,
   pub ProcessHeap: PVOID,
   pub CriticalSectionHandle: HANDLE,
   pub CriticalSectionOwnerThread: HANDLE,
   pub Reserved: [PVOID; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_DEBUG_INFORMATION__bindgen_ty_1 {
   pub Modules: PRTL_PROCESS_MODULES,
   pub ModulesEx: PRTL_PROCESS_MODULE_INFORMATION_EX,
}
impl Default for _RTL_DEBUG_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_DEBUG_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DEBUG_INFORMATION = _RTL_DEBUG_INFORMATION;
pub type PRTL_DEBUG_INFORMATION = *mut _RTL_DEBUG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PARSE_MESSAGE_CONTEXT {
   pub fFlags: ULONG,
   pub cwSavColumn: ULONG,
   pub iwSrc: SIZE_T,
   pub iwDst: SIZE_T,
   pub iwDstSpace: SIZE_T,
   pub lpvArgStart: va_list,
}
impl Default for _PARSE_MESSAGE_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PARSE_MESSAGE_CONTEXT = _PARSE_MESSAGE_CONTEXT;
pub type PPARSE_MESSAGE_CONTEXT = *mut _PARSE_MESSAGE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
   _unused: [u8; 0],
}
pub type IN_ADDR = in_addr;
pub type PIN_ADDR = *mut in_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in6_addr {
   _unused: [u8; 0],
}
pub type IN6_ADDR = in6_addr;
pub type PIN6_ADDR = *mut in6_addr;
pub type PCIN_ADDR = *const IN_ADDR;
pub type PCIN6_ADDR = *const IN6_ADDR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TIME_FIELDS {
   pub Year: CSHORT,
   pub Month: CSHORT,
   pub Day: CSHORT,
   pub Hour: CSHORT,
   pub Minute: CSHORT,
   pub Second: CSHORT,
   pub Milliseconds: CSHORT,
   pub Weekday: CSHORT,
}
pub type TIME_FIELDS = _TIME_FIELDS;
pub type PTIME_FIELDS = *mut _TIME_FIELDS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_TIME_ZONE_INFORMATION {
   pub Bias: LONG,
   pub StandardName: [WCHAR; 32usize],
   pub StandardStart: TIME_FIELDS,
   pub StandardBias: LONG,
   pub DaylightName: [WCHAR; 32usize],
   pub DaylightStart: TIME_FIELDS,
   pub DaylightBias: LONG,
}
pub type RTL_TIME_ZONE_INFORMATION = _RTL_TIME_ZONE_INFORMATION;
pub type PRTL_TIME_ZONE_INFORMATION = *mut _RTL_TIME_ZONE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BITMAP {
   pub SizeOfBitMap: ULONG,
   pub Buffer: PULONG,
}
impl Default for _RTL_BITMAP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BITMAP = _RTL_BITMAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BITMAP_RUN {
   pub StartingIndex: ULONG,
   pub NumberOfBits: ULONG,
}
pub type RTL_BITMAP_RUN = _RTL_BITMAP_RUN;
pub type PRTL_BITMAP_RUN = *mut _RTL_BITMAP_RUN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BITMAP_EX {
   pub SizeOfBitMap: ULONG64,
   pub Buffer: PULONG64,
}
impl Default for _RTL_BITMAP_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BITMAP_EX = _RTL_BITMAP_EX;
pub type PRTL_BITMAP_EX = *mut _RTL_BITMAP_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_HANDLE_TABLE_ENTRY {
   pub __bindgen_anon_1: _RTL_HANDLE_TABLE_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_HANDLE_TABLE_ENTRY__bindgen_ty_1 {
   pub Flags: ULONG,
   pub NextFree: *mut _RTL_HANDLE_TABLE_ENTRY,
}
impl Default for _RTL_HANDLE_TABLE_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_HANDLE_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HANDLE_TABLE_ENTRY = _RTL_HANDLE_TABLE_ENTRY;
pub type PRTL_HANDLE_TABLE_ENTRY = *mut _RTL_HANDLE_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HANDLE_TABLE {
   pub MaximumNumberOfHandles: ULONG,
   pub SizeOfHandleTableEntry: ULONG,
   pub Reserved: [ULONG; 2usize],
   pub FreeHandles: PRTL_HANDLE_TABLE_ENTRY,
   pub CommittedHandles: PRTL_HANDLE_TABLE_ENTRY,
   pub UnCommittedHandles: PRTL_HANDLE_TABLE_ENTRY,
   pub MaxReservedHandles: PRTL_HANDLE_TABLE_ENTRY,
}
impl Default for _RTL_HANDLE_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HANDLE_TABLE = _RTL_HANDLE_TABLE;
pub type PRTL_HANDLE_TABLE = *mut _RTL_HANDLE_TABLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _COMPOUND_ACCESS_ALLOWED_ACE {
   pub Header: ACE_HEADER,
   pub Mask: ACCESS_MASK,
   pub CompoundAceType: USHORT,
   pub Reserved: USHORT,
   pub SidStart: ULONG,
}
pub type COMPOUND_ACCESS_ALLOWED_ACE = _COMPOUND_ACCESS_ALLOWED_ACE;
pub type PCOMPOUND_ACCESS_ALLOWED_ACE = *mut _COMPOUND_ACCESS_ALLOWED_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_ACE_DATA {
   pub AceType: UCHAR,
   pub InheritFlags: UCHAR,
   pub AceFlags: UCHAR,
   pub AccessMask: ACCESS_MASK,
   pub Sid: *mut PSID,
}
impl Default for _RTL_ACE_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_ACE_DATA = _RTL_ACE_DATA;
pub type PRTL_ACE_DATA = *mut _RTL_ACE_DATA;
pub type PRTL_START_POOL_THREAD = ::core::option::Option<
   unsafe extern "C" fn(arg1: PTHREAD_START_ROUTINE, arg2: PVOID, arg3: PHANDLE) -> NTSTATUS,
>;
pub type PRTL_EXIT_POOL_THREAD =
   ::core::option::Option<unsafe extern "C" fn(arg1: NTSTATUS) -> NTSTATUS>;
pub type PRTL_QUERY_REGISTRY_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      arg1: PWSTR,
      arg2: ULONG,
      arg3: PVOID,
      arg4: ULONG,
      arg5: PVOID,
      arg6: PVOID,
   ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_QUERY_REGISTRY_TABLE {
   pub QueryRoutine: PRTL_QUERY_REGISTRY_ROUTINE,
   pub Flags: ULONG,
   pub Name: PWSTR,
   pub EntryContext: PVOID,
   pub DefaultType: ULONG,
   pub DefaultData: PVOID,
   pub DefaultLength: ULONG,
}
impl Default for _RTL_QUERY_REGISTRY_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_QUERY_REGISTRY_TABLE = _RTL_QUERY_REGISTRY_TABLE;
pub type PRTL_QUERY_REGISTRY_TABLE = *mut _RTL_QUERY_REGISTRY_TABLE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_ELEVATION_FLAGS {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _RTL_ELEVATION_FLAGS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_ELEVATION_FLAGS__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _RTL_ELEVATION_FLAGS__bindgen_ty_1 {
   #[inline]
   pub fn ElevationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ElevationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn VirtualizationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualizationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InstallerDetectEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InstallerDetectEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ElevationEnabled: ULONG,
      VirtualizationEnabled: ULONG,
      InstallerDetectEnabled: ULONG,
      ReservedBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ElevationEnabled: u32 = unsafe { ::core::mem::transmute(ElevationEnabled) };
         ElevationEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let VirtualizationEnabled: u32 = unsafe { ::core::mem::transmute(VirtualizationEnabled) };
         VirtualizationEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let InstallerDetectEnabled: u32 =
            unsafe { ::core::mem::transmute(InstallerDetectEnabled) };
         InstallerDetectEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let ReservedBits: u32 = unsafe { ::core::mem::transmute(ReservedBits) };
         ReservedBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_ELEVATION_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_ELEVATION_FLAGS = _RTL_ELEVATION_FLAGS;
pub type PRTL_ELEVATION_FLAGS = *mut _RTL_ELEVATION_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_UNLOAD_EVENT_TRACE {
   pub BaseAddress: PVOID,
   pub SizeOfImage: SIZE_T,
   pub Sequence: ULONG,
   pub TimeDateStamp: ULONG,
   pub CheckSum: ULONG,
   pub ImageName: [WCHAR; 32usize],
   pub Version: [ULONG; 2usize],
}
impl Default for _RTL_UNLOAD_EVENT_TRACE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_UNLOAD_EVENT_TRACE = _RTL_UNLOAD_EVENT_TRACE;
pub type PRTL_UNLOAD_EVENT_TRACE = *mut _RTL_UNLOAD_EVENT_TRACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_UNLOAD_EVENT_TRACE32 {
   pub BaseAddress: ULONG,
   pub SizeOfImage: ULONG,
   pub Sequence: ULONG,
   pub TimeDateStamp: ULONG,
   pub CheckSum: ULONG,
   pub ImageName: [WCHAR; 32usize],
   pub Version: [ULONG; 2usize],
}
pub type RTL_UNLOAD_EVENT_TRACE32 = _RTL_UNLOAD_EVENT_TRACE32;
pub type PRTL_UNLOAD_EVENT_TRACE32 = *mut _RTL_UNLOAD_EVENT_TRACE32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IMAGE_MITIGATION_POLICY {
   ImageDepPolicy = 0,
   ImageAslrPolicy = 1,
   ImageDynamicCodePolicy = 2,
   ImageStrictHandleCheckPolicy = 3,
   ImageSystemCallDisablePolicy = 4,
   ImageMitigationOptionsMask = 5,
   ImageExtensionPointDisablePolicy = 6,
   ImageControlFlowGuardPolicy = 7,
   ImageSignaturePolicy = 8,
   ImageFontDisablePolicy = 9,
   ImageImageLoadPolicy = 10,
   ImagePayloadRestrictionPolicy = 11,
   ImageChildProcessPolicy = 12,
   ImageSehopPolicy = 13,
   ImageHeapPolicy = 14,
   ImageUserShadowStackPolicy = 15,
   ImageRedirectionTrustPolicy = 16,
   ImageUserPointerAuthPolicy = 17,
   MaxImageMitigationPolicy = 18,
}
pub use self::_IMAGE_MITIGATION_POLICY as IMAGE_MITIGATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_IMAGE_MITIGATION_POLICY {
   pub __bindgen_anon_1: _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_1,
   pub __bindgen_anon_2: _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_1 {
   #[inline]
   pub fn AuditState(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
   }
   #[inline]
   pub fn set_AuditState(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditFlag(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_AuditFlag(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableAdditionalAuditingOption(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_EnableAdditionalAuditingOption(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 60u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      AuditState: ULONG64,
      AuditFlag: ULONG64,
      EnableAdditionalAuditingOption: ULONG64,
      Reserved: ULONG64,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let AuditState: u64 = unsafe { ::core::mem::transmute(AuditState) };
         AuditState as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let AuditFlag: u64 = unsafe { ::core::mem::transmute(AuditFlag) };
         AuditFlag as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let EnableAdditionalAuditingOption: u64 =
            unsafe { ::core::mem::transmute(EnableAdditionalAuditingOption) };
         EnableAdditionalAuditingOption as u64
      });
      __bindgen_bitfield_unit.set(4usize, 60u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_2 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_2 {
   #[inline]
   pub fn PolicyState(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
   }
   #[inline]
   pub fn set_PolicyState(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn AlwaysInherit(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_AlwaysInherit(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EnableAdditionalPolicyOption(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_EnableAdditionalPolicyOption(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AuditReserved(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
   }
   #[inline]
   pub fn set_AuditReserved(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 60u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      PolicyState: ULONG64,
      AlwaysInherit: ULONG64,
      EnableAdditionalPolicyOption: ULONG64,
      AuditReserved: ULONG64,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let PolicyState: u64 = unsafe { ::core::mem::transmute(PolicyState) };
         PolicyState as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let AlwaysInherit: u64 = unsafe { ::core::mem::transmute(AlwaysInherit) };
         AlwaysInherit as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let EnableAdditionalPolicyOption: u64 =
            unsafe { ::core::mem::transmute(EnableAdditionalPolicyOption) };
         EnableAdditionalPolicyOption as u64
      });
      __bindgen_bitfield_unit.set(4usize, 60u8, {
         let AuditReserved: u64 = unsafe { ::core::mem::transmute(AuditReserved) };
         AuditReserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_IMAGE_MITIGATION_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_POLICY = _RTL_IMAGE_MITIGATION_POLICY;
pub type PRTL_IMAGE_MITIGATION_POLICY = *mut _RTL_IMAGE_MITIGATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_DEP_POLICY {
   pub Dep: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_DEP_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_DEP_POLICY = _RTL_IMAGE_MITIGATION_DEP_POLICY;
pub type PRTL_IMAGE_MITIGATION_DEP_POLICY = *mut _RTL_IMAGE_MITIGATION_DEP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_ASLR_POLICY {
   pub ForceRelocateImages: RTL_IMAGE_MITIGATION_POLICY,
   pub BottomUpRandomization: RTL_IMAGE_MITIGATION_POLICY,
   pub HighEntropyRandomization: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_ASLR_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_ASLR_POLICY = _RTL_IMAGE_MITIGATION_ASLR_POLICY;
pub type PRTL_IMAGE_MITIGATION_ASLR_POLICY = *mut _RTL_IMAGE_MITIGATION_ASLR_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY {
   pub BlockDynamicCode: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY = _RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY;
pub type PRTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY = *mut _RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
   pub StrictHandleChecks: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
   _RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub type PRTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
   *mut _RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
   pub BlockWin32kSystemCalls: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
   _RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub type PRTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
   *mut _RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
   pub DisableExtensionPoints: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
   _RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub type PRTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
   *mut _RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
   pub ControlFlowGuard: RTL_IMAGE_MITIGATION_POLICY,
   pub StrictControlFlowGuard: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
   _RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub type PRTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
   *mut _RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY {
   pub BlockNonMicrosoftSignedBinaries: RTL_IMAGE_MITIGATION_POLICY,
   pub EnforceSigningOnModuleDependencies: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY =
   _RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY;
pub type PRTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY =
   *mut _RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY {
   pub DisableNonSystemFonts: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY = _RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY;
pub type PRTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY = *mut _RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY {
   pub BlockRemoteImageLoads: RTL_IMAGE_MITIGATION_POLICY,
   pub BlockLowLabelImageLoads: RTL_IMAGE_MITIGATION_POLICY,
   pub PreferSystem32: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY = _RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY;
pub type PRTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY = *mut _RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
   pub EnableExportAddressFilter: RTL_IMAGE_MITIGATION_POLICY,
   pub EnableExportAddressFilterPlus: RTL_IMAGE_MITIGATION_POLICY,
   pub EnableImportAddressFilter: RTL_IMAGE_MITIGATION_POLICY,
   pub EnableRopStackPivot: RTL_IMAGE_MITIGATION_POLICY,
   pub EnableRopCallerCheck: RTL_IMAGE_MITIGATION_POLICY,
   pub EnableRopSimExec: RTL_IMAGE_MITIGATION_POLICY,
   pub EafPlusModuleList: [WCHAR; 512usize],
}
impl Default for _RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
   _RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
pub type PRTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
   *mut _RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY {
   pub DisallowChildProcessCreation: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY = _RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY;
pub type PRTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY =
   *mut _RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_SEHOP_POLICY {
   pub Sehop: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_SEHOP_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_SEHOP_POLICY = _RTL_IMAGE_MITIGATION_SEHOP_POLICY;
pub type PRTL_IMAGE_MITIGATION_SEHOP_POLICY = *mut _RTL_IMAGE_MITIGATION_SEHOP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_HEAP_POLICY {
   pub TerminateOnHeapErrors: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_HEAP_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_HEAP_POLICY = _RTL_IMAGE_MITIGATION_HEAP_POLICY;
pub type PRTL_IMAGE_MITIGATION_HEAP_POLICY = *mut _RTL_IMAGE_MITIGATION_HEAP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY {
   pub UserShadowStack: RTL_IMAGE_MITIGATION_POLICY,
   pub SetContextIpValidation: RTL_IMAGE_MITIGATION_POLICY,
   pub BlockNonCetBinaries: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY =
   _RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY;
pub type PRTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY =
   *mut _RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY {
   pub BlockUntrustedRedirections: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY =
   _RTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY;
pub type PRTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY =
   *mut _RTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY {
   pub PointerAuthUserIp: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY =
   _RTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY;
pub type PRTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY =
   *mut _RTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_IMAGE_MITIGATION_OPTION_STATE {
   RtlMitigationOptionStateNotConfigured = 0,
   RtlMitigationOptionStateOn = 1,
   RtlMitigationOptionStateOff = 2,
   RtlMitigationOptionStateForce = 3,
   RtlMitigationOptionStateOption = 4,
}
pub use self::_RTL_IMAGE_MITIGATION_OPTION_STATE as RTL_IMAGE_MITIGATION_OPTION_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _APPCONTAINER_SID_TYPE {
   NotAppContainerSidType = 0,
   ChildAppContainerSidType = 1,
   ParentAppContainerSidType = 2,
   InvalidAppContainerSidType = 3,
   MaxAppContainerSidType = 4,
}
pub use self::_APPCONTAINER_SID_TYPE as APPCONTAINER_SID_TYPE;
pub type PAPPCONTAINER_SID_TYPE = *mut _APPCONTAINER_SID_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STATE_LOCATION_TYPE {
   LocationTypeRegistry = 0,
   LocationTypeFileSystem = 1,
   LocationTypeMaximum = 2,
}
pub use self::_STATE_LOCATION_TYPE as STATE_LOCATION_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_PKG_CLAIM {
   pub Flags: ULONG,
   pub Origin: ULONG,
}
pub type PS_PKG_CLAIM = _PS_PKG_CLAIM;
pub type PPS_PKG_CLAIM = *mut _PS_PKG_CLAIM;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_BSD_ITEM_TYPE {
   RtlBsdItemVersionNumber = 0,
   RtlBsdItemProductType = 1,
   RtlBsdItemAabEnabled = 2,
   RtlBsdItemAabTimeout = 3,
   RtlBsdItemBootGood = 4,
   RtlBsdItemBootShutdown = 5,
   RtlBsdSleepInProgress = 6,
   RtlBsdPowerTransition = 7,
   RtlBsdItemBootAttemptCount = 8,
   RtlBsdItemBootCheckpoint = 9,
   RtlBsdItemBootId = 10,
   RtlBsdItemShutdownBootId = 11,
   RtlBsdItemReportedAbnormalShutdownBootId = 12,
   RtlBsdItemErrorInfo = 13,
   RtlBsdItemPowerButtonPressInfo = 14,
   RtlBsdItemChecksum = 15,
   RtlBsdPowerTransitionExtension = 16,
   RtlBsdItemFeatureConfigurationState = 17,
   RtlBsdItemMax = 18,
}
pub use self::_RTL_BSD_ITEM_TYPE as RTL_BSD_ITEM_TYPE;
#[repr(C)]
pub struct _RTL_BSD_DATA_POWER_TRANSITION {
   pub PowerButtonTimestamp: LARGE_INTEGER,
   pub Flags: _RTL_BSD_DATA_POWER_TRANSITION__bindgen_ty_1,
   pub ConnectedStandbyScenarioInstanceId: UCHAR,
   pub ConnectedStandbyEntryReason: UCHAR,
   pub ConnectedStandbyExitReason: UCHAR,
   pub SystemSleepTransitionCount: USHORT,
   pub LastReferenceTime: LARGE_INTEGER,
   pub LastReferenceTimeChecksum: ULONG,
   pub LastUpdateBootId: ULONG,
}
#[repr(C)]
pub struct _RTL_BSD_DATA_POWER_TRANSITION__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _RTL_BSD_DATA_POWER_TRANSITION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _RTL_BSD_DATA_POWER_TRANSITION__bindgen_ty_1 {
   #[inline]
   pub fn SystemRunning(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SystemRunning(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ConnectedStandbyInProgress(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ConnectedStandbyInProgress(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn UserShutdownInProgress(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_UserShutdownInProgress(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SystemShutdownInProgress(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SystemShutdownInProgress(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SleepInProgress(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_SleepInProgress(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SystemRunning: BOOLEAN,
      ConnectedStandbyInProgress: BOOLEAN,
      UserShutdownInProgress: BOOLEAN,
      SystemShutdownInProgress: BOOLEAN,
      SleepInProgress: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SystemRunning: u8 = unsafe { ::core::mem::transmute(SystemRunning) };
         SystemRunning as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ConnectedStandbyInProgress: u8 =
            unsafe { ::core::mem::transmute(ConnectedStandbyInProgress) };
         ConnectedStandbyInProgress as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let UserShutdownInProgress: u8 = unsafe { ::core::mem::transmute(UserShutdownInProgress) };
         UserShutdownInProgress as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SystemShutdownInProgress: u8 =
            unsafe { ::core::mem::transmute(SystemShutdownInProgress) };
         SystemShutdownInProgress as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let SleepInProgress: u8 = unsafe { ::core::mem::transmute(SleepInProgress) };
         SleepInProgress as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_BSD_DATA_POWER_TRANSITION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BSD_DATA_POWER_TRANSITION = _RTL_BSD_DATA_POWER_TRANSITION;
pub type PRTL_BSD_DATA_POWER_TRANSITION = *mut _RTL_BSD_DATA_POWER_TRANSITION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BSD_DATA_ERROR_INFO {
   pub BootId: ULONG,
   pub RepeatCount: ULONG,
   pub OtherErrorCount: ULONG,
   pub Code: ULONG,
   pub OtherErrorCount2: ULONG,
}
pub type RTL_BSD_DATA_ERROR_INFO = _RTL_BSD_DATA_ERROR_INFO;
pub type PRTL_BSD_DATA_ERROR_INFO = *mut _RTL_BSD_DATA_ERROR_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_BSD_POWER_BUTTON_PRESS_INFO {
   pub LastPressTime: LARGE_INTEGER,
   pub CumulativePressCount: ULONG,
   pub LastPressBootId: USHORT,
   pub LastPowerWatchdogStage: UCHAR,
   pub Flags: _RTL_BSD_POWER_BUTTON_PRESS_INFO__bindgen_ty_1,
   pub LastReleaseTime: LARGE_INTEGER,
   pub CumulativeReleaseCount: ULONG,
   pub LastReleaseBootId: USHORT,
   pub ErrorCount: USHORT,
   pub CurrentConnectedStandbyPhase: UCHAR,
   pub TransitionLatestCheckpointId: ULONG,
   pub TransitionLatestCheckpointType: ULONG,
   pub TransitionLatestCheckpointSequenceNumber: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BSD_POWER_BUTTON_PRESS_INFO__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _RTL_BSD_POWER_BUTTON_PRESS_INFO__bindgen_ty_1 {
   #[inline]
   pub fn WatchdogArmed(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_WatchdogArmed(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ShutdownInProgress(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ShutdownInProgress(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      WatchdogArmed: UCHAR,
      ShutdownInProgress: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let WatchdogArmed: u8 = unsafe { ::core::mem::transmute(WatchdogArmed) };
         WatchdogArmed as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ShutdownInProgress: u8 = unsafe { ::core::mem::transmute(ShutdownInProgress) };
         ShutdownInProgress as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_BSD_POWER_BUTTON_PRESS_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BSD_POWER_BUTTON_PRESS_INFO = _RTL_BSD_POWER_BUTTON_PRESS_INFO;
pub type PRTL_BSD_POWER_BUTTON_PRESS_INFO = *mut _RTL_BSD_POWER_BUTTON_PRESS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BSD_ITEM {
   pub Type: RTL_BSD_ITEM_TYPE,
   pub DataBuffer: PVOID,
   pub DataLength: ULONG,
}
impl Default for _RTL_BSD_ITEM {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BSD_ITEM = _RTL_BSD_ITEM;
pub type PRTL_BSD_ITEM = *mut _RTL_BSD_ITEM;
pub type PRTL_SECURE_MEMORY_CACHE_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: SIZE_T) -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __RTL_FEATURE_USAGE_REPORT {
   pub FeatureId: ULONG,
   pub ReportingKind: USHORT,
   pub ReportingOptions: USHORT,
}
pub type RTL_FEATURE_USAGE_REPORT = __RTL_FEATURE_USAGE_REPORT;
pub type PRTL_FEATURE_USAGE_REPORT = *mut __RTL_FEATURE_USAGE_REPORT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_FEATURE_CONFIGURATION_TYPE {
   RtlFeatureConfigurationBoot = 0,
   RtlFeatureConfigurationRuntime = 1,
   RtlFeatureConfigurationCount = 2,
}
pub use self::_RTL_FEATURE_CONFIGURATION_TYPE as RTL_FEATURE_CONFIGURATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_FEATURE_CONFIGURATION {
   pub FeatureId: ULONG,
   pub __bindgen_anon_1: _RTL_FEATURE_CONFIGURATION__bindgen_ty_1,
   pub VariantPayload: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_FEATURE_CONFIGURATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _RTL_FEATURE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_FEATURE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _RTL_FEATURE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Priority(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Priority(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn EnabledState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_EnabledState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn IsWexpConfiguration(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsWexpConfiguration(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HasSubscriptions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HasSubscriptions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Variant(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_Variant(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub fn VariantPayloadKind(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_VariantPayloadKind(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Priority: ULONG,
      EnabledState: ULONG,
      IsWexpConfiguration: ULONG,
      HasSubscriptions: ULONG,
      Variant: ULONG,
      VariantPayloadKind: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let Priority: u32 = unsafe { ::core::mem::transmute(Priority) };
         Priority as u64
      });
      __bindgen_bitfield_unit.set(4usize, 2u8, {
         let EnabledState: u32 = unsafe { ::core::mem::transmute(EnabledState) };
         EnabledState as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let IsWexpConfiguration: u32 = unsafe { ::core::mem::transmute(IsWexpConfiguration) };
         IsWexpConfiguration as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let HasSubscriptions: u32 = unsafe { ::core::mem::transmute(HasSubscriptions) };
         HasSubscriptions as u64
      });
      __bindgen_bitfield_unit.set(8usize, 6u8, {
         let Variant: u32 = unsafe { ::core::mem::transmute(Variant) };
         Variant as u64
      });
      __bindgen_bitfield_unit.set(14usize, 2u8, {
         let VariantPayloadKind: u32 = unsafe { ::core::mem::transmute(VariantPayloadKind) };
         VariantPayloadKind as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_FEATURE_CONFIGURATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_FEATURE_CONFIGURATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_FEATURE_CONFIGURATION = _RTL_FEATURE_CONFIGURATION;
pub type PRTL_FEATURE_CONFIGURATION_CHANGE_NOTIFICATION =
   ::core::option::Option<unsafe extern "C" fn(arg1: PVOID)>;
pub type PRTL_RUN_ONCE_INIT_FN = ::core::option::Option<
   unsafe extern "C" fn(arg1: PRTL_RUN_ONCE, arg2: PVOID, arg3: *mut PVOID) -> LOGICAL,
>;
pub type PWNF_USER_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      arg1: WNF_STATE_NAME,
      arg2: WNF_CHANGE_STAMP,
      arg3: PWNF_TYPE_ID,
      arg4: PVOID,
      arg5: *const cty::c_void,
      arg6: ULONG,
   ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DEBUG_POGO_ENTRY {
   pub Rva: ULONG,
   pub Size: ULONG,
   pub Name: [CHAR; 1usize],
}
pub type IMAGE_DEBUG_POGO_ENTRY = _IMAGE_DEBUG_POGO_ENTRY;
pub type PIMAGE_DEBUG_POGO_ENTRY = *mut _IMAGE_DEBUG_POGO_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DEBUG_POGO_SIGNATURE {
   pub Signature: ULONG,
}
pub type IMAGE_DEBUG_POGO_SIGNATURE = _IMAGE_DEBUG_POGO_SIGNATURE;
pub type PIMAGE_DEBUG_POGO_SIGNATURE = *mut _IMAGE_DEBUG_POGO_SIGNATURE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_RELOCATION_RECORD {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _IMAGE_RELOCATION_RECORD {
   #[inline]
   pub fn Offset(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
   }
   #[inline]
   pub fn set_Offset(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub fn Type(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Offset: USHORT, Type: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 12u8, {
         let Offset: u16 = unsafe { ::core::mem::transmute(Offset) };
         Offset as u64
      });
      __bindgen_bitfield_unit.set(12usize, 4u8, {
         let Type: u16 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type IMAGE_RELOCATION_RECORD = _IMAGE_RELOCATION_RECORD;
pub type PIMAGE_RELOCATION_RECORD = *mut _IMAGE_RELOCATION_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_CHPE_METADATA_X86 {
   pub Version: ULONG,
   pub CHPECodeAddressRangeOffset: ULONG,
   pub CHPECodeAddressRangeCount: ULONG,
   pub WowA64ExceptionHandlerFunctionPointer: ULONG,
   pub WowA64DispatchCallFunctionPointer: ULONG,
   pub WowA64DispatchIndirectCallFunctionPointer: ULONG,
   pub WowA64DispatchIndirectCallCfgFunctionPointer: ULONG,
   pub WowA64DispatchRetFunctionPointer: ULONG,
   pub WowA64DispatchRetLeafFunctionPointer: ULONG,
   pub WowA64DispatchJumpFunctionPointer: ULONG,
   pub CompilerIATPointer: ULONG,
   pub WowA64RdtscFunctionPointer: ULONG,
}
pub type IMAGE_CHPE_METADATA_X86 = _IMAGE_CHPE_METADATA_X86;
pub type PIMAGE_CHPE_METADATA_X86 = *mut _IMAGE_CHPE_METADATA_X86;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_CHPE_RANGE_ENTRY {
   pub __bindgen_anon_1: _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1,
   pub Length: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1 {
   pub StartOffset: ULONG,
   pub __bindgen_anon_1: _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn NativeCode(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NativeCode(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn AddressBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_AddressBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      NativeCode: ULONG,
      AddressBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let NativeCode: u32 = unsafe { ::core::mem::transmute(NativeCode) };
         NativeCode as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let AddressBits: u32 = unsafe { ::core::mem::transmute(AddressBits) };
         AddressBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_CHPE_RANGE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IMAGE_CHPE_RANGE_ENTRY = _IMAGE_CHPE_RANGE_ENTRY;
pub type PIMAGE_CHPE_RANGE_ENTRY = *mut _IMAGE_CHPE_RANGE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_ARM64EC_METADATA {
   pub Version: ULONG,
   pub CodeMap: ULONG,
   pub CodeMapCount: ULONG,
   pub CodeRangesToEntryPoints: ULONG,
   pub RedirectionMetadata: ULONG,
   pub tbd__os_arm64x_dispatch_call_no_redirect: ULONG,
   pub tbd__os_arm64x_dispatch_ret: ULONG,
   pub tbd__os_arm64x_dispatch_call: ULONG,
   pub tbd__os_arm64x_dispatch_icall: ULONG,
   pub tbd__os_arm64x_dispatch_icall_cfg: ULONG,
   pub AlternateEntryPoint: ULONG,
   pub AuxiliaryIAT: ULONG,
   pub CodeRangesToEntryPointsCount: ULONG,
   pub RedirectionMetadataCount: ULONG,
   pub GetX64InformationFunctionPointer: ULONG,
   pub SetX64InformationFunctionPointer: ULONG,
   pub ExtraRFETable: ULONG,
   pub ExtraRFETableSize: ULONG,
   pub __os_arm64x_dispatch_fptr: ULONG,
   pub AuxiliaryIATCopy: ULONG,
}
pub type IMAGE_ARM64EC_METADATA = _IMAGE_ARM64EC_METADATA;
pub type PIMAGE_ARM64EC_METADATA = *mut _IMAGE_ARM64EC_METADATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_ARM64EC_CODE_MAP_ENTRY {
   pub __bindgen_anon_1: _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1,
   pub Length: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1 {
   pub StartOffset: ULONG,
   pub __bindgen_anon_1: _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Type(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn AddressBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_AddressBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Type: ULONG, AddressBits: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let Type: u32 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let AddressBits: u32 = unsafe { ::core::mem::transmute(AddressBits) };
         AddressBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_ARM64EC_CODE_MAP_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IMAGE_ARM64EC_CODE_MAP_ENTRY = _IMAGE_ARM64EC_CODE_MAP_ENTRY;
pub type PIMAGE_ARM64EC_CODE_MAP_ENTRY = *mut _IMAGE_ARM64EC_CODE_MAP_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_ARM64EC_REDIRECTION_ENTRY {
   pub Source: ULONG,
   pub Destination: ULONG,
}
pub type IMAGE_ARM64EC_REDIRECTION_ENTRY = _IMAGE_ARM64EC_REDIRECTION_ENTRY;
pub type PIMAGE_ARM64EC_REDIRECTION_ENTRY = *mut _IMAGE_ARM64EC_REDIRECTION_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_ARM64EC_CODE_RANGE_ENTRY_POINT {
   pub StartRva: ULONG,
   pub EndRva: ULONG,
   pub EntryPoint: ULONG,
}
pub type IMAGE_ARM64EC_CODE_RANGE_ENTRY_POINT = _IMAGE_ARM64EC_CODE_RANGE_ENTRY_POINT;
pub type PIMAGE_ARM64EC_CODE_RANGE_ENTRY_POINT = *mut _IMAGE_ARM64EC_CODE_RANGE_ENTRY_POINT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DVRT_ARM64X_FIXUP_RECORD {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _IMAGE_DVRT_ARM64X_FIXUP_RECORD {
   #[inline]
   pub fn Offset(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
   }
   #[inline]
   pub fn set_Offset(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub fn Type(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn Size(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
   }
   #[inline]
   pub fn set_Size(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Offset: USHORT,
      Type: USHORT,
      Size: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 12u8, {
         let Offset: u16 = unsafe { ::core::mem::transmute(Offset) };
         Offset as u64
      });
      __bindgen_bitfield_unit.set(12usize, 2u8, {
         let Type: u16 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(14usize, 2u8, {
         let Size: u16 = unsafe { ::core::mem::transmute(Size) };
         Size as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type IMAGE_DVRT_ARM64X_FIXUP_RECORD = _IMAGE_DVRT_ARM64X_FIXUP_RECORD;
pub type PIMAGE_DVRT_ARM64X_FIXUP_RECORD = *mut _IMAGE_DVRT_ARM64X_FIXUP_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _IMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD {
   #[inline]
   pub fn Offset(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
   }
   #[inline]
   pub fn set_Offset(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub fn Type(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn Sign(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_Sign(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Scale(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_Scale(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Offset: USHORT,
      Type: USHORT,
      Sign: USHORT,
      Scale: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 12u8, {
         let Offset: u16 = unsafe { ::core::mem::transmute(Offset) };
         Offset as u64
      });
      __bindgen_bitfield_unit.set(12usize, 2u8, {
         let Type: u16 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let Sign: u16 = unsafe { ::core::mem::transmute(Sign) };
         Sign as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let Scale: u16 = unsafe { ::core::mem::transmute(Scale) };
         Scale as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type IMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD = _IMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD;
pub type PIMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD = *mut _IMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD;
pub type UNALIGNED_PIMAGE_THUNK_DATA32 = *mut IMAGE_THUNK_DATA32;
pub type UNALIGNED_PIMAGE_THUNK_DATA64 = *mut IMAGE_THUNK_DATA64;
#[repr(C)]
pub struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE {
   pub Version: ULONG64,
   pub Name: UNICODE_STRING,
}
impl Default for _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE = _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;
pub type PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE = *mut _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
   pub pValue: PVOID,
   pub ValueLength: ULONG,
}
impl Default for _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
pub type PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE =
   *mut _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
#[repr(C)]
pub struct _TOKEN_SECURITY_ATTRIBUTE_V1 {
   pub Name: UNICODE_STRING,
   pub ValueType: USHORT,
   pub Reserved: USHORT,
   pub Flags: ULONG,
   pub ValueCount: ULONG,
   pub Values: _TOKEN_SECURITY_ATTRIBUTE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TOKEN_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
   pub pInt64: PLONG64,
   pub pUint64: PULONG64,
   pub pString: PUNICODE_STRING,
   pub pFqbn: PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE,
   pub pOctetString: PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
}
impl Default for _TOKEN_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TOKEN_SECURITY_ATTRIBUTE_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTE_V1 = _TOKEN_SECURITY_ATTRIBUTE_V1;
pub type PTOKEN_SECURITY_ATTRIBUTE_V1 = *mut _TOKEN_SECURITY_ATTRIBUTE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION {
   pub Version: USHORT,
   pub Reserved: USHORT,
   pub AttributeCount: ULONG,
   pub Attribute: _TOKEN_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TOKEN_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
   pub pAttributeV1: PTOKEN_SECURITY_ATTRIBUTE_V1,
}
impl Default for _TOKEN_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TOKEN_SECURITY_ATTRIBUTES_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTES_INFORMATION = _TOKEN_SECURITY_ATTRIBUTES_INFORMATION;
pub type PTOKEN_SECURITY_ATTRIBUTES_INFORMATION = *mut _TOKEN_SECURITY_ATTRIBUTES_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TOKEN_SECURITY_ATTRIBUTE_OPERATION {
   TOKEN_SECURITY_ATTRIBUTE_OPERATION_NONE = 0,
   TOKEN_SECURITY_ATTRIBUTE_OPERATION_REPLACE_ALL = 1,
   TOKEN_SECURITY_ATTRIBUTE_OPERATION_ADD = 2,
   TOKEN_SECURITY_ATTRIBUTE_OPERATION_DELETE = 3,
   TOKEN_SECURITY_ATTRIBUTE_OPERATION_REPLACE = 4,
}
pub use self::_TOKEN_SECURITY_ATTRIBUTE_OPERATION as TOKEN_SECURITY_ATTRIBUTE_OPERATION;
pub type PTOKEN_SECURITY_ATTRIBUTE_OPERATION = *mut _TOKEN_SECURITY_ATTRIBUTE_OPERATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION {
   pub Attributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
   pub Operations: PTOKEN_SECURITY_ATTRIBUTE_OPERATION,
}
impl Default for _TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION =
   _TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION;
pub type PTOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION =
   *mut _TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PROCESS_TRUST_LEVEL {
   pub TrustLevelSid: PSID,
}
impl Default for _TOKEN_PROCESS_TRUST_LEVEL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_PROCESS_TRUST_LEVEL = _TOKEN_PROCESS_TRUST_LEVEL;
pub type PTOKEN_PROCESS_TRUST_LEVEL = *mut _TOKEN_PROCESS_TRUST_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_ALPC {
   _unused: [u8; 0],
}
pub type TP_ALPC = _TP_ALPC;
pub type PTP_ALPC = *mut _TP_ALPC;
pub type PTP_ALPC_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Alpc: PTP_ALPC),
>;
pub type PTP_ALPC_CALLBACK_EX = ::core::option::Option<
   unsafe extern "C" fn(
      Instance: PTP_CALLBACK_INSTANCE,
      Context: PVOID,
      Alpc: PTP_ALPC,
      ApcContext: PVOID,
   ),
>;
pub type PTP_IO_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      Instance: PTP_CALLBACK_INSTANCE,
      Context: PVOID,
      ApcContext: PVOID,
      IoSB: PIO_STATUS_BLOCK,
      Io: PTP_IO,
   ),
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TP_TRACE_TYPE {
   TpTraceThreadPriority = 1,
   TpTraceThreadAffinity = 2,
   MaxTpTraceType = 3,
}
pub use self::_TP_TRACE_TYPE as TP_TRACE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KCONTINUE_TYPE {
   KCONTINUE_UNWIND = 0,
   KCONTINUE_RESUME = 1,
   KCONTINUE_LONGJUMP = 2,
   KCONTINUE_SET = 3,
   KCONTINUE_LAST = 4,
}
pub use self::_KCONTINUE_TYPE as KCONTINUE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCONTINUE_ARGUMENT {
   pub ContinueType: KCONTINUE_TYPE,
   pub ContinueFlags: ULONG,
   pub Reserved: [ULONGLONG; 2usize],
}
impl Default for _KCONTINUE_ARGUMENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KCONTINUE_ARGUMENT = _KCONTINUE_ARGUMENT;
pub type PKCONTINUE_ARGUMENT = *mut _KCONTINUE_ARGUMENT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WOW64_SHARED_INFORMATION {
   SharedNtdll32LdrInitializeThunk = 0,
   SharedNtdll32KiUserExceptionDispatcher = 1,
   SharedNtdll32KiUserApcDispatcher = 2,
   SharedNtdll32KiUserCallbackDispatcher = 3,
   SharedNtdll32ExpInterlockedPopEntrySListFault = 4,
   SharedNtdll32ExpInterlockedPopEntrySListResume = 5,
   SharedNtdll32ExpInterlockedPopEntrySListEnd = 6,
   SharedNtdll32RtlUserThreadStart = 7,
   SharedNtdll32pQueryProcessDebugInformationRemote = 8,
   SharedNtdll32BaseAddress = 9,
   SharedNtdll32LdrSystemDllInitBlock = 10,
   Wow64SharedPageEntriesCount = 11,
}
pub use self::_WOW64_SHARED_INFORMATION as WOW64_SHARED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_BALANCED_NODE32 {
   pub __bindgen_anon_1: _RTL_BALANCED_NODE32__bindgen_ty_1,
   pub __bindgen_anon_2: _RTL_BALANCED_NODE32__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE32__bindgen_ty_1 {
   pub Children: [ULONG; 2usize],
   pub __bindgen_anon_1: _RTL_BALANCED_NODE32__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BALANCED_NODE32__bindgen_ty_1__bindgen_ty_1 {
   pub Left: ULONG,
   pub Right: ULONG,
}
impl Default for _RTL_BALANCED_NODE32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE32__bindgen_ty_2 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub ParentValue: ULONG,
}
impl Default for _RTL_BALANCED_NODE32__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _RTL_BALANCED_NODE32__bindgen_ty_2 {
   #[inline]
   pub fn Red(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Red(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Balance(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_Balance(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(Red: ULONG, Balance: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Red: u32 = unsafe { ::core::mem::transmute(Red) };
         Red as u64
      });
      __bindgen_bitfield_unit.set(1usize, 2u8, {
         let Balance: u32 = unsafe { ::core::mem::transmute(Balance) };
         Balance as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_BALANCED_NODE32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BALANCED_NODE32 = _RTL_BALANCED_NODE32;
pub type PRTL_BALANCED_NODE32 = *mut _RTL_BALANCED_NODE32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_RB_TREE32 {
   pub Root: ULONG,
   pub Min: ULONG,
}
pub type RTL_RB_TREE32 = _RTL_RB_TREE32;
pub type PRTL_RB_TREE32 = *mut _RTL_RB_TREE32;
#[repr(C)]
pub struct _PEB_LDR_DATA32 {
   pub Length: ULONG,
   pub Initialized: BOOLEAN,
   pub SsHandle: ULONG,
   pub InLoadOrderModuleList: LIST_ENTRY32,
   pub InMemoryOrderModuleList: LIST_ENTRY32,
   pub InInitializationOrderModuleList: LIST_ENTRY32,
   pub EntryInProgress: ULONG,
   pub ShutdownInProgress: BOOLEAN,
   pub ShutdownThreadId: ULONG,
}
impl Default for _PEB_LDR_DATA32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEB_LDR_DATA32 = _PEB_LDR_DATA32;
pub type PPEB_LDR_DATA32 = *mut _PEB_LDR_DATA32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_SERVICE_TAG_RECORD32 {
   pub Next: ULONG,
   pub ServiceTag: ULONG,
}
pub type LDR_SERVICE_TAG_RECORD32 = _LDR_SERVICE_TAG_RECORD32;
pub type PLDR_SERVICE_TAG_RECORD32 = *mut _LDR_SERVICE_TAG_RECORD32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDRP_CSLIST32 {
   pub Tail: ULONG,
}
pub type LDRP_CSLIST32 = _LDRP_CSLIST32;
pub type PLDRP_CSLIST32 = *mut _LDRP_CSLIST32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_DDAG_NODE32 {
   pub Modules: LIST_ENTRY32,
   pub ServiceTagList: ULONG,
   pub LoadCount: ULONG,
   pub LoadWhileUnloadingCount: ULONG,
   pub LowestLink: ULONG,
   pub __bindgen_anon_1: _LDR_DDAG_NODE32__bindgen_ty_1,
   pub IncomingDependencies: LDRP_CSLIST32,
   pub State: LDR_DDAG_STATE,
   pub CondenseLink: SINGLE_LIST_ENTRY32,
   pub PreorderNumber: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DDAG_NODE32__bindgen_ty_1 {
   pub Dependencies: LDRP_CSLIST32,
   pub RemovalLink: SINGLE_LIST_ENTRY32,
}
impl Default for _LDR_DDAG_NODE32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDR_DDAG_NODE32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DDAG_NODE32 = _LDR_DDAG_NODE32;
pub type PLDR_DDAG_NODE32 = *mut _LDR_DDAG_NODE32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY32 {
   pub InLoadOrderLinks: LIST_ENTRY32,
   pub InMemoryOrderLinks: LIST_ENTRY32,
   pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY32__bindgen_ty_1,
   pub DllBase: ULONG,
   pub EntryPoint: ULONG,
   pub SizeOfImage: ULONG,
   pub FullDllName: UNICODE_STRING32,
   pub BaseDllName: UNICODE_STRING32,
   pub __bindgen_anon_2: _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2,
   pub ObsoleteLoadCount: USHORT,
   pub TlsIndex: USHORT,
   pub HashLinks: LIST_ENTRY32,
   pub TimeDateStamp: ULONG,
   pub EntryPointActivationContext: ULONG,
   pub Lock: ULONG,
   pub DdagNode: ULONG,
   pub NodeModuleLink: LIST_ENTRY32,
   pub LoadContext: ULONG,
   pub ParentDllBase: ULONG,
   pub SwitchBackContext: ULONG,
   pub BaseAddressIndexNode: RTL_BALANCED_NODE32,
   pub MappingInfoIndexNode: RTL_BALANCED_NODE32,
   pub OriginalBase: ULONG,
   pub LoadTime: LARGE_INTEGER,
   pub BaseNameHashValue: ULONG,
   pub LoadReason: LDR_DLL_LOAD_REASON,
   pub ImplicitPathOptions: ULONG,
   pub ReferenceCount: ULONG,
   pub DependentLoadFlags: ULONG,
   pub SigningLevel: UCHAR,
   pub CheckSum: ULONG,
   pub ActivePatchImageBase: ULONG,
   pub HotPatchState: LDR_HOT_PATCH_STATE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DATA_TABLE_ENTRY32__bindgen_ty_1 {
   pub InInitializationOrderLinks: LIST_ENTRY32,
   pub InProgressLinks: LIST_ENTRY32,
}
impl Default for _LDR_DATA_TABLE_ENTRY32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2 {
   pub FlagGroup: [UCHAR; 4usize],
   pub Flags: ULONG,
   pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn PackagedBinary(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PackagedBinary(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn MarkedForRemoval(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MarkedForRemoval(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ImageDll(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageDll(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LoadNotificationsSent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadNotificationsSent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn TelemetryEntryProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_TelemetryEntryProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessStaticImport(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessStaticImport(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InLegacyLists(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InLegacyLists(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InIndexes(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InIndexes(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ShimDll(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ShimDll(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InExceptionTable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InExceptionTable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn LoadInProgress(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadInProgress(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LoadConfigProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadConfigProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn EntryProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EntryProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProtectDelayLoad(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProtectDelayLoad(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags3(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags3(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn DontCallForThreads(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DontCallForThreads(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessAttachCalled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessAttachCalled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(19usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessAttachFailed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessAttachFailed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CorDeferredValidate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorDeferredValidate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CorImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DontRelocate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DontRelocate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CorILOnly(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorILOnly(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ChpeImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ChpeImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(25usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags5(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags5(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(26usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn Redirected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Redirected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedFlags6(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags6(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(29usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn CompatDatabaseProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CompatDatabaseProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      PackagedBinary: ULONG,
      MarkedForRemoval: ULONG,
      ImageDll: ULONG,
      LoadNotificationsSent: ULONG,
      TelemetryEntryProcessed: ULONG,
      ProcessStaticImport: ULONG,
      InLegacyLists: ULONG,
      InIndexes: ULONG,
      ShimDll: ULONG,
      InExceptionTable: ULONG,
      ReservedFlags1: ULONG,
      LoadInProgress: ULONG,
      LoadConfigProcessed: ULONG,
      EntryProcessed: ULONG,
      ProtectDelayLoad: ULONG,
      ReservedFlags3: ULONG,
      DontCallForThreads: ULONG,
      ProcessAttachCalled: ULONG,
      ProcessAttachFailed: ULONG,
      CorDeferredValidate: ULONG,
      CorImage: ULONG,
      DontRelocate: ULONG,
      CorILOnly: ULONG,
      ChpeImage: ULONG,
      ReservedFlags5: ULONG,
      Redirected: ULONG,
      ReservedFlags6: ULONG,
      CompatDatabaseProcessed: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let PackagedBinary: u32 = unsafe { ::core::mem::transmute(PackagedBinary) };
         PackagedBinary as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let MarkedForRemoval: u32 = unsafe { ::core::mem::transmute(MarkedForRemoval) };
         MarkedForRemoval as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ImageDll: u32 = unsafe { ::core::mem::transmute(ImageDll) };
         ImageDll as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let LoadNotificationsSent: u32 = unsafe { ::core::mem::transmute(LoadNotificationsSent) };
         LoadNotificationsSent as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let TelemetryEntryProcessed: u32 =
            unsafe { ::core::mem::transmute(TelemetryEntryProcessed) };
         TelemetryEntryProcessed as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let ProcessStaticImport: u32 = unsafe { ::core::mem::transmute(ProcessStaticImport) };
         ProcessStaticImport as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let InLegacyLists: u32 = unsafe { ::core::mem::transmute(InLegacyLists) };
         InLegacyLists as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let InIndexes: u32 = unsafe { ::core::mem::transmute(InIndexes) };
         InIndexes as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let ShimDll: u32 = unsafe { ::core::mem::transmute(ShimDll) };
         ShimDll as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let InExceptionTable: u32 = unsafe { ::core::mem::transmute(InExceptionTable) };
         InExceptionTable as u64
      });
      __bindgen_bitfield_unit.set(10usize, 2u8, {
         let ReservedFlags1: u32 = unsafe { ::core::mem::transmute(ReservedFlags1) };
         ReservedFlags1 as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let LoadInProgress: u32 = unsafe { ::core::mem::transmute(LoadInProgress) };
         LoadInProgress as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let LoadConfigProcessed: u32 = unsafe { ::core::mem::transmute(LoadConfigProcessed) };
         LoadConfigProcessed as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let EntryProcessed: u32 = unsafe { ::core::mem::transmute(EntryProcessed) };
         EntryProcessed as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let ProtectDelayLoad: u32 = unsafe { ::core::mem::transmute(ProtectDelayLoad) };
         ProtectDelayLoad as u64
      });
      __bindgen_bitfield_unit.set(16usize, 2u8, {
         let ReservedFlags3: u32 = unsafe { ::core::mem::transmute(ReservedFlags3) };
         ReservedFlags3 as u64
      });
      __bindgen_bitfield_unit.set(18usize, 1u8, {
         let DontCallForThreads: u32 = unsafe { ::core::mem::transmute(DontCallForThreads) };
         DontCallForThreads as u64
      });
      __bindgen_bitfield_unit.set(19usize, 1u8, {
         let ProcessAttachCalled: u32 = unsafe { ::core::mem::transmute(ProcessAttachCalled) };
         ProcessAttachCalled as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let ProcessAttachFailed: u32 = unsafe { ::core::mem::transmute(ProcessAttachFailed) };
         ProcessAttachFailed as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let CorDeferredValidate: u32 = unsafe { ::core::mem::transmute(CorDeferredValidate) };
         CorDeferredValidate as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let CorImage: u32 = unsafe { ::core::mem::transmute(CorImage) };
         CorImage as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let DontRelocate: u32 = unsafe { ::core::mem::transmute(DontRelocate) };
         DontRelocate as u64
      });
      __bindgen_bitfield_unit.set(24usize, 1u8, {
         let CorILOnly: u32 = unsafe { ::core::mem::transmute(CorILOnly) };
         CorILOnly as u64
      });
      __bindgen_bitfield_unit.set(25usize, 1u8, {
         let ChpeImage: u32 = unsafe { ::core::mem::transmute(ChpeImage) };
         ChpeImage as u64
      });
      __bindgen_bitfield_unit.set(26usize, 2u8, {
         let ReservedFlags5: u32 = unsafe { ::core::mem::transmute(ReservedFlags5) };
         ReservedFlags5 as u64
      });
      __bindgen_bitfield_unit.set(28usize, 1u8, {
         let Redirected: u32 = unsafe { ::core::mem::transmute(Redirected) };
         Redirected as u64
      });
      __bindgen_bitfield_unit.set(29usize, 2u8, {
         let ReservedFlags6: u32 = unsafe { ::core::mem::transmute(ReservedFlags6) };
         ReservedFlags6 as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let CompatDatabaseProcessed: u32 =
            unsafe { ::core::mem::transmute(CompatDatabaseProcessed) };
         CompatDatabaseProcessed as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDR_DATA_TABLE_ENTRY32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DATA_TABLE_ENTRY32 = _LDR_DATA_TABLE_ENTRY32;
pub type PLDR_DATA_TABLE_ENTRY32 = *mut _LDR_DATA_TABLE_ENTRY32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CURDIR32 {
   pub DosPath: UNICODE_STRING32,
   pub Handle: ULONG,
}
pub type CURDIR32 = _CURDIR32;
pub type PCURDIR32 = *mut _CURDIR32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_DRIVE_LETTER_CURDIR32 {
   pub Flags: USHORT,
   pub Length: USHORT,
   pub TimeStamp: ULONG,
   pub DosPath: STRING32,
}
pub type RTL_DRIVE_LETTER_CURDIR32 = _RTL_DRIVE_LETTER_CURDIR32;
pub type PRTL_DRIVE_LETTER_CURDIR32 = *mut _RTL_DRIVE_LETTER_CURDIR32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_USER_PROCESS_PARAMETERS32 {
   pub MaximumLength: ULONG,
   pub Length: ULONG,
   pub Flags: ULONG,
   pub DebugFlags: ULONG,
   pub ConsoleHandle: ULONG,
   pub ConsoleFlags: ULONG,
   pub StandardInput: ULONG,
   pub StandardOutput: ULONG,
   pub StandardError: ULONG,
   pub CurrentDirectory: CURDIR32,
   pub DllPath: UNICODE_STRING32,
   pub ImagePathName: UNICODE_STRING32,
   pub CommandLine: UNICODE_STRING32,
   pub Environment: ULONG,
   pub StartingX: ULONG,
   pub StartingY: ULONG,
   pub CountX: ULONG,
   pub CountY: ULONG,
   pub CountCharsX: ULONG,
   pub CountCharsY: ULONG,
   pub FillAttribute: ULONG,
   pub WindowFlags: ULONG,
   pub ShowWindowFlags: ULONG,
   pub WindowTitle: UNICODE_STRING32,
   pub DesktopInfo: UNICODE_STRING32,
   pub ShellInfo: UNICODE_STRING32,
   pub RuntimeData: UNICODE_STRING32,
   pub CurrentDirectories: [RTL_DRIVE_LETTER_CURDIR32; 32usize],
   pub EnvironmentSize: ULONG,
   pub EnvironmentVersion: ULONG,
   pub PackageDependencyData: ULONG,
   pub ProcessGroupId: ULONG,
   pub LoaderThreads: ULONG,
   pub RedirectionDllName: UNICODE_STRING32,
   pub HeapPartitionName: UNICODE_STRING32,
   pub DefaultThreadpoolCpuSetMasks: ULONG,
   pub DefaultThreadpoolCpuSetMaskCount: ULONG,
   pub DefaultThreadpoolThreadMaximum: ULONG,
}
pub type RTL_USER_PROCESS_PARAMETERS32 = _RTL_USER_PROCESS_PARAMETERS32;
pub type PRTL_USER_PROCESS_PARAMETERS32 = *mut _RTL_USER_PROCESS_PARAMETERS32;
#[repr(C)]
pub struct _PEB32 {
   pub InheritedAddressSpace: BOOLEAN,
   pub ReadImageFileExecOptions: BOOLEAN,
   pub BeingDebugged: BOOLEAN,
   pub __bindgen_anon_1: _PEB32__bindgen_ty_1,
   pub Mutant: ULONG,
   pub ImageBaseAddress: ULONG,
   pub Ldr: ULONG,
   pub ProcessParameters: ULONG,
   pub SubSystemData: ULONG,
   pub ProcessHeap: ULONG,
   pub FastPebLock: ULONG,
   pub AtlThunkSListPtr: ULONG,
   pub IFEOKey: ULONG,
   pub __bindgen_anon_2: _PEB32__bindgen_ty_2,
   pub __bindgen_anon_3: _PEB32__bindgen_ty_3,
   pub SystemReserved: ULONG,
   pub AtlThunkSListPtr32: ULONG,
   pub ApiSetMap: ULONG,
   pub TlsExpansionCounter: ULONG,
   pub TlsBitmap: ULONG,
   pub TlsBitmapBits: [ULONG; 2usize],
   pub ReadOnlySharedMemoryBase: ULONG,
   pub SharedData: ULONG,
   pub ReadOnlyStaticServerData: ULONG,
   pub AnsiCodePageData: ULONG,
   pub OemCodePageData: ULONG,
   pub UnicodeCaseTableData: ULONG,
   pub NumberOfProcessors: ULONG,
   pub NtGlobalFlag: ULONG,
   pub CriticalSectionTimeout: LARGE_INTEGER,
   pub HeapSegmentReserve: ULONG,
   pub HeapSegmentCommit: ULONG,
   pub HeapDeCommitTotalFreeThreshold: ULONG,
   pub HeapDeCommitFreeBlockThreshold: ULONG,
   pub NumberOfHeaps: ULONG,
   pub MaximumNumberOfHeaps: ULONG,
   pub ProcessHeaps: ULONG,
   pub GdiSharedHandleTable: ULONG,
   pub ProcessStarterHelper: ULONG,
   pub GdiDCAttributeList: ULONG,
   pub LoaderLock: ULONG,
   pub OSMajorVersion: ULONG,
   pub OSMinorVersion: ULONG,
   pub OSBuildNumber: USHORT,
   pub OSCSDVersion: USHORT,
   pub OSPlatformId: ULONG,
   pub ImageSubsystem: ULONG,
   pub ImageSubsystemMajorVersion: ULONG,
   pub ImageSubsystemMinorVersion: ULONG,
   pub ActiveProcessAffinityMask: ULONG,
   pub GdiHandleBuffer: GDI_HANDLE_BUFFER32,
   pub PostProcessInitRoutine: ULONG,
   pub TlsExpansionBitmap: ULONG,
   pub TlsExpansionBitmapBits: [ULONG; 32usize],
   pub SessionId: ULONG,
   pub AppCompatFlags: ULARGE_INTEGER,
   pub AppCompatFlagsUser: ULARGE_INTEGER,
   pub pShimData: ULONG,
   pub AppCompatInfo: ULONG,
   pub CSDVersion: UNICODE_STRING32,
   pub ActivationContextData: ULONG,
   pub ProcessAssemblyStorageMap: ULONG,
   pub SystemDefaultActivationContextData: ULONG,
   pub SystemAssemblyStorageMap: ULONG,
   pub MinimumStackCommit: ULONG,
   pub SparePointers: [ULONG; 2usize],
   pub PatchLoaderData: ULONG,
   pub ChpeV2ProcessInfo: ULONG,
   pub AppModelFeatureState: ULONG,
   pub SpareUlongs: [ULONG; 2usize],
   pub ActiveCodePage: USHORT,
   pub OemCodePage: USHORT,
   pub UseCaseMapping: USHORT,
   pub UnusedNlsField: USHORT,
   pub WerRegistrationData: ULONG,
   pub WerShipAssertPtr: ULONG,
   pub __bindgen_anon_4: _PEB32__bindgen_ty_4,
   pub pImageHeaderHash: ULONG,
   pub __bindgen_anon_5: _PEB32__bindgen_ty_5,
   pub CsrServerReadOnlySharedMemoryBase: ULONGLONG,
   pub TppWorkerpListLock: ULONG,
   pub TppWorkerpList: LIST_ENTRY32,
   pub WaitOnAddressHashTable: [ULONG; 128usize],
   pub TelemetryCoverageHeader: ULONG,
   pub CloudFileFlags: ULONG,
   pub CloudFileDiagFlags: ULONG,
   pub PlaceholderCompatibilityMode: CHAR,
   pub PlaceholderCompatibilityModeReserved: [CHAR; 7usize],
   pub LeapSecondData: ULONG,
   pub __bindgen_anon_6: _PEB32__bindgen_ty_6,
   pub NtGlobalFlag2: ULONG,
   pub ExtendedFeatureDisableMask: ULONGLONG,
}
#[repr(C)]
pub union _PEB32__bindgen_ty_1 {
   pub BitField: ::core::mem::ManuallyDrop<BOOLEAN>,
   pub __bindgen_anon_1: ::core::mem::ManuallyDrop<_PEB32__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
pub struct _PEB32__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _PEB32__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PEB32__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ImageUsesLargePages(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ImageUsesLargePages(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsProtectedProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsProtectedProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsImageDynamicallyRelocated(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsImageDynamicallyRelocated(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SkipPatchingUser32Forwarders(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SkipPatchingUser32Forwarders(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsPackagedProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsPackagedProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsAppContainer(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsAppContainer(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsProtectedProcessLight(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsProtectedProcessLight(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn IsLongPathAwareProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsLongPathAwareProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ImageUsesLargePages: BOOLEAN,
      IsProtectedProcess: BOOLEAN,
      IsImageDynamicallyRelocated: BOOLEAN,
      SkipPatchingUser32Forwarders: BOOLEAN,
      IsPackagedProcess: BOOLEAN,
      IsAppContainer: BOOLEAN,
      IsProtectedProcessLight: BOOLEAN,
      IsLongPathAwareProcess: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ImageUsesLargePages: u8 = unsafe { ::core::mem::transmute(ImageUsesLargePages) };
         ImageUsesLargePages as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsProtectedProcess: u8 = unsafe { ::core::mem::transmute(IsProtectedProcess) };
         IsProtectedProcess as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IsImageDynamicallyRelocated: u8 =
            unsafe { ::core::mem::transmute(IsImageDynamicallyRelocated) };
         IsImageDynamicallyRelocated as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SkipPatchingUser32Forwarders: u8 =
            unsafe { ::core::mem::transmute(SkipPatchingUser32Forwarders) };
         SkipPatchingUser32Forwarders as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let IsPackagedProcess: u8 = unsafe { ::core::mem::transmute(IsPackagedProcess) };
         IsPackagedProcess as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let IsAppContainer: u8 = unsafe { ::core::mem::transmute(IsAppContainer) };
         IsAppContainer as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let IsProtectedProcessLight: u8 =
            unsafe { ::core::mem::transmute(IsProtectedProcessLight) };
         IsProtectedProcessLight as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let IsLongPathAwareProcess: u8 = unsafe { ::core::mem::transmute(IsLongPathAwareProcess) };
         IsLongPathAwareProcess as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_2 {
   pub CrossProcessFlags: ULONG,
   pub __bindgen_anon_1: _PEB32__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB32__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB32__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn ProcessInJob(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessInJob(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessInitializing(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessInitializing(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessUsingVEH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingVEH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessUsingVCH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingVCH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ProcessUsingFTH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingFTH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ReservedBits0(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedBits0(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ProcessInJob: ULONG,
      ProcessInitializing: ULONG,
      ProcessUsingVEH: ULONG,
      ProcessUsingVCH: ULONG,
      ProcessUsingFTH: ULONG,
      ReservedBits0: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ProcessInJob: u32 = unsafe { ::core::mem::transmute(ProcessInJob) };
         ProcessInJob as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ProcessInitializing: u32 = unsafe { ::core::mem::transmute(ProcessInitializing) };
         ProcessInitializing as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ProcessUsingVEH: u32 = unsafe { ::core::mem::transmute(ProcessUsingVEH) };
         ProcessUsingVEH as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ProcessUsingVCH: u32 = unsafe { ::core::mem::transmute(ProcessUsingVCH) };
         ProcessUsingVCH as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let ProcessUsingFTH: u32 = unsafe { ::core::mem::transmute(ProcessUsingFTH) };
         ProcessUsingFTH as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedBits0: u32 = unsafe { ::core::mem::transmute(ReservedBits0) };
         ReservedBits0 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB32__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_3 {
   pub KernelCallbackTable: ULONG,
   pub UserSharedInfoPtr: ULONG,
}
impl Default for _PEB32__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_4 {
   pub pContextData: ULONG,
   pub pUnused: ULONG,
   pub EcCodeBitMap: ULONG,
}
impl Default for _PEB32__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_5 {
   pub TracingFlags: ULONG,
   pub __bindgen_anon_1: _PEB32__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB32__bindgen_ty_5__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB32__bindgen_ty_5__bindgen_ty_1 {
   #[inline]
   pub fn HeapTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HeapTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn CritSecTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CritSecTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LibLoaderTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LibLoaderTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareTracingBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_SpareTracingBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      HeapTracingEnabled: ULONG,
      CritSecTracingEnabled: ULONG,
      LibLoaderTracingEnabled: ULONG,
      SpareTracingBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let HeapTracingEnabled: u32 = unsafe { ::core::mem::transmute(HeapTracingEnabled) };
         HeapTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let CritSecTracingEnabled: u32 = unsafe { ::core::mem::transmute(CritSecTracingEnabled) };
         CritSecTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let LibLoaderTracingEnabled: u32 =
            unsafe { ::core::mem::transmute(LibLoaderTracingEnabled) };
         LibLoaderTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let SpareTracingBits: u32 = unsafe { ::core::mem::transmute(SpareTracingBits) };
         SpareTracingBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB32__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_6 {
   pub LeapSecondFlags: ULONG,
   pub __bindgen_anon_1: _PEB32__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB32__bindgen_ty_6__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB32__bindgen_ty_6__bindgen_ty_1 {
   #[inline]
   pub fn SixtySecondEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SixtySecondEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SixtySecondEnabled: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SixtySecondEnabled: u32 = unsafe { ::core::mem::transmute(SixtySecondEnabled) };
         SixtySecondEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB32__bindgen_ty_6 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PEB32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEB32 = _PEB32;
pub type PPEB32 = *mut _PEB32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDI_TEB_BATCH32 {
   pub Offset: ULONG,
   pub HDC: ULONG,
   pub Buffer: [ULONG; 310usize],
}
impl Default for _GDI_TEB_BATCH32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GDI_TEB_BATCH32 = _GDI_TEB_BATCH32;
pub type PGDI_TEB_BATCH32 = *mut _GDI_TEB_BATCH32;
#[repr(C)]
pub struct _TEB32 {
   pub NtTib: NT_TIB32,
   pub EnvironmentPointer: ULONG,
   pub ClientId: CLIENT_ID32,
   pub ActiveRpcHandle: ULONG,
   pub ThreadLocalStoragePointer: ULONG,
   pub ProcessEnvironmentBlock: ULONG,
   pub LastErrorValue: ULONG,
   pub CountOfOwnedCriticalSections: ULONG,
   pub CsrClientThread: ULONG,
   pub Win32ThreadInfo: ULONG,
   pub User32Reserved: [ULONG; 26usize],
   pub UserReserved: [ULONG; 5usize],
   pub WOW32Reserved: ULONG,
   pub CurrentLocale: LCID,
   pub FpSoftwareStatusRegister: ULONG,
   pub ReservedForDebuggerInstrumentation: [ULONG; 16usize],
   pub SystemReserved1: [ULONG; 36usize],
   pub WorkingOnBehalfTicket: [UCHAR; 8usize],
   pub ExceptionCode: NTSTATUS,
   pub ActivationContextStackPointer: ULONG,
   pub InstrumentationCallbackSp: ULONG,
   pub InstrumentationCallbackPreviousPc: ULONG,
   pub InstrumentationCallbackPreviousSp: ULONG,
   pub InstrumentationCallbackDisabled: BOOLEAN,
   pub SpareBytes: [UCHAR; 23usize],
   pub TxFsContext: ULONG,
   pub GdiTebBatch: GDI_TEB_BATCH32,
   pub RealClientId: CLIENT_ID32,
   pub GdiCachedProcessHandle: ULONG,
   pub GdiClientPID: ULONG,
   pub GdiClientTID: ULONG,
   pub GdiThreadLocalInfo: ULONG,
   pub Win32ClientInfo: [ULONG; 62usize],
   pub glDispatchTable: [ULONG; 233usize],
   pub glReserved1: [ULONG; 29usize],
   pub glReserved2: ULONG,
   pub glSectionInfo: ULONG,
   pub glSection: ULONG,
   pub glTable: ULONG,
   pub glCurrentRC: ULONG,
   pub glContext: ULONG,
   pub LastStatusValue: NTSTATUS,
   pub StaticUnicodeString: UNICODE_STRING32,
   pub StaticUnicodeBuffer: [WCHAR; 261usize],
   pub DeallocationStack: ULONG,
   pub TlsSlots: [ULONG; 64usize],
   pub TlsLinks: LIST_ENTRY32,
   pub Vdm: ULONG,
   pub ReservedForNtRpc: ULONG,
   pub DbgSsReserved: [ULONG; 2usize],
   pub HardErrorMode: ULONG,
   pub Instrumentation: [ULONG; 9usize],
   pub ActivityId: GUID,
   pub SubProcessTag: ULONG,
   pub PerflibData: ULONG,
   pub EtwTraceData: ULONG,
   pub WinSockData: ULONG,
   pub GdiBatchCount: ULONG,
   pub __bindgen_anon_1: _TEB32__bindgen_ty_1,
   pub GuaranteedStackBytes: ULONG,
   pub ReservedForPerf: ULONG,
   pub ReservedForOle: ULONG,
   pub WaitingOnLoaderLock: ULONG,
   pub SavedPriorityState: ULONG,
   pub ReservedForCodeCoverage: ULONG,
   pub ThreadPoolData: ULONG,
   pub TlsExpansionSlots: ULONG,
   pub MuiGeneration: ULONG,
   pub IsImpersonating: ULONG,
   pub NlsCache: ULONG,
   pub pShimData: ULONG,
   pub HeapVirtualAffinity: USHORT,
   pub LowFragHeapDataSlot: USHORT,
   pub CurrentTransactionHandle: ULONG,
   pub ActiveFrame: ULONG,
   pub FlsData: ULONG,
   pub PreferredLanguages: ULONG,
   pub UserPrefLanguages: ULONG,
   pub MergedPrefLanguages: ULONG,
   pub MuiImpersonation: ULONG,
   pub __bindgen_anon_2: _TEB32__bindgen_ty_2,
   pub __bindgen_anon_3: _TEB32__bindgen_ty_3,
   pub TxnScopeEnterCallback: ULONG,
   pub TxnScopeExitCallback: ULONG,
   pub TxnScopeContext: ULONG,
   pub LockCount: ULONG,
   pub WowTebOffset: LONG,
   pub ResourceRetValue: ULONG,
   pub ReservedForWdf: ULONG,
   pub ReservedForCrt: ULONGLONG,
   pub EffectiveContainerId: GUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_1 {
   pub CurrentIdealProcessor: PROCESSOR_NUMBER,
   pub IdealProcessorValue: ULONG,
   pub __bindgen_anon_1: _TEB32__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB32__bindgen_ty_1__bindgen_ty_1 {
   pub ReservedPad0: UCHAR,
   pub ReservedPad1: UCHAR,
   pub ReservedPad2: UCHAR,
   pub IdealProcessor: UCHAR,
}
impl Default for _TEB32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_2 {
   pub CrossTebFlags: USHORT,
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _TEB32__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _TEB32__bindgen_ty_2 {
   #[inline]
   pub fn SpareCrossTebBits(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
   }
   #[inline]
   pub fn set_SpareCrossTebBits(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(SpareCrossTebBits: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 16u8, {
         let SpareCrossTebBits: u16 = unsafe { ::core::mem::transmute(SpareCrossTebBits) };
         SpareCrossTebBits as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_3 {
   pub SameTebFlags: USHORT,
   pub __bindgen_anon_1: _TEB32__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB32__bindgen_ty_3__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TEB32__bindgen_ty_3__bindgen_ty_1 {
   #[inline]
   pub fn SafeThunkCall(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SafeThunkCall(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InDebugPrint(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_InDebugPrint(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn HasFiberData(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_HasFiberData(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SkipThreadAttach(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SkipThreadAttach(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn WerInShipAssertCode(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_WerInShipAssertCode(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn RanProcessInit(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_RanProcessInit(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn ClonedThread(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_ClonedThread(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SuppressDebugMsg(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SuppressDebugMsg(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DisableUserStackWalk(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_DisableUserStackWalk(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn RtlExceptionAttached(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_RtlExceptionAttached(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn InitialThread(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_InitialThread(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SessionAware(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SessionAware(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LoadOwner(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_LoadOwner(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn LoaderWorker(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_LoaderWorker(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn SpareSameTebBits(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
   }
   #[inline]
   pub fn set_SpareSameTebBits(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SafeThunkCall: USHORT,
      InDebugPrint: USHORT,
      HasFiberData: USHORT,
      SkipThreadAttach: USHORT,
      WerInShipAssertCode: USHORT,
      RanProcessInit: USHORT,
      ClonedThread: USHORT,
      SuppressDebugMsg: USHORT,
      DisableUserStackWalk: USHORT,
      RtlExceptionAttached: USHORT,
      InitialThread: USHORT,
      SessionAware: USHORT,
      LoadOwner: USHORT,
      LoaderWorker: USHORT,
      SpareSameTebBits: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SafeThunkCall: u16 = unsafe { ::core::mem::transmute(SafeThunkCall) };
         SafeThunkCall as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let InDebugPrint: u16 = unsafe { ::core::mem::transmute(InDebugPrint) };
         InDebugPrint as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let HasFiberData: u16 = unsafe { ::core::mem::transmute(HasFiberData) };
         HasFiberData as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SkipThreadAttach: u16 = unsafe { ::core::mem::transmute(SkipThreadAttach) };
         SkipThreadAttach as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let WerInShipAssertCode: u16 = unsafe { ::core::mem::transmute(WerInShipAssertCode) };
         WerInShipAssertCode as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let RanProcessInit: u16 = unsafe { ::core::mem::transmute(RanProcessInit) };
         RanProcessInit as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let ClonedThread: u16 = unsafe { ::core::mem::transmute(ClonedThread) };
         ClonedThread as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let SuppressDebugMsg: u16 = unsafe { ::core::mem::transmute(SuppressDebugMsg) };
         SuppressDebugMsg as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let DisableUserStackWalk: u16 = unsafe { ::core::mem::transmute(DisableUserStackWalk) };
         DisableUserStackWalk as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let RtlExceptionAttached: u16 = unsafe { ::core::mem::transmute(RtlExceptionAttached) };
         RtlExceptionAttached as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let InitialThread: u16 = unsafe { ::core::mem::transmute(InitialThread) };
         InitialThread as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let SessionAware: u16 = unsafe { ::core::mem::transmute(SessionAware) };
         SessionAware as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let LoadOwner: u16 = unsafe { ::core::mem::transmute(LoadOwner) };
         LoadOwner as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let LoaderWorker: u16 = unsafe { ::core::mem::transmute(LoaderWorker) };
         LoaderWorker as u64
      });
      __bindgen_bitfield_unit.set(14usize, 2u8, {
         let SpareSameTebBits: u16 = unsafe { ::core::mem::transmute(SpareSameTebBits) };
         SpareSameTebBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _TEB32__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TEB32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TEB32 = _TEB32;
pub type PTEB32 = *mut _TEB32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WOW64_EXECUTE_OPTIONS {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _WOW64_EXECUTE_OPTIONS__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WOW64_EXECUTE_OPTIONS__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WOW64_EXECUTE_OPTIONS__bindgen_ty_1 {
   #[inline]
   pub fn StackReserveSize(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_StackReserveSize(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub fn StackCommitSize(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_StackCommitSize(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub fn Deprecated0(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Deprecated0(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DisableWowAssert(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisableWowAssert(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn DisableTurboDispatch(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisableTurboDispatch(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Unused(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 13u8) as u32) }
   }
   #[inline]
   pub fn set_Unused(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 13u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved0(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved0(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(29usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved2(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved2(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(30usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn Reserved3(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved3(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      StackReserveSize: ULONG,
      StackCommitSize: ULONG,
      Deprecated0: ULONG,
      DisableWowAssert: ULONG,
      DisableTurboDispatch: ULONG,
      Unused: ULONG,
      Reserved0: ULONG,
      Reserved1: ULONG,
      Reserved2: ULONG,
      Reserved3: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let StackReserveSize: u32 = unsafe { ::core::mem::transmute(StackReserveSize) };
         StackReserveSize as u64
      });
      __bindgen_bitfield_unit.set(8usize, 4u8, {
         let StackCommitSize: u32 = unsafe { ::core::mem::transmute(StackCommitSize) };
         StackCommitSize as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let Deprecated0: u32 = unsafe { ::core::mem::transmute(Deprecated0) };
         Deprecated0 as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let DisableWowAssert: u32 = unsafe { ::core::mem::transmute(DisableWowAssert) };
         DisableWowAssert as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let DisableTurboDispatch: u32 = unsafe { ::core::mem::transmute(DisableTurboDispatch) };
         DisableTurboDispatch as u64
      });
      __bindgen_bitfield_unit.set(15usize, 13u8, {
         let Unused: u32 = unsafe { ::core::mem::transmute(Unused) };
         Unused as u64
      });
      __bindgen_bitfield_unit.set(28usize, 1u8, {
         let Reserved0: u32 = unsafe { ::core::mem::transmute(Reserved0) };
         Reserved0 as u64
      });
      __bindgen_bitfield_unit.set(29usize, 1u8, {
         let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit.set(30usize, 1u8, {
         let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
         Reserved2 as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
         Reserved3 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _WOW64_EXECUTE_OPTIONS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WOW64_EXECUTE_OPTIONS = _WOW64_EXECUTE_OPTIONS;
pub type PWOW64_EXECUTE_OPTIONS = *mut _WOW64_EXECUTE_OPTIONS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64INFO {
   pub NativeSystemPageSize: ULONG,
   pub CpuFlags: ULONG,
   pub Wow64ExecuteFlags: WOW64_EXECUTE_OPTIONS,
   pub InstrumentationCallback: ULONG,
}
impl Default for _WOW64INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WOW64INFO = _WOW64INFO;
pub type PWOW64INFO = *mut _WOW64INFO;
#[repr(C)]
pub struct _PEB32_WITH_WOW64INFO {
   pub Peb32: PEB32,
   pub Wow64Info: WOW64INFO,
}
impl Default for _PEB32_WITH_WOW64INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEB32_WITH_WOW64INFO = _PEB32_WITH_WOW64INFO;
pub type PPEB32_WITH_WOW64INFO = *mut _PEB32_WITH_WOW64INFO;
pub type SAM_HANDLE = PVOID;
pub type PSAM_HANDLE = *mut PVOID;
pub type SAM_ENUMERATE_HANDLE = ULONG;
pub type PSAM_ENUMERATE_HANDLE = *mut ULONG;
#[repr(C)]
pub struct _SAM_RID_ENUMERATION {
   pub RelativeId: ULONG,
   pub Name: UNICODE_STRING,
}
impl Default for _SAM_RID_ENUMERATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_RID_ENUMERATION = _SAM_RID_ENUMERATION;
pub type PSAM_RID_ENUMERATION = *mut _SAM_RID_ENUMERATION;
#[repr(C)]
pub struct _SAM_SID_ENUMERATION {
   pub Sid: PSID,
   pub Name: UNICODE_STRING,
}
impl Default for _SAM_SID_ENUMERATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_SID_ENUMERATION = _SAM_SID_ENUMERATION;
pub type PSAM_SID_ENUMERATION = *mut _SAM_SID_ENUMERATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SAM_BYTE_ARRAY {
   pub Size: ULONG,
   pub Data: PUCHAR,
}
impl Default for _SAM_BYTE_ARRAY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_BYTE_ARRAY = _SAM_BYTE_ARRAY;
pub type PSAM_BYTE_ARRAY = *mut _SAM_BYTE_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SAM_BYTE_ARRAY_32K {
   pub Size: ULONG,
   pub Data: PUCHAR,
}
impl Default for _SAM_BYTE_ARRAY_32K {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_BYTE_ARRAY_32K = _SAM_BYTE_ARRAY_32K;
pub type PSAM_BYTE_ARRAY_32K = *mut _SAM_BYTE_ARRAY_32K;
pub type SAM_SHELL_OBJECT_PROPERTIES = SAM_BYTE_ARRAY_32K;
pub type PSAM_SHELL_OBJECT_PROPERTIES = *mut SAM_BYTE_ARRAY_32K;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_AUTH_IDENTITY_HANDLE {
   _unused: [u8; 0],
}
pub type PRPC_AUTH_IDENTITY_HANDLE = *mut _RPC_AUTH_IDENTITY_HANDLE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_INFORMATION_CLASS {
   DomainPasswordInformation = 1,
   DomainGeneralInformation = 2,
   DomainLogoffInformation = 3,
   DomainOemInformation = 4,
   DomainNameInformation = 5,
   DomainReplicationInformation = 6,
   DomainServerRoleInformation = 7,
   DomainModifiedInformation = 8,
   DomainStateInformation = 9,
   DomainUasInformation = 10,
   DomainGeneralInformation2 = 11,
   DomainLockoutInformation = 12,
   DomainModifiedInformation2 = 13,
}
pub use self::_DOMAIN_INFORMATION_CLASS as DOMAIN_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_SERVER_ENABLE_STATE {
   DomainServerEnabled = 1,
   DomainServerDisabled = 2,
}
pub use self::_DOMAIN_SERVER_ENABLE_STATE as DOMAIN_SERVER_ENABLE_STATE;
pub type PDOMAIN_SERVER_ENABLE_STATE = *mut _DOMAIN_SERVER_ENABLE_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_SERVER_ROLE {
   DomainServerRoleBackup = 2,
   DomainServerRolePrimary = 3,
}
pub use self::_DOMAIN_SERVER_ROLE as DOMAIN_SERVER_ROLE;
pub type PDOMAIN_SERVER_ROLE = *mut _DOMAIN_SERVER_ROLE;
#[repr(C, packed(4))]
pub struct _DOMAIN_GENERAL_INFORMATION {
   pub ForceLogoff: LARGE_INTEGER,
   pub OemInformation: UNICODE_STRING,
   pub DomainName: UNICODE_STRING,
   pub ReplicaSourceNodeName: UNICODE_STRING,
   pub DomainModifiedCount: LARGE_INTEGER,
   pub DomainServerState: DOMAIN_SERVER_ENABLE_STATE,
   pub DomainServerRole: DOMAIN_SERVER_ROLE,
   pub UasCompatibilityRequired: BOOLEAN,
   pub UserCount: ULONG,
   pub GroupCount: ULONG,
   pub AliasCount: ULONG,
}
impl Default for _DOMAIN_GENERAL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_GENERAL_INFORMATION = _DOMAIN_GENERAL_INFORMATION;
pub type PDOMAIN_GENERAL_INFORMATION = *mut _DOMAIN_GENERAL_INFORMATION;
#[repr(C, packed(4))]
pub struct _DOMAIN_GENERAL_INFORMATION2 {
   pub I1: DOMAIN_GENERAL_INFORMATION,
   pub LockoutDuration: LARGE_INTEGER,
   pub LockoutObservationWindow: LARGE_INTEGER,
   pub LockoutThreshold: USHORT,
}
impl Default for _DOMAIN_GENERAL_INFORMATION2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_GENERAL_INFORMATION2 = _DOMAIN_GENERAL_INFORMATION2;
pub type PDOMAIN_GENERAL_INFORMATION2 = *mut _DOMAIN_GENERAL_INFORMATION2;
#[repr(C)]
pub struct _DOMAIN_UAS_INFORMATION {
   pub UasCompatibilityRequired: BOOLEAN,
}
impl Default for _DOMAIN_UAS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_UAS_INFORMATION = _DOMAIN_UAS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_PASSWORD_INFORMATION {
   pub MinPasswordLength: USHORT,
   pub PasswordHistoryLength: USHORT,
   pub PasswordProperties: ULONG,
   pub MaxPasswordAge: LARGE_INTEGER,
   pub MinPasswordAge: LARGE_INTEGER,
}
impl Default for _DOMAIN_PASSWORD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_PASSWORD_INFORMATION = _DOMAIN_PASSWORD_INFORMATION;
pub type PDOMAIN_PASSWORD_INFORMATION = *mut _DOMAIN_PASSWORD_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_PASSWORD_CONSTRUCTION {
   DomainPasswordSimple = 1,
   DomainPasswordComplex = 2,
}
pub use self::_DOMAIN_PASSWORD_CONSTRUCTION as DOMAIN_PASSWORD_CONSTRUCTION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_LOGOFF_INFORMATION {
   pub ForceLogoff: LARGE_INTEGER,
}
impl Default for _DOMAIN_LOGOFF_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_LOGOFF_INFORMATION = _DOMAIN_LOGOFF_INFORMATION;
pub type PDOMAIN_LOGOFF_INFORMATION = *mut _DOMAIN_LOGOFF_INFORMATION;
#[repr(C)]
pub struct _DOMAIN_OEM_INFORMATION {
   pub OemInformation: UNICODE_STRING,
}
impl Default for _DOMAIN_OEM_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_OEM_INFORMATION = _DOMAIN_OEM_INFORMATION;
pub type PDOMAIN_OEM_INFORMATION = *mut _DOMAIN_OEM_INFORMATION;
#[repr(C)]
pub struct _DOMAIN_NAME_INFORMATION {
   pub DomainName: UNICODE_STRING,
}
impl Default for _DOMAIN_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_NAME_INFORMATION = _DOMAIN_NAME_INFORMATION;
pub type PDOMAIN_NAME_INFORMATION = *mut _DOMAIN_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOMAIN_SERVER_ROLE_INFORMATION {
   pub DomainServerRole: DOMAIN_SERVER_ROLE,
}
impl Default for _DOMAIN_SERVER_ROLE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_SERVER_ROLE_INFORMATION = _DOMAIN_SERVER_ROLE_INFORMATION;
pub type PDOMAIN_SERVER_ROLE_INFORMATION = *mut _DOMAIN_SERVER_ROLE_INFORMATION;
#[repr(C)]
pub struct _DOMAIN_REPLICATION_INFORMATION {
   pub ReplicaSourceNodeName: UNICODE_STRING,
}
impl Default for _DOMAIN_REPLICATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_REPLICATION_INFORMATION = _DOMAIN_REPLICATION_INFORMATION;
pub type PDOMAIN_REPLICATION_INFORMATION = *mut _DOMAIN_REPLICATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_MODIFIED_INFORMATION {
   pub DomainModifiedCount: LARGE_INTEGER,
   pub CreationTime: LARGE_INTEGER,
}
impl Default for _DOMAIN_MODIFIED_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_MODIFIED_INFORMATION = _DOMAIN_MODIFIED_INFORMATION;
pub type PDOMAIN_MODIFIED_INFORMATION = *mut _DOMAIN_MODIFIED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_MODIFIED_INFORMATION2 {
   pub DomainModifiedCount: LARGE_INTEGER,
   pub CreationTime: LARGE_INTEGER,
   pub ModifiedCountAtLastPromotion: LARGE_INTEGER,
}
impl Default for _DOMAIN_MODIFIED_INFORMATION2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_MODIFIED_INFORMATION2 = _DOMAIN_MODIFIED_INFORMATION2;
pub type PDOMAIN_MODIFIED_INFORMATION2 = *mut _DOMAIN_MODIFIED_INFORMATION2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOMAIN_STATE_INFORMATION {
   pub DomainServerState: DOMAIN_SERVER_ENABLE_STATE,
}
impl Default for _DOMAIN_STATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_STATE_INFORMATION = _DOMAIN_STATE_INFORMATION;
pub type PDOMAIN_STATE_INFORMATION = *mut _DOMAIN_STATE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_LOCKOUT_INFORMATION {
   pub LockoutDuration: LARGE_INTEGER,
   pub LockoutObservationWindow: LARGE_INTEGER,
   pub LockoutThreshold: USHORT,
}
impl Default for _DOMAIN_LOCKOUT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_LOCKOUT_INFORMATION = _DOMAIN_LOCKOUT_INFORMATION;
pub type PDOMAIN_LOCKOUT_INFORMATION = *mut _DOMAIN_LOCKOUT_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_DISPLAY_INFORMATION {
   DomainDisplayUser = 1,
   DomainDisplayMachine = 2,
   DomainDisplayGroup = 3,
   DomainDisplayOemUser = 4,
   DomainDisplayOemGroup = 5,
   DomainDisplayServer = 6,
}
pub use self::_DOMAIN_DISPLAY_INFORMATION as DOMAIN_DISPLAY_INFORMATION;
pub type PDOMAIN_DISPLAY_INFORMATION = *mut _DOMAIN_DISPLAY_INFORMATION;
#[repr(C)]
pub struct _DOMAIN_DISPLAY_USER {
   pub Index: ULONG,
   pub Rid: ULONG,
   pub AccountControl: ULONG,
   pub LogonName: UNICODE_STRING,
   pub AdminComment: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
}
impl Default for _DOMAIN_DISPLAY_USER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_DISPLAY_USER = _DOMAIN_DISPLAY_USER;
pub type PDOMAIN_DISPLAY_USER = *mut _DOMAIN_DISPLAY_USER;
#[repr(C)]
pub struct _DOMAIN_DISPLAY_MACHINE {
   pub Index: ULONG,
   pub Rid: ULONG,
   pub AccountControl: ULONG,
   pub Machine: UNICODE_STRING,
   pub Comment: UNICODE_STRING,
}
impl Default for _DOMAIN_DISPLAY_MACHINE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_DISPLAY_MACHINE = _DOMAIN_DISPLAY_MACHINE;
pub type PDOMAIN_DISPLAY_MACHINE = *mut _DOMAIN_DISPLAY_MACHINE;
#[repr(C)]
pub struct _DOMAIN_DISPLAY_GROUP {
   pub Index: ULONG,
   pub Rid: ULONG,
   pub Attributes: ULONG,
   pub Group: UNICODE_STRING,
   pub Comment: UNICODE_STRING,
}
impl Default for _DOMAIN_DISPLAY_GROUP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_DISPLAY_GROUP = _DOMAIN_DISPLAY_GROUP;
pub type PDOMAIN_DISPLAY_GROUP = *mut _DOMAIN_DISPLAY_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOMAIN_DISPLAY_OEM_USER {
   pub Index: ULONG,
   pub User: OEM_STRING,
}
impl Default for _DOMAIN_DISPLAY_OEM_USER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_DISPLAY_OEM_USER = _DOMAIN_DISPLAY_OEM_USER;
pub type PDOMAIN_DISPLAY_OEM_USER = *mut _DOMAIN_DISPLAY_OEM_USER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOMAIN_DISPLAY_OEM_GROUP {
   pub Index: ULONG,
   pub Group: OEM_STRING,
}
impl Default for _DOMAIN_DISPLAY_OEM_GROUP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_DISPLAY_OEM_GROUP = _DOMAIN_DISPLAY_OEM_GROUP;
pub type PDOMAIN_DISPLAY_OEM_GROUP = *mut _DOMAIN_DISPLAY_OEM_GROUP;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION {
   DomainLocalizableAccountsBasic = 1,
}
pub use self::_DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION as DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION;
pub type PDOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION = *mut _DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION;
#[repr(C)]
pub struct _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY {
   pub Rid: ULONG,
   pub Use: SID_NAME_USE,
   pub Name: UNICODE_STRING,
   pub AdminComment: UNICODE_STRING,
}
impl Default for _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_LOCALIZABLE_ACCOUNT_ENTRY = _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY;
pub type PDOMAIN_LOCALIZABLE_ACCOUNT_ENTRY = *mut _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOMAIN_LOCALIZABLE_ACCOUNTS {
   pub Count: ULONG,
   pub Entries: *mut DOMAIN_LOCALIZABLE_ACCOUNT_ENTRY,
}
impl Default for _DOMAIN_LOCALIZABLE_ACCOUNTS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_LOCALIZABLE_ACCOUNTS_BASIC = _DOMAIN_LOCALIZABLE_ACCOUNTS;
pub type PDOMAIN_LOCALIZABLE_ACCOUNTS_BASIC = *mut _DOMAIN_LOCALIZABLE_ACCOUNTS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DOMAIN_LOCALIZABLE_INFO_BUFFER {
   pub Basic: DOMAIN_LOCALIZABLE_ACCOUNTS_BASIC,
}
impl Default for _DOMAIN_LOCALIZABLE_INFO_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_LOCALIZABLE_ACCOUNTS_INFO_BUFFER = _DOMAIN_LOCALIZABLE_INFO_BUFFER;
pub type PDOMAIN_LOCALIZABLE_ACCOUNTS_INFO_BUFFER = *mut _DOMAIN_LOCALIZABLE_INFO_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GROUP_MEMBERSHIP {
   pub RelativeId: ULONG,
   pub Attributes: ULONG,
}
pub type GROUP_MEMBERSHIP = _GROUP_MEMBERSHIP;
pub type PGROUP_MEMBERSHIP = *mut _GROUP_MEMBERSHIP;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _GROUP_INFORMATION_CLASS {
   GroupGeneralInformation = 1,
   GroupNameInformation = 2,
   GroupAttributeInformation = 3,
   GroupAdminCommentInformation = 4,
   GroupReplicationInformation = 5,
}
pub use self::_GROUP_INFORMATION_CLASS as GROUP_INFORMATION_CLASS;
#[repr(C)]
pub struct _GROUP_GENERAL_INFORMATION {
   pub Name: UNICODE_STRING,
   pub Attributes: ULONG,
   pub MemberCount: ULONG,
   pub AdminComment: UNICODE_STRING,
}
impl Default for _GROUP_GENERAL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GROUP_GENERAL_INFORMATION = _GROUP_GENERAL_INFORMATION;
pub type PGROUP_GENERAL_INFORMATION = *mut _GROUP_GENERAL_INFORMATION;
#[repr(C)]
pub struct _GROUP_NAME_INFORMATION {
   pub Name: UNICODE_STRING,
}
impl Default for _GROUP_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GROUP_NAME_INFORMATION = _GROUP_NAME_INFORMATION;
pub type PGROUP_NAME_INFORMATION = *mut _GROUP_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GROUP_ATTRIBUTE_INFORMATION {
   pub Attributes: ULONG,
}
pub type GROUP_ATTRIBUTE_INFORMATION = _GROUP_ATTRIBUTE_INFORMATION;
pub type PGROUP_ATTRIBUTE_INFORMATION = *mut _GROUP_ATTRIBUTE_INFORMATION;
#[repr(C)]
pub struct _GROUP_ADM_COMMENT_INFORMATION {
   pub AdminComment: UNICODE_STRING,
}
impl Default for _GROUP_ADM_COMMENT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GROUP_ADM_COMMENT_INFORMATION = _GROUP_ADM_COMMENT_INFORMATION;
pub type PGROUP_ADM_COMMENT_INFORMATION = *mut _GROUP_ADM_COMMENT_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ALIAS_INFORMATION_CLASS {
   AliasGeneralInformation = 1,
   AliasNameInformation = 2,
   AliasAdminCommentInformation = 3,
   AliasReplicationInformation = 4,
   AliasExtendedInformation = 5,
}
pub use self::_ALIAS_INFORMATION_CLASS as ALIAS_INFORMATION_CLASS;
#[repr(C)]
pub struct _ALIAS_GENERAL_INFORMATION {
   pub Name: UNICODE_STRING,
   pub MemberCount: ULONG,
   pub AdminComment: UNICODE_STRING,
}
impl Default for _ALIAS_GENERAL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALIAS_GENERAL_INFORMATION = _ALIAS_GENERAL_INFORMATION;
pub type PALIAS_GENERAL_INFORMATION = *mut _ALIAS_GENERAL_INFORMATION;
#[repr(C)]
pub struct _ALIAS_NAME_INFORMATION {
   pub Name: UNICODE_STRING,
}
impl Default for _ALIAS_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALIAS_NAME_INFORMATION = _ALIAS_NAME_INFORMATION;
pub type PALIAS_NAME_INFORMATION = *mut _ALIAS_NAME_INFORMATION;
#[repr(C)]
pub struct _ALIAS_ADM_COMMENT_INFORMATION {
   pub AdminComment: UNICODE_STRING,
}
impl Default for _ALIAS_ADM_COMMENT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALIAS_ADM_COMMENT_INFORMATION = _ALIAS_ADM_COMMENT_INFORMATION;
pub type PALIAS_ADM_COMMENT_INFORMATION = *mut _ALIAS_ADM_COMMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALIAS_EXTENDED_INFORMATION {
   pub WhichFields: ULONG,
   pub ShellAdminObjectProperties: SAM_SHELL_OBJECT_PROPERTIES,
}
impl Default for _ALIAS_EXTENDED_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALIAS_EXTENDED_INFORMATION = _ALIAS_EXTENDED_INFORMATION;
pub type PALIAS_EXTENDED_INFORMATION = *mut _ALIAS_EXTENDED_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOGON_HOURS {
   pub UnitsPerWeek: USHORT,
   pub LogonHours: PUCHAR,
}
impl Default for _LOGON_HOURS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LOGON_HOURS = _LOGON_HOURS;
pub type PLOGON_HOURS = *mut _LOGON_HOURS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SR_SECURITY_DESCRIPTOR {
   pub Length: ULONG,
   pub SecurityDescriptor: PUCHAR,
}
impl Default for _SR_SECURITY_DESCRIPTOR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SR_SECURITY_DESCRIPTOR = _SR_SECURITY_DESCRIPTOR;
pub type PSR_SECURITY_DESCRIPTOR = *mut _SR_SECURITY_DESCRIPTOR;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _USER_INFORMATION_CLASS {
   UserGeneralInformation = 1,
   UserPreferencesInformation = 2,
   UserLogonInformation = 3,
   UserLogonHoursInformation = 4,
   UserAccountInformation = 5,
   UserNameInformation = 6,
   UserAccountNameInformation = 7,
   UserFullNameInformation = 8,
   UserPrimaryGroupInformation = 9,
   UserHomeInformation = 10,
   UserScriptInformation = 11,
   UserProfileInformation = 12,
   UserAdminCommentInformation = 13,
   UserWorkStationsInformation = 14,
   UserSetPasswordInformation = 15,
   UserControlInformation = 16,
   UserExpiresInformation = 17,
   UserInternal1Information = 18,
   UserInternal2Information = 19,
   UserParametersInformation = 20,
   UserAllInformation = 21,
   UserInternal3Information = 22,
   UserInternal4Information = 23,
   UserInternal5Information = 24,
   UserInternal4InformationNew = 25,
   UserInternal5InformationNew = 26,
   UserInternal6Information = 27,
   UserExtendedInformation = 28,
   UserLogonUIInformation = 29,
   UserUnknownTodoInformation = 30,
   UserInternal7Information = 31,
   UserInternal8Information = 32,
}
pub use self::_USER_INFORMATION_CLASS as USER_INFORMATION_CLASS;
pub type PUSER_INFORMATION_CLASS = *mut _USER_INFORMATION_CLASS;
#[repr(C)]
pub struct _USER_GENERAL_INFORMATION {
   pub UserName: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
   pub PrimaryGroupId: ULONG,
   pub AdminComment: UNICODE_STRING,
   pub UserComment: UNICODE_STRING,
}
impl Default for _USER_GENERAL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_GENERAL_INFORMATION = _USER_GENERAL_INFORMATION;
pub type PUSER_GENERAL_INFORMATION = *mut _USER_GENERAL_INFORMATION;
#[repr(C)]
pub struct _USER_PREFERENCES_INFORMATION {
   pub UserComment: UNICODE_STRING,
   pub Reserved1: UNICODE_STRING,
   pub CountryCode: USHORT,
   pub CodePage: USHORT,
}
impl Default for _USER_PREFERENCES_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_PREFERENCES_INFORMATION = _USER_PREFERENCES_INFORMATION;
pub type PUSER_PREFERENCES_INFORMATION = *mut _USER_PREFERENCES_INFORMATION;
#[repr(C, packed(4))]
pub struct _USER_LOGON_INFORMATION {
   pub UserName: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
   pub UserId: ULONG,
   pub PrimaryGroupId: ULONG,
   pub HomeDirectory: UNICODE_STRING,
   pub HomeDirectoryDrive: UNICODE_STRING,
   pub ScriptPath: UNICODE_STRING,
   pub ProfilePath: UNICODE_STRING,
   pub WorkStations: UNICODE_STRING,
   pub LastLogon: LARGE_INTEGER,
   pub LastLogoff: LARGE_INTEGER,
   pub PasswordLastSet: LARGE_INTEGER,
   pub PasswordCanChange: LARGE_INTEGER,
   pub PasswordMustChange: LARGE_INTEGER,
   pub LogonHours: LOGON_HOURS,
   pub BadPasswordCount: USHORT,
   pub LogonCount: USHORT,
   pub UserAccountControl: ULONG,
}
impl Default for _USER_LOGON_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_LOGON_INFORMATION = _USER_LOGON_INFORMATION;
pub type PUSER_LOGON_INFORMATION = *mut _USER_LOGON_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _USER_LOGON_HOURS_INFORMATION {
   pub LogonHours: LOGON_HOURS,
}
impl Default for _USER_LOGON_HOURS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_LOGON_HOURS_INFORMATION = _USER_LOGON_HOURS_INFORMATION;
pub type PUSER_LOGON_HOURS_INFORMATION = *mut _USER_LOGON_HOURS_INFORMATION;
#[repr(C, packed(4))]
pub struct _USER_ACCOUNT_INFORMATION {
   pub UserName: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
   pub UserId: ULONG,
   pub PrimaryGroupId: ULONG,
   pub HomeDirectory: UNICODE_STRING,
   pub HomeDirectoryDrive: UNICODE_STRING,
   pub ScriptPath: UNICODE_STRING,
   pub ProfilePath: UNICODE_STRING,
   pub AdminComment: UNICODE_STRING,
   pub WorkStations: UNICODE_STRING,
   pub LastLogon: LARGE_INTEGER,
   pub LastLogoff: LARGE_INTEGER,
   pub LogonHours: LOGON_HOURS,
   pub BadPasswordCount: USHORT,
   pub LogonCount: USHORT,
   pub PasswordLastSet: LARGE_INTEGER,
   pub AccountExpires: LARGE_INTEGER,
   pub UserAccountControl: ULONG,
}
impl Default for _USER_ACCOUNT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_ACCOUNT_INFORMATION = _USER_ACCOUNT_INFORMATION;
pub type PUSER_ACCOUNT_INFORMATION = *mut _USER_ACCOUNT_INFORMATION;
#[repr(C)]
pub struct _USER_NAME_INFORMATION {
   pub UserName: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
}
impl Default for _USER_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_NAME_INFORMATION = _USER_NAME_INFORMATION;
pub type PUSER_NAME_INFORMATION = *mut _USER_NAME_INFORMATION;
#[repr(C)]
pub struct _USER_ACCOUNT_NAME_INFORMATION {
   pub UserName: UNICODE_STRING,
}
impl Default for _USER_ACCOUNT_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_ACCOUNT_NAME_INFORMATION = _USER_ACCOUNT_NAME_INFORMATION;
pub type PUSER_ACCOUNT_NAME_INFORMATION = *mut _USER_ACCOUNT_NAME_INFORMATION;
#[repr(C)]
pub struct _USER_FULL_NAME_INFORMATION {
   pub FullName: UNICODE_STRING,
}
impl Default for _USER_FULL_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_FULL_NAME_INFORMATION = _USER_FULL_NAME_INFORMATION;
pub type PUSER_FULL_NAME_INFORMATION = *mut _USER_FULL_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _USER_PRIMARY_GROUP_INFORMATION {
   pub PrimaryGroupId: ULONG,
}
pub type USER_PRIMARY_GROUP_INFORMATION = _USER_PRIMARY_GROUP_INFORMATION;
pub type PUSER_PRIMARY_GROUP_INFORMATION = *mut _USER_PRIMARY_GROUP_INFORMATION;
#[repr(C)]
pub struct _USER_HOME_INFORMATION {
   pub HomeDirectory: UNICODE_STRING,
   pub HomeDirectoryDrive: UNICODE_STRING,
}
impl Default for _USER_HOME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_HOME_INFORMATION = _USER_HOME_INFORMATION;
pub type PUSER_HOME_INFORMATION = *mut _USER_HOME_INFORMATION;
#[repr(C)]
pub struct _USER_SCRIPT_INFORMATION {
   pub ScriptPath: UNICODE_STRING,
}
impl Default for _USER_SCRIPT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_SCRIPT_INFORMATION = _USER_SCRIPT_INFORMATION;
pub type PUSER_SCRIPT_INFORMATION = *mut _USER_SCRIPT_INFORMATION;
#[repr(C)]
pub struct _USER_PROFILE_INFORMATION {
   pub ProfilePath: UNICODE_STRING,
}
impl Default for _USER_PROFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_PROFILE_INFORMATION = _USER_PROFILE_INFORMATION;
pub type PUSER_PROFILE_INFORMATION = *mut _USER_PROFILE_INFORMATION;
#[repr(C)]
pub struct _USER_ADMIN_COMMENT_INFORMATION {
   pub AdminComment: UNICODE_STRING,
}
impl Default for _USER_ADMIN_COMMENT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_ADMIN_COMMENT_INFORMATION = _USER_ADMIN_COMMENT_INFORMATION;
pub type PUSER_ADMIN_COMMENT_INFORMATION = *mut _USER_ADMIN_COMMENT_INFORMATION;
#[repr(C)]
pub struct _USER_WORKSTATIONS_INFORMATION {
   pub WorkStations: UNICODE_STRING,
}
impl Default for _USER_WORKSTATIONS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_WORKSTATIONS_INFORMATION = _USER_WORKSTATIONS_INFORMATION;
pub type PUSER_WORKSTATIONS_INFORMATION = *mut _USER_WORKSTATIONS_INFORMATION;
#[repr(C)]
pub struct _USER_SET_PASSWORD_INFORMATION {
   pub Password: UNICODE_STRING,
   pub PasswordExpired: BOOLEAN,
}
impl Default for _USER_SET_PASSWORD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_SET_PASSWORD_INFORMATION = _USER_SET_PASSWORD_INFORMATION;
pub type PUSER_SET_PASSWORD_INFORMATION = *mut _USER_SET_PASSWORD_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _USER_CONTROL_INFORMATION {
   pub UserAccountControl: ULONG,
}
pub type USER_CONTROL_INFORMATION = _USER_CONTROL_INFORMATION;
pub type PUSER_CONTROL_INFORMATION = *mut _USER_CONTROL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _USER_EXPIRES_INFORMATION {
   pub AccountExpires: LARGE_INTEGER,
}
impl Default for _USER_EXPIRES_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_EXPIRES_INFORMATION = _USER_EXPIRES_INFORMATION;
pub type PUSER_EXPIRES_INFORMATION = *mut _USER_EXPIRES_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CYPHER_BLOCK {
   pub data: [CHAR; 8usize],
}
pub type CYPHER_BLOCK = _CYPHER_BLOCK;
pub type PCYPHER_BLOCK = *mut _CYPHER_BLOCK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ENCRYPTED_NT_OWF_PASSWORD {
   pub data: [CYPHER_BLOCK; 2usize],
}
pub type ENCRYPTED_NT_OWF_PASSWORD = _ENCRYPTED_NT_OWF_PASSWORD;
pub type PENCRYPTED_NT_OWF_PASSWORD = *mut _ENCRYPTED_NT_OWF_PASSWORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ENCRYPTED_LM_OWF_PASSWORD {
   pub data: [CYPHER_BLOCK; 2usize],
}
pub type ENCRYPTED_LM_OWF_PASSWORD = _ENCRYPTED_LM_OWF_PASSWORD;
pub type PENCRYPTED_LM_OWF_PASSWORD = *mut _ENCRYPTED_LM_OWF_PASSWORD;
#[repr(C)]
pub struct _USER_INTERNAL1_INFORMATION {
   pub EncryptedNtOwfPassword: ENCRYPTED_NT_OWF_PASSWORD,
   pub EncryptedLmOwfPassword: ENCRYPTED_LM_OWF_PASSWORD,
   pub NtPasswordPresent: BOOLEAN,
   pub LmPasswordPresent: BOOLEAN,
   pub PasswordExpired: BOOLEAN,
}
impl Default for _USER_INTERNAL1_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL1_INFORMATION = _USER_INTERNAL1_INFORMATION;
pub type PUSER_INTERNAL1_INFORMATION = *mut _USER_INTERNAL1_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _USER_INTERNAL2_INFORMATION {
   pub StatisticsToApply: ULONG,
   pub LastLogon: LARGE_INTEGER,
   pub LastLogoff: LARGE_INTEGER,
   pub BadPasswordCount: USHORT,
   pub LogonCount: USHORT,
}
impl Default for _USER_INTERNAL2_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL2_INFORMATION = _USER_INTERNAL2_INFORMATION;
pub type PUSER_INTERNAL2_INFORMATION = *mut _USER_INTERNAL2_INFORMATION;
#[repr(C)]
pub struct _USER_PARAMETERS_INFORMATION {
   pub Parameters: UNICODE_STRING,
}
impl Default for _USER_PARAMETERS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_PARAMETERS_INFORMATION = _USER_PARAMETERS_INFORMATION;
pub type PUSER_PARAMETERS_INFORMATION = *mut _USER_PARAMETERS_INFORMATION;
#[repr(C, packed(4))]
pub struct _USER_ALL_INFORMATION {
   pub LastLogon: LARGE_INTEGER,
   pub LastLogoff: LARGE_INTEGER,
   pub PasswordLastSet: LARGE_INTEGER,
   pub AccountExpires: LARGE_INTEGER,
   pub PasswordCanChange: LARGE_INTEGER,
   pub PasswordMustChange: LARGE_INTEGER,
   pub UserName: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
   pub HomeDirectory: UNICODE_STRING,
   pub HomeDirectoryDrive: UNICODE_STRING,
   pub ScriptPath: UNICODE_STRING,
   pub ProfilePath: UNICODE_STRING,
   pub AdminComment: UNICODE_STRING,
   pub WorkStations: UNICODE_STRING,
   pub UserComment: UNICODE_STRING,
   pub Parameters: UNICODE_STRING,
   pub LmPassword: UNICODE_STRING,
   pub NtPassword: UNICODE_STRING,
   pub PrivateData: UNICODE_STRING,
   pub SecurityDescriptor: SR_SECURITY_DESCRIPTOR,
   pub UserId: ULONG,
   pub PrimaryGroupId: ULONG,
   pub UserAccountControl: ULONG,
   pub WhichFields: ULONG,
   pub LogonHours: LOGON_HOURS,
   pub BadPasswordCount: USHORT,
   pub LogonCount: USHORT,
   pub CountryCode: USHORT,
   pub CodePage: USHORT,
   pub LmPasswordPresent: BOOLEAN,
   pub NtPasswordPresent: BOOLEAN,
   pub PasswordExpired: BOOLEAN,
   pub PrivateDataSensitive: BOOLEAN,
}
impl Default for _USER_ALL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_ALL_INFORMATION = _USER_ALL_INFORMATION;
pub type PUSER_ALL_INFORMATION = *mut _USER_ALL_INFORMATION;
#[repr(C, packed(4))]
pub struct _USER_INTERNAL3_INFORMATION {
   pub I1: USER_ALL_INFORMATION,
   pub LastBadPasswordTime: LARGE_INTEGER,
}
impl Default for _USER_INTERNAL3_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL3_INFORMATION = _USER_INTERNAL3_INFORMATION;
pub type PUSER_INTERNAL3_INFORMATION = *mut _USER_INTERNAL3_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTED_USER_PASSWORD {
   pub Buffer: [UCHAR; 516usize],
}
impl Default for _ENCRYPTED_USER_PASSWORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ENCRYPTED_USER_PASSWORD = _ENCRYPTED_USER_PASSWORD;
pub type PENCRYPTED_USER_PASSWORD = *mut _ENCRYPTED_USER_PASSWORD;
#[repr(C)]
pub struct _USER_INTERNAL4_INFORMATION {
   pub I1: USER_ALL_INFORMATION,
   pub UserPassword: ENCRYPTED_USER_PASSWORD,
}
impl Default for _USER_INTERNAL4_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL4_INFORMATION = _USER_INTERNAL4_INFORMATION;
pub type PUSER_INTERNAL4_INFORMATION = *mut _USER_INTERNAL4_INFORMATION;
#[repr(C)]
pub struct _USER_INTERNAL5_INFORMATION {
   pub UserPassword: ENCRYPTED_USER_PASSWORD,
   pub PasswordExpired: BOOLEAN,
}
impl Default for _USER_INTERNAL5_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL5_INFORMATION = _USER_INTERNAL5_INFORMATION;
pub type PUSER_INTERNAL5_INFORMATION = *mut _USER_INTERNAL5_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTED_USER_PASSWORD_NEW {
   pub Buffer: [UCHAR; 532usize],
}
impl Default for _ENCRYPTED_USER_PASSWORD_NEW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ENCRYPTED_USER_PASSWORD_NEW = _ENCRYPTED_USER_PASSWORD_NEW;
pub type PENCRYPTED_USER_PASSWORD_NEW = *mut _ENCRYPTED_USER_PASSWORD_NEW;
#[repr(C)]
pub struct _USER_INTERNAL4_INFORMATION_NEW {
   pub I1: USER_ALL_INFORMATION,
   pub UserPassword: ENCRYPTED_USER_PASSWORD_NEW,
}
impl Default for _USER_INTERNAL4_INFORMATION_NEW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL4_INFORMATION_NEW = _USER_INTERNAL4_INFORMATION_NEW;
pub type PUSER_INTERNAL4_INFORMATION_NEW = *mut _USER_INTERNAL4_INFORMATION_NEW;
#[repr(C)]
pub struct _USER_INTERNAL5_INFORMATION_NEW {
   pub UserPassword: ENCRYPTED_USER_PASSWORD_NEW,
   pub PasswordExpired: BOOLEAN,
}
impl Default for _USER_INTERNAL5_INFORMATION_NEW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL5_INFORMATION_NEW = _USER_INTERNAL5_INFORMATION_NEW;
pub type PUSER_INTERNAL5_INFORMATION_NEW = *mut _USER_INTERNAL5_INFORMATION_NEW;
#[repr(C)]
pub struct _USER_ALLOWED_TO_DELEGATE_TO_LIST {
   pub Size: ULONG,
   pub NumSPNs: ULONG,
   pub SPNList: [UNICODE_STRING; 1usize],
}
impl Default for _USER_ALLOWED_TO_DELEGATE_TO_LIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_ALLOWED_TO_DELEGATE_TO_LIST = _USER_ALLOWED_TO_DELEGATE_TO_LIST;
pub type PUSER_ALLOWED_TO_DELEGATE_TO_LIST = *mut _USER_ALLOWED_TO_DELEGATE_TO_LIST;
#[repr(C)]
pub struct _USER_INTERNAL6_INFORMATION {
   pub I1: USER_ALL_INFORMATION,
   pub LastBadPasswordTime: LARGE_INTEGER,
   pub ExtendedFields: ULONG,
   pub UPNDefaulted: BOOLEAN,
   pub UPN: UNICODE_STRING,
   pub A2D2List: PUSER_ALLOWED_TO_DELEGATE_TO_LIST,
}
impl Default for _USER_INTERNAL6_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL6_INFORMATION = _USER_INTERNAL6_INFORMATION;
pub type PUSER_INTERNAL6_INFORMATION = *mut _USER_INTERNAL6_INFORMATION;
pub type SAM_USER_TILE = SAM_BYTE_ARRAY_32K;
pub type PSAM_USER_TILE = *mut SAM_BYTE_ARRAY_32K;
#[repr(C)]
pub struct _USER_EXTENDED_INFORMATION {
   pub ExtendedWhichFields: ULONG,
   pub UserTile: SAM_USER_TILE,
   pub PasswordHint: UNICODE_STRING,
   pub DontShowInLogonUI: BOOLEAN,
   pub ShellAdminObjectProperties: SAM_SHELL_OBJECT_PROPERTIES,
}
impl Default for _USER_EXTENDED_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_EXTENDED_INFORMATION = _USER_EXTENDED_INFORMATION;
pub type PUSER_EXTENDED_INFORMATION = *mut _USER_EXTENDED_INFORMATION;
#[repr(C)]
pub struct _USER_LOGON_UI_INFORMATION {
   pub PasswordIsBlank: BOOLEAN,
   pub AccountIsDisabled: BOOLEAN,
}
impl Default for _USER_LOGON_UI_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_LOGON_UI_INFORMATION = _USER_LOGON_UI_INFORMATION;
pub type PUSER_LOGON_UI_INFORMATION = *mut _USER_LOGON_UI_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTED_PASSWORD_AES {
   pub AuthData: [UCHAR; 64usize],
   pub Salt: [UCHAR; 16usize],
   pub cbCipher: ULONG,
   pub Cipher: PUCHAR,
   pub PBKDF2Iterations: ULONGLONG,
}
impl Default for _ENCRYPTED_PASSWORD_AES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ENCRYPTED_PASSWORD_AES = _ENCRYPTED_PASSWORD_AES;
pub type PENCRYPTED_PASSWORD_AES = *mut _ENCRYPTED_PASSWORD_AES;
#[repr(C)]
pub struct _USER_INTERNAL7_INFORMATION {
   pub UserPassword: ENCRYPTED_PASSWORD_AES,
   pub PasswordExpired: BOOLEAN,
}
impl Default for _USER_INTERNAL7_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL7_INFORMATION = _USER_INTERNAL7_INFORMATION;
pub type PUSER_INTERNAL7_INFORMATION = *mut _USER_INTERNAL7_INFORMATION;
#[repr(C)]
pub struct _USER_INTERNAL8_INFORMATION {
   pub I1: USER_ALL_INFORMATION,
   pub UserPassword: ENCRYPTED_PASSWORD_AES,
}
impl Default for _USER_INTERNAL8_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL8_INFORMATION = _USER_INTERNAL8_INFORMATION;
pub type PUSER_INTERNAL8_INFORMATION = *mut _USER_INTERNAL8_INFORMATION;
#[repr(C)]
pub struct _USER_PWD_CHANGE_FAILURE_INFORMATION {
   pub ExtendedFailureReason: ULONG,
   pub FilterModuleName: UNICODE_STRING,
}
impl Default for _USER_PWD_CHANGE_FAILURE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_PWD_CHANGE_FAILURE_INFORMATION = _USER_PWD_CHANGE_FAILURE_INFORMATION;
pub type PUSER_PWD_CHANGE_FAILURE_INFORMATION = *mut _USER_PWD_CHANGE_FAILURE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURITY_DB_DELTA_TYPE {
   SecurityDbNew = 1,
   SecurityDbRename = 2,
   SecurityDbDelete = 3,
   SecurityDbChangeMemberAdd = 4,
   SecurityDbChangeMemberSet = 5,
   SecurityDbChangeMemberDel = 6,
   SecurityDbChange = 7,
   SecurityDbChangePassword = 8,
}
pub use self::_SECURITY_DB_DELTA_TYPE as SECURITY_DB_DELTA_TYPE;
pub type PSECURITY_DB_DELTA_TYPE = *mut _SECURITY_DB_DELTA_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURITY_DB_OBJECT_TYPE {
   SecurityDbObjectSamDomain = 1,
   SecurityDbObjectSamUser = 2,
   SecurityDbObjectSamGroup = 3,
   SecurityDbObjectSamAlias = 4,
   SecurityDbObjectLsaPolicy = 5,
   SecurityDbObjectLsaTDomain = 6,
   SecurityDbObjectLsaAccount = 7,
   SecurityDbObjectLsaSecret = 8,
}
pub use self::_SECURITY_DB_OBJECT_TYPE as SECURITY_DB_OBJECT_TYPE;
pub type PSECURITY_DB_OBJECT_TYPE = *mut _SECURITY_DB_OBJECT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SAM_ACCOUNT_TYPE {
   SamObjectUser = 1,
   SamObjectGroup = 2,
   SamObjectAlias = 3,
}
pub use self::_SAM_ACCOUNT_TYPE as SAM_ACCOUNT_TYPE;
pub type PSAM_ACCOUNT_TYPE = *mut _SAM_ACCOUNT_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SAM_GROUP_MEMBER_ID {
   pub MemberRid: ULONG,
}
pub type SAM_GROUP_MEMBER_ID = _SAM_GROUP_MEMBER_ID;
pub type PSAM_GROUP_MEMBER_ID = *mut _SAM_GROUP_MEMBER_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SAM_ALIAS_MEMBER_ID {
   pub MemberSid: PSID,
}
impl Default for _SAM_ALIAS_MEMBER_ID {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_ALIAS_MEMBER_ID = _SAM_ALIAS_MEMBER_ID;
pub type PSAM_ALIAS_MEMBER_ID = *mut _SAM_ALIAS_MEMBER_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SAM_DELTA_DATA {
   pub GroupMemberId: SAM_GROUP_MEMBER_ID,
   pub AliasMemberId: SAM_ALIAS_MEMBER_ID,
   pub AccountControl: ULONG,
}
impl Default for _SAM_DELTA_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_DELTA_DATA = _SAM_DELTA_DATA;
pub type PSAM_DELTA_DATA = *mut _SAM_DELTA_DATA;
pub type PSAM_DELTA_NOTIFICATION_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      DomainSid: PSID,
      DeltaType: SECURITY_DB_DELTA_TYPE,
      ObjectType: SECURITY_DB_OBJECT_TYPE,
      ObjectRid: ULONG,
      ObjectName: PUNICODE_STRING,
      ModifiedCount: PLARGE_INTEGER,
      DeltaData: PSAM_DELTA_DATA,
   ) -> NTSTATUS,
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PASSWORD_POLICY_VALIDATION_TYPE {
   SamValidateAuthentication = 1,
   SamValidatePasswordChange = 2,
   SamValidatePasswordReset = 3,
}
pub use self::_PASSWORD_POLICY_VALIDATION_TYPE as PASSWORD_POLICY_VALIDATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SAM_VALIDATE_PASSWORD_HASH {
   pub Length: ULONG,
   pub Hash: PUCHAR,
}
impl Default for _SAM_VALIDATE_PASSWORD_HASH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_PASSWORD_HASH = _SAM_VALIDATE_PASSWORD_HASH;
pub type PSAM_VALIDATE_PASSWORD_HASH = *mut _SAM_VALIDATE_PASSWORD_HASH;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SAM_VALIDATE_PERSISTED_FIELDS {
   pub PresentFields: ULONG,
   pub PasswordLastSet: LARGE_INTEGER,
   pub BadPasswordTime: LARGE_INTEGER,
   pub LockoutTime: LARGE_INTEGER,
   pub BadPasswordCount: ULONG,
   pub PasswordHistoryLength: ULONG,
   pub PasswordHistory: PSAM_VALIDATE_PASSWORD_HASH,
}
impl Default for _SAM_VALIDATE_PERSISTED_FIELDS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_PERSISTED_FIELDS = _SAM_VALIDATE_PERSISTED_FIELDS;
pub type PSAM_VALIDATE_PERSISTED_FIELDS = *mut _SAM_VALIDATE_PERSISTED_FIELDS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SAM_VALIDATE_VALIDATION_STATUS {
   SamValidateSuccess = 0,
   SamValidatePasswordMustChange = 1,
   SamValidateAccountLockedOut = 2,
   SamValidatePasswordExpired = 3,
   SamValidatePasswordIncorrect = 4,
   SamValidatePasswordIsInHistory = 5,
   SamValidatePasswordTooShort = 6,
   SamValidatePasswordTooLong = 7,
   SamValidatePasswordNotComplexEnough = 8,
   SamValidatePasswordTooRecent = 9,
   SamValidatePasswordFilterError = 10,
}
pub use self::_SAM_VALIDATE_VALIDATION_STATUS as SAM_VALIDATE_VALIDATION_STATUS;
pub type PSAM_VALIDATE_VALIDATION_STATUS = *mut _SAM_VALIDATE_VALIDATION_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SAM_VALIDATE_STANDARD_OUTPUT_ARG {
   pub ChangedPersistedFields: SAM_VALIDATE_PERSISTED_FIELDS,
   pub ValidationStatus: SAM_VALIDATE_VALIDATION_STATUS,
}
impl Default for _SAM_VALIDATE_STANDARD_OUTPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_STANDARD_OUTPUT_ARG = _SAM_VALIDATE_STANDARD_OUTPUT_ARG;
pub type PSAM_VALIDATE_STANDARD_OUTPUT_ARG = *mut _SAM_VALIDATE_STANDARD_OUTPUT_ARG;
#[repr(C)]
pub struct _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG {
   pub InputPersistedFields: SAM_VALIDATE_PERSISTED_FIELDS,
   pub PasswordMatched: BOOLEAN,
}
impl Default for _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_AUTHENTICATION_INPUT_ARG = _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG;
pub type PSAM_VALIDATE_AUTHENTICATION_INPUT_ARG = *mut _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG;
#[repr(C)]
pub struct _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG {
   pub InputPersistedFields: SAM_VALIDATE_PERSISTED_FIELDS,
   pub ClearPassword: UNICODE_STRING,
   pub UserAccountName: UNICODE_STRING,
   pub HashedPassword: SAM_VALIDATE_PASSWORD_HASH,
   pub PasswordMatch: BOOLEAN,
}
impl Default for _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG = _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG;
pub type PSAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG = *mut _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG;
#[repr(C)]
pub struct _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG {
   pub InputPersistedFields: SAM_VALIDATE_PERSISTED_FIELDS,
   pub ClearPassword: UNICODE_STRING,
   pub UserAccountName: UNICODE_STRING,
   pub HashedPassword: SAM_VALIDATE_PASSWORD_HASH,
   pub PasswordMustChangeAtNextLogon: BOOLEAN,
   pub ClearLockout: BOOLEAN,
}
impl Default for _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG = _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG;
pub type PSAM_VALIDATE_PASSWORD_RESET_INPUT_ARG = *mut _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG;
#[repr(C)]
pub union _SAM_VALIDATE_INPUT_ARG {
   pub ValidateAuthenticationInput:
      ::core::mem::ManuallyDrop<SAM_VALIDATE_AUTHENTICATION_INPUT_ARG>,
   pub ValidatePasswordChangeInput:
      ::core::mem::ManuallyDrop<SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG>,
   pub ValidatePasswordResetInput: ::core::mem::ManuallyDrop<SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG>,
}
impl Default for _SAM_VALIDATE_INPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_INPUT_ARG = _SAM_VALIDATE_INPUT_ARG;
pub type PSAM_VALIDATE_INPUT_ARG = *mut _SAM_VALIDATE_INPUT_ARG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SAM_VALIDATE_OUTPUT_ARG {
   pub ValidateAuthenticationOutput: SAM_VALIDATE_STANDARD_OUTPUT_ARG,
   pub ValidatePasswordChangeOutput: SAM_VALIDATE_STANDARD_OUTPUT_ARG,
   pub ValidatePasswordResetOutput: SAM_VALIDATE_STANDARD_OUTPUT_ARG,
}
impl Default for _SAM_VALIDATE_OUTPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_OUTPUT_ARG = _SAM_VALIDATE_OUTPUT_ARG;
pub type PSAM_VALIDATE_OUTPUT_ARG = *mut _SAM_VALIDATE_OUTPUT_ARG;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SAM_GENERIC_OPERATION_TYPE {
   SamObjectChangeNotificationOperation = 0,
}
pub use self::_SAM_GENERIC_OPERATION_TYPE as SAM_GENERIC_OPERATION_TYPE;
pub type PSAM_GENERIC_OPERATION_TYPE = *mut _SAM_GENERIC_OPERATION_TYPE;
#[repr(C)]
pub struct _SAM_OPERATION_OBJCHG_INPUT {
   pub Register: BOOLEAN,
   pub EventHandle: ULONG64,
   pub ObjectType: SECURITY_DB_OBJECT_TYPE,
   pub ProcessID: ULONG,
}
impl Default for _SAM_OPERATION_OBJCHG_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_OPERATION_OBJCHG_INPUT = _SAM_OPERATION_OBJCHG_INPUT;
pub type PSAM_OPERATION_OBJCHG_INPUT = *mut _SAM_OPERATION_OBJCHG_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SAM_OPERATION_OBJCHG_OUTPUT {
   pub Reserved: ULONG,
}
pub type SAM_OPERATION_OBJCHG_OUTPUT = _SAM_OPERATION_OBJCHG_OUTPUT;
pub type PSAM_OPERATION_OBJCHG_OUTPUT = *mut _SAM_OPERATION_OBJCHG_OUTPUT;
#[repr(C)]
pub union _SAM_GENERIC_OPERATION_INPUT {
   pub ObjChangeIn: ::core::mem::ManuallyDrop<SAM_OPERATION_OBJCHG_INPUT>,
}
impl Default for _SAM_GENERIC_OPERATION_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_GENERIC_OPERATION_INPUT = _SAM_GENERIC_OPERATION_INPUT;
pub type PSAM_GENERIC_OPERATION_INPUT = *mut _SAM_GENERIC_OPERATION_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SAM_GENERIC_OPERATION_OUTPUT {
   pub ObjChangeOut: SAM_OPERATION_OBJCHG_OUTPUT,
}
impl Default for _SAM_GENERIC_OPERATION_OUTPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_GENERIC_OPERATION_OUTPUT = _SAM_GENERIC_OPERATION_OUTPUT;
pub type PSAM_GENERIC_OPERATION_OUTPUT = *mut _SAM_GENERIC_OPERATION_OUTPUT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _VDMSERVICECLASS {
   VdmStartExecution = 0,
   VdmQueueInterrupt = 1,
   VdmDelayInterrupt = 2,
   VdmInitialize = 3,
   VdmFeatures = 4,
   VdmSetInt21Handler = 5,
   VdmQueryDir = 6,
   VdmPrinterDirectIoOpen = 7,
   VdmPrinterDirectIoClose = 8,
   VdmPrinterInitialize = 9,
   VdmSetLdtEntries = 10,
   VdmSetProcessLdtInfo = 11,
   VdmAdlibEmulation = 12,
   VdmPMCliControl = 13,
   VdmQueryVdmProcess = 14,
   VdmPreInitialize = 15,
}
pub use self::_VDMSERVICECLASS as VDMSERVICECLASS;
pub type PVDMSERVICECLASS = *mut _VDMSERVICECLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETWTRACECONTROLCODE {
   EtwStartLoggerCode = 1,
   EtwStopLoggerCode = 2,
   EtwQueryLoggerCode = 3,
   EtwUpdateLoggerCode = 4,
   EtwFlushLoggerCode = 5,
   EtwIncrementLoggerFile = 6,
   EtwRealtimeTransition = 7,
   EtwRealtimeConnectCode = 11,
   EtwActivityIdCreate = 12,
   EtwWdiScenarioCode = 13,
   EtwRealtimeDisconnectCode = 14,
   EtwRegisterGuidsCode = 15,
   EtwReceiveNotification = 16,
   EtwSendDataBlock = 17,
   EtwSendReplyDataBlock = 18,
   EtwReceiveReplyDataBlock = 19,
   EtwWdiSemUpdate = 20,
   EtwEnumTraceGuidList = 21,
   EtwGetTraceGuidInfo = 22,
   EtwEnumerateTraceGuids = 23,
   EtwRegisterSecurityProv = 24,
   EtwReferenceTimeCode = 25,
   EtwTrackBinaryCode = 26,
   EtwAddNotificationEvent = 27,
   EtwUpdateDisallowList = 28,
   EtwSetEnableAllKeywordsCode = 29,
   EtwSetProviderTraitsCode = 30,
   EtwUseDescriptorTypeCode = 31,
   EtwEnumTraceGroupList = 32,
   EtwGetTraceGroupInfo = 33,
   EtwGetDisallowList = 34,
   EtwSetCompressionSettings = 35,
   EtwGetCompressionSettings = 36,
   EtwUpdatePeriodicCaptureState = 37,
   EtwGetPrivateSessionTraceHandle = 38,
   EtwRegisterPrivateSession = 39,
   EtwQuerySessionDemuxObject = 40,
   EtwSetProviderBinaryTracking = 41,
   EtwMaxLoggers = 42,
   EtwMaxPmcCounter = 43,
   EtwQueryUsedProcessorCount = 44,
   EtwGetPmcOwnership = 45,
   EtwGetPmcSessions = 46,
}
pub use self::_ETWTRACECONTROLCODE as ETWTRACECONTROLCODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_TRACE_PROVIDER_INSTANCE_INFO {
   pub NextOffset: ULONG,
   pub EnableCount: ULONG,
   pub Pid: ULONG,
   pub Flags: ULONG,
}
pub type ETW_TRACE_PROVIDER_INSTANCE_INFO = _ETW_TRACE_PROVIDER_INSTANCE_INFO;
pub type PETW_TRACE_PROVIDER_INSTANCE_INFO = *mut _ETW_TRACE_PROVIDER_INSTANCE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_TRACE_GUID_INFO {
   pub InstanceCount: ULONG,
   pub Reserved: ULONG,
}
pub type ETW_TRACE_GUID_INFO = _ETW_TRACE_GUID_INFO;
pub type PETW_TRACE_GUID_INFO = *mut _ETW_TRACE_GUID_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_REF_CLOCK {
   pub StartTime: LARGE_INTEGER,
   pub StartPerfClock: LARGE_INTEGER,
}
impl Default for _ETW_REF_CLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_REF_CLOCK = _ETW_REF_CLOCK;
pub type PETW_REF_CLOCK = *mut _ETW_REF_CLOCK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_UMGL_KEY {
   pub LoggerId: UCHAR,
   pub Flags: UCHAR,
}
pub type ETW_UMGL_KEY = _ETW_UMGL_KEY;
pub type PETW_UMGL_KEY = *mut _ETW_UMGL_KEY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_KERNEL_HEADER_EXTENSION {
   pub GroupMasks: PERFINFO_GROUPMASK,
   pub Version: ULONG,
}
pub type ETW_KERNEL_HEADER_EXTENSION = _ETW_KERNEL_HEADER_EXTENSION;
pub type PETW_KERNEL_HEADER_EXTENSION = *mut _ETW_KERNEL_HEADER_EXTENSION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_SET_MARK_INFORMATION {
   pub Flag: ULONG,
   pub Mark: [WCHAR; 1usize],
}
pub type ETW_SET_MARK_INFORMATION = _ETW_SET_MARK_INFORMATION;
pub type PETW_SET_MARK_INFORMATION = *mut _ETW_SET_MARK_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_NOTIFICATION_TYPE {
   EtwNotificationTypeNoReply = 1,
   EtwNotificationTypeLegacyEnable = 2,
   EtwNotificationTypeEnable = 3,
   EtwNotificationTypePrivateLogger = 4,
   EtwNotificationTypePerflib = 5,
   EtwNotificationTypeAudio = 6,
   EtwNotificationTypeSession = 7,
   EtwNotificationTypeReserved = 8,
   EtwNotificationTypeCredentialUI = 9,
   EtwNotificationTypeInProcSession = 10,
   EtwNotificationTypeMax = 11,
}
pub use self::_ETW_NOTIFICATION_TYPE as ETW_NOTIFICATION_TYPE;
#[repr(C)]
pub struct _ETW_NOTIFICATION_HEADER {
   pub NotificationType: ETW_NOTIFICATION_TYPE,
   pub NotificationSize: ULONG,
   pub Offset: ULONG,
   pub ReplyRequested: BOOLEAN,
   pub Timeout: ULONG,
   pub __bindgen_anon_1: _ETW_NOTIFICATION_HEADER__bindgen_ty_1,
   pub Reserved2: ULONGLONG,
   pub TargetPID: ULONG,
   pub SourcePID: ULONG,
   pub DestinationGuid: GUID,
   pub SourceGuid: GUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_NOTIFICATION_HEADER__bindgen_ty_1 {
   pub ReplyCount: ULONG,
   pub NotifyeeCount: ULONG,
}
impl Default for _ETW_NOTIFICATION_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ETW_NOTIFICATION_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_NOTIFICATION_HEADER = _ETW_NOTIFICATION_HEADER;
pub type PETW_NOTIFICATION_HEADER = *mut _ETW_NOTIFICATION_HEADER;
pub type PETW_NOTIFICATION_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(NotificationHeader: PETW_NOTIFICATION_HEADER, Context: PVOID) -> ULONG,
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_SESSION_NOTIFICATION_TYPE {
   EtwSessionNotificationMediaChanged = 1,
   EtwSessionNotificationSessionTerminated = 2,
   EtwSessionNotificationLogfileError = 3,
   EtwSessionNotificationRealtimeError = 4,
   EtwSessionNotificationSessionStarted = 5,
   EtwSessionNotificationMax = 6,
}
pub use self::_ETW_SESSION_NOTIFICATION_TYPE as ETW_SESSION_NOTIFICATION_TYPE;
#[repr(C)]
pub struct _ETW_SESSION_NOTIFICATION_PACKET {
   pub NotificationHeader: ETW_NOTIFICATION_HEADER,
   pub Type: ETW_SESSION_NOTIFICATION_TYPE,
   pub Status: NTSTATUS,
   pub TraceHandle: TRACEHANDLE,
   pub Reserved: [ULONG; 2usize],
}
impl Default for _ETW_SESSION_NOTIFICATION_PACKET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_SESSION_NOTIFICATION_PACKET = _ETW_SESSION_NOTIFICATION_PACKET;
pub type PETW_SESSION_NOTIFICATION_PACKET = *mut _ETW_SESSION_NOTIFICATION_PACKET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_DESCRIPTOR {
   pub Id: USHORT,
   pub Version: UCHAR,
   pub Channel: UCHAR,
   pub Level: UCHAR,
   pub Opcode: UCHAR,
   pub Task: USHORT,
   pub Keyword: ULONGLONG,
}
pub type EVENT_DESCRIPTOR = _EVENT_DESCRIPTOR;
pub type PEVENT_DESCRIPTOR = *mut _EVENT_DESCRIPTOR;
pub type PCEVENT_DESCRIPTOR = *const EVENT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_DATA_DESCRIPTOR {
   _unused: [u8; 0],
}
pub type EVENT_DATA_DESCRIPTOR = _EVENT_DATA_DESCRIPTOR;
pub type PEVENT_DATA_DESCRIPTOR = *mut _EVENT_DATA_DESCRIPTOR;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_INFO_CLASS {
   __bindgen_cannot_repr_c_on_empty_enum = 0,
}
pub use self::_EVENT_INFO_CLASS as EVENT_INFO_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TELEMETRY_COVERAGE_POINT {
   pub Name: PWSTR,
   pub Hash: ULONG,
   pub LastCoveredRound: ULONG,
   pub Flags: ULONG,
}
impl Default for _TELEMETRY_COVERAGE_POINT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TELEMETRY_COVERAGE_POINT = _TELEMETRY_COVERAGE_POINT;
pub type PTELEMETRY_COVERAGE_POINT = *mut _TELEMETRY_COVERAGE_POINT;
extern "C" {
   pub static mut NlsAnsiCodePage: USHORT;
   pub static mut NlsMbCodePageTag: BOOLEAN;
   pub static mut NlsMbOemCodePageTag: BOOLEAN;
   pub fn NtCallbackReturn(OutputBuffer: PVOID, OutputLength: ULONG, Status: NTSTATUS) -> NTSTATUS;
   pub fn NtFlushProcessWriteBuffers() -> NTSTATUS;
   pub fn NtQueryDebugFilterState(ComponentId: ULONG, Level: ULONG) -> NTSTATUS;
   pub fn NtSetDebugFilterState(ComponentId: ULONG, Level: ULONG, State: BOOLEAN) -> NTSTATUS;
   pub fn NtYieldExecution() -> NTSTATUS;
   pub fn LdrLoadDll(
      DllPath: PWSTR,
      DllCharacteristics: PULONG,
      DllName: PUNICODE_STRING,
      DllHandle: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrUnloadDll(DllHandle: PVOID) -> NTSTATUS;
   pub fn LdrGetDllHandle(
      DllPath: PWSTR,
      DllCharacteristics: PULONG,
      DllName: PUNICODE_STRING,
      DllHandle: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrGetDllHandleEx(
      Flags: ULONG,
      DllPath: PWSTR,
      DllCharacteristics: PULONG,
      DllName: PUNICODE_STRING,
      DllHandle: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrGetDllHandleByMapping(BaseAddress: PVOID, DllHandle: *mut PVOID) -> NTSTATUS;
   pub fn LdrGetDllHandleByName(
      BaseDllName: PUNICODE_STRING,
      FullDllName: PUNICODE_STRING,
      DllHandle: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrGetDllFullName(DllHandle: PVOID, FullDllName: PUNICODE_STRING) -> NTSTATUS;
   pub fn LdrGetDllPath(
      DllName: PCWSTR,
      Flags: ULONG,
      DllPath: *mut PWSTR,
      SearchPaths: *mut PWSTR,
   ) -> NTSTATUS;
   pub fn LdrGetDllDirectory(DllDirectory: PUNICODE_STRING) -> NTSTATUS;
   pub fn LdrSetDllDirectory(DllDirectory: PUNICODE_STRING) -> NTSTATUS;
   pub fn LdrAddRefDll(Flags: ULONG, DllHandle: PVOID) -> NTSTATUS;
   pub fn LdrGetProcedureAddress(
      DllHandle: PVOID,
      ProcedureName: PANSI_STRING,
      ProcedureNumber: ULONG,
      ProcedureAddress: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrGetProcedureAddressEx(
      DllHandle: PVOID,
      ProcedureName: PANSI_STRING,
      ProcedureNumber: ULONG,
      ProcedureAddress: *mut PVOID,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrGetKnownDllSectionHandle(
      DllName: PCWSTR,
      KnownDlls32: BOOLEAN,
      Section: PHANDLE,
   ) -> NTSTATUS;
   pub fn LdrGetProcedureAddressForCaller(
      DllHandle: PVOID,
      ProcedureName: PANSI_STRING,
      ProcedureNumber: ULONG,
      ProcedureAddress: *mut PVOID,
      Flags: ULONG,
      Callback: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrLockLoaderLock(Flags: ULONG, Disposition: *mut ULONG, Cookie: *mut PVOID) -> NTSTATUS;
   pub fn LdrUnlockLoaderLock(Flags: ULONG, Cookie: PVOID) -> NTSTATUS;
   pub fn LdrRelocateImage(
      NewBase: PVOID,
      LoaderName: PSTR,
      Success: NTSTATUS,
      Conflict: NTSTATUS,
      Invalid: NTSTATUS,
   ) -> NTSTATUS;
   pub fn LdrRelocateImageWithBias(
      NewBase: PVOID,
      Bias: LONGLONG,
      LoaderName: PSTR,
      Success: NTSTATUS,
      Conflict: NTSTATUS,
      Invalid: NTSTATUS,
   ) -> NTSTATUS;
   pub fn LdrProcessRelocationBlock(
      VA: ULONG_PTR,
      SizeOfBlock: ULONG,
      NextOffset: PUSHORT,
      Diff: LONG_PTR,
   ) -> PIMAGE_BASE_RELOCATION;
   pub fn LdrProcessRelocationBlockEx(
      Machine: ULONG,
      VA: ULONG_PTR,
      SizeOfBlock: ULONG,
      NextOffset: PUSHORT,
      Diff: LONG_PTR,
   ) -> PIMAGE_BASE_RELOCATION;
   pub fn LdrVerifyMappedImageMatchesChecksum(
      BaseAddress: PVOID,
      NumberOfBytes: SIZE_T,
      FileLength: ULONG,
   ) -> BOOLEAN;
   pub fn LdrVerifyImageMatchesChecksum(
      ImageFileHandle: HANDLE,
      ImportCallbackRoutine: PLDR_IMPORT_MODULE_CALLBACK,
      ImportCallbackParameter: PVOID,
      ImageCharacteristics: PUSHORT,
   ) -> NTSTATUS;
   pub fn LdrVerifyImageMatchesChecksumEx(
      ImageFileHandle: HANDLE,
      VerifyInfo: PLDR_VERIFY_IMAGE_INFO,
   ) -> NTSTATUS;
   pub fn LdrQueryModuleServiceTags(
      DllHandle: PVOID,
      ServiceTagBuffer: PULONG,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn LdrRegisterDllNotification(
      Flags: ULONG,
      NotificationFunction: PLDR_DLL_NOTIFICATION_FUNCTION,
      Context: PVOID,
      Cookie: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrUnregisterDllNotification(Cookie: PVOID) -> NTSTATUS;
   pub fn LdrStandardizeSystemPath(SystemPath: PUNICODE_STRING) -> PUNICODE_STRING;
   pub fn LdrGetFailureData() -> PLDR_FAILURE_DATA;
   pub static mut LdrSystemDllInitBlock: PS_SYSTEM_DLL_INIT_BLOCK;
   pub fn LdrAddLoadAsDataTable(
      Module: PVOID,
      FilePath: PWSTR,
      Size: SIZE_T,
      Handle: HANDLE,
      ActCtx: PACTIVATION_CONTEXT,
   ) -> NTSTATUS;
   pub fn LdrRemoveLoadAsDataTable(
      InitModule: PVOID,
      BaseModule: *mut PVOID,
      Size: PSIZE_T,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrGetFileNameFromLoadAsDataTable(Module: PVOID, pFileNamePrt: *mut PVOID) -> NTSTATUS;
   pub fn LdrDisableThreadCalloutsForDll(DllImageBase: PVOID) -> NTSTATUS;
   pub fn LdrAccessResource(
      DllHandle: PVOID,
      ResourceDataEntry: PIMAGE_RESOURCE_DATA_ENTRY,
      ResourceBuffer: *mut PVOID,
      ResourceLength: *mut ULONG,
   ) -> NTSTATUS;
   pub fn LdrFindResource_U(
      DllHandle: PVOID,
      ResourceInfo: PLDR_RESOURCE_INFO,
      Level: ULONG,
      ResourceDataEntry: *mut PIMAGE_RESOURCE_DATA_ENTRY,
   ) -> NTSTATUS;
   pub fn LdrFindResourceEx_U(
      Flags: ULONG,
      DllHandle: PVOID,
      ResourceInfo: PLDR_RESOURCE_INFO,
      Level: ULONG,
      ResourceDataEntry: *mut PIMAGE_RESOURCE_DATA_ENTRY,
   ) -> NTSTATUS;
   pub fn LdrFindResourceDirectory_U(
      DllHandle: PVOID,
      ResourceInfo: PLDR_RESOURCE_INFO,
      Level: ULONG,
      ResourceDirectory: *mut PIMAGE_RESOURCE_DIRECTORY,
   ) -> NTSTATUS;
   pub fn LdrEnumResources(
      DllHandle: PVOID,
      ResourceInfo: PLDR_RESOURCE_INFO,
      Level: ULONG,
      ResourceCount: *mut ULONG,
      Resources: PLDR_ENUM_RESOURCE_ENTRY,
   ) -> NTSTATUS;
   pub fn LdrFindEntryForAddress(DllHandle: PVOID, Entry: *mut PLDR_DATA_TABLE_ENTRY) -> NTSTATUS;
   pub fn LdrLoadAlternateResourceModule(
      DllHandle: PVOID,
      ResourceDllBase: *mut PVOID,
      ResourceOffset: *mut ULONG_PTR,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrLoadAlternateResourceModuleEx(
      DllHandle: PVOID,
      LanguageId: LANGID,
      ResourceDllBase: *mut PVOID,
      ResourceOffset: *mut ULONG_PTR,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrUnloadAlternateResourceModule(DllHandle: PVOID) -> BOOLEAN;
   pub fn LdrUnloadAlternateResourceModuleEx(DllHandle: PVOID, Flags: ULONG) -> BOOLEAN;
   pub fn LdrQueryProcessModuleInformation(
      ModuleInformation: PRTL_PROCESS_MODULES,
      Size: ULONG,
      ReturnedSize: PULONG,
   ) -> NTSTATUS;
   pub fn LdrEnumerateLoadedModules(
      ReservedFlag: BOOLEAN,
      EnumProc: PLDR_ENUM_CALLBACK,
      Context: PVOID,
   ) -> NTSTATUS;
   pub fn LdrOpenImageFileOptionsKey(
      SubKey: PUNICODE_STRING,
      Wow64: BOOLEAN,
      NewKeyHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn LdrQueryImageFileKeyOption(
      KeyHandle: HANDLE,
      ValueName: PCWSTR,
      Type: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
      ReturnedLength: PULONG,
   ) -> NTSTATUS;
   pub fn LdrQueryImageFileExecutionOptions(
      SubKey: PUNICODE_STRING,
      ValueName: PCWSTR,
      ValueSize: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
      ReturnedLength: PULONG,
   ) -> NTSTATUS;
   pub fn LdrQueryImageFileExecutionOptionsEx(
      SubKey: PUNICODE_STRING,
      ValueName: PCWSTR,
      Type: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
      ReturnedLength: PULONG,
      Wow64: BOOLEAN,
   ) -> NTSTATUS;
   pub fn LdrQueryOptionalDelayLoadedAPI(
      ParentModuleBase: PVOID,
      DllName: PCSTR,
      ProcedureName: PCSTR,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrResolveDelayLoadedAPI(
      ParentModuleBase: PVOID,
      DelayloadDescriptor: PCIMAGE_DELAYLOAD_DESCRIPTOR,
      FailureDllHook: PDELAYLOAD_FAILURE_DLL_CALLBACK,
      FailureSystemHook: PDELAYLOAD_FAILURE_SYSTEM_ROUTINE,
      ThunkAddress: PIMAGE_THUNK_DATA,
      Flags: ULONG,
   ) -> PVOID;
   pub fn LdrResolveDelayLoadsFromDll(
      ParentModuleBase: PVOID,
      TargetDllName: PCSTR,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrSetDefaultDllDirectories(DirectoryFlags: ULONG) -> NTSTATUS;
   pub fn LdrAddDllDirectory(
      NewDirectory: PUNICODE_STRING,
      Cookie: PDLL_DIRECTORY_COOKIE,
   ) -> NTSTATUS;
   pub fn LdrRemoveDllDirectory(Cookie: DLL_DIRECTORY_COOKIE) -> NTSTATUS;
   pub fn LdrShutdownProcess() -> !;
   pub fn LdrShutdownThread() -> !;
   pub fn LdrSetImplicitPathOptions(ImplicitPathOptions: ULONG) -> NTSTATUS;
   pub fn LdrControlFlowGuardEnforced() -> BOOLEAN;
   pub fn LdrIsModuleSxsRedirected(DllHandle: PVOID) -> BOOLEAN;
   pub fn LdrUpdatePackageSearchPath(SearchPathA: PWSTR) -> NTSTATUS;
   pub fn LdrCreateEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      Reserved: ULONG,
      Size: SIZE_T,
      InitialCommitment: SIZE_T,
      EnclaveType: ULONG,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn LdrInitializeEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn LdrDeleteEnclave(BaseAddress: PVOID) -> NTSTATUS;
   pub fn LdrCallEnclave(
      Routine: PENCLAVE_ROUTINE,
      Flags: ULONG,
      RoutineParamReturn: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrLoadEnclaveModule(
      BaseAddress: PVOID,
      DllPath: PWSTR,
      DllName: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn NtDelayExecution(Alertable: BOOLEAN, DelayInterval: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtQuerySystemEnvironmentValue(
      VariableName: PUNICODE_STRING,
      VariableValue: PWSTR,
      ValueLength: USHORT,
      ReturnLength: PUSHORT,
   ) -> NTSTATUS;
   pub fn NtSetSystemEnvironmentValue(
      VariableName: PUNICODE_STRING,
      VariableValue: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn NtQuerySystemEnvironmentValueEx(
      VariableName: PUNICODE_STRING,
      VendorGuid: PCGUID,
      Value: PVOID,
      ValueLength: PULONG,
      Attributes: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetSystemEnvironmentValueEx(
      VariableName: PUNICODE_STRING,
      VendorGuid: PCGUID,
      Value: PVOID,
      ValueLength: ULONG,
      Attributes: ULONG,
   ) -> NTSTATUS;
   pub fn NtEnumerateSystemEnvironmentValuesEx(
      InformationClass: ULONG,
      Buffer: PVOID,
      BufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAddBootEntry(BootEntry: PBOOT_ENTRY, Id: PULONG) -> NTSTATUS;
   pub fn NtDeleteBootEntry(Id: ULONG) -> NTSTATUS;
   pub fn NtModifyBootEntry(BootEntry: PBOOT_ENTRY) -> NTSTATUS;
   pub fn NtEnumerateBootEntries(Buffer: PVOID, BufferLength: PULONG) -> NTSTATUS;
   pub fn NtQueryBootEntryOrder(Ids: PULONG, Count: PULONG) -> NTSTATUS;
   pub fn NtSetBootEntryOrder(Ids: PULONG, Count: ULONG) -> NTSTATUS;
   pub fn NtQueryBootOptions(BootOptions: PBOOT_OPTIONS, BootOptionsLength: PULONG) -> NTSTATUS;
   pub fn NtSetBootOptions(BootOptions: PBOOT_OPTIONS, FieldsToChange: ULONG) -> NTSTATUS;
   pub fn NtTranslateFilePath(
      InputFilePath: PFILE_PATH,
      OutputType: ULONG,
      OutputFilePath: PFILE_PATH,
      OutputFilePathLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAddDriverEntry(DriverEntry: PEFI_DRIVER_ENTRY, Id: PULONG) -> NTSTATUS;
   pub fn NtDeleteDriverEntry(Id: ULONG) -> NTSTATUS;
   pub fn NtModifyDriverEntry(DriverEntry: PEFI_DRIVER_ENTRY) -> NTSTATUS;
   pub fn NtEnumerateDriverEntries(Buffer: PVOID, BufferLength: PULONG) -> NTSTATUS;
   pub fn NtQueryDriverEntryOrder(Ids: PULONG, Count: PULONG) -> NTSTATUS;
   pub fn NtSetDriverEntryOrder(Ids: PULONG, Count: ULONG) -> NTSTATUS;
   pub fn NtFilterBootOption(
      FilterOperation: FILTER_BOOT_OPTION_OPERATION,
      ObjectType: ULONG,
      ElementType: ULONG,
      Data: PVOID,
      DataSize: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateEvent(
      EventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      EventType: EVENT_TYPE,
      InitialState: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtOpenEvent(
      EventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtSetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   pub fn NtSetEventBoostPriority(EventHandle: HANDLE) -> NTSTATUS;
   pub fn NtClearEvent(EventHandle: HANDLE) -> NTSTATUS;
   pub fn NtResetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   pub fn NtPulseEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   pub fn NtQueryEvent(
      EventHandle: HANDLE,
      EventInformationClass: EVENT_INFORMATION_CLASS,
      EventInformation: PVOID,
      EventInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreateEventPair(
      EventPairHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtOpenEventPair(
      EventPairHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtSetLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn NtSetHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn NtWaitLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn NtWaitHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn NtSetLowWaitHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn NtSetHighWaitLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn NtCreateMutant(
      MutantHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      InitialOwner: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtOpenMutant(
      MutantHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtReleaseMutant(MutantHandle: HANDLE, PreviousCount: PLONG) -> NTSTATUS;
   pub fn NtQueryMutant(
      MutantHandle: HANDLE,
      MutantInformationClass: MUTANT_INFORMATION_CLASS,
      MutantInformation: PVOID,
      MutantInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreateSemaphore(
      SemaphoreHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      InitialCount: LONG,
      MaximumCount: LONG,
   ) -> NTSTATUS;
   pub fn NtOpenSemaphore(
      SemaphoreHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtReleaseSemaphore(
      SemaphoreHandle: HANDLE,
      ReleaseCount: LONG,
      PreviousCount: PLONG,
   ) -> NTSTATUS;
   pub fn NtQuerySemaphore(
      SemaphoreHandle: HANDLE,
      SemaphoreInformationClass: SEMAPHORE_INFORMATION_CLASS,
      SemaphoreInformation: PVOID,
      SemaphoreInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreateTimer(
      TimerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TimerType: TIMER_TYPE,
   ) -> NTSTATUS;
   pub fn NtOpenTimer(
      TimerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtSetTimer(
      TimerHandle: HANDLE,
      DueTime: PLARGE_INTEGER,
      TimerApcRoutine: PTIMER_APC_ROUTINE,
      TimerContext: PVOID,
      ResumeTimer: BOOLEAN,
      Period: LONG,
      PreviousState: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtSetTimerEx(
      TimerHandle: HANDLE,
      TimerSetInformationClass: TIMER_SET_INFORMATION_CLASS,
      TimerSetInformation: PVOID,
      TimerSetInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtCancelTimer(TimerHandle: HANDLE, CurrentState: PBOOLEAN) -> NTSTATUS;
   pub fn NtQueryTimer(
      TimerHandle: HANDLE,
      TimerInformationClass: TIMER_INFORMATION_CLASS,
      TimerInformation: PVOID,
      TimerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreateIRTimer(TimerHandle: PHANDLE, DesiredAccess: ACCESS_MASK) -> NTSTATUS;
   pub fn NtSetIRTimer(TimerHandle: HANDLE, DueTime: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtCreateTimer2(
      TimerHandle: PHANDLE,
      Reserved1: PVOID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Attributes: ULONG,
      DesiredAccess: ACCESS_MASK,
   ) -> NTSTATUS;
   pub fn NtSetTimer2(
      TimerHandle: HANDLE,
      DueTime: PLARGE_INTEGER,
      Period: PLARGE_INTEGER,
      Parameters: PT2_SET_PARAMETERS,
   ) -> NTSTATUS;
   pub fn NtCancelTimer2(TimerHandle: HANDLE, Parameters: PT2_CANCEL_PARAMETERS) -> NTSTATUS;
   pub fn NtCreateProfile(
      ProfileHandle: PHANDLE,
      Process: HANDLE,
      ProfileBase: PVOID,
      ProfileSize: SIZE_T,
      BucketSize: ULONG,
      Buffer: PULONG,
      BufferSize: ULONG,
      ProfileSource: KPROFILE_SOURCE,
      Affinity: KAFFINITY,
   ) -> NTSTATUS;
   pub fn NtCreateProfileEx(
      ProfileHandle: PHANDLE,
      Process: HANDLE,
      ProfileBase: PVOID,
      ProfileSize: SIZE_T,
      BucketSize: ULONG,
      Buffer: PULONG,
      BufferSize: ULONG,
      ProfileSource: KPROFILE_SOURCE,
      GroupCount: USHORT,
      GroupAffinity: PGROUP_AFFINITY,
   ) -> NTSTATUS;
   pub fn NtStartProfile(ProfileHandle: HANDLE) -> NTSTATUS;
   pub fn NtStopProfile(ProfileHandle: HANDLE) -> NTSTATUS;
   pub fn NtQueryIntervalProfile(ProfileSource: KPROFILE_SOURCE, Interval: PULONG) -> NTSTATUS;
   pub fn NtSetIntervalProfile(Interval: ULONG, Source: KPROFILE_SOURCE) -> NTSTATUS;
   pub fn NtCreateKeyedEvent(
      KeyedEventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenKeyedEvent(
      KeyedEventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtReleaseKeyedEvent(
      KeyedEventHandle: HANDLE,
      KeyValue: PVOID,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtWaitForKeyedEvent(
      KeyedEventHandle: HANDLE,
      KeyValue: PVOID,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtUmsThreadYield(SchedulerParam: PVOID) -> NTSTATUS;
   pub fn NtCreateWnfStateName(
      StateName: PWNF_STATE_NAME,
      NameLifetime: WNF_STATE_NAME_LIFETIME,
      DataScope: WNF_DATA_SCOPE,
      PersistData: BOOLEAN,
      TypeId: PCWNF_TYPE_ID,
      MaximumStateSize: ULONG,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn NtDeleteWnfStateName(StateName: PCWNF_STATE_NAME) -> NTSTATUS;
   pub fn NtUpdateWnfStateData(
      StateName: PCWNF_STATE_NAME,
      Buffer: *const cty::c_void,
      Length: ULONG,
      TypeId: PCWNF_TYPE_ID,
      ExplicitScope: *const cty::c_void,
      MatchingChangeStamp: WNF_CHANGE_STAMP,
      CheckStamp: LOGICAL,
   ) -> NTSTATUS;
   pub fn NtDeleteWnfStateData(
      StateName: PCWNF_STATE_NAME,
      ExplicitScope: *const cty::c_void,
   ) -> NTSTATUS;
   pub fn NtQueryWnfStateData(
      StateName: PCWNF_STATE_NAME,
      TypeId: PCWNF_TYPE_ID,
      ExplicitScope: *const cty::c_void,
      ChangeStamp: PWNF_CHANGE_STAMP,
      Buffer: PVOID,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn NtQueryWnfStateNameInformation(
      StateName: PCWNF_STATE_NAME,
      NameInfoClass: WNF_STATE_NAME_INFORMATION,
      ExplicitScope: *const cty::c_void,
      InfoBuffer: PVOID,
      InfoBufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn NtSubscribeWnfStateChange(
      StateName: PCWNF_STATE_NAME,
      ChangeStamp: WNF_CHANGE_STAMP,
      EventMask: ULONG,
      SubscriptionId: PULONG64,
   ) -> NTSTATUS;
   pub fn NtUnsubscribeWnfStateChange(StateName: PCWNF_STATE_NAME) -> NTSTATUS;
   pub fn NtGetCompleteWnfStateSubscription(
      OldDescriptorStateName: PWNF_STATE_NAME,
      OldSubscriptionId: *mut ULONG64,
      OldDescriptorEventMask: ULONG,
      OldDescriptorStatus: ULONG,
      NewDeliveryDescriptor: PWNF_DELIVERY_DESCRIPTOR,
      DescriptorSize: ULONG,
   ) -> NTSTATUS;
   pub fn NtSetWnfProcessNotificationEvent(NotificationEvent: HANDLE) -> NTSTATUS;
   pub fn NtCreateWorkerFactory(
      WorkerFactoryHandleReturn: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CompletionPortHandle: HANDLE,
      WorkerProcessHandle: HANDLE,
      StartRoutine: PVOID,
      StartParameter: PVOID,
      MaxThreadCount: ULONG,
      StackReserve: SIZE_T,
      StackCommit: SIZE_T,
   ) -> NTSTATUS;
   pub fn NtQueryInformationWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
      WorkerFactoryInformation: PVOID,
      WorkerFactoryInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
      WorkerFactoryInformation: PVOID,
      WorkerFactoryInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtShutdownWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      PendingWorkerCount: *mut LONG,
   ) -> NTSTATUS;
   pub fn NtReleaseWorkerFactoryWorker(WorkerFactoryHandle: HANDLE) -> NTSTATUS;
   pub fn NtWorkerFactoryWorkerReady(WorkerFactoryHandle: HANDLE) -> NTSTATUS;
   pub fn NtWaitForWorkViaWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      MiniPackets: PFILE_IO_COMPLETION_INFORMATION,
      Count: ULONG,
      PacketsReturned: PULONG,
      DeferredWork: PWORKER_FACTORY_DEFERRED_WORK,
   ) -> NTSTATUS;
   pub fn NtQuerySystemTime(SystemTime: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtSetSystemTime(SystemTime: PLARGE_INTEGER, PreviousTime: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtQueryTimerResolution(
      MaximumTime: PULONG,
      MinimumTime: PULONG,
      CurrentTime: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetTimerResolution(
      DesiredTime: ULONG,
      SetResolution: BOOLEAN,
      ActualTime: PULONG,
   ) -> NTSTATUS;
   pub fn NtQueryPerformanceCounter(
      PerformanceCounter: PLARGE_INTEGER,
      PerformanceFrequency: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtQueryAuxiliaryCounterFrequency(AuxiliaryCounterFrequency: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(
      ConvertAuxiliaryToPerformanceCounter: BOOLEAN,
      PerformanceOrAuxiliaryCounterValue: PLARGE_INTEGER,
      ConvertedValue: PLARGE_INTEGER,
      ConversionError: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtAllocateLocallyUniqueId(Luid: PLUID) -> NTSTATUS;
   pub fn NtSetUuidSeed(Seed: PCHAR) -> NTSTATUS;
   pub fn NtAllocateUuids(
      Time: PULARGE_INTEGER,
      Range: PULONG,
      Sequence: PULONG,
      Seed: PCHAR,
   ) -> NTSTATUS;
   pub fn NtQuerySystemInformation(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtQuerySystemInformationEx(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetSystemInformation(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtSystemDebugControl(
      Command: SYSDBG_COMMAND,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtRaiseHardError(
      ErrorStatus: NTSTATUS,
      NumberOfParameters: ULONG,
      UnicodeStringParameterMask: ULONG,
      Parameters: PULONG_PTR,
      ValidResponseOptions: ULONG,
      Response: PULONG,
   ) -> NTSTATUS;
   pub fn NtGetTickCount64() -> ULONGLONG;
   pub fn NtGetTickCount() -> ULONG;
   pub fn NtQueryDefaultLocale(UserProfile: BOOLEAN, DefaultLocaleId: PLCID) -> NTSTATUS;
   pub fn NtSetDefaultLocale(UserProfile: BOOLEAN, DefaultLocaleId: LCID) -> NTSTATUS;
   pub fn NtQueryInstallUILanguage(InstallUILanguageId: *mut LANGID) -> NTSTATUS;
   pub fn NtFlushInstallUILanguage(InstallUILanguage: LANGID, SetComittedFlag: ULONG) -> NTSTATUS;
   pub fn NtQueryDefaultUILanguage(DefaultUILanguageId: *mut LANGID) -> NTSTATUS;
   pub fn NtSetDefaultUILanguage(DefaultUILanguageId: LANGID) -> NTSTATUS;
   pub fn NtIsUILanguageComitted() -> NTSTATUS;
   pub fn NtInitializeNlsFiles(
      BaseAddress: *mut PVOID,
      DefaultLocaleId: PLCID,
      DefaultCasingTableSize: PLARGE_INTEGER,
      CurrentNLSVersion: PULONG,
   ) -> NTSTATUS;
   pub fn NtGetNlsSectionPtr(
      SectionType: ULONG,
      SectionData: ULONG,
      ContextData: PVOID,
      SectionPointer: *mut PVOID,
      SectionSize: PULONG,
   ) -> NTSTATUS;
   pub fn NtMapCMFModule(
      What: ULONG,
      Index: ULONG,
      CacheIndexOut: PULONG,
      CacheFlagsOut: PULONG,
      ViewSizeOut: PULONG,
      BaseAddress: *mut PVOID,
   ) -> NTSTATUS;
   pub fn NtGetMUIRegistryInfo(Flags: ULONG, DataSize: PULONG, Data: PVOID) -> NTSTATUS;
   pub fn NtAddAtom(AtomName: PWSTR, Length: ULONG, Atom: PRTL_ATOM) -> NTSTATUS;
   pub fn NtAddAtomEx(AtomName: PWSTR, Length: ULONG, Atom: PRTL_ATOM, Flags: ULONG) -> NTSTATUS;
   pub fn NtFindAtom(AtomName: PWSTR, Length: ULONG, Atom: PRTL_ATOM) -> NTSTATUS;
   pub fn NtDeleteAtom(Atom: RTL_ATOM) -> NTSTATUS;
   pub fn NtQueryInformationAtom(
      Atom: RTL_ATOM,
      AtomInformationClass: ATOM_INFORMATION_CLASS,
      AtomInformation: PVOID,
      AtomInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtQueryLicenseValue(
      ValueName: PUNICODE_STRING,
      Type: PULONG,
      Data: PVOID,
      DataSize: ULONG,
      ResultDataSize: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetDefaultHardErrorPort(DefaultHardErrorPort: HANDLE) -> NTSTATUS;
   pub fn NtShutdownSystem(Action: SHUTDOWN_ACTION) -> NTSTATUS;
   pub fn NtDisplayString(String: PUNICODE_STRING) -> NTSTATUS;
   pub fn NtDrawText(Text: PUNICODE_STRING) -> NTSTATUS;
   pub static GUID_BAD_MEMORY_GROUP: GUID;
   pub static GUID_BOOT_LOADER_SETTINGS_GROUP: GUID;
   pub static GUID_CURRENT_BOOT_ENTRY: GUID;
   pub static GUID_DEBUGGER_SETTINGS_GROUP: GUID;
   pub static GUID_DEFAULT_BOOT_ENTRY: GUID;
   pub static GUID_EMS_SETTINGS_GROUP: GUID;
   pub static GUID_FIRMWARE_BOOTMGR: GUID;
   pub static GUID_GLOBAL_SETTINGS_GROUP: GUID;
   pub static GUID_HYPERVISOR_SETTINGS_GROUP: GUID;
   pub static GUID_KERNEL_DEBUGGER_SETTINGS_GROUP: GUID;
   pub static GUID_RESUME_LOADER_SETTINGS_GROUP: GUID;
   pub static GUID_WINDOWS_BOOTMGR: GUID;
   pub static GUID_WINDOWS_LEGACY_NTLDR: GUID;
   pub static GUID_WINDOWS_MEMORY_TESTER: GUID;
   pub static GUID_WINDOWS_OS_TARGET_TEMPLATE_EFI: GUID;
   pub static GUID_WINDOWS_OS_TARGET_TEMPLATE_PCAT: GUID;
   pub static GUID_WINDOWS_RESUME_TARGET_TEMPLATE_EFI: GUID;
   pub static GUID_WINDOWS_RESUME_TARGET_TEMPLATE_PCAT: GUID;
   pub static GUID_WINDOWS_SETUP_EFI: GUID;
   pub static GUID_WINDOWS_SETUP_PCAT: GUID;
   pub static GUID_WINDOWS_SETUP_RAMDISK_OPTIONS: GUID;
   pub static GUID_WINDOWS_SETUP_BOOT_ENTRY: GUID;
   pub fn BcdSetLogging(
      BcdLoggingLevel: BCD_MESSAGE_TYPE,
      BcdMessageCallbackRoutine: BCD_MESSAGE_CALLBACK,
   ) -> NTSTATUS;
   pub fn BcdInitializeBcdSyncMutant();
   pub fn BcdGetSystemStorePath(BcdSystemStorePath: *mut PWSTR) -> NTSTATUS;
   pub fn BcdSetSystemStoreDevice(SystemPartition: UNICODE_STRING) -> NTSTATUS;
   pub fn BcdOpenSystemStore(BcdStoreHandle: PHANDLE) -> NTSTATUS;
   pub fn BcdOpenStoreFromFile(BcdFilePath: UNICODE_STRING, BcdStoreHandle: PHANDLE) -> NTSTATUS;
   pub fn BcdCreateStore(BcdFilePath: UNICODE_STRING, BcdStoreHandle: PHANDLE) -> NTSTATUS;
   pub fn BcdExportStore(BcdFilePath: UNICODE_STRING) -> NTSTATUS;
   pub fn BcdImportStore(BcdFilePath: UNICODE_STRING) -> NTSTATUS;
   pub fn BcdImportStoreWithFlags(
      BcdFilePath: UNICODE_STRING,
      BcdImportFlags: BCD_IMPORT_FLAGS,
   ) -> NTSTATUS;
   pub fn BcdDeleteObjectReferences(BcdStoreHandle: HANDLE, Identifier: PGUID) -> NTSTATUS;
   pub fn BcdDeleteSystemStore() -> NTSTATUS;
   pub fn BcdOpenStore(
      BcdFilePath: UNICODE_STRING,
      BcdOpenFlags: BCD_OPEN_FLAGS,
      BcdStoreHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn BcdCloseStore(BcdStoreHandle: HANDLE) -> NTSTATUS;
   pub fn BcdFlushStore(BcdStoreHandle: HANDLE) -> NTSTATUS;
   pub fn BcdForciblyUnloadStore(BcdStoreHandle: HANDLE) -> NTSTATUS;
   pub fn BcdMarkAsSystemStore(BcdStoreHandle: HANDLE) -> NTSTATUS;
   pub fn BcdEnumerateObjects(
      BcdStoreHandle: HANDLE,
      BcdEnumDescriptor: PBCD_OBJECT_DESCRIPTION,
      Buffer: PVOID,
      BufferSize: PULONG,
      ObjectCount: PULONG,
   ) -> NTSTATUS;
   pub fn BcdOpenObject(
      BcdStoreHandle: HANDLE,
      Identifier: *const GUID,
      BcdObjectHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn BcdCreateObject(
      BcdStoreHandle: HANDLE,
      Identifier: PGUID,
      Description: PBCD_OBJECT_DESCRIPTION,
      BcdObjectHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn BcdDeleteObject(BcdObjectHandle: HANDLE) -> NTSTATUS;
   pub fn BcdCloseObject(BcdObjectHandle: HANDLE) -> NTSTATUS;
   pub fn BcdCopyObject(
      BcdStoreHandle: HANDLE,
      BcdObjectHandle: HANDLE,
      BcdCopyFlags: BCD_COPY_FLAGS,
      TargetStoreHandle: HANDLE,
      TargetObjectHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn BcdCopyObjectEx(
      BcdStoreHandle: HANDLE,
      BcdObjectHandle: HANDLE,
      BcdCopyFlags: BCD_COPY_FLAGS,
      TargetStoreHandle: HANDLE,
      TargetObjectId: PGUID,
      TargetObjectHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn BcdCopyObjects(
      BcdStoreHandle: HANDLE,
      Characteristics: BCD_OBJECT_DESCRIPTION,
      BcdCopyFlags: BCD_COPY_FLAGS,
      TargetStoreHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn BcdMigrateObjectElementValues(
      TemplateObjectHandle: HANDLE,
      SourceObjectHandle: HANDLE,
      TargetObjectHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn BcdQueryObject(
      BcdObjectHandle: HANDLE,
      BcdVersion: ULONG,
      Description: BCD_OBJECT_DESCRIPTION,
      Identifier: PGUID,
   ) -> NTSTATUS;
   pub fn BcdEnumerateElementTypes(
      BcdObjectHandle: HANDLE,
      Buffer: PVOID,
      BufferSize: PULONG,
      ElementCount: PULONG,
   ) -> NTSTATUS;
   pub fn BcdEnumerateElements(
      BcdObjectHandle: HANDLE,
      Buffer: PVOID,
      BufferSize: PULONG,
      ElementCount: PULONG,
   ) -> NTSTATUS;
   pub fn BcdEnumerateElementsWithFlags(
      BcdObjectHandle: HANDLE,
      BcdFlags: BCD_FLAGS,
      Buffer: PVOID,
      BufferSize: PULONG,
      ElementCount: PULONG,
   ) -> NTSTATUS;
   pub fn BcdEnumerateAndUnpackElements(
      BcdStoreHandle: HANDLE,
      BcdObjectHandle: HANDLE,
      BcdFlags: BCD_FLAGS,
      Buffer: PVOID,
      BufferSize: PULONG,
      ElementCount: PULONG,
   ) -> NTSTATUS;
   pub fn BcdGetElementData(
      BcdObjectHandle: HANDLE,
      BcdElement: ULONG,
      Buffer: PVOID,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn BcdGetElementDataWithFlags(
      BcdObjectHandle: HANDLE,
      BcdElement: ULONG,
      BcdFlags: BCD_FLAGS,
      Buffer: PVOID,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn BcdSetElementData(
      BcdObjectHandle: HANDLE,
      BcdElement: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn BcdSetElementDataWithFlags(
      BcdObjectHandle: HANDLE,
      BcdElement: ULONG,
      BcdFlags: BCD_FLAGS,
      Buffer: PVOID,
      BufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn BcdDeleteElement(BcdObjectHandle: HANDLE, BcdElement: ULONG) -> NTSTATUS;
   pub fn NtAllocateVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      RegionSize: PSIZE_T,
      AllocationType: ULONG,
      Protect: ULONG,
   ) -> NTSTATUS;
   pub fn NtAllocateVirtualMemoryEx(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      AllocationType: ULONG,
      PageProtection: ULONG,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn NtFreeVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      FreeType: ULONG,
   ) -> NTSTATUS;
   pub fn NtReadVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtReadVirtualMemoryEx(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtWriteVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesWritten: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtProtectVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      NewProtect: ULONG,
      OldProtect: PULONG,
   ) -> NTSTATUS;
   pub fn NtQueryVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      MemoryInformationClass: MEMORY_INFORMATION_CLASS,
      MemoryInformation: PVOID,
      MemoryInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtFlushVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      IoStatus: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn NtSetInformationVirtualMemory(
      ProcessHandle: HANDLE,
      VmInformationClass: VIRTUAL_MEMORY_INFORMATION_CLASS,
      NumberOfEntries: ULONG_PTR,
      VirtualAddresses: PMEMORY_RANGE_ENTRY,
      VmInformation: PVOID,
      VmInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtLockVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      MapType: ULONG,
   ) -> NTSTATUS;
   pub fn NtUnlockVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      MapType: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateSection(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaximumSize: PLARGE_INTEGER,
      SectionPageProtection: ULONG,
      AllocationAttributes: ULONG,
      FileHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn NtCreateSectionEx(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaximumSize: PLARGE_INTEGER,
      SectionPageProtection: ULONG,
      AllocationAttributes: ULONG,
      FileHandle: HANDLE,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenSection(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtMapViewOfSection(
      SectionHandle: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      CommitSize: SIZE_T,
      SectionOffset: PLARGE_INTEGER,
      ViewSize: PSIZE_T,
      InheritDisposition: SECTION_INHERIT,
      AllocationType: ULONG,
      Win32Protect: ULONG,
   ) -> NTSTATUS;
   pub fn NtMapViewOfSectionEx(
      SectionHandle: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      SectionOffset: PLARGE_INTEGER,
      ViewSize: PSIZE_T,
      AllocationType: ULONG,
      Win32Protect: ULONG,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn NtUnmapViewOfSection(ProcessHandle: HANDLE, BaseAddress: PVOID) -> NTSTATUS;
   pub fn NtUnmapViewOfSectionEx(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtExtendSection(SectionHandle: HANDLE, NewSectionSize: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtQuerySection(
      SectionHandle: HANDLE,
      SectionInformationClass: SECTION_INFORMATION_CLASS,
      SectionInformation: PVOID,
      SectionInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtAreMappedFilesTheSame(
      File1MappedAsAnImage: PVOID,
      File2MappedAsFile: PVOID,
   ) -> NTSTATUS;
   pub fn NtCreatePartition(
      ParentPartitionHandle: HANDLE,
      PartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PreferredNode: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenPartition(
      PartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtManagePartition(
      TargetHandle: HANDLE,
      SourceHandle: HANDLE,
      PartitionInformationClass: PARTITION_INFORMATION_CLASS,
      PartitionInformation: PVOID,
      PartitionInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtMapUserPhysicalPages(
      VirtualAddress: PVOID,
      NumberOfPages: ULONG_PTR,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtMapUserPhysicalPagesScatter(
      VirtualAddresses: *mut PVOID,
      NumberOfPages: ULONG_PTR,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtAllocateUserPhysicalPages(
      ProcessHandle: HANDLE,
      NumberOfPages: PULONG_PTR,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtAllocateUserPhysicalPagesEx(
      ProcessHandle: HANDLE,
      NumberOfPages: PULONG_PTR,
      UserPfnArray: PULONG_PTR,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn NtFreeUserPhysicalPages(
      ProcessHandle: HANDLE,
      NumberOfPages: PULONG_PTR,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtGetWriteWatch(
      ProcessHandle: HANDLE,
      Flags: ULONG,
      BaseAddress: PVOID,
      RegionSize: SIZE_T,
      UserAddressArray: *mut PVOID,
      EntriesInUserAddressArray: PULONG_PTR,
      Granularity: PULONG,
   ) -> NTSTATUS;
   pub fn NtResetWriteWatch(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      RegionSize: SIZE_T,
   ) -> NTSTATUS;
   pub fn NtCreatePagingFile(
      PageFileName: PUNICODE_STRING,
      MinimumSize: PLARGE_INTEGER,
      MaximumSize: PLARGE_INTEGER,
      Priority: ULONG,
   ) -> NTSTATUS;
   pub fn NtFlushInstructionCache(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Length: SIZE_T,
   ) -> NTSTATUS;
   pub fn NtFlushWriteBuffer() -> NTSTATUS;
   pub fn NtCreateEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      Size: SIZE_T,
      InitialCommitment: SIZE_T,
      EnclaveType: ULONG,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn NtLoadEnclaveData(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      Protect: ULONG,
      PageInformation: PVOID,
      PageInformationLength: ULONG,
      NumberOfBytesWritten: PSIZE_T,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn NtInitializeEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn NtTerminateEnclave(BaseAddress: PVOID, Flags: ULONG) -> NTSTATUS;
   pub fn NtCallEnclave(
      Routine: PENCLAVE_ROUTINE,
      Reserved: PVOID,
      Flags: ULONG,
      RoutineParamReturn: *mut PVOID,
   ) -> NTSTATUS;
   pub fn NtQueryObject(
      Handle: HANDLE,
      ObjectInformationClass: OBJECT_INFORMATION_CLASS,
      ObjectInformation: PVOID,
      ObjectInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationObject(
      Handle: HANDLE,
      ObjectInformationClass: OBJECT_INFORMATION_CLASS,
      ObjectInformation: PVOID,
      ObjectInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtDuplicateObject(
      SourceProcessHandle: HANDLE,
      SourceHandle: HANDLE,
      TargetProcessHandle: HANDLE,
      TargetHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Options: ULONG,
   ) -> NTSTATUS;
   pub fn NtMakeTemporaryObject(Handle: HANDLE) -> NTSTATUS;
   pub fn NtMakePermanentObject(Handle: HANDLE) -> NTSTATUS;
   pub fn NtSignalAndWaitForSingleObject(
      SignalHandle: HANDLE,
      WaitHandle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtWaitForSingleObject(
      Handle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtWaitForMultipleObjects(
      Count: ULONG,
      Handles: *mut HANDLE,
      WaitType: WAIT_TYPE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtWaitForMultipleObjects32(
      Count: ULONG,
      Handles: *mut LONG,
      WaitType: WAIT_TYPE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtSetSecurityObject(
      Handle: HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn NtQuerySecurityObject(
      Handle: HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Length: ULONG,
      LengthNeeded: PULONG,
   ) -> NTSTATUS;
   pub fn NtClose(Handle: HANDLE) -> NTSTATUS;
   pub fn NtCompareObjects(FirstObjectHandle: HANDLE, SecondObjectHandle: HANDLE) -> NTSTATUS;
   pub fn NtCreateDirectoryObject(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtCreateDirectoryObjectEx(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ShadowDirectoryHandle: HANDLE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenDirectoryObject(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtQueryDirectoryObject(
      DirectoryHandle: HANDLE,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      RestartScan: BOOLEAN,
      Context: PULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreatePrivateNamespace(
      NamespaceHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      BoundaryDescriptor: POBJECT_BOUNDARY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn NtOpenPrivateNamespace(
      NamespaceHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      BoundaryDescriptor: POBJECT_BOUNDARY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn NtDeletePrivateNamespace(NamespaceHandle: HANDLE) -> NTSTATUS;
   pub fn NtCreateSymbolicLinkObject(
      LinkHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LinkTarget: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn NtOpenSymbolicLinkObject(
      LinkHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtQuerySymbolicLinkObject(
      LinkHandle: HANDLE,
      LinkTarget: PUNICODE_STRING,
      ReturnedLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationSymbolicLink(
      LinkHandle: HANDLE,
      SymbolicLinkInformationClass: SYMBOLIC_LINK_INFO_CLASS,
      SymbolicLinkInformation: PVOID,
      SymbolicLinkInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueryPortInformationProcess() -> NTSTATUS;
   pub fn NtCreateProcess(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ParentProcess: HANDLE,
      InheritObjectTable: BOOLEAN,
      SectionHandle: HANDLE,
      DebugPort: HANDLE,
      TokenHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn NtCreateProcessEx(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ParentProcess: HANDLE,
      Flags: ULONG,
      SectionHandle: HANDLE,
      DebugPort: HANDLE,
      TokenHandle: HANDLE,
      Reserved: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenProcess(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ClientId: PCLIENT_ID,
   ) -> NTSTATUS;
   pub fn NtTerminateProcess(ProcessHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn NtSuspendProcess(ProcessHandle: HANDLE) -> NTSTATUS;
   pub fn NtResumeProcess(ProcessHandle: HANDLE) -> NTSTATUS;
   pub static mut __ImageBase: IMAGE_DOS_HEADER;
   pub fn NtQueryInformationProcess(
      ProcessHandle: HANDLE,
      ProcessInformationClass: PROCESSINFOCLASS,
      ProcessInformation: PVOID,
      ProcessInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtGetNextProcess(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Flags: ULONG,
      NewProcessHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtGetNextThread(
      ProcessHandle: HANDLE,
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Flags: ULONG,
      NewThreadHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtSetInformationProcess(
      ProcessHandle: HANDLE,
      ProcessInformationClass: PROCESSINFOCLASS,
      ProcessInformation: PVOID,
      ProcessInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateProcessStateChange(
      ProcessStateChangeHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn NtChangeProcessState(
      ProcessStateChangeHandle: HANDLE,
      ProcessHandle: HANDLE,
      StateChangeType: PROCESS_STATE_CHANGE_TYPE,
      ExtendedInformation: PVOID,
      ExtendedInformationLength: SIZE_T,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn NtCreateThreadStateChange(
      ThreadStateChangeHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ThreadHandle: HANDLE,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn NtChangeThreadState(
      ThreadStateChangeHandle: HANDLE,
      ThreadHandle: HANDLE,
      StateChangeType: THREAD_STATE_CHANGE_TYPE,
      ExtendedInformation: PVOID,
      ExtendedInformationLength: SIZE_T,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn NtCreateThread(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      ClientId: PCLIENT_ID,
      ThreadContext: PCONTEXT,
      InitialTeb: PINITIAL_TEB,
      CreateSuspended: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtOpenThread(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ClientId: PCLIENT_ID,
   ) -> NTSTATUS;
   pub fn NtTerminateThread(ThreadHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn NtSuspendThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   pub fn NtResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   pub fn NtGetCurrentProcessorNumber() -> ULONG;
   pub fn NtGetCurrentProcessorNumberEx(ProcessorNumber: PPROCESSOR_NUMBER) -> ULONG;
   pub fn NtGetContextThread(ThreadHandle: HANDLE, ThreadContext: PCONTEXT) -> NTSTATUS;
   pub fn NtSetContextThread(ThreadHandle: HANDLE, ThreadContext: PCONTEXT) -> NTSTATUS;
   pub fn NtQueryInformationThread(
      ThreadHandle: HANDLE,
      ThreadInformationClass: THREADINFOCLASS,
      ThreadInformation: PVOID,
      ThreadInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationThread(
      ThreadHandle: HANDLE,
      ThreadInformationClass: THREADINFOCLASS,
      ThreadInformation: PVOID,
      ThreadInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtAlertThread(ThreadHandle: HANDLE) -> NTSTATUS;
   pub fn NtAlertResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   pub fn NtTestAlert() -> NTSTATUS;
   pub fn NtImpersonateThread(
      ServerThreadHandle: HANDLE,
      ClientThreadHandle: HANDLE,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
   ) -> NTSTATUS;
   pub fn NtRegisterThreadTerminatePort(PortHandle: HANDLE) -> NTSTATUS;
   pub fn NtSetLdtEntries(
      Selector0: ULONG,
      Entry0Low: ULONG,
      Entry0Hi: ULONG,
      Selector1: ULONG,
      Entry1Low: ULONG,
      Entry1Hi: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueueApcThread(
      ThreadHandle: HANDLE,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn NtQueueApcThreadEx(
      ThreadHandle: HANDLE,
      ReserveHandle: HANDLE,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn NtQueueApcThreadEx2(
      ThreadHandle: HANDLE,
      ReserveHandle: HANDLE,
      ApcFlags: ULONG,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn NtAlertThreadByThreadId(ThreadId: HANDLE) -> NTSTATUS;
   pub fn NtWaitForAlertByThreadId(Address: PVOID, Timeout: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtCreateUserProcess(
      ProcessHandle: PHANDLE,
      ThreadHandle: PHANDLE,
      ProcessDesiredAccess: ACCESS_MASK,
      ThreadDesiredAccess: ACCESS_MASK,
      ProcessObjectAttributes: POBJECT_ATTRIBUTES,
      ThreadObjectAttributes: POBJECT_ATTRIBUTES,
      ProcessFlags: ULONG,
      ThreadFlags: ULONG,
      ProcessParameters: PVOID,
      CreateInfo: PPS_CREATE_INFO,
      AttributeList: PPS_ATTRIBUTE_LIST,
   ) -> NTSTATUS;
   pub fn NtCreateThreadEx(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      StartRoutine: PUSER_THREAD_START_ROUTINE,
      Argument: PVOID,
      CreateFlags: ULONG,
      ZeroBits: SIZE_T,
      StackSize: SIZE_T,
      MaximumStackSize: SIZE_T,
      AttributeList: PPS_ATTRIBUTE_LIST,
   ) -> NTSTATUS;
   pub fn NtCreateJobObject(
      JobHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtOpenJobObject(
      JobHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtAssignProcessToJobObject(JobHandle: HANDLE, ProcessHandle: HANDLE) -> NTSTATUS;
   pub fn NtTerminateJobObject(JobHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn NtIsProcessInJob(ProcessHandle: HANDLE, JobHandle: HANDLE) -> NTSTATUS;
   pub fn NtQueryInformationJobObject(
      JobHandle: HANDLE,
      JobObjectInformationClass: JOBOBJECTINFOCLASS,
      JobObjectInformation: PVOID,
      JobObjectInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationJobObject(
      JobHandle: HANDLE,
      JobObjectInformationClass: JOBOBJECTINFOCLASS,
      JobObjectInformation: PVOID,
      JobObjectInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateJobSet(NumJob: ULONG, UserJobSet: PJOB_SET_ARRAY, Flags: ULONG) -> NTSTATUS;
   pub fn NtRevertContainerImpersonation() -> NTSTATUS;
   pub fn NtAllocateReserveObject(
      MemoryReserveHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Type: MEMORY_RESERVE_TYPE,
   ) -> NTSTATUS;
   pub fn PssNtCaptureSnapshot(
      SnapshotHandle: PHANDLE,
      ProcessHandle: HANDLE,
      CaptureFlags: ULONG,
      ThreadContextFlags: ULONG,
   ) -> NTSTATUS;
   pub fn NtPssCaptureVaSpaceBulk(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      BulkInformation: PNTPSS_MEMORY_BULK_INFORMATION,
      BulkInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn DbgUserBreakPoint();
   pub fn DbgBreakPoint();
   pub fn DbgBreakPointWithStatus(Status: ULONG);
   pub fn DbgPrint(Format: PCSTR, ...) -> ULONG;
   pub fn DbgPrintEx(ComponentId: ULONG, Level: ULONG, Format: PCSTR, ...) -> ULONG;
   pub fn vDbgPrintEx(ComponentId: ULONG, Level: ULONG, Format: PCCH, arglist: va_list) -> ULONG;
   pub fn vDbgPrintExWithPrefix(
      Prefix: PCCH,
      ComponentId: ULONG,
      Level: ULONG,
      Format: PCCH,
      arglist: va_list,
   ) -> ULONG;
   pub fn DbgQueryDebugFilterState(ComponentId: ULONG, Level: ULONG) -> NTSTATUS;
   pub fn DbgSetDebugFilterState(ComponentId: ULONG, Level: ULONG, State: BOOLEAN) -> NTSTATUS;
   pub fn DbgPrompt(Prompt: PCCH, Response: PCH, Length: ULONG) -> ULONG;
   pub fn NtCreateDebugObject(
      DebugObjectHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtDebugActiveProcess(ProcessHandle: HANDLE, DebugObjectHandle: HANDLE) -> NTSTATUS;
   pub fn NtDebugContinue(
      DebugObjectHandle: HANDLE,
      ClientId: PCLIENT_ID,
      ContinueStatus: NTSTATUS,
   ) -> NTSTATUS;
   pub fn NtRemoveProcessDebug(ProcessHandle: HANDLE, DebugObjectHandle: HANDLE) -> NTSTATUS;
   pub fn NtSetInformationDebugObject(
      DebugObjectHandle: HANDLE,
      DebugObjectInformationClass: DEBUGOBJECTINFOCLASS,
      DebugInformation: PVOID,
      DebugInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtWaitForDebugEvent(
      DebugObjectHandle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
      WaitStateChange: PDBGUI_WAIT_STATE_CHANGE,
   ) -> NTSTATUS;
   pub fn DbgUiConnectToDbg() -> NTSTATUS;
   pub fn DbgUiGetThreadDebugObject() -> HANDLE;
   pub fn DbgUiSetThreadDebugObject(DebugObject: HANDLE);
   pub fn DbgUiWaitStateChange(
      StateChange: PDBGUI_WAIT_STATE_CHANGE,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn DbgUiContinue(AppClientId: PCLIENT_ID, ContinueStatus: NTSTATUS) -> NTSTATUS;
   pub fn DbgUiStopDebugging(Process: HANDLE) -> NTSTATUS;
   pub fn DbgUiDebugActiveProcess(Process: HANDLE) -> NTSTATUS;
   pub fn DbgUiRemoteBreakin(Context: PVOID);
   pub fn DbgUiIssueRemoteBreakin(Process: HANDLE) -> NTSTATUS;
   pub fn DbgUiConvertStateChangeStructure(
      StateChange: PDBGUI_WAIT_STATE_CHANGE,
      DebugEvent: LPDEBUG_EVENT,
   ) -> NTSTATUS;
   pub fn DbgUiConvertStateChangeStructureEx(
      StateChange: PDBGUI_WAIT_STATE_CHANGE,
      DebugEvent: LPDEBUG_EVENT,
   ) -> NTSTATUS;
   pub fn EtwEventRegister(
      ProviderId: LPCGUID,
      EnableCallback: PENABLECALLBACK,
      CallbackContext: PVOID,
      RegHandle: PREGHANDLE,
   ) -> NTSTATUS;
   pub fn NtCreateFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      AllocationSize: PLARGE_INTEGER,
      FileAttributes: ULONG,
      ShareAccess: ULONG,
      CreateDisposition: ULONG,
      CreateOptions: ULONG,
      EaBuffer: PVOID,
      EaLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateNamedPipeFile(
      FileHandle: PHANDLE,
      DesiredAccess: ULONG,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ShareAccess: ULONG,
      CreateDisposition: ULONG,
      CreateOptions: ULONG,
      NamedPipeType: ULONG,
      ReadMode: ULONG,
      CompletionMode: ULONG,
      MaximumInstances: ULONG,
      InboundQuota: ULONG,
      OutboundQuota: ULONG,
      DefaultTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtCreateMailslotFile(
      FileHandle: PHANDLE,
      DesiredAccess: ULONG,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CreateOptions: ULONG,
      MailslotQuota: ULONG,
      MaximumMessageSize: ULONG,
      ReadTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtOpenFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ShareAccess: ULONG,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn NtDeleteFile(ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
   pub fn NtFlushBuffersFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
   pub fn NtFlushBuffersFileEx(
      FileHandle: HANDLE,
      Flags: ULONG,
      Parameters: PVOID,
      ParametersSize: ULONG,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn NtQueryInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn NtQueryInformationByName(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn NtSetInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn NtQueryDirectoryFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
      ReturnSingleEntry: BOOLEAN,
      FileName: PUNICODE_STRING,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtQueryDirectoryFileEx(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
      QueryFlags: ULONG,
      FileName: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn NtQueryEaFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      EaList: PVOID,
      EaListLength: ULONG,
      EaIndex: PULONG,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtSetEaFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueryQuotaInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      SidList: PVOID,
      SidListLength: ULONG,
      StartSid: PSID,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtSetQuotaInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueryVolumeInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsInformation: PVOID,
      Length: ULONG,
      FsInformationClass: FSINFOCLASS,
   ) -> NTSTATUS;
   pub fn NtSetVolumeInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsInformation: PVOID,
      Length: ULONG,
      FsInformationClass: FSINFOCLASS,
   ) -> NTSTATUS;
   pub fn NtCancelIoFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
   pub fn NtCancelIoFileEx(
      FileHandle: HANDLE,
      IoRequestToCancel: PIO_STATUS_BLOCK,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn NtCancelSynchronousIoFile(
      ThreadHandle: HANDLE,
      IoRequestToCancel: PIO_STATUS_BLOCK,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn NtDeviceIoControlFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      IoControlCode: ULONG,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtFsControlFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsControlCode: ULONG,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtReadFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn NtWriteFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn NtReadFileScatter(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      SegmentArray: PFILE_SEGMENT_ELEMENT,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn NtWriteFileGather(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      SegmentArray: PFILE_SEGMENT_ELEMENT,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn NtLockFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ByteOffset: PLARGE_INTEGER,
      Length: PLARGE_INTEGER,
      Key: ULONG,
      FailImmediately: BOOLEAN,
      ExclusiveLock: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtUnlockFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ByteOffset: PLARGE_INTEGER,
      Length: PLARGE_INTEGER,
      Key: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueryAttributesFile(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      FileInformation: PFILE_BASIC_INFORMATION,
   ) -> NTSTATUS;
   pub fn NtQueryFullAttributesFile(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      FileInformation: PFILE_NETWORK_OPEN_INFORMATION,
   ) -> NTSTATUS;
   pub fn NtNotifyChangeDirectoryFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtNotifyChangeDirectoryFileEx(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn NtLoadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
   pub fn NtUnloadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
   pub fn NtCreateIoCompletion(
      IoCompletionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Count: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenIoCompletion(
      IoCompletionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtQueryIoCompletion(
      IoCompletionHandle: HANDLE,
      IoCompletionInformationClass: IO_COMPLETION_INFORMATION_CLASS,
      IoCompletionInformation: PVOID,
      IoCompletionInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetIoCompletion(
      IoCompletionHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtSetIoCompletionEx(
      IoCompletionHandle: HANDLE,
      IoCompletionPacketHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtRemoveIoCompletion(
      IoCompletionHandle: HANDLE,
      KeyContext: *mut PVOID,
      ApcContext: *mut PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtRemoveIoCompletionEx(
      IoCompletionHandle: HANDLE,
      IoCompletionInformation: PFILE_IO_COMPLETION_INFORMATION,
      Count: ULONG,
      NumEntriesRemoved: PULONG,
      Timeout: PLARGE_INTEGER,
      Alertable: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtCreateWaitCompletionPacket(
      WaitCompletionPacketHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtAssociateWaitCompletionPacket(
      WaitCompletionPacketHandle: HANDLE,
      IoCompletionHandle: HANDLE,
      TargetObjectHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
      AlreadySignaled: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtCancelWaitCompletionPacket(
      WaitCompletionPacketHandle: HANDLE,
      RemoveSignaledPacket: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtOpenSession(
      SessionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtNotifyChangeSession(
      SessionHandle: HANDLE,
      ChangeSequenceNumber: ULONG,
      ChangeTimeStamp: PLARGE_INTEGER,
      Event: IO_SESSION_EVENT,
      NewState: IO_SESSION_STATE,
      PreviousState: IO_SESSION_STATE,
      Payload: PVOID,
      PayloadSize: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateIoRing(
      IoRingHandle: PHANDLE,
      CreateParametersLength: ULONG,
      CreateParameters: PVOID,
      OutputParametersLength: ULONG,
      OutputParameters: PVOID,
   ) -> NTSTATUS;
   pub fn NtSubmitIoRing(
      IoRingHandle: HANDLE,
      Flags: ULONG,
      WaitOperations: ULONG,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtQueryIoRingCapabilities(
      IoRingCapabilitiesLength: SIZE_T,
      IoRingCapabilities: PVOID,
   ) -> NTSTATUS;
   pub fn NtSetInformationIoRing(
      IoRingHandle: HANDLE,
      IoRingInformationClass: ULONG,
      IoRingInformationLength: ULONG,
      IoRingInformation: PVOID,
   ) -> NTSTATUS;
   pub fn NtCreatePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaxConnectionInfoLength: ULONG,
      MaxMessageLength: ULONG,
      MaxPoolUsage: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateWaitablePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaxConnectionInfoLength: ULONG,
      MaxMessageLength: ULONG,
      MaxPoolUsage: ULONG,
   ) -> NTSTATUS;
   pub fn NtConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
      ClientView: PPORT_VIEW,
      ServerView: PREMOTE_PORT_VIEW,
      MaxMessageLength: PULONG,
      ConnectionInformation: PVOID,
      ConnectionInformationLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSecureConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
      ClientView: PPORT_VIEW,
      RequiredServerSid: PSID,
      ServerView: PREMOTE_PORT_VIEW,
      MaxMessageLength: PULONG,
      ConnectionInformation: PVOID,
      ConnectionInformationLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtListenPort(PortHandle: HANDLE, ConnectionRequest: PPORT_MESSAGE) -> NTSTATUS;
   pub fn NtAcceptConnectPort(
      PortHandle: PHANDLE,
      PortContext: PVOID,
      ConnectionRequest: PPORT_MESSAGE,
      AcceptConnection: BOOLEAN,
      ServerView: PPORT_VIEW,
      ClientView: PREMOTE_PORT_VIEW,
   ) -> NTSTATUS;
   pub fn NtCompleteConnectPort(PortHandle: HANDLE) -> NTSTATUS;
   pub fn NtRequestPort(PortHandle: HANDLE, RequestMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn NtRequestWaitReplyPort(
      PortHandle: HANDLE,
      RequestMessage: PPORT_MESSAGE,
      ReplyMessage: PPORT_MESSAGE,
   ) -> NTSTATUS;
   pub fn NtReplyPort(PortHandle: HANDLE, ReplyMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn NtReplyWaitReplyPort(PortHandle: HANDLE, ReplyMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn NtReplyWaitReceivePort(
      PortHandle: HANDLE,
      PortContext: *mut PVOID,
      ReplyMessage: PPORT_MESSAGE,
      ReceiveMessage: PPORT_MESSAGE,
   ) -> NTSTATUS;
   pub fn NtReplyWaitReceivePortEx(
      PortHandle: HANDLE,
      PortContext: *mut PVOID,
      ReplyMessage: PPORT_MESSAGE,
      ReceiveMessage: PPORT_MESSAGE,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtImpersonateClientOfPort(PortHandle: HANDLE, Message: PPORT_MESSAGE) -> NTSTATUS;
   pub fn NtReadRequestData(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      DataEntryIndex: ULONG,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtWriteRequestData(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      DataEntryIndex: ULONG,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesWritten: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtQueryInformationPort(
      PortHandle: HANDLE,
      PortInformationClass: PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAlpcCreatePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtAlpcDisconnectPort(PortHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
   pub fn NtAlpcQueryInformation(
      PortHandle: HANDLE,
      PortInformationClass: ALPC_PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAlpcSetInformation(
      PortHandle: HANDLE,
      PortInformationClass: ALPC_PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn NtAlpcCreatePortSection(
      PortHandle: HANDLE,
      Flags: ULONG,
      SectionHandle: HANDLE,
      SectionSize: SIZE_T,
      AlpcSectionHandle: PALPC_HANDLE,
      ActualSectionSize: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtAlpcDeletePortSection(
      PortHandle: HANDLE,
      Flags: ULONG,
      SectionHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn NtAlpcCreateResourceReserve(
      PortHandle: HANDLE,
      Flags: ULONG,
      MessageSize: SIZE_T,
      ResourceId: PALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn NtAlpcDeleteResourceReserve(
      PortHandle: HANDLE,
      Flags: ULONG,
      ResourceId: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn NtAlpcCreateSectionView(
      PortHandle: HANDLE,
      Flags: ULONG,
      ViewAttributes: PALPC_DATA_VIEW_ATTR,
   ) -> NTSTATUS;
   pub fn NtAlpcDeleteSectionView(PortHandle: HANDLE, Flags: ULONG, ViewBase: PVOID) -> NTSTATUS;
   pub fn NtAlpcCreateSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      SecurityAttribute: PALPC_SECURITY_ATTR,
   ) -> NTSTATUS;
   pub fn NtAlpcDeleteSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      ContextHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn NtAlpcRevokeSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      ContextHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn NtAlpcQueryInformationMessage(
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      MessageInformationClass: ALPC_MESSAGE_INFORMATION_CLASS,
      MessageInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAlpcConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      Flags: ULONG,
      RequiredServerSid: PSID,
      ConnectionMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      OutMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      InMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtAlpcConnectPortEx(
      PortHandle: PHANDLE,
      ConnectionPortObjectAttributes: POBJECT_ATTRIBUTES,
      ClientPortObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      Flags: ULONG,
      ServerSecurityRequirements: PSECURITY_DESCRIPTOR,
      ConnectionMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      OutMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      InMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtAlpcAcceptConnectPort(
      PortHandle: PHANDLE,
      ConnectionPortHandle: HANDLE,
      Flags: ULONG,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      PortContext: PVOID,
      ConnectionRequest: PPORT_MESSAGE,
      ConnectionMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      AcceptConnection: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtAlpcSendWaitReceivePort(
      PortHandle: HANDLE,
      Flags: ULONG,
      SendMessageA: PPORT_MESSAGE,
      SendMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      ReceiveMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      ReceiveMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtAlpcCancelMessage(
      PortHandle: HANDLE,
      Flags: ULONG,
      MessageContext: PALPC_CONTEXT_ATTR,
   ) -> NTSTATUS;
   pub fn NtAlpcImpersonateClientOfPort(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      Flags: PVOID,
   ) -> NTSTATUS;
   pub fn NtAlpcImpersonateClientContainerOfPort(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtAlpcOpenSenderProcess(
      ProcessHandle: PHANDLE,
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      Flags: ULONG,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtAlpcOpenSenderThread(
      ThreadHandle: PHANDLE,
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      Flags: ULONG,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn AlpcMaxAllowedMessageLength() -> ULONG;
   pub fn AlpcGetHeaderSize(Flags: ULONG) -> ULONG;
   pub fn AlpcInitializeMessageAttribute(
      AttributeFlags: ULONG,
      Buffer: PALPC_MESSAGE_ATTRIBUTES,
      BufferSize: SIZE_T,
      RequiredBufferSize: PSIZE_T,
   ) -> NTSTATUS;
   pub fn AlpcGetMessageAttribute(Buffer: PALPC_MESSAGE_ATTRIBUTES, AttributeFlag: ULONG) -> PVOID;
   pub fn AlpcRegisterCompletionList(
      PortHandle: HANDLE,
      Buffer: PALPC_COMPLETION_LIST_HEADER,
      Size: ULONG,
      ConcurrencyCount: ULONG,
      AttributeFlags: ULONG,
   ) -> NTSTATUS;
   pub fn AlpcUnregisterCompletionList(PortHandle: HANDLE) -> NTSTATUS;
   pub fn AlpcRundownCompletionList(PortHandle: HANDLE) -> NTSTATUS;
   pub fn AlpcAdjustCompletionListConcurrencyCount(
      PortHandle: HANDLE,
      ConcurrencyCount: ULONG,
   ) -> NTSTATUS;
   pub fn AlpcRegisterCompletionListWorkerThread(CompletionList: PVOID) -> BOOLEAN;
   pub fn AlpcUnregisterCompletionListWorkerThread(CompletionList: PVOID) -> BOOLEAN;
   pub fn AlpcGetCompletionListLastMessageInformation(
      CompletionList: PVOID,
      LastMessageId: PULONG,
      LastCallbackId: PULONG,
   );
   pub fn AlpcGetOutstandingCompletionListMessageCount(CompletionList: PVOID) -> ULONG;
   pub fn AlpcGetMessageFromCompletionList(
      CompletionList: PVOID,
      MessageAttributes: *mut PALPC_MESSAGE_ATTRIBUTES,
   ) -> PPORT_MESSAGE;
   pub fn AlpcFreeCompletionListMessage(CompletionList: PVOID, Message: PPORT_MESSAGE);
   pub fn AlpcGetCompletionListMessageAttributes(
      CompletionList: PVOID,
      Message: PPORT_MESSAGE,
   ) -> PALPC_MESSAGE_ATTRIBUTES;
   pub fn NtPlugPlayControl(
      PnPControlClass: PLUGPLAY_CONTROL_CLASS,
      PnPControlData: PVOID,
      PnPControlDataLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtSerializeBoot() -> NTSTATUS;
   pub fn NtEnableLastKnownGood() -> NTSTATUS;
   pub fn NtDisableLastKnownGood() -> NTSTATUS;
   pub fn NtReplacePartitionUnit(
      TargetInstancePath: PUNICODE_STRING,
      SpareInstancePath: PUNICODE_STRING,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtPowerInformation(
      InformationLevel: POWER_INFORMATION_LEVEL,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtSetThreadExecutionState(
      NewFlags: EXECUTION_STATE,
      PreviousFlags: *mut EXECUTION_STATE,
   ) -> NTSTATUS;
   pub fn NtInitiatePowerAction(
      SystemAction: POWER_ACTION,
      LightestSystemState: SYSTEM_POWER_STATE,
      Flags: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtSetSystemPowerState(
      SystemAction: POWER_ACTION,
      LightestSystemState: SYSTEM_POWER_STATE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtGetDevicePowerState(Device: HANDLE, State: PDEVICE_POWER_STATE) -> NTSTATUS;
   pub fn NtIsSystemResumeAutomatic() -> BOOLEAN;
   pub fn NtCreateKey(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TitleIndex: ULONG,
      Class: PUNICODE_STRING,
      CreateOptions: ULONG,
      Disposition: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreateKeyTransacted(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TitleIndex: ULONG,
      Class: PUNICODE_STRING,
      CreateOptions: ULONG,
      TransactionHandle: HANDLE,
      Disposition: PULONG,
   ) -> NTSTATUS;
   pub fn NtOpenKey(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtOpenKeyTransacted(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TransactionHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn NtOpenKeyEx(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenKeyTransactedEx(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      OpenOptions: ULONG,
      TransactionHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn NtDeleteKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn NtRenameKey(KeyHandle: HANDLE, NewName: PUNICODE_STRING) -> NTSTATUS;
   pub fn NtDeleteValueKey(KeyHandle: HANDLE, ValueName: PUNICODE_STRING) -> NTSTATUS;
   pub fn NtQueryKey(
      KeyHandle: HANDLE,
      KeyInformationClass: KEY_INFORMATION_CLASS,
      KeyInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationKey(
      KeyHandle: HANDLE,
      KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
      KeySetInformation: PVOID,
      KeySetInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueryValueKey(
      KeyHandle: HANDLE,
      ValueName: PUNICODE_STRING,
      KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
      KeyValueInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetValueKey(
      KeyHandle: HANDLE,
      ValueName: PUNICODE_STRING,
      TitleIndex: ULONG,
      Type: ULONG,
      Data: PVOID,
      DataSize: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueryMultipleValueKey(
      KeyHandle: HANDLE,
      ValueEntries: PKEY_VALUE_ENTRY,
      EntryCount: ULONG,
      ValueBuffer: PVOID,
      BufferLength: PULONG,
      RequiredBufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtEnumerateKey(
      KeyHandle: HANDLE,
      Index: ULONG,
      KeyInformationClass: KEY_INFORMATION_CLASS,
      KeyInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtEnumerateValueKey(
      KeyHandle: HANDLE,
      Index: ULONG,
      KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
      KeyValueInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtFlushKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn NtCompactKeys(Count: ULONG, KeyArray: *mut HANDLE) -> NTSTATUS;
   pub fn NtCompressKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn NtLoadKey(TargetKey: POBJECT_ATTRIBUTES, SourceFile: POBJECT_ATTRIBUTES) -> NTSTATUS;
   pub fn NtLoadKey2(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtLoadKeyEx(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
      TrustClassKey: HANDLE,
      Event: HANDLE,
      DesiredAccess: ACCESS_MASK,
      RootHandle: PHANDLE,
      Reserved: PVOID,
   ) -> NTSTATUS;
   pub fn NtLoadKey3(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
      ExtendedParameters: PCM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
      DesiredAccess: ACCESS_MASK,
      RootHandle: PHANDLE,
      Reserved: PVOID,
   ) -> NTSTATUS;
   pub fn NtReplaceKey(
      NewFile: POBJECT_ATTRIBUTES,
      TargetHandle: HANDLE,
      OldFile: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtSaveKey(KeyHandle: HANDLE, FileHandle: HANDLE) -> NTSTATUS;
   pub fn NtSaveKeyEx(KeyHandle: HANDLE, FileHandle: HANDLE, Format: ULONG) -> NTSTATUS;
   pub fn NtSaveMergedKeys(
      HighPrecedenceKeyHandle: HANDLE,
      LowPrecedenceKeyHandle: HANDLE,
      FileHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn NtRestoreKey(KeyHandle: HANDLE, FileHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
   pub fn NtUnloadKey(TargetKey: POBJECT_ATTRIBUTES) -> NTSTATUS;
   pub fn NtUnloadKey2(TargetKey: POBJECT_ATTRIBUTES, Flags: ULONG) -> NTSTATUS;
   pub fn NtUnloadKeyEx(TargetKey: POBJECT_ATTRIBUTES, Event: HANDLE) -> NTSTATUS;
   pub fn NtNotifyChangeKey(
      KeyHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      Buffer: PVOID,
      BufferSize: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtNotifyChangeMultipleKeys(
      MasterKeyHandle: HANDLE,
      Count: ULONG,
      SubordinateObjects: *mut OBJECT_ATTRIBUTES,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      Buffer: PVOID,
      BufferSize: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtQueryOpenSubKeys(TargetKey: POBJECT_ATTRIBUTES, HandleCount: PULONG) -> NTSTATUS;
   pub fn NtQueryOpenSubKeysEx(
      TargetKey: POBJECT_ATTRIBUTES,
      BufferLength: ULONG,
      Buffer: PVOID,
      RequiredSize: PULONG,
   ) -> NTSTATUS;
   pub fn NtInitializeRegistry(BootCondition: USHORT) -> NTSTATUS;
   pub fn NtLockRegistryKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn NtLockProductActivationKeys(pPrivateVer: *mut ULONG, pSafeMode: *mut ULONG) -> NTSTATUS;
   pub fn NtFreezeRegistry(TimeOutInSeconds: ULONG) -> NTSTATUS;
   pub fn NtThawRegistry() -> NTSTATUS;
   pub fn NtCreateRegistryTransaction(
      RegistryTransactionHandle: *mut HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjAttributes: POBJECT_ATTRIBUTES,
      CreateOptions: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenRegistryTransaction(
      RegistryTransactionHandle: *mut HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtCommitRegistryTransaction(RegistryTransactionHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
   pub fn NtRollbackRegistryTransaction(
      RegistryTransactionHandle: HANDLE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn InitializeListHead(ListHead: PLIST_ENTRY);
   pub fn IsListEmpty(ListHead: PLIST_ENTRY) -> BOOLEAN;
   pub fn RemoveEntryList(Entry: PLIST_ENTRY) -> BOOLEAN;
   pub fn RemoveHeadList(ListHead: PLIST_ENTRY) -> PLIST_ENTRY;
   pub fn RemoveTailList(ListHead: PLIST_ENTRY) -> PLIST_ENTRY;
   pub fn InsertTailList(ListHead: PLIST_ENTRY, Entry: PLIST_ENTRY);
   pub fn InsertHeadList(ListHead: PLIST_ENTRY, Entry: PLIST_ENTRY);
   pub fn AppendTailList(ListHead: PLIST_ENTRY, ListToAppend: PLIST_ENTRY);
   pub fn PopEntryList(ListHead: PSINGLE_LIST_ENTRY) -> PSINGLE_LIST_ENTRY;
   pub fn PushEntryList(ListHead: PSINGLE_LIST_ENTRY, Entry: PSINGLE_LIST_ENTRY);
   pub fn RtlInitializeGenericTableAvl(
      Table: PRTL_AVL_TABLE,
      CompareRoutine: PRTL_AVL_COMPARE_ROUTINE,
      AllocateRoutine: PRTL_AVL_ALLOCATE_ROUTINE,
      FreeRoutine: PRTL_AVL_FREE_ROUTINE,
      TableContext: PVOID,
   );
   pub fn RtlInsertElementGenericTableAvl(
      Table: PRTL_AVL_TABLE,
      Buffer: PVOID,
      BufferSize: CLONG,
      NewElement: PBOOLEAN,
   ) -> PVOID;
   pub fn RtlInsertElementGenericTableFullAvl(
      Table: PRTL_AVL_TABLE,
      Buffer: PVOID,
      BufferSize: CLONG,
      NewElement: PBOOLEAN,
      NodeOrParent: PVOID,
      SearchResult: TABLE_SEARCH_RESULT,
   ) -> PVOID;
   pub fn RtlDeleteElementGenericTableAvl(Table: PRTL_AVL_TABLE, Buffer: PVOID) -> BOOLEAN;
   pub fn RtlLookupElementGenericTableAvl(Table: PRTL_AVL_TABLE, Buffer: PVOID) -> PVOID;
   pub fn RtlLookupElementGenericTableFullAvl(
      Table: PRTL_AVL_TABLE,
      Buffer: PVOID,
      NodeOrParent: *mut PVOID,
      SearchResult: *mut TABLE_SEARCH_RESULT,
   ) -> PVOID;
   pub fn RtlEnumerateGenericTableAvl(Table: PRTL_AVL_TABLE, Restart: BOOLEAN) -> PVOID;
   pub fn RtlEnumerateGenericTableWithoutSplayingAvl(
      Table: PRTL_AVL_TABLE,
      RestartKey: *mut PVOID,
   ) -> PVOID;
   pub fn RtlLookupFirstMatchingElementGenericTableAvl(
      Table: PRTL_AVL_TABLE,
      Buffer: PVOID,
      RestartKey: *mut PVOID,
   ) -> PVOID;
   pub fn RtlEnumerateGenericTableLikeADirectory(
      Table: PRTL_AVL_TABLE,
      MatchFunction: PRTL_AVL_MATCH_FUNCTION,
      MatchData: PVOID,
      NextFlag: ULONG,
      RestartKey: *mut PVOID,
      DeleteCount: PULONG,
      Buffer: PVOID,
   ) -> PVOID;
   pub fn RtlGetElementGenericTableAvl(Table: PRTL_AVL_TABLE, I: ULONG) -> PVOID;
   pub fn RtlNumberGenericTableElementsAvl(Table: PRTL_AVL_TABLE) -> ULONG;
   pub fn RtlIsGenericTableEmptyAvl(Table: PRTL_AVL_TABLE) -> BOOLEAN;
   pub fn RtlSplay(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlDelete(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlDeleteNoSplay(Links: PRTL_SPLAY_LINKS, Root: *mut PRTL_SPLAY_LINKS);
   pub fn RtlSubtreeSuccessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlSubtreePredecessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlRealSuccessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlRealPredecessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlInitializeGenericTable(
      Table: PRTL_GENERIC_TABLE,
      CompareRoutine: PRTL_GENERIC_COMPARE_ROUTINE,
      AllocateRoutine: PRTL_GENERIC_ALLOCATE_ROUTINE,
      FreeRoutine: PRTL_GENERIC_FREE_ROUTINE,
      TableContext: PVOID,
   );
   pub fn RtlInsertElementGenericTable(
      Table: PRTL_GENERIC_TABLE,
      Buffer: PVOID,
      BufferSize: CLONG,
      NewElement: PBOOLEAN,
   ) -> PVOID;
   pub fn RtlInsertElementGenericTableFull(
      Table: PRTL_GENERIC_TABLE,
      Buffer: PVOID,
      BufferSize: CLONG,
      NewElement: PBOOLEAN,
      NodeOrParent: PVOID,
      SearchResult: TABLE_SEARCH_RESULT,
   ) -> PVOID;
   pub fn RtlDeleteElementGenericTable(Table: PRTL_GENERIC_TABLE, Buffer: PVOID) -> BOOLEAN;
   pub fn RtlLookupElementGenericTable(Table: PRTL_GENERIC_TABLE, Buffer: PVOID) -> PVOID;
   pub fn RtlLookupElementGenericTableFull(
      Table: PRTL_GENERIC_TABLE,
      Buffer: PVOID,
      NodeOrParent: *mut PVOID,
      SearchResult: *mut TABLE_SEARCH_RESULT,
   ) -> PVOID;
   pub fn RtlEnumerateGenericTable(Table: PRTL_GENERIC_TABLE, Restart: BOOLEAN) -> PVOID;
   pub fn RtlEnumerateGenericTableWithoutSplaying(
      Table: PRTL_GENERIC_TABLE,
      RestartKey: *mut PVOID,
   ) -> PVOID;
   pub fn RtlGetElementGenericTable(Table: PRTL_GENERIC_TABLE, I: ULONG) -> PVOID;
   pub fn RtlNumberGenericTableElements(Table: PRTL_GENERIC_TABLE) -> ULONG;
   pub fn RtlIsGenericTableEmpty(Table: PRTL_GENERIC_TABLE) -> BOOLEAN;
   pub fn RtlRbInsertNodeEx(
      Tree: PRTL_RB_TREE,
      Parent: PRTL_BALANCED_NODE,
      Right: BOOLEAN,
      Node: PRTL_BALANCED_NODE,
   ) -> BOOLEAN;
   pub fn RtlRbRemoveNode(Tree: PRTL_RB_TREE, Node: PRTL_BALANCED_NODE) -> BOOLEAN;
   pub fn RtlInitHashTableContext(Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT);
   pub fn RtlInitHashTableContextFromEnumerator(
      Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   );
   pub fn RtlReleaseHashTableContext(Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT);
   pub fn RtlTotalBucketsHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> ULONG;
   pub fn RtlNonEmptyBucketsHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> ULONG;
   pub fn RtlEmptyBucketsHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> ULONG;
   pub fn RtlTotalEntriesHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> ULONG;
   pub fn RtlActiveEnumeratorsHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> ULONG;
   pub fn RtlCreateHashTable(
      HashTable: *mut PRTL_DYNAMIC_HASH_TABLE,
      Shift: ULONG,
      Flags: ULONG,
   ) -> BOOLEAN;
   pub fn RtlDeleteHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> LOGICAL;
   pub fn RtlInsertEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Entry: PRTL_DYNAMIC_HASH_TABLE_ENTRY,
      Signature: ULONG_PTR,
      Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
   ) -> BOOLEAN;
   pub fn RtlRemoveEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Entry: PRTL_DYNAMIC_HASH_TABLE_ENTRY,
      Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
   ) -> BOOLEAN;
   pub fn RtlLookupEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Signature: ULONG_PTR,
      Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
   ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
   pub fn RtlGetNextEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
   ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
   pub fn RtlInitEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> BOOLEAN;
   pub fn RtlEnumerateEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
   pub fn RtlEndEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   );
   pub fn RtlInitWeakEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> BOOLEAN;
   pub fn RtlWeaklyEnumerateEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
   pub fn RtlEndWeakEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   );
   pub fn RtlExpandHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> BOOLEAN;
   pub fn RtlContractHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> BOOLEAN;
   pub fn RtlInitStrongEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> BOOLEAN;
   pub fn RtlStronglyEnumerateEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
   pub fn RtlEndStrongEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   );
   pub fn RtlInitializeCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> NTSTATUS;
   pub fn RtlInitializeCriticalSectionAndSpinCount(
      CriticalSection: PRTL_CRITICAL_SECTION,
      SpinCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlInitializeCriticalSectionEx(
      CriticalSection: PRTL_CRITICAL_SECTION,
      SpinCount: ULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDeleteCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> NTSTATUS;
   pub fn RtlEnterCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> NTSTATUS;
   pub fn RtlLeaveCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> NTSTATUS;
   pub fn RtlTryEnterCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> LOGICAL;
   pub fn RtlIsCriticalSectionLocked(CriticalSection: PRTL_CRITICAL_SECTION) -> LOGICAL;
   pub fn RtlIsCriticalSectionLockedByThread(CriticalSection: PRTL_CRITICAL_SECTION) -> LOGICAL;
   pub fn RtlGetCriticalSectionRecursionCount(CriticalSection: PRTL_CRITICAL_SECTION) -> ULONG;
   pub fn RtlSetCriticalSectionSpinCount(
      CriticalSection: PRTL_CRITICAL_SECTION,
      SpinCount: ULONG,
   ) -> ULONG;
   pub fn RtlQueryCriticalSectionOwner(EventHandle: HANDLE) -> HANDLE;
   pub fn RtlCheckForOrphanedCriticalSections(ThreadHandle: HANDLE);
   pub fn RtlInitializeResource(Resource: PRTL_RESOURCE);
   pub fn RtlDeleteResource(Resource: PRTL_RESOURCE);
   pub fn RtlAcquireResourceShared(Resource: PRTL_RESOURCE, Wait: BOOLEAN) -> BOOLEAN;
   pub fn RtlAcquireResourceExclusive(Resource: PRTL_RESOURCE, Wait: BOOLEAN) -> BOOLEAN;
   pub fn RtlReleaseResource(Resource: PRTL_RESOURCE);
   pub fn RtlConvertSharedToExclusive(Resource: PRTL_RESOURCE);
   pub fn RtlConvertExclusiveToShared(Resource: PRTL_RESOURCE);
   pub fn RtlInitializeSRWLock(SRWLock: PRTL_SRWLOCK);
   pub fn RtlAcquireSRWLockExclusive(SRWLock: PRTL_SRWLOCK);
   pub fn RtlAcquireSRWLockShared(SRWLock: PRTL_SRWLOCK);
   pub fn RtlReleaseSRWLockExclusive(SRWLock: PRTL_SRWLOCK);
   pub fn RtlReleaseSRWLockShared(SRWLock: PRTL_SRWLOCK);
   pub fn RtlTryAcquireSRWLockExclusive(SRWLock: PRTL_SRWLOCK) -> BOOLEAN;
   pub fn RtlTryAcquireSRWLockShared(SRWLock: PRTL_SRWLOCK) -> BOOLEAN;
   pub fn RtlAcquireReleaseSRWLockExclusive(SRWLock: PRTL_SRWLOCK);
   pub fn RtlInitializeConditionVariable(ConditionVariable: PRTL_CONDITION_VARIABLE);
   pub fn RtlSleepConditionVariableCS(
      ConditionVariable: PRTL_CONDITION_VARIABLE,
      CriticalSection: PRTL_CRITICAL_SECTION,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn RtlSleepConditionVariableSRW(
      ConditionVariable: PRTL_CONDITION_VARIABLE,
      SRWLock: PRTL_SRWLOCK,
      Timeout: PLARGE_INTEGER,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlWakeConditionVariable(ConditionVariable: PRTL_CONDITION_VARIABLE);
   pub fn RtlWakeAllConditionVariable(ConditionVariable: PRTL_CONDITION_VARIABLE);
   pub fn RtlInitBarrier(Barrier: PRTL_BARRIER, TotalThreads: ULONG, SpinCount: ULONG) -> NTSTATUS;
   pub fn RtlDeleteBarrier(Barrier: PRTL_BARRIER) -> NTSTATUS;
   pub fn RtlBarrier(Barrier: PRTL_BARRIER, Flags: ULONG) -> BOOLEAN;
   pub fn RtlBarrierForDelete(Barrier: PRTL_BARRIER, Flags: ULONG) -> BOOLEAN;
   pub fn RtlWaitOnAddress(
      Address: *mut cty::c_void,
      CompareAddress: PVOID,
      AddressSize: SIZE_T,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn RtlWakeAddressAll(Address: PVOID);
   pub fn RtlWakeAddressSingle(Address: PVOID);
   pub fn RtlReadHandleNoFence(Address: *const HANDLE) -> HANDLE;
   pub fn RtlInitEmptyAnsiString(AnsiString: PANSI_STRING, Buffer: PCHAR, MaximumLength: USHORT);
   pub fn RtlInitString(DestinationString: PSTRING, SourceString: PCSTR);
   pub fn RtlInitStringEx(DestinationString: PSTRING, SourceString: PCSZ) -> NTSTATUS;
   pub fn RtlInitAnsiString(DestinationString: PANSI_STRING, SourceString: PCSTR);
   pub fn RtlInitAnsiStringEx(DestinationString: PANSI_STRING, SourceString: PCSZ) -> NTSTATUS;
   pub fn RtlFreeAnsiString(AnsiString: PANSI_STRING);
   pub fn RtlInitUTF8String(DestinationString: PUTF8_STRING, SourceString: PCSZ);
   pub fn RtlInitUTF8StringEx(DestinationString: PUTF8_STRING, SourceString: PCSZ) -> NTSTATUS;
   pub fn RtlFreeUTF8String(Utf8String: PUTF8_STRING);
   pub fn RtlFreeOemString(OemString: POEM_STRING);
   pub fn RtlCopyString(DestinationString: PSTRING, SourceString: PSTRING);
   pub fn RtlUpperChar(Character: CHAR) -> CHAR;
   pub fn RtlCompareString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> LONG;
   pub fn RtlEqualString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> BOOLEAN;
   pub fn RtlPrefixString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> BOOLEAN;
   pub fn RtlAppendStringToString(Destination: PSTRING, Source: PSTRING) -> NTSTATUS;
   pub fn RtlAppendAsciizToString(Destination: PSTRING, Source: PCSTR) -> NTSTATUS;
   pub fn RtlUpperString(DestinationString: PSTRING, SourceString: *const STRING);
   pub fn RtlIsNullOrEmptyUnicodeString(String: PUNICODE_STRING) -> BOOLEAN;
   pub fn RtlInitEmptyUnicodeString(
      DestinationString: PUNICODE_STRING,
      Buffer: PWCHAR,
      MaximumLength: USHORT,
   );
   pub fn RtlInitUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCWSTR);
   pub fn RtlInitUnicodeStringEx(
      DestinationString: PUNICODE_STRING,
      SourceString: PCWSTR,
   ) -> NTSTATUS;
   pub fn RtlCreateUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PCWSTR,
   ) -> BOOLEAN;
   pub fn RtlCreateUnicodeStringFromAsciiz(
      DestinationString: PUNICODE_STRING,
      SourceString: PCSTR,
   ) -> BOOLEAN;
   pub fn RtlFreeUnicodeString(UnicodeString: PUNICODE_STRING);
   pub fn RtlDuplicateUnicodeString(
      Flags: ULONG,
      StringIn: PUNICODE_STRING,
      StringOut: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlCopyUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCUNICODE_STRING);
   pub fn RtlUpcaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
   pub fn RtlDowncaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
   pub fn RtlCompareUnicodeString(
      String1: PUNICODE_STRING,
      String2: PUNICODE_STRING,
      CaseInSensitive: BOOLEAN,
   ) -> LONG;
   pub fn RtlCompareUnicodeStrings(
      String1: PCWCH,
      String1Length: SIZE_T,
      String2: PCWCH,
      String2Length: SIZE_T,
      CaseInSensitive: BOOLEAN,
   ) -> LONG;
   pub fn RtlEqualUnicodeString(
      String1: PUNICODE_STRING,
      String2: PUNICODE_STRING,
      CaseInSensitive: BOOLEAN,
   ) -> BOOLEAN;
   pub fn RtlHashUnicodeString(
      String: PUNICODE_STRING,
      CaseInSensitive: BOOLEAN,
      HashAlgorithm: ULONG,
      HashValue: PULONG,
   ) -> NTSTATUS;
   pub fn RtlValidateUnicodeString(Flags: ULONG, String: PUNICODE_STRING) -> NTSTATUS;
   pub fn RtlPrefixUnicodeString(
      String1: PUNICODE_STRING,
      String2: PUNICODE_STRING,
      CaseInSensitive: BOOLEAN,
   ) -> BOOLEAN;
   pub fn RtlFindUnicodeSubstring(
      FullString: PUNICODE_STRING,
      SearchString: PUNICODE_STRING,
      CaseInSensitive: BOOLEAN,
   ) -> PWCHAR;
   pub fn RtlFindCharInUnicodeString(
      Flags: ULONG,
      StringToSearch: PUNICODE_STRING,
      CharSet: PUNICODE_STRING,
      NonInclusivePrefixLength: PUSHORT,
   ) -> NTSTATUS;
   pub fn RtlAppendUnicodeStringToString(
      Destination: PUNICODE_STRING,
      Source: PCUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlAppendUnicodeToString(Destination: PUNICODE_STRING, Source: PCWSTR) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlDowncaseUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlEraseUnicodeString(String: PUNICODE_STRING);
   pub fn RtlAnsiStringToUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PANSI_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUnicodeStringToAnsiString(
      DestinationString: PANSI_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUnicodeStringToAnsiSize(SourceString: PUNICODE_STRING) -> ULONG;
   pub fn RtlUnicodeStringToUTF8String(
      DestinationString: PUTF8_STRING,
      SourceString: PCUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUTF8StringToUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PUTF8_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAnsiCharToUnicodeChar(SourceCharacter: *mut PUCHAR) -> WCHAR;
   pub fn RtlUpcaseUnicodeStringToAnsiString(
      DestinationString: PANSI_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlOemStringToUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: POEM_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUnicodeStringToOemString(
      DestinationString: POEM_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeStringToOemString(
      DestinationString: POEM_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlOemStringToCountedUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PCOEM_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUnicodeStringToCountedOemString(
      DestinationString: POEM_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeStringToCountedOemString(
      DestinationString: POEM_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlMultiByteToUnicodeN(
      UnicodeString: PWCH,
      MaxBytesInUnicodeString: ULONG,
      BytesInUnicodeString: PULONG,
      MultiByteString: PCSTR,
      BytesInMultiByteString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlMultiByteToUnicodeSize(
      BytesInUnicodeString: PULONG,
      MultiByteString: PCSTR,
      BytesInMultiByteString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnicodeToMultiByteN(
      MultiByteString: PCHAR,
      MaxBytesInMultiByteString: ULONG,
      BytesInMultiByteString: PULONG,
      UnicodeString: PCWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnicodeToMultiByteSize(
      BytesInMultiByteString: PULONG,
      UnicodeString: PCWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeToMultiByteN(
      MultiByteString: PCHAR,
      MaxBytesInMultiByteString: ULONG,
      BytesInMultiByteString: PULONG,
      UnicodeString: PCWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlOemToUnicodeN(
      UnicodeString: PWSTR,
      MaxBytesInUnicodeString: ULONG,
      BytesInUnicodeString: PULONG,
      OemString: PCCH,
      BytesInOemString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnicodeToOemN(
      OemString: PCHAR,
      MaxBytesInOemString: ULONG,
      BytesInOemString: PULONG,
      UnicodeString: PCWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeToOemN(
      OemString: PCHAR,
      MaxBytesInOemString: ULONG,
      BytesInOemString: PULONG,
      UnicodeString: PCWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlConsoleMultiByteToUnicodeN(
      UnicodeString: PWCH,
      MaxBytesInUnicodeString: ULONG,
      BytesInUnicodeString: PULONG,
      MultiByteString: PCCH,
      BytesInMultiByteString: ULONG,
      pdwSpecialChar: PULONG,
   ) -> NTSTATUS;
   pub fn RtlUTF8ToUnicodeN(
      UnicodeStringDestination: PWSTR,
      UnicodeStringMaxByteCount: ULONG,
      UnicodeStringActualByteCount: PULONG,
      UTF8StringSource: PCCH,
      UTF8StringByteCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnicodeToUTF8N(
      UTF8StringDestination: PCHAR,
      UTF8StringMaxByteCount: ULONG,
      UTF8StringActualByteCount: PULONG,
      UnicodeStringSource: PCWCH,
      UnicodeStringByteCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlCustomCPToUnicodeN(
      CustomCP: PCPTABLEINFO,
      UnicodeString: PWCH,
      MaxBytesInUnicodeString: ULONG,
      BytesInUnicodeString: PULONG,
      CustomCPString: PCH,
      BytesInCustomCPString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnicodeToCustomCPN(
      CustomCP: PCPTABLEINFO,
      CustomCPString: PCH,
      MaxBytesInCustomCPString: ULONG,
      BytesInCustomCPString: PULONG,
      UnicodeString: PWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeToCustomCPN(
      CustomCP: PCPTABLEINFO,
      CustomCPString: PCH,
      MaxBytesInCustomCPString: ULONG,
      BytesInCustomCPString: PULONG,
      UnicodeString: PWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlInitCodePageTable(TableBase: PUSHORT, CodePageTable: PCPTABLEINFO);
   pub fn RtlInitNlsTables(
      AnsiNlsBase: PUSHORT,
      OemNlsBase: PUSHORT,
      LanguageNlsBase: PUSHORT,
      TableInfo: PNLSTABLEINFO,
   );
   pub fn RtlResetRtlTranslations(TableInfo: PNLSTABLEINFO);
   pub fn RtlIsTextUnicode(Buffer: PVOID, Size: ULONG, Result: PULONG) -> BOOLEAN;
   pub fn RtlNormalizeString(
      NormForm: ULONG,
      SourceString: PCWSTR,
      SourceStringLength: LONG,
      DestinationString: PWSTR,
      DestinationStringLength: PLONG,
   ) -> NTSTATUS;
   pub fn RtlIsNormalizedString(
      NormForm: ULONG,
      SourceString: PCWSTR,
      SourceStringLength: LONG,
      Normalized: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlIsNameInExpression(
      Expression: PUNICODE_STRING,
      Name: PUNICODE_STRING,
      IgnoreCase: BOOLEAN,
      UpcaseTable: PWCH,
   ) -> BOOLEAN;
   pub fn RtlIsNameInUnUpcasedExpression(
      Expression: PUNICODE_STRING,
      Name: PUNICODE_STRING,
      IgnoreCase: BOOLEAN,
      UpcaseTable: PWCH,
   ) -> BOOLEAN;
   pub fn RtlDoesNameContainWildCards(Expression: PUNICODE_STRING) -> BOOLEAN;
   pub fn RtlEqualDomainName(String1: PUNICODE_STRING, String2: PUNICODE_STRING) -> BOOLEAN;
   pub fn RtlEqualComputerName(String1: PUNICODE_STRING, String2: PUNICODE_STRING) -> BOOLEAN;
   pub fn RtlDnsHostNameToComputerName(
      ComputerNameString: PUNICODE_STRING,
      DnsHostNameString: PUNICODE_STRING,
      AllocateComputerNameString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlStringFromGUID(Guid: PGUID, GuidString: PUNICODE_STRING) -> NTSTATUS;
   pub fn RtlStringFromGUIDEx(
      Guid: PGUID,
      GuidString: PUNICODE_STRING,
      AllocateGuidString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlGUIDFromString(GuidString: PUNICODE_STRING, Guid: PGUID) -> NTSTATUS;
   pub fn RtlCompareAltitudes(Altitude1: PUNICODE_STRING, Altitude2: PUNICODE_STRING) -> LONG;
   pub fn RtlIdnToAscii(
      Flags: ULONG,
      SourceString: PCWSTR,
      SourceStringLength: LONG,
      DestinationString: PWSTR,
      DestinationStringLength: PLONG,
   ) -> NTSTATUS;
   pub fn RtlIdnToUnicode(
      Flags: ULONG,
      SourceString: PCWSTR,
      SourceStringLength: LONG,
      DestinationString: PWSTR,
      DestinationStringLength: PLONG,
   ) -> NTSTATUS;
   pub fn RtlIdnToNameprepUnicode(
      Flags: ULONG,
      SourceString: PCWSTR,
      SourceStringLength: LONG,
      DestinationString: PWSTR,
      DestinationStringLength: PLONG,
   ) -> NTSTATUS;
   pub fn PfxInitialize(PrefixTable: PPREFIX_TABLE);
   pub fn PfxInsertPrefix(
      PrefixTable: PPREFIX_TABLE,
      Prefix: PSTRING,
      PrefixTableEntry: PPREFIX_TABLE_ENTRY,
   ) -> BOOLEAN;
   pub fn PfxRemovePrefix(PrefixTable: PPREFIX_TABLE, PrefixTableEntry: PPREFIX_TABLE_ENTRY);
   pub fn PfxFindPrefix(PrefixTable: PPREFIX_TABLE, FullName: PSTRING) -> PPREFIX_TABLE_ENTRY;
   pub fn RtlInitializeUnicodePrefix(PrefixTable: PUNICODE_PREFIX_TABLE);
   pub fn RtlInsertUnicodePrefix(
      PrefixTable: PUNICODE_PREFIX_TABLE,
      Prefix: PUNICODE_STRING,
      PrefixTableEntry: PUNICODE_PREFIX_TABLE_ENTRY,
   ) -> BOOLEAN;
   pub fn RtlRemoveUnicodePrefix(
      PrefixTable: PUNICODE_PREFIX_TABLE,
      PrefixTableEntry: PUNICODE_PREFIX_TABLE_ENTRY,
   );
   pub fn RtlFindUnicodePrefix(
      PrefixTable: PUNICODE_PREFIX_TABLE,
      FullName: PUNICODE_STRING,
      CaseInsensitiveIndex: ULONG,
   ) -> PUNICODE_PREFIX_TABLE_ENTRY;
   pub fn RtlNextUnicodePrefix(
      PrefixTable: PUNICODE_PREFIX_TABLE,
      Restart: BOOLEAN,
   ) -> PUNICODE_PREFIX_TABLE_ENTRY;
   pub fn RtlGetCompressionWorkSpaceSize(
      CompressionFormatAndEngine: USHORT,
      CompressBufferWorkSpaceSize: PULONG,
      CompressFragmentWorkSpaceSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlCompressBuffer(
      CompressionFormatAndEngine: USHORT,
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      UncompressedChunkSize: ULONG,
      FinalCompressedSize: PULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlDecompressBuffer(
      CompressionFormat: USHORT,
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      FinalUncompressedSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlDecompressBufferEx(
      CompressionFormat: USHORT,
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      FinalUncompressedSize: PULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlDecompressBufferEx2(
      CompressionFormat: USHORT,
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      UncompressedChunkSize: ULONG,
      FinalUncompressedSize: PULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlDecompressFragment(
      CompressionFormat: USHORT,
      UncompressedFragment: PUCHAR,
      UncompressedFragmentSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      FragmentOffset: ULONG,
      FinalUncompressedSize: PULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlDecompressFragmentEx(
      CompressionFormat: USHORT,
      UncompressedFragment: PUCHAR,
      UncompressedFragmentSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      FragmentOffset: ULONG,
      UncompressedChunkSize: ULONG,
      FinalUncompressedSize: PULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlDescribeChunk(
      CompressionFormat: USHORT,
      CompressedBuffer: *mut PUCHAR,
      EndOfCompressedBufferPlus1: PUCHAR,
      ChunkBuffer: *mut PUCHAR,
      ChunkSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlReserveChunk(
      CompressionFormat: USHORT,
      CompressedBuffer: *mut PUCHAR,
      EndOfCompressedBufferPlus1: PUCHAR,
      ChunkBuffer: *mut PUCHAR,
      ChunkSize: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDecompressChunks(
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      CompressedTail: PUCHAR,
      CompressedTailSize: ULONG,
      CompressedDataInfo: PCOMPRESSED_DATA_INFO,
   ) -> NTSTATUS;
   pub fn RtlCompressChunks(
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      CompressedDataInfo: PCOMPRESSED_DATA_INFO,
      CompressedDataInfoLength: ULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlConvertLCIDToString(
      LcidValue: LCID,
      Base: ULONG,
      Padding: ULONG,
      pResultBuf: PWSTR,
      Size: ULONG,
   ) -> NTSTATUS;
   pub fn RtlIsValidLocaleName(LocaleName: PCWSTR, Flags: ULONG) -> BOOLEAN;
   pub fn RtlGetParentLocaleName(
      LocaleName: PCWSTR,
      ParentLocaleName: PUNICODE_STRING,
      Flags: ULONG,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlLcidToLocaleName(
      lcid: LCID,
      LocaleName: PUNICODE_STRING,
      Flags: ULONG,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlLocaleNameToLcid(LocaleName: PCWSTR, lcid: PLCID, Flags: ULONG) -> NTSTATUS;
   pub fn RtlLCIDToCultureName(Lcid: LCID, String: PUNICODE_STRING) -> BOOLEAN;
   pub fn RtlCultureNameToLCID(String: PUNICODE_STRING, Lcid: PLCID) -> BOOLEAN;
   pub fn RtlCleanUpTEBLangLists();
   pub fn RtlGetThreadPreferredUILanguages(
      Flags: ULONG,
      NumberOfLanguages: PULONG,
      Languages: PZZWSTR,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetProcessPreferredUILanguages(
      Flags: ULONG,
      NumberOfLanguages: PULONG,
      Languages: PZZWSTR,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetSystemPreferredUILanguages(
      Flags: ULONG,
      LocaleName: PCWSTR,
      NumberOfLanguages: PULONG,
      Languages: PZZWSTR,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlpGetSystemDefaultUILanguage(DefaultUILanguageId: LANGID, Lcid: PLCID) -> NTSTATUS;
   pub fn RtlGetUserPreferredUILanguages(
      Flags: ULONG,
      LocaleName: PCWSTR,
      NumberOfLanguages: PULONG,
      Languages: PZZWSTR,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetUILanguageInfo(
      Flags: ULONG,
      Languages: PCZZWSTR,
      FallbackLanguages: PZZWSTR,
      NumberOfFallbackLanguages: PULONG,
      Attributes: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetLocaleFileMappingAddress(
      BaseAddress: *mut PVOID,
      DefaultLocaleId: PLCID,
      DefaultCasingTableSize: PLARGE_INTEGER,
      CurrentNLSVersion: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetCurrentPeb() -> PPEB;
   pub fn RtlAcquirePebLock() -> NTSTATUS;
   pub fn RtlReleasePebLock() -> NTSTATUS;
   pub fn RtlTryAcquirePebLock() -> LOGICAL;
   pub fn RtlCreateProcessParameters(
      pProcessParameters: *mut PRTL_USER_PROCESS_PARAMETERS,
      ImagePathName: PUNICODE_STRING,
      DllPath: PUNICODE_STRING,
      CurrentDirectory: PUNICODE_STRING,
      CommandLine: PUNICODE_STRING,
      Environment: PVOID,
      WindowTitle: PUNICODE_STRING,
      DesktopInfo: PUNICODE_STRING,
      ShellInfo: PUNICODE_STRING,
      RuntimeData: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlCreateProcessParametersEx(
      pProcessParameters: *mut PRTL_USER_PROCESS_PARAMETERS,
      ImagePathName: PUNICODE_STRING,
      DllPath: PUNICODE_STRING,
      CurrentDirectory: PUNICODE_STRING,
      CommandLine: PUNICODE_STRING,
      Environment: PVOID,
      WindowTitle: PUNICODE_STRING,
      DesktopInfo: PUNICODE_STRING,
      ShellInfo: PUNICODE_STRING,
      RuntimeData: PUNICODE_STRING,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDestroyProcessParameters(ProcessParameters: PRTL_USER_PROCESS_PARAMETERS) -> NTSTATUS;
   pub fn RtlNormalizeProcessParams(
      ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
   ) -> PRTL_USER_PROCESS_PARAMETERS;
   pub fn RtlDeNormalizeProcessParams(
      ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
   ) -> PRTL_USER_PROCESS_PARAMETERS;
   pub fn RtlCreateUserProcess(
      NtImagePathName: PUNICODE_STRING,
      AttributesDeprecated: ULONG,
      ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
      ProcessSecurityDescriptor: PSECURITY_DESCRIPTOR,
      ThreadSecurityDescriptor: PSECURITY_DESCRIPTOR,
      ParentProcess: HANDLE,
      InheritHandles: BOOLEAN,
      DebugPort: HANDLE,
      TokenHandle: HANDLE,
      ProcessInformation: PRTL_USER_PROCESS_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlCreateUserProcessEx(
      NtImagePathName: PUNICODE_STRING,
      ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
      InheritHandles: BOOLEAN,
      ProcessExtendedParameters: PRTL_USER_PROCESS_EXTENDED_PARAMETERS,
      ProcessInformation: PRTL_USER_PROCESS_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlExitUserProcess(ExitStatus: NTSTATUS) -> !;
   pub fn RtlCloneUserProcess(
      ProcessFlags: ULONG,
      ProcessSecurityDescriptor: PSECURITY_DESCRIPTOR,
      ThreadSecurityDescriptor: PSECURITY_DESCRIPTOR,
      DebugPort: HANDLE,
      ProcessInformation: PRTL_USER_PROCESS_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlUpdateClonedCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
   pub fn RtlUpdateClonedSRWLock(SRWLock: PRTL_SRWLOCK, Shared: LOGICAL);
   pub fn RtlCreateProcessReflection(
      ProcessHandle: HANDLE,
      Flags: ULONG,
      StartRoutine: PVOID,
      StartContext: PVOID,
      EventHandle: HANDLE,
      ReflectionInformation: PRTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlSetProcessIsCritical(
      NewValue: BOOLEAN,
      OldValue: PBOOLEAN,
      CheckFlag: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlSetThreadIsCritical(
      NewValue: BOOLEAN,
      OldValue: PBOOLEAN,
      CheckFlag: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlSetThreadSubProcessTag(SubProcessTag: PVOID) -> PVOID;
   pub fn RtlValidProcessProtection(ProcessProtection: PS_PROTECTION) -> BOOLEAN;
   pub fn RtlTestProtectedAccess(Source: PS_PROTECTION, Target: PS_PROTECTION) -> BOOLEAN;
   pub fn RtlIsCurrentProcess(ProcessHandle: HANDLE) -> BOOLEAN;
   pub fn RtlIsCurrentThread(ThreadHandle: HANDLE) -> BOOLEAN;
   pub fn RtlCreateUserThread(
      ProcessHandle: HANDLE,
      ThreadSecurityDescriptor: PSECURITY_DESCRIPTOR,
      CreateSuspended: BOOLEAN,
      ZeroBits: ULONG,
      MaximumStackSize: SIZE_T,
      CommittedStackSize: SIZE_T,
      StartAddress: PUSER_THREAD_START_ROUTINE,
      Parameter: PVOID,
      ThreadHandle: PHANDLE,
      ClientId: PCLIENT_ID,
   ) -> NTSTATUS;
   pub fn RtlExitUserThread(ExitStatus: NTSTATUS) -> !;
   pub fn RtlIsCurrentThreadAttachExempt() -> BOOLEAN;
   pub fn RtlCreateUserStack(
      CommittedStackSize: SIZE_T,
      MaximumStackSize: SIZE_T,
      ZeroBits: ULONG_PTR,
      PageSize: SIZE_T,
      ReserveAlignment: ULONG_PTR,
      InitialTeb: PINITIAL_TEB,
   ) -> NTSTATUS;
   pub fn RtlFreeUserStack(AllocationBase: PVOID) -> NTSTATUS;
   pub fn RtlInitializeContext(
      Reserved: HANDLE,
      Context: PCONTEXT,
      Parameter: PVOID,
      InitialPc: PVOID,
      InitialSp: PVOID,
   ) -> ULONG64;
   pub fn RtlInitializeExtendedContext(
      Context: PCONTEXT,
      ContextFlags: ULONG,
      ContextEx: *mut PCONTEXT_EX,
   ) -> NTSTATUS;
   pub fn RtlInitializeExtendedContext2(
      Context: PCONTEXT,
      ContextFlags: ULONG,
      ContextEx: *mut PCONTEXT_EX,
      EnabledExtendedFeatures: ULONG64,
   ) -> NTSTATUS;
   pub fn RtlCopyContext(Context: PCONTEXT, ContextFlags: ULONG, Source: PCONTEXT) -> NTSTATUS;
   pub fn RtlCopyExtendedContext(
      Destination: PCONTEXT_EX,
      ContextFlags: ULONG,
      Source: PCONTEXT_EX,
   ) -> NTSTATUS;
   pub fn RtlGetExtendedContextLength(ContextFlags: ULONG, ContextLength: PULONG) -> NTSTATUS;
   pub fn RtlGetExtendedContextLength2(
      ContextFlags: ULONG,
      ContextLength: PULONG,
      EnabledExtendedFeatures: ULONG64,
   ) -> NTSTATUS;
   pub fn RtlGetExtendedFeaturesMask(ContextEx: PCONTEXT_EX) -> ULONG64;
   pub fn RtlLocateExtendedFeature(
      ContextEx: PCONTEXT_EX,
      FeatureId: ULONG,
      Length: PULONG,
   ) -> PVOID;
   pub fn RtlLocateLegacyContext(ContextEx: PCONTEXT_EX, Length: PULONG) -> PCONTEXT;
   pub fn RtlSetExtendedFeaturesMask(ContextEx: PCONTEXT_EX, FeatureMask: ULONG64);
   pub fn RtlWow64GetThreadContext(ThreadHandle: HANDLE, ThreadContext: PWOW64_CONTEXT)
      -> NTSTATUS;
   pub fn RtlWow64SetThreadContext(ThreadHandle: HANDLE, ThreadContext: PWOW64_CONTEXT)
      -> NTSTATUS;
   pub fn RtlRemoteCall(
      ProcessHandle: HANDLE,
      ThreadHandle: HANDLE,
      CallSite: PVOID,
      ArgumentCount: ULONG,
      Arguments: PULONG_PTR,
      PassContext: BOOLEAN,
      AlreadySuspended: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAddVectoredExceptionHandler(
      First: ULONG,
      Handler: PVECTORED_EXCEPTION_HANDLER,
   ) -> PVOID;
   pub fn RtlRemoveVectoredExceptionHandler(Handle: PVOID) -> ULONG;
   pub fn RtlAddVectoredContinueHandler(
      First: ULONG,
      Handler: PVECTORED_EXCEPTION_HANDLER,
   ) -> PVOID;
   pub fn RtlRemoveVectoredContinueHandler(Handle: PVOID) -> ULONG;
   pub fn RtlSetUnhandledExceptionFilter(
      UnhandledExceptionFilter: PRTLP_UNHANDLED_EXCEPTION_FILTER,
   );
   pub fn RtlUnhandledExceptionFilter(ExceptionPointers: PEXCEPTION_POINTERS) -> LONG;
   pub fn RtlUnhandledExceptionFilter2(
      ExceptionPointers: PEXCEPTION_POINTERS,
      Flags: ULONG,
   ) -> LONG;
   pub fn RtlKnownExceptionFilter(ExceptionPointers: PEXCEPTION_POINTERS) -> LONG;
   pub fn RtlGetFunctionTableListHead() -> PLIST_ENTRY;
   pub fn RtlGetActiveActivationContext(ActivationContext: PACTIVATION_CONTEXT) -> NTSTATUS;
   pub fn RtlAddRefActivationContext(ActivationContext: PACTIVATION_CONTEXT);
   pub fn RtlReleaseActivationContext(ActivationContext: PACTIVATION_CONTEXT);
   pub fn RtlZombifyActivationContext(ActivationContext: PACTIVATION_CONTEXT) -> NTSTATUS;
   pub fn RtlIsActivationContextActive(ActivationContext: PACTIVATION_CONTEXT) -> BOOLEAN;
   pub fn RtlActivateActivationContext(
      Flags: ULONG,
      ActivationContext: PACTIVATION_CONTEXT,
      Cookie: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn RtlActivateActivationContextEx(
      Flags: ULONG,
      Teb: PTEB,
      ActivationContext: PACTIVATION_CONTEXT,
      Cookie: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn RtlDeactivateActivationContext(Flags: ULONG, Cookie: ULONG_PTR);
   pub fn RtlCreateActivationContext(
      Flags: ULONG,
      ActivationContextData: PACTIVATION_CONTEXT_DATA,
      ExtraBytes: ULONG,
      NotificationRoutine: PACTIVATION_CONTEXT_NOTIFY_ROUTINE,
      NotificationContext: PVOID,
      ActivationContext: *mut PACTIVATION_CONTEXT,
   ) -> NTSTATUS;
   pub fn RtlFindActivationContextSectionString(
      Flags: ULONG,
      ExtensionGuid: PGUID,
      SectionId: ULONG,
      StringToFind: PUNICODE_STRING,
      ReturnedData: PACTCTX_SECTION_KEYED_DATA,
   ) -> NTSTATUS;
   pub fn RtlFindActivationContextSectionGuid(
      Flags: ULONG,
      ExtensionGuid: PGUID,
      SectionId: ULONG,
      GuidToFind: PGUID,
      ReturnedData: PACTCTX_SECTION_KEYED_DATA,
   ) -> NTSTATUS;
   pub fn RtlQueryActivationContextApplicationSettings(
      Flags: ULONG,
      ActivationContext: PACTIVATION_CONTEXT,
      SettingsNameSpace: PWSTR,
      SettingName: PWSTR,
      Buffer: PWSTR,
      BufferLength: SIZE_T,
      RequiredLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlQueryInformationActivationContext(
      Flags: ULONG,
      ActivationContext: PACTIVATION_CONTEXT,
      SubInstanceIndex: PACTIVATION_CONTEXT_QUERY_INDEX,
      ActivationContextInformationClass: ACTIVATION_CONTEXT_INFO_CLASS,
      ActivationContextInformation: PVOID,
      ActivationContextInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlQueryInformationActiveActivationContext(
      ActivationContextInformationClass: ACTIVATION_CONTEXT_INFO_CLASS,
      ActivationContextInformation: PVOID,
      ActivationContextInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlImageNtHeader(BaseOfImage: PVOID) -> PIMAGE_NT_HEADERS;
   pub fn RtlImageNtHeaderEx(
      Flags: ULONG,
      BaseOfImage: PVOID,
      Size: ULONG64,
      OutHeaders: *mut PIMAGE_NT_HEADERS,
   ) -> NTSTATUS;
   pub fn RtlAddressInSectionTable(
      NtHeaders: PIMAGE_NT_HEADERS,
      BaseOfImage: PVOID,
      VirtualAddress: ULONG,
   ) -> PVOID;
   pub fn RtlSectionTableFromVirtualAddress(
      NtHeaders: PIMAGE_NT_HEADERS,
      BaseOfImage: PVOID,
      VirtualAddress: ULONG,
   ) -> PIMAGE_SECTION_HEADER;
   pub fn RtlImageDirectoryEntryToData(
      BaseOfImage: PVOID,
      MappedAsImage: BOOLEAN,
      DirectoryEntry: USHORT,
      Size: PULONG,
   ) -> PVOID;
   pub fn RtlImageRvaToSection(
      NtHeaders: PIMAGE_NT_HEADERS,
      BaseOfImage: PVOID,
      Rva: ULONG,
   ) -> PIMAGE_SECTION_HEADER;
   pub fn RtlImageRvaToVa(
      NtHeaders: PIMAGE_NT_HEADERS,
      BaseOfImage: PVOID,
      Rva: ULONG,
      LastRvaSection: *mut PIMAGE_SECTION_HEADER,
   ) -> PVOID;
   pub fn RtlFindExportedRoutineByName(BaseOfImage: PVOID, RoutineName: PCSTR) -> PVOID;
   pub fn RtlGuardCheckLongJumpTarget(
      PcValue: PVOID,
      IsFastFail: BOOL,
      IsLongJumpTarget: PBOOL,
   ) -> NTSTATUS;
   pub fn RtlCompareMemoryUlong(Source: PVOID, Length: SIZE_T, Pattern: ULONG) -> SIZE_T;
   pub fn RtlFillMemoryUlong(Destination: PVOID, Length: SIZE_T, Pattern: ULONG);
   pub fn RtlIsZeroMemory(Buffer: PVOID, Length: SIZE_T) -> BOOLEAN;
   pub fn RtlCreateEnvironment(
      CloneCurrentEnvironment: BOOLEAN,
      Environment: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlCreateEnvironmentEx(
      SourceEnvironment: PVOID,
      Environment: *mut PVOID,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDestroyEnvironment(Environment: PVOID) -> NTSTATUS;
   pub fn RtlSetCurrentEnvironment(Environment: PVOID, PreviousEnvironment: *mut PVOID)
      -> NTSTATUS;
   pub fn RtlSetEnvironmentVar(
      Environment: *mut PVOID,
      Name: PCWSTR,
      NameLength: SIZE_T,
      Value: PCWSTR,
      ValueLength: SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlSetEnvironmentVariable(
      Environment: *mut PVOID,
      Name: PUNICODE_STRING,
      Value: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlQueryEnvironmentVariable(
      Environment: PVOID,
      Name: PCWSTR,
      NameLength: SIZE_T,
      Value: PWSTR,
      ValueLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlQueryEnvironmentVariable_U(
      Environment: PVOID,
      Name: PUNICODE_STRING,
      Value: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlExpandEnvironmentStrings(
      Environment: PVOID,
      Source: PCWSTR,
      SourceLength: SIZE_T,
      Destination: PWSTR,
      DestinationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlExpandEnvironmentStrings_U(
      Environment: PVOID,
      Source: PUNICODE_STRING,
      Destination: PUNICODE_STRING,
      ReturnedLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSetEnvironmentStrings(NewEnvironment: PCWCHAR, NewEnvironmentSize: SIZE_T)
      -> NTSTATUS;
   pub static mut RtlDosPathSeperatorsString: UNICODE_STRING;
   pub static mut RtlAlternateDosPathSeperatorString: UNICODE_STRING;
   pub static mut RtlNtPathSeperatorString: UNICODE_STRING;
   pub fn RtlDetermineDosPathNameType_U(DosFileName: PCWSTR) -> RTL_PATH_TYPE;
   pub fn RtlIsDosDeviceName_U(DosFileName: PCWSTR) -> ULONG;
   pub fn RtlGetFullPathName_U(
      FileName: PCWSTR,
      BufferLength: ULONG,
      Buffer: PWSTR,
      FilePart: *mut PWSTR,
   ) -> ULONG;
   pub fn RtlGetFullPathName_UEx(
      FileName: PCWSTR,
      BufferLength: ULONG,
      Buffer: PWSTR,
      FilePart: *mut PWSTR,
      BytesRequired: *mut ULONG,
   ) -> NTSTATUS;
   pub fn RtlGetFullPathName_UstrEx(
      FileName: PUNICODE_STRING,
      StaticString: PUNICODE_STRING,
      DynamicString: PUNICODE_STRING,
      StringUsed: *mut PUNICODE_STRING,
      FilePartPrefixCch: *mut SIZE_T,
      NameInvalid: PBOOLEAN,
      InputPathType: *mut RTL_PATH_TYPE,
      BytesRequired: *mut SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlGetCurrentDirectory_U(BufferLength: ULONG, Buffer: PWSTR) -> ULONG;
   pub fn RtlSetCurrentDirectory_U(PathName: PUNICODE_STRING) -> NTSTATUS;
   pub fn RtlGetLongestNtPathLength() -> ULONG;
   pub fn RtlNtPathNameToDosPathName(
      Flags: ULONG,
      Path: PRTL_UNICODE_STRING_BUFFER,
      Disposition: PULONG,
      FilePart: *mut PWSTR,
   ) -> NTSTATUS;
   pub fn RtlDosPathNameToNtPathName_U(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> BOOLEAN;
   pub fn RtlDosPathNameToNtPathName_U_WithStatus(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> NTSTATUS;
   pub fn RtlDosLongPathNameToNtPathName_U_WithStatus(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> NTSTATUS;
   pub fn RtlDosPathNameToRelativeNtPathName_U(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> BOOLEAN;
   pub fn RtlDosPathNameToRelativeNtPathName_U_WithStatus(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> NTSTATUS;
   pub fn RtlDosLongPathNameToRelativeNtPathName_U_WithStatus(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> NTSTATUS;
   pub fn RtlReleaseRelativeName(RelativeName: PRTL_RELATIVE_NAME_U);
   pub fn RtlDosSearchPath_U(
      Path: PCWSTR,
      FileName: PCWSTR,
      Extension: PCWSTR,
      BufferLength: ULONG,
      Buffer: PWSTR,
      FilePart: *mut PWSTR,
   ) -> ULONG;
   pub fn RtlDosSearchPath_Ustr(
      Flags: ULONG,
      Path: PUNICODE_STRING,
      FileName: PUNICODE_STRING,
      DefaultExtension: PUNICODE_STRING,
      StaticString: PUNICODE_STRING,
      DynamicString: PUNICODE_STRING,
      FullFileNameOut: *mut PCUNICODE_STRING,
      FilePartPrefixCch: *mut SIZE_T,
      BytesRequired: *mut SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlDoesFileExists_U(FileName: PCWSTR) -> BOOLEAN;
   pub fn RtlDosApplyFileIsolationRedirection_Ustr(
      Flags: ULONG,
      OriginalName: PUNICODE_STRING,
      Extension: PUNICODE_STRING,
      StaticString: PUNICODE_STRING,
      DynamicString: PUNICODE_STRING,
      NewName: *mut PUNICODE_STRING,
      NewFlags: PULONG,
      FileNameSize: PSIZE_T,
      RequiredLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlGetLengthWithoutLastFullDosOrNtPathElement(
      Flags: ULONG,
      PathString: PUNICODE_STRING,
      Length: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetLengthWithoutTrailingPathSeperators(
      Flags: ULONG,
      PathString: PUNICODE_STRING,
      Length: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGenerate8dot3Name(
      Name: PUNICODE_STRING,
      AllowExtendedCharacters: BOOLEAN,
      Context: PGENERATE_NAME_CONTEXT,
      Name8dot3: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlComputePrivatizedDllName_U(
      DllName: PUNICODE_STRING,
      RealName: PUNICODE_STRING,
      LocalName: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlGetSearchPath(SearchPathA: *mut PWSTR) -> NTSTATUS;
   pub fn RtlSetSearchPathMode(Flags: ULONG) -> NTSTATUS;
   pub fn RtlGetExePath(DosPathName: PCWSTR, SearchPathA: *mut PWSTR) -> NTSTATUS;
   pub fn RtlReleasePath(Path: PWSTR);
   pub fn RtlReplaceSystemDirectoryInPath(
      Destination: PUNICODE_STRING,
      Machine: USHORT,
      TargetMachine: USHORT,
      IncludePathSeperator: BOOLEAN,
   ) -> ULONG;
   pub fn RtlWow64GetProcessMachines(
      ProcessHandle: HANDLE,
      ProcessMachine: PUSHORT,
      NativeMachine: PUSHORT,
   ) -> NTSTATUS;
   pub fn RtlGetImageFileMachines(FileName: PCWSTR, FileMachines: PUSHORT) -> NTSTATUS;
   pub fn RtlGetNtSystemRoot() -> PWSTR;
   pub fn RtlAreLongPathsEnabled() -> BOOLEAN;
   pub fn RtlIsThreadWithinLoaderCallout() -> BOOLEAN;
   pub fn RtlDllShutdownInProgress() -> BOOLEAN;
   pub fn RtlCreateHeap(
      Flags: ULONG,
      HeapBase: PVOID,
      ReserveSize: SIZE_T,
      CommitSize: SIZE_T,
      Lock: PVOID,
      Parameters: PVOID,
   ) -> PVOID;
   pub fn RtlDestroyHeap(HeapHandle: PVOID) -> PVOID;
   pub fn RtlAllocateHeap(HeapHandle: PVOID, Flags: ULONG, Size: SIZE_T) -> PVOID;
   pub fn RtlFreeHeap(HeapHandle: PVOID, Flags: ULONG, BaseAddress: PVOID) -> LOGICAL;
   pub fn RtlSizeHeap(HeapHandle: PVOID, Flags: ULONG, BaseAddress: PVOID) -> SIZE_T;
   pub fn RtlZeroHeap(HeapHandle: PVOID, Flags: ULONG) -> NTSTATUS;
   pub fn RtlProtectHeap(HeapHandle: PVOID, MakeReadOnly: BOOLEAN);
   pub fn RtlLockHeap(HeapHandle: PVOID) -> BOOLEAN;
   pub fn RtlUnlockHeap(HeapHandle: PVOID) -> BOOLEAN;
   pub fn RtlReAllocateHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      BaseAddress: PVOID,
      Size: SIZE_T,
   ) -> PVOID;
   pub fn RtlGetUserInfoHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      BaseAddress: PVOID,
      UserValue: *mut PVOID,
      UserFlags: PULONG,
   ) -> BOOLEAN;
   pub fn RtlSetUserValueHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      BaseAddress: PVOID,
      UserValue: PVOID,
   ) -> BOOLEAN;
   pub fn RtlSetUserFlagsHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      BaseAddress: PVOID,
      UserFlagsReset: ULONG,
      UserFlagsSet: ULONG,
   ) -> BOOLEAN;
   pub fn RtlCreateTagHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      TagPrefix: PWSTR,
      TagNames: PWSTR,
   ) -> ULONG;
   pub fn RtlQueryTagHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      TagIndex: USHORT,
      ResetCounters: BOOLEAN,
      TagInfo: PRTL_HEAP_TAG_INFO,
   ) -> PWSTR;
   pub fn RtlExtendHeap(HeapHandle: PVOID, Flags: ULONG, Base: PVOID, Size: SIZE_T) -> NTSTATUS;
   pub fn RtlCompactHeap(HeapHandle: PVOID, Flags: ULONG) -> SIZE_T;
   pub fn RtlValidateHeap(HeapHandle: PVOID, Flags: ULONG, BaseAddress: PVOID) -> BOOLEAN;
   pub fn RtlValidateProcessHeaps() -> BOOLEAN;
   pub fn RtlGetProcessHeaps(NumberOfHeaps: ULONG, ProcessHeaps: *mut PVOID) -> ULONG;
   pub fn RtlEnumProcessHeaps(EnumRoutine: PRTL_ENUM_HEAPS_ROUTINE, Parameter: PVOID) -> NTSTATUS;
   pub fn RtlUsageHeap(HeapHandle: PVOID, Flags: ULONG, Usage: PRTL_HEAP_USAGE) -> NTSTATUS;
   pub fn RtlWalkHeap(HeapHandle: PVOID, Entry: PRTL_HEAP_WALK_ENTRY) -> NTSTATUS;
   pub fn RtlQueryHeapInformation(
      HeapHandle: PVOID,
      HeapInformationClass: HEAP_INFORMATION_CLASS,
      HeapInformation: PVOID,
      HeapInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlSetHeapInformation(
      HeapHandle: PVOID,
      HeapInformationClass: HEAP_INFORMATION_CLASS,
      HeapInformation: PVOID,
      HeapInformationLength: SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlMultipleAllocateHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      Size: SIZE_T,
      Count: ULONG,
      Array: *mut PVOID,
   ) -> ULONG;
   pub fn RtlMultipleFreeHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      Count: ULONG,
      Array: *mut PVOID,
   ) -> ULONG;
   pub fn RtlDetectHeapLeaks();
   pub fn RtlFlushHeaps();
   pub fn RtlCreateMemoryZone(
      MemoryZone: *mut PVOID,
      InitialSize: SIZE_T,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDestroyMemoryZone(MemoryZone: PVOID) -> NTSTATUS;
   pub fn RtlAllocateMemoryZone(
      MemoryZone: PVOID,
      BlockSize: SIZE_T,
      Block: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlResetMemoryZone(MemoryZone: PVOID) -> NTSTATUS;
   pub fn RtlLockMemoryZone(MemoryZone: PVOID) -> NTSTATUS;
   pub fn RtlUnlockMemoryZone(MemoryZone: PVOID) -> NTSTATUS;
   pub fn RtlCreateMemoryBlockLookaside(
      MemoryBlockLookaside: *mut PVOID,
      Flags: ULONG,
      InitialSize: ULONG,
      MinimumBlockSize: ULONG,
      MaximumBlockSize: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDestroyMemoryBlockLookaside(MemoryBlockLookaside: PVOID) -> NTSTATUS;
   pub fn RtlAllocateMemoryBlockLookaside(
      MemoryBlockLookaside: PVOID,
      BlockSize: ULONG,
      Block: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlFreeMemoryBlockLookaside(MemoryBlockLookaside: PVOID, Block: PVOID) -> NTSTATUS;
   pub fn RtlExtendMemoryBlockLookaside(MemoryBlockLookaside: PVOID, Increment: ULONG) -> NTSTATUS;
   pub fn RtlResetMemoryBlockLookaside(MemoryBlockLookaside: PVOID) -> NTSTATUS;
   pub fn RtlLockMemoryBlockLookaside(MemoryBlockLookaside: PVOID) -> NTSTATUS;
   pub fn RtlUnlockMemoryBlockLookaside(MemoryBlockLookaside: PVOID) -> NTSTATUS;
   pub fn RtlGetCurrentTransaction() -> HANDLE;
   pub fn RtlSetCurrentTransaction(TransactionHandle: HANDLE) -> LOGICAL;
   pub fn RtlIsEqualLuid(L1: PLUID, L2: PLUID) -> BOOLEAN;
   pub fn RtlIsZeroLuid(L1: PLUID) -> BOOLEAN;
   pub fn RtlConvertLongToLuid(Long: LONG) -> LUID;
   pub fn RtlConvertUlongToLuid(Ulong: ULONG) -> LUID;
   pub fn RtlCopyLuid(DestinationLuid: PLUID, SourceLuid: PLUID);
   pub fn RtlCopyLuidAndAttributesArray(
      Count: ULONG,
      Src: PLUID_AND_ATTRIBUTES,
      Dest: PLUID_AND_ATTRIBUTES,
   );
   pub fn RtlCreateQueryDebugBuffer(
      MaximumCommit: ULONG,
      UseEventPair: BOOLEAN,
   ) -> PRTL_DEBUG_INFORMATION;
   pub fn RtlDestroyQueryDebugBuffer(Buffer: PRTL_DEBUG_INFORMATION) -> NTSTATUS;
   pub fn RtlCommitDebugInfo(Buffer: PRTL_DEBUG_INFORMATION, Size: SIZE_T) -> PVOID;
   pub fn RtlDeCommitDebugInfo(Buffer: PRTL_DEBUG_INFORMATION, p: PVOID, Size: SIZE_T);
   pub fn RtlQueryProcessDebugInformation(
      UniqueProcessId: HANDLE,
      Flags: ULONG,
      Buffer: PRTL_DEBUG_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlSetProcessDebugInformation(
      UniqueProcessId: HANDLE,
      Flags: ULONG,
      Buffer: PRTL_DEBUG_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlIsAnyDebuggerPresent() -> BOOLEAN;
   pub fn RtlFindMessage(
      DllHandle: PVOID,
      MessageTableId: ULONG,
      MessageLanguageId: ULONG,
      MessageId: ULONG,
      MessageEntry: *mut PMESSAGE_RESOURCE_ENTRY,
   ) -> NTSTATUS;
   pub fn RtlFormatMessage(
      MessageFormat: PWSTR,
      MaximumWidth: ULONG,
      IgnoreInserts: BOOLEAN,
      ArgumentsAreAnsi: BOOLEAN,
      ArgumentsAreAnArray: BOOLEAN,
      Arguments: *mut va_list,
      Buffer: PWSTR,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlFormatMessageEx(
      MessageFormat: PWSTR,
      MaximumWidth: ULONG,
      IgnoreInserts: BOOLEAN,
      ArgumentsAreAnsi: BOOLEAN,
      ArgumentsAreAnArray: BOOLEAN,
      Arguments: *mut va_list,
      Buffer: PWSTR,
      Length: ULONG,
      ReturnLength: PULONG,
      ParseContext: PPARSE_MESSAGE_CONTEXT,
   ) -> NTSTATUS;
   pub fn RtlGetFileMUIPath(
      Flags: ULONG,
      FilePath: PCWSTR,
      Language: PWSTR,
      LanguageLength: PULONG,
      FileMUIPath: PWSTR,
      FileMUIPathLength: PULONG,
      Enumerator: PULONGLONG,
   ) -> NTSTATUS;
   pub fn RtlLoadString(
      DllHandle: PVOID,
      StringId: ULONG,
      StringLanguage: PCWSTR,
      Flags: ULONG,
      ReturnString: *mut PCWSTR,
      ReturnStringLen: PUSHORT,
      ReturnLanguageName: PWSTR,
      ReturnLanguageLen: PULONG,
   ) -> NTSTATUS;
   pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;
   pub fn RtlNtStatusToDosErrorNoTeb(Status: NTSTATUS) -> ULONG;
   pub fn RtlGetLastNtStatus() -> NTSTATUS;
   pub fn RtlGetLastWin32Error() -> LONG;
   pub fn RtlSetLastWin32ErrorAndNtStatusFromNtStatus(Status: NTSTATUS);
   pub fn RtlSetLastWin32Error(Win32Error: LONG);
   pub fn RtlRestoreLastWin32Error(Win32Error: LONG);
   pub fn RtlGetThreadErrorMode() -> ULONG;
   pub fn RtlSetThreadErrorMode(NewMode: ULONG, OldMode: PULONG) -> NTSTATUS;
   pub fn RtlReportException(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlReportExceptionEx(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
      Flags: ULONG,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn RtlWerpReportException(
      ProcessId: ULONG,
      CrashReportSharedMem: HANDLE,
      Flags: ULONG,
      CrashVerticalProcessHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn RtlReportSilentProcessExit(ProcessHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn RtlUniform(Seed: PULONG) -> ULONG;
   pub fn RtlRandom(Seed: PULONG) -> ULONG;
   pub fn RtlRandomEx(Seed: PULONG) -> ULONG;
   pub fn RtlComputeImportTableHash(
      FileHandle: HANDLE,
      Hash: PCHAR,
      ImportTableHashRevision: ULONG,
   ) -> NTSTATUS;
   pub fn RtlIntegerToChar(Value: ULONG, Base: ULONG, OutputLength: LONG, String: PSTR)
      -> NTSTATUS;
   pub fn RtlCharToInteger(String: PCSTR, Base: ULONG, Value: PULONG) -> NTSTATUS;
   pub fn RtlLargeIntegerToChar(
      Value: PLARGE_INTEGER,
      Base: ULONG,
      OutputLength: LONG,
      String: PSTR,
   ) -> NTSTATUS;
   pub fn RtlIntegerToUnicodeString(Value: ULONG, Base: ULONG, String: PUNICODE_STRING)
      -> NTSTATUS;
   pub fn RtlInt64ToUnicodeString(
      Value: ULONGLONG,
      Base: ULONG,
      String: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlUnicodeStringToInteger(
      String: PUNICODE_STRING,
      Base: ULONG,
      Value: PULONG,
   ) -> NTSTATUS;
   pub fn RtlIpv4AddressToStringW(Address: PCIN_ADDR, AddressString: PWSTR) -> PWSTR;
   pub fn RtlIpv4AddressToStringExW(
      Address: PCIN_ADDR,
      Port: USHORT,
      AddressString: PWSTR,
      AddressStringLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlIpv6AddressToStringW(Address: PCIN6_ADDR, AddressString: PWSTR) -> PWSTR;
   pub fn RtlIpv6AddressToStringExW(
      Address: PCIN6_ADDR,
      ScopeId: ULONG,
      Port: USHORT,
      AddressString: PWSTR,
      AddressStringLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlIpv4StringToAddressW(
      AddressString: PCWSTR,
      Strict: BOOLEAN,
      Terminator: *mut LPCWSTR,
      Address: PIN_ADDR,
   ) -> NTSTATUS;
   pub fn RtlIpv4StringToAddressExW(
      AddressString: PCWSTR,
      Strict: BOOLEAN,
      Address: PIN_ADDR,
      Port: PUSHORT,
   ) -> NTSTATUS;
   pub fn RtlIpv6StringToAddressW(
      AddressString: PCWSTR,
      Terminator: *mut PCWSTR,
      Address: PIN6_ADDR,
   ) -> NTSTATUS;
   pub fn RtlIpv6StringToAddressExW(
      AddressString: PCWSTR,
      Address: PIN6_ADDR,
      ScopeId: PULONG,
      Port: PUSHORT,
   ) -> NTSTATUS;
   pub fn RtlCutoverTimeToSystemTime(
      CutoverTime: PTIME_FIELDS,
      SystemTime: PLARGE_INTEGER,
      CurrentSystemTime: PLARGE_INTEGER,
      ThisYear: BOOLEAN,
   ) -> BOOLEAN;
   pub fn RtlSystemTimeToLocalTime(
      SystemTime: PLARGE_INTEGER,
      LocalTime: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn RtlLocalTimeToSystemTime(
      LocalTime: PLARGE_INTEGER,
      SystemTime: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn RtlTimeToElapsedTimeFields(Time: PLARGE_INTEGER, TimeFields: PTIME_FIELDS);
   pub fn RtlTimeToTimeFields(Time: PLARGE_INTEGER, TimeFields: PTIME_FIELDS);
   pub fn RtlTimeFieldsToTime(TimeFields: PTIME_FIELDS, Time: PLARGE_INTEGER) -> BOOLEAN;
   pub fn RtlTimeToSecondsSince1980(Time: PLARGE_INTEGER, ElapsedSeconds: PULONG) -> BOOLEAN;
   pub fn RtlSecondsSince1980ToTime(ElapsedSeconds: ULONG, Time: PLARGE_INTEGER);
   pub fn RtlTimeToSecondsSince1970(Time: PLARGE_INTEGER, ElapsedSeconds: PULONG) -> BOOLEAN;
   pub fn RtlSecondsSince1970ToTime(ElapsedSeconds: ULONG, Time: PLARGE_INTEGER);
   pub fn RtlGetSystemTimePrecise() -> LARGE_INTEGER;
   pub fn RtlGetSystemTimeAndBias(
      TimeZoneBias: KSYSTEM_TIME,
      TimeZoneBiasEffectiveStart: PLARGE_INTEGER,
      TimeZoneBiasEffectiveEnd: PLARGE_INTEGER,
   ) -> KSYSTEM_TIME;
   pub fn RtlGetInterruptTimePrecise(PerformanceCounter: PLARGE_INTEGER) -> LARGE_INTEGER;
   pub fn RtlQueryUnbiasedInterruptTime(InterruptTime: PLARGE_INTEGER) -> BOOLEAN;
   pub fn RtlQueryTimeZoneInformation(TimeZoneInformation: PRTL_TIME_ZONE_INFORMATION) -> NTSTATUS;
   pub fn RtlSetTimeZoneInformation(TimeZoneInformation: PRTL_TIME_ZONE_INFORMATION) -> NTSTATUS;
   pub fn RtlInitializeBitMap(BitMapHeader: PRTL_BITMAP, BitMapBuffer: PULONG, SizeOfBitMap: ULONG);
   pub fn RtlClearBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG);
   pub fn RtlSetBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG);
   pub fn RtlTestBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG) -> BOOLEAN;
   pub fn RtlClearAllBits(BitMapHeader: PRTL_BITMAP);
   pub fn RtlSetAllBits(BitMapHeader: PRTL_BITMAP);
   pub fn RtlFindClearBits(
      BitMapHeader: PRTL_BITMAP,
      NumberToFind: ULONG,
      HintIndex: ULONG,
   ) -> ULONG;
   pub fn RtlFindSetBits(BitMapHeader: PRTL_BITMAP, NumberToFind: ULONG, HintIndex: ULONG)
      -> ULONG;
   pub fn RtlFindClearBitsAndSet(
      BitMapHeader: PRTL_BITMAP,
      NumberToFind: ULONG,
      HintIndex: ULONG,
   ) -> ULONG;
   pub fn RtlFindSetBitsAndClear(
      BitMapHeader: PRTL_BITMAP,
      NumberToFind: ULONG,
      HintIndex: ULONG,
   ) -> ULONG;
   pub fn RtlClearBits(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, NumberToClear: ULONG);
   pub fn RtlSetBits(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, NumberToSet: ULONG);
   pub fn RtlFindMostSignificantBit(Set: ULONGLONG) -> CCHAR;
   pub fn RtlFindLeastSignificantBit(Set: ULONGLONG) -> CCHAR;
   pub fn RtlFindClearRuns(
      BitMapHeader: PRTL_BITMAP,
      RunArray: PRTL_BITMAP_RUN,
      SizeOfRunArray: ULONG,
      LocateLongestRuns: BOOLEAN,
   ) -> ULONG;
   pub fn RtlFindLongestRunClear(BitMapHeader: PRTL_BITMAP, StartingIndex: PULONG) -> ULONG;
   pub fn RtlFindFirstRunClear(BitMapHeader: PRTL_BITMAP, StartingIndex: PULONG) -> ULONG;
   pub fn RtlCheckBit(BitMapHeader: PRTL_BITMAP, BitPosition: ULONG) -> BOOLEAN;
   pub fn RtlNumberOfClearBits(BitMapHeader: PRTL_BITMAP) -> ULONG;
   pub fn RtlNumberOfSetBits(BitMapHeader: PRTL_BITMAP) -> ULONG;
   pub fn RtlAreBitsClear(
      BitMapHeader: PRTL_BITMAP,
      StartingIndex: ULONG,
      Length: ULONG,
   ) -> BOOLEAN;
   pub fn RtlAreBitsSet(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, Length: ULONG) -> BOOLEAN;
   pub fn RtlFindNextForwardRunClear(
      BitMapHeader: PRTL_BITMAP,
      FromIndex: ULONG,
      StartingRunIndex: PULONG,
   ) -> ULONG;
   pub fn RtlFindLastBackwardRunClear(
      BitMapHeader: PRTL_BITMAP,
      FromIndex: ULONG,
      StartingRunIndex: PULONG,
   ) -> ULONG;
   pub fn RtlNumberOfSetBitsUlongPtr(Target: ULONG_PTR) -> ULONG;
   pub fn RtlInterlockedClearBitRun(
      BitMapHeader: PRTL_BITMAP,
      StartingIndex: ULONG,
      NumberToClear: ULONG,
   );
   pub fn RtlInterlockedSetBitRun(
      BitMapHeader: PRTL_BITMAP,
      StartingIndex: ULONG,
      NumberToSet: ULONG,
   );
   pub fn RtlCopyBitMap(Source: PRTL_BITMAP, Destination: PRTL_BITMAP, TargetBit: ULONG);
   pub fn RtlExtractBitMap(
      Source: PRTL_BITMAP,
      Destination: PRTL_BITMAP,
      TargetBit: ULONG,
      NumberOfBits: ULONG,
   );
   pub fn RtlNumberOfClearBitsInRange(
      BitMapHeader: PRTL_BITMAP,
      StartingIndex: ULONG,
      Length: ULONG,
   ) -> ULONG;
   pub fn RtlNumberOfSetBitsInRange(
      BitMapHeader: PRTL_BITMAP,
      StartingIndex: ULONG,
      Length: ULONG,
   ) -> ULONG;
   pub fn RtlInitializeBitMapEx(
      BitMapHeader: PRTL_BITMAP_EX,
      BitMapBuffer: PULONG64,
      SizeOfBitMap: ULONG64,
   );
   pub fn RtlTestBitEx(BitMapHeader: PRTL_BITMAP_EX, BitNumber: ULONG64) -> BOOLEAN;
   pub fn RtlClearAllBitsEx(BitMapHeader: PRTL_BITMAP_EX);
   pub fn RtlClearBitEx(BitMapHeader: PRTL_BITMAP_EX, BitNumber: ULONG64);
   pub fn RtlSetBitEx(BitMapHeader: PRTL_BITMAP_EX, BitNumber: ULONG64);
   pub fn RtlFindSetBitsEx(
      BitMapHeader: PRTL_BITMAP_EX,
      NumberToFind: ULONG64,
      HintIndex: ULONG64,
   ) -> ULONG64;
   pub fn RtlFindSetBitsAndClearEx(
      BitMapHeader: PRTL_BITMAP_EX,
      NumberToFind: ULONG64,
      HintIndex: ULONG64,
   ) -> ULONG64;
   pub fn RtlInitializeHandleTable(
      MaximumNumberOfHandles: ULONG,
      SizeOfHandleTableEntry: ULONG,
      HandleTable: PRTL_HANDLE_TABLE,
   );
   pub fn RtlDestroyHandleTable(HandleTable: PRTL_HANDLE_TABLE) -> NTSTATUS;
   pub fn RtlAllocateHandle(
      HandleTable: PRTL_HANDLE_TABLE,
      HandleIndex: PULONG,
   ) -> PRTL_HANDLE_TABLE_ENTRY;
   pub fn RtlFreeHandle(HandleTable: PRTL_HANDLE_TABLE, Handle: PRTL_HANDLE_TABLE_ENTRY)
      -> BOOLEAN;
   pub fn RtlIsValidHandle(
      HandleTable: PRTL_HANDLE_TABLE,
      Handle: PRTL_HANDLE_TABLE_ENTRY,
   ) -> BOOLEAN;
   pub fn RtlIsValidIndexHandle(
      HandleTable: PRTL_HANDLE_TABLE,
      HandleIndex: ULONG,
      Handle: *mut PRTL_HANDLE_TABLE_ENTRY,
   ) -> BOOLEAN;
   pub fn RtlCreateAtomTable(NumberOfBuckets: ULONG, AtomTableHandle: *mut PVOID) -> NTSTATUS;
   pub fn RtlDestroyAtomTable(AtomTableHandle: PVOID) -> NTSTATUS;
   pub fn RtlEmptyAtomTable(AtomTableHandle: PVOID, IncludePinnedAtoms: BOOLEAN) -> NTSTATUS;
   pub fn RtlAddAtomToAtomTable(
      AtomTableHandle: PVOID,
      AtomName: PWSTR,
      Atom: PRTL_ATOM,
   ) -> NTSTATUS;
   pub fn RtlLookupAtomInAtomTable(
      AtomTableHandle: PVOID,
      AtomName: PWSTR,
      Atom: PRTL_ATOM,
   ) -> NTSTATUS;
   pub fn RtlDeleteAtomFromAtomTable(AtomTableHandle: PVOID, Atom: RTL_ATOM) -> NTSTATUS;
   pub fn RtlPinAtomInAtomTable(AtomTableHandle: PVOID, Atom: RTL_ATOM) -> NTSTATUS;
   pub fn RtlQueryAtomInAtomTable(
      AtomTableHandle: PVOID,
      Atom: RTL_ATOM,
      AtomUsage: PULONG,
      AtomFlags: PULONG,
      AtomName: PWSTR,
      AtomNameLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetIntegerAtom(AtomName: PWSTR, IntegerAtom: PUSHORT) -> BOOLEAN;
   pub fn RtlValidSid(Sid: PSID) -> BOOLEAN;
   pub fn RtlEqualSid(Sid1: PSID, Sid2: PSID) -> BOOLEAN;
   pub fn RtlEqualPrefixSid(Sid1: PSID, Sid2: PSID) -> BOOLEAN;
   pub fn RtlLengthRequiredSid(SubAuthorityCount: ULONG) -> ULONG;
   pub fn RtlFreeSid(Sid: PSID) -> PVOID;
   pub fn RtlAllocateAndInitializeSid(
      IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
      SubAuthorityCount: UCHAR,
      SubAuthority0: ULONG,
      SubAuthority1: ULONG,
      SubAuthority2: ULONG,
      SubAuthority3: ULONG,
      SubAuthority4: ULONG,
      SubAuthority5: ULONG,
      SubAuthority6: ULONG,
      SubAuthority7: ULONG,
      Sid: *mut PSID,
   ) -> NTSTATUS;
   pub fn RtlAllocateAndInitializeSidEx(
      IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
      SubAuthorityCount: UCHAR,
      SubAuthorities: PULONG,
      Sid: *mut PSID,
   ) -> NTSTATUS;
   pub fn RtlInitializeSid(
      Sid: PSID,
      IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
      SubAuthorityCount: UCHAR,
   ) -> NTSTATUS;
   pub fn RtlInitializeSidEx(
      Sid: PSID,
      IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
      SubAuthorityCount: UCHAR,
      ...
   ) -> NTSTATUS;
   pub fn RtlIdentifierAuthoritySid(Sid: PSID) -> PSID_IDENTIFIER_AUTHORITY;
   pub fn RtlSubAuthoritySid(Sid: PSID, SubAuthority: ULONG) -> PULONG;
   pub fn RtlSubAuthorityCountSid(Sid: PSID) -> PUCHAR;
   pub fn RtlLengthSid(Sid: PSID) -> ULONG;
   pub fn RtlCopySid(
      DestinationSidLength: ULONG,
      DestinationSid: PSID,
      SourceSid: PSID,
   ) -> NTSTATUS;
   pub fn RtlCopySidAndAttributesArray(
      Count: ULONG,
      Src: PSID_AND_ATTRIBUTES,
      SidAreaSize: ULONG,
      Dest: PSID_AND_ATTRIBUTES,
      SidArea: PSID,
      RemainingSidArea: *mut PSID,
      RemainingSidAreaSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlCreateServiceSid(
      ServiceName: PUNICODE_STRING,
      ServiceSid: PSID,
      ServiceSidLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSidDominates(Sid1: PSID, Sid2: PSID, Dominates: PBOOLEAN) -> NTSTATUS;
   pub fn RtlSidDominatesForTrust(Sid1: PSID, Sid2: PSID, DominatesTrust: PBOOLEAN) -> NTSTATUS;
   pub fn RtlSidEqualLevel(Sid1: PSID, Sid2: PSID, EqualLevel: PBOOLEAN) -> NTSTATUS;
   pub fn RtlSidIsHigherLevel(Sid1: PSID, Sid2: PSID, HigherLevel: PBOOLEAN) -> NTSTATUS;
   pub fn RtlCreateVirtualAccountSid(
      Name: PUNICODE_STRING,
      BaseSubAuthority: ULONG,
      Sid: PSID,
      SidLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlReplaceSidInSd(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      OldSid: PSID,
      NewSid: PSID,
      NumChanges: *mut ULONG,
   ) -> NTSTATUS;
   pub fn RtlLengthSidAsUnicodeString(Sid: PSID, StringLength: PULONG) -> NTSTATUS;
   pub fn RtlConvertSidToUnicodeString(
      UnicodeString: PUNICODE_STRING,
      Sid: PSID,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlSidHashInitialize(
      SidAttr: PSID_AND_ATTRIBUTES,
      SidCount: ULONG,
      SidAttrHash: PSID_AND_ATTRIBUTES_HASH,
   ) -> NTSTATUS;
   pub fn RtlSidHashLookup(SidAttrHash: PSID_AND_ATTRIBUTES_HASH, Sid: PSID)
      -> PSID_AND_ATTRIBUTES;
   pub fn RtlIsElevatedRid(SidAttr: PSID_AND_ATTRIBUTES) -> BOOLEAN;
   pub fn RtlDeriveCapabilitySidsFromName(
      UnicodeString: PUNICODE_STRING,
      CapabilityGroupSid: PSID,
      CapabilitySid: PSID,
   ) -> NTSTATUS;
   pub fn RtlCreateSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Revision: ULONG,
   ) -> NTSTATUS;
   pub fn RtlValidSecurityDescriptor(SecurityDescriptor: PSECURITY_DESCRIPTOR) -> BOOLEAN;
   pub fn RtlLengthSecurityDescriptor(SecurityDescriptor: PSECURITY_DESCRIPTOR) -> ULONG;
   pub fn RtlValidRelativeSecurityDescriptor(
      SecurityDescriptorInput: PSECURITY_DESCRIPTOR,
      SecurityDescriptorLength: ULONG,
      RequiredInformation: SECURITY_INFORMATION,
   ) -> BOOLEAN;
   pub fn RtlGetControlSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Control: PSECURITY_DESCRIPTOR_CONTROL,
      Revision: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSetControlSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      ControlBitsOfInterest: SECURITY_DESCRIPTOR_CONTROL,
      ControlBitsToSet: SECURITY_DESCRIPTOR_CONTROL,
   ) -> NTSTATUS;
   pub fn RtlSetAttributesSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Control: SECURITY_DESCRIPTOR_CONTROL,
      Revision: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetSecurityDescriptorRMControl(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      RMControl: PUCHAR,
   ) -> BOOLEAN;
   pub fn RtlSetSecurityDescriptorRMControl(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      RMControl: PUCHAR,
   );
   pub fn RtlSetDaclSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      DaclPresent: BOOLEAN,
      Dacl: PACL,
      DaclDefaulted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlGetDaclSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      DaclPresent: PBOOLEAN,
      Dacl: *mut PACL,
      DaclDefaulted: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlSetSaclSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      SaclPresent: BOOLEAN,
      Sacl: PACL,
      SaclDefaulted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlGetSaclSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      SaclPresent: PBOOLEAN,
      Sacl: *mut PACL,
      SaclDefaulted: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlSetOwnerSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Owner: PSID,
      OwnerDefaulted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlGetOwnerSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Owner: *mut PSID,
      OwnerDefaulted: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlSetGroupSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Group: PSID,
      GroupDefaulted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlGetGroupSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Group: *mut PSID,
      GroupDefaulted: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlMakeSelfRelativeSD(
      AbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
      SelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
      BufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlAbsoluteToSelfRelativeSD(
      AbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
      SelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
      BufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSelfRelativeToAbsoluteSD(
      SelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
      AbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
      AbsoluteSecurityDescriptorSize: PULONG,
      Dacl: PACL,
      DaclSize: PULONG,
      Sacl: PACL,
      SaclSize: PULONG,
      Owner: PSID,
      OwnerSize: PULONG,
      PrimaryGroup: PSID,
      PrimaryGroupSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSelfRelativeToAbsoluteSD2(
      SelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlNormalizeSecurityDescriptor(
      SecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
      SecurityDescriptorLength: DWORD,
      NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
      NewSecurityDescriptorLength: PDWORD,
      CheckOnly: BOOLEAN,
   ) -> BOOLEAN;
   pub fn RtlAreAllAccessesGranted(
      GrantedAccess: ACCESS_MASK,
      DesiredAccess: ACCESS_MASK,
   ) -> BOOLEAN;
   pub fn RtlAreAnyAccessesGranted(
      GrantedAccess: ACCESS_MASK,
      DesiredAccess: ACCESS_MASK,
   ) -> BOOLEAN;
   pub fn RtlMapGenericMask(AccessMask: PACCESS_MASK, GenericMapping: PGENERIC_MAPPING);
   pub fn RtlCreateAcl(Acl: PACL, AclLength: ULONG, AclRevision: ULONG) -> NTSTATUS;
   pub fn RtlValidAcl(Acl: PACL) -> BOOLEAN;
   pub fn RtlQueryInformationAcl(
      Acl: PACL,
      AclInformation: PVOID,
      AclInformationLength: ULONG,
      AclInformationClass: ACL_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn RtlSetInformationAcl(
      Acl: PACL,
      AclInformation: PVOID,
      AclInformationLength: ULONG,
      AclInformationClass: ACL_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn RtlAddAce(
      Acl: PACL,
      AceRevision: ULONG,
      StartingAceIndex: ULONG,
      AceList: PVOID,
      AceListLength: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDeleteAce(Acl: PACL, AceIndex: ULONG) -> NTSTATUS;
   pub fn RtlGetAce(Acl: PACL, AceIndex: ULONG, Ace: *mut PVOID) -> NTSTATUS;
   pub fn RtlFirstFreeAce(Acl: PACL, FirstFree: *mut PVOID) -> BOOLEAN;
   pub fn RtlFindAceByType(Acl: PACL, AceType: UCHAR, Index: PULONG) -> PVOID;
   pub fn RtlOwnerAcesPresent(pAcl: PACL) -> BOOLEAN;
   pub fn RtlAddAccessAllowedAce(
      Acl: PACL,
      AceRevision: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAccessAllowedAceEx(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAccessDeniedAce(
      Acl: PACL,
      AceRevision: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAccessDeniedAceEx(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAuditAccessAce(
      Acl: PACL,
      AceRevision: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
      AuditSuccess: BOOLEAN,
      AuditFailure: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAddAuditAccessAceEx(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
      AuditSuccess: BOOLEAN,
      AuditFailure: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAddAccessAllowedObjectAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      ObjectTypeGuid: PGUID,
      InheritedObjectTypeGuid: PGUID,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAccessDeniedObjectAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      ObjectTypeGuid: PGUID,
      InheritedObjectTypeGuid: PGUID,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAuditAccessObjectAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      ObjectTypeGuid: PGUID,
      InheritedObjectTypeGuid: PGUID,
      Sid: PSID,
      AuditSuccess: BOOLEAN,
      AuditFailure: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAddCompoundAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceType: UCHAR,
      AccessMask: ACCESS_MASK,
      ServerSid: PSID,
      ClientSid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddMandatoryAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      Sid: PSID,
      AceType: UCHAR,
      AccessMask: ACCESS_MASK,
   ) -> NTSTATUS;
   pub fn RtlAddResourceAttributeAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ULONG,
      Sid: PSID,
      AttributeInfo: PCLAIM_SECURITY_ATTRIBUTES_INFORMATION,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlAddScopedPolicyIDAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ULONG,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddProcessTrustLabelAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      ProcessTrustLabelSid: PSID,
      AceType: UCHAR,
      AccessMask: ACCESS_MASK,
   ) -> NTSTATUS;
   pub fn RtlDefaultNpAcl(Acl: *mut PACL) -> NTSTATUS;
   pub fn RtlNewSecurityObject(
      ParentDescriptor: PSECURITY_DESCRIPTOR,
      CreatorDescriptor: PSECURITY_DESCRIPTOR,
      NewDescriptor: *mut PSECURITY_DESCRIPTOR,
      IsDirectoryObject: BOOLEAN,
      Token: HANDLE,
      GenericMapping: PGENERIC_MAPPING,
   ) -> NTSTATUS;
   pub fn RtlNewSecurityObjectEx(
      ParentDescriptor: PSECURITY_DESCRIPTOR,
      CreatorDescriptor: PSECURITY_DESCRIPTOR,
      NewDescriptor: *mut PSECURITY_DESCRIPTOR,
      ObjectType: *mut GUID,
      IsDirectoryObject: BOOLEAN,
      AutoInheritFlags: ULONG,
      Token: HANDLE,
      GenericMapping: PGENERIC_MAPPING,
   ) -> NTSTATUS;
   pub fn RtlNewSecurityObjectWithMultipleInheritance(
      ParentDescriptor: PSECURITY_DESCRIPTOR,
      CreatorDescriptor: PSECURITY_DESCRIPTOR,
      NewDescriptor: *mut PSECURITY_DESCRIPTOR,
      ObjectType: *mut *mut GUID,
      GuidCount: ULONG,
      IsDirectoryObject: BOOLEAN,
      AutoInheritFlags: ULONG,
      Token: HANDLE,
      GenericMapping: PGENERIC_MAPPING,
   ) -> NTSTATUS;
   pub fn RtlDeleteSecurityObject(ObjectDescriptor: *mut PSECURITY_DESCRIPTOR) -> NTSTATUS;
   pub fn RtlQuerySecurityObject(
      ObjectDescriptor: PSECURITY_DESCRIPTOR,
      SecurityInformation: SECURITY_INFORMATION,
      ResultantDescriptor: PSECURITY_DESCRIPTOR,
      DescriptorLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSetSecurityObject(
      SecurityInformation: SECURITY_INFORMATION,
      ModificationDescriptor: PSECURITY_DESCRIPTOR,
      ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
      GenericMapping: PGENERIC_MAPPING,
      TokenHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn RtlSetSecurityObjectEx(
      SecurityInformation: SECURITY_INFORMATION,
      ModificationDescriptor: PSECURITY_DESCRIPTOR,
      ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
      AutoInheritFlags: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      TokenHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn RtlConvertToAutoInheritSecurityObject(
      ParentDescriptor: PSECURITY_DESCRIPTOR,
      CurrentSecurityDescriptor: PSECURITY_DESCRIPTOR,
      NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
      ObjectType: *mut GUID,
      IsDirectoryObject: BOOLEAN,
      GenericMapping: PGENERIC_MAPPING,
   ) -> NTSTATUS;
   pub fn RtlNewInstanceSecurityObject(
      ParentDescriptorChanged: BOOLEAN,
      CreatorDescriptorChanged: BOOLEAN,
      OldClientTokenModifiedId: PLUID,
      NewClientTokenModifiedId: PLUID,
      ParentDescriptor: PSECURITY_DESCRIPTOR,
      CreatorDescriptor: PSECURITY_DESCRIPTOR,
      NewDescriptor: *mut PSECURITY_DESCRIPTOR,
      IsDirectoryObject: BOOLEAN,
      TokenHandle: HANDLE,
      GenericMapping: PGENERIC_MAPPING,
   ) -> NTSTATUS;
   pub fn RtlCopySecurityDescriptor(
      InputSecurityDescriptor: PSECURITY_DESCRIPTOR,
      OutputSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn RtlCreateUserSecurityObject(
      AceData: PRTL_ACE_DATA,
      AceCount: ULONG,
      OwnerSid: PSID,
      GroupSid: PSID,
      IsDirectoryObject: BOOLEAN,
      GenericMapping: PGENERIC_MAPPING,
      NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn RtlCreateAndSetSD(
      AceData: PRTL_ACE_DATA,
      AceCount: ULONG,
      OwnerSid: PSID,
      GroupSid: PSID,
      NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn RtlRunEncodeUnicodeString(Seed: PUCHAR, String: PUNICODE_STRING);
   pub fn RtlRunDecodeUnicodeString(Seed: UCHAR, String: PUNICODE_STRING);
   pub fn RtlImpersonateSelf(ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL) -> NTSTATUS;
   pub fn RtlImpersonateSelfEx(
      ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
      AdditionalAccess: ACCESS_MASK,
      ThreadToken: PHANDLE,
   ) -> NTSTATUS;
   pub fn RtlAdjustPrivilege(
      Privilege: ULONG,
      Enable: BOOLEAN,
      Client: BOOLEAN,
      WasEnabled: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAcquirePrivilege(
      Privilege: PULONG,
      NumPriv: ULONG,
      Flags: ULONG,
      ReturnedState: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlReleasePrivilege(StatePointer: PVOID);
   pub fn RtlRemovePrivileges(
      TokenHandle: HANDLE,
      PrivilegesToKeep: PULONG,
      PrivilegeCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlIsUntrustedObject(
      Handle: HANDLE,
      Object: PVOID,
      IsUntrustedObject: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlQueryValidationRunlevel(ComponentName: PUNICODE_STRING) -> ULONG;
   pub fn RtlCreateBoundaryDescriptor(
      Name: PUNICODE_STRING,
      Flags: ULONG,
   ) -> POBJECT_BOUNDARY_DESCRIPTOR;
   pub fn RtlDeleteBoundaryDescriptor(BoundaryDescriptor: POBJECT_BOUNDARY_DESCRIPTOR);
   pub fn RtlAddSIDToBoundaryDescriptor(
      BoundaryDescriptor: *mut POBJECT_BOUNDARY_DESCRIPTOR,
      RequiredSid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddIntegrityLabelToBoundaryDescriptor(
      BoundaryDescriptor: *mut POBJECT_BOUNDARY_DESCRIPTOR,
      IntegrityLabel: PSID,
   ) -> NTSTATUS;
   pub fn RtlGetVersion(VersionInformation: PRTL_OSVERSIONINFOEXW) -> NTSTATUS;
   pub fn RtlVerifyVersionInfo(
      VersionInformation: PRTL_OSVERSIONINFOEXW,
      TypeMask: ULONG,
      ConditionMask: ULONGLONG,
   ) -> NTSTATUS;
   pub fn RtlGetNtVersionNumbers(
      NtMajorVersion: PULONG,
      NtMinorVersion: PULONG,
      NtBuildNumber: PULONG,
   );
   pub fn RtlGetNtGlobalFlags() -> ULONG;
   pub fn RtlGetNtProductType(NtProductType: PNT_PRODUCT_TYPE) -> BOOLEAN;
   pub fn RtlGetSuiteMask() -> ULONG;
   pub fn RtlRegisterWait(
      WaitHandle: PHANDLE,
      Handle: HANDLE,
      Function: WAITORTIMERCALLBACKFUNC,
      Context: PVOID,
      Milliseconds: ULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDeregisterWait(WaitHandle: HANDLE) -> NTSTATUS;
   pub fn RtlDeregisterWaitEx(WaitHandle: HANDLE, CompletionEvent: HANDLE) -> NTSTATUS;
   pub fn RtlQueueWorkItem(Function: WORKERCALLBACKFUNC, Context: PVOID, Flags: ULONG) -> NTSTATUS;
   pub fn RtlSetIoCompletionCallback(
      FileHandle: HANDLE,
      CompletionProc: APC_CALLBACK_FUNCTION,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlSetThreadPoolStartFunc(
      StartPoolThread: PRTL_START_POOL_THREAD,
      ExitPoolThread: PRTL_EXIT_POOL_THREAD,
   ) -> NTSTATUS;
   pub fn RtlUserThreadStart(Function: PTHREAD_START_ROUTINE, Parameter: PVOID);
   pub fn LdrInitializeThunk(ContextRecord: PCONTEXT, Parameter: PVOID);
   pub fn RtlDelayExecution(Alertable: BOOLEAN, DelayInterval: PLARGE_INTEGER) -> NTSTATUS;
   pub fn RtlCreateTimerQueue(TimerQueueHandle: PHANDLE) -> NTSTATUS;
   pub fn RtlCreateTimer(
      TimerQueueHandle: HANDLE,
      Handle: PHANDLE,
      Function: WAITORTIMERCALLBACKFUNC,
      Context: PVOID,
      DueTime: ULONG,
      Period: ULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlSetTimer(
      TimerQueueHandle: HANDLE,
      Handle: PHANDLE,
      Function: WAITORTIMERCALLBACKFUNC,
      Context: PVOID,
      DueTime: ULONG,
      Period: ULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUpdateTimer(
      TimerQueueHandle: HANDLE,
      TimerHandle: HANDLE,
      DueTime: ULONG,
      Period: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDeleteTimer(
      TimerQueueHandle: HANDLE,
      TimerToCancel: HANDLE,
      Event: HANDLE,
   ) -> NTSTATUS;
   pub fn RtlDeleteTimerQueue(TimerQueueHandle: HANDLE) -> NTSTATUS;
   pub fn RtlDeleteTimerQueueEx(TimerQueueHandle: HANDLE, Event: HANDLE) -> NTSTATUS;
   pub fn RtlFormatCurrentUserKeyPath(CurrentUserKeyPath: PUNICODE_STRING) -> NTSTATUS;
   pub fn RtlOpenCurrentUser(DesiredAccess: ACCESS_MASK, CurrentUserKey: PHANDLE) -> NTSTATUS;
   pub fn RtlCreateRegistryKey(RelativeTo: ULONG, Path: PWSTR) -> NTSTATUS;
   pub fn RtlCheckRegistryKey(RelativeTo: ULONG, Path: PWSTR) -> NTSTATUS;
   pub fn RtlQueryRegistryValues(
      RelativeTo: ULONG,
      Path: PCWSTR,
      QueryTable: PRTL_QUERY_REGISTRY_TABLE,
      Context: PVOID,
      Environment: PVOID,
   ) -> NTSTATUS;
   pub fn RtlQueryRegistryValuesEx(
      RelativeTo: ULONG,
      Path: PCWSTR,
      QueryTable: PRTL_QUERY_REGISTRY_TABLE,
      Context: PVOID,
      Environment: PVOID,
   ) -> NTSTATUS;
   pub fn RtlQueryRegistryValueWithFallback(
      PrimaryHandle: HANDLE,
      FallbackHandle: HANDLE,
      ValueName: PUNICODE_STRING,
      ValueLength: ULONG,
      ValueType: PULONG,
      ValueData: PVOID,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlWriteRegistryValue(
      RelativeTo: ULONG,
      Path: PCWSTR,
      ValueName: PCWSTR,
      ValueType: ULONG,
      ValueData: PVOID,
      ValueLength: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDeleteRegistryValue(RelativeTo: ULONG, Path: PCWSTR, ValueName: PCWSTR) -> NTSTATUS;
   pub fn RtlEnableThreadProfiling(
      ThreadHandle: HANDLE,
      Flags: ULONG,
      HardwareCounters: ULONG64,
      PerformanceDataHandle: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlDisableThreadProfiling(PerformanceDataHandle: PVOID) -> NTSTATUS;
   pub fn RtlQueryThreadProfiling(ThreadHandle: HANDLE, Enabled: PBOOLEAN) -> NTSTATUS;
   pub fn RtlReadThreadProfilingData(
      PerformanceDataHandle: HANDLE,
      Flags: ULONG,
      PerformanceData: PPERFORMANCE_DATA,
   ) -> NTSTATUS;
   pub fn RtlGetNativeSystemInformation(
      SystemInformationClass: ULONG,
      NativeSystemInformation: PVOID,
      InformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlQueueApcWow64Thread(
      ThreadHandle: HANDLE,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn RtlWow64EnableFsRedirection(Wow64FsEnableRedirection: BOOLEAN) -> NTSTATUS;
   pub fn RtlWow64EnableFsRedirectionEx(
      Wow64FsEnableRedirection: PVOID,
      OldFsRedirectionLevel: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlComputeCrc32(PartialCrc: ULONG32, Buffer: PVOID, Length: ULONG) -> ULONG32;
   pub fn RtlEncodePointer(Ptr: PVOID) -> PVOID;
   pub fn RtlDecodePointer(Ptr: PVOID) -> PVOID;
   pub fn RtlEncodeSystemPointer(Ptr: PVOID) -> PVOID;
   pub fn RtlDecodeSystemPointer(Ptr: PVOID) -> PVOID;
   pub fn RtlEncodeRemotePointer(
      ProcessHandle: HANDLE,
      Pointer: PVOID,
      EncodedPointer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlDecodeRemotePointer(
      ProcessHandle: HANDLE,
      Pointer: PVOID,
      DecodedPointer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlIsProcessorFeaturePresent(ProcessorFeature: ULONG) -> BOOLEAN;
   pub fn RtlGetCurrentProcessorNumber() -> ULONG;
   pub fn RtlGetCurrentProcessorNumberEx(ProcessorNumber: PPROCESSOR_NUMBER);
   pub fn RtlPushFrame(Frame: PTEB_ACTIVE_FRAME);
   pub fn RtlPopFrame(Frame: PTEB_ACTIVE_FRAME);
   pub fn RtlGetFrame() -> PTEB_ACTIVE_FRAME;
   pub fn RtlWalkFrameChain(Callers: *mut PVOID, Count: ULONG, Flags: ULONG) -> ULONG;
   pub fn RtlGetCallersAddress(CallersAddress: *mut PVOID, CallersCaller: *mut PVOID);
   pub fn RtlGetEnabledExtendedFeatures(FeatureMask: ULONG64) -> ULONG64;
   pub fn RtlGetEnabledExtendedAndSupervisorFeatures(FeatureMask: ULONG64) -> ULONG64;
   pub fn RtlLocateSupervisorFeature(
      XStateHeader: PXSAVE_AREA_HEADER,
      FeatureId: ULONG,
      Length: PULONG,
   ) -> PVOID;
   pub fn RtlQueryElevationFlags(Flags: PRTL_ELEVATION_FLAGS) -> NTSTATUS;
   pub fn RtlRegisterThreadWithCsrss() -> NTSTATUS;
   pub fn RtlLockCurrentThread() -> NTSTATUS;
   pub fn RtlUnlockCurrentThread() -> NTSTATUS;
   pub fn RtlLockModuleSection(Address: PVOID) -> NTSTATUS;
   pub fn RtlUnlockModuleSection(Address: PVOID) -> NTSTATUS;
   pub fn RtlGetUnloadEventTrace() -> PRTL_UNLOAD_EVENT_TRACE;
   pub fn RtlGetUnloadEventTraceEx(
      ElementSize: *mut PULONG,
      ElementCount: *mut PULONG,
      EventTrace: *mut PVOID,
   );
   pub fn RtlQueryPerformanceCounter(PerformanceCounter: PLARGE_INTEGER) -> LOGICAL;
   pub fn RtlQueryPerformanceFrequency(PerformanceFrequency: PLARGE_INTEGER) -> LOGICAL;
   pub fn RtlQueryImageMitigationPolicy(
      ImagePath: PWSTR,
      Policy: IMAGE_MITIGATION_POLICY,
      Flags: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn RtlSetImageMitigationPolicy(
      ImagePath: PWSTR,
      Policy: IMAGE_MITIGATION_POLICY,
      Flags: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn RtlGetCurrentServiceSessionId() -> ULONG;
   pub fn RtlGetActiveConsoleId() -> ULONG;
   pub fn RtlGetConsoleSessionForegroundProcessId() -> ULONGLONG;
   pub fn RtlGetTokenNamedObjectPath(
      TokenHandle: HANDLE,
      Sid: PSID,
      ObjectPath: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlGetAppContainerNamedObjectPath(
      TokenHandle: HANDLE,
      AppContainerSid: PSID,
      RelativePath: BOOLEAN,
      ObjectPath: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlGetAppContainerParent(
      AppContainerSid: PSID,
      AppContainerSidParent: *mut PSID,
   ) -> NTSTATUS;
   pub fn RtlCheckSandboxedToken(TokenHandle: HANDLE, IsSandboxed: PBOOLEAN) -> NTSTATUS;
   pub fn RtlCheckTokenCapability(
      TokenHandle: HANDLE,
      CapabilitySidToCheck: PSID,
      HasCapability: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlCapabilityCheck(
      TokenHandle: HANDLE,
      CapabilityName: PUNICODE_STRING,
      HasCapability: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlCheckTokenMembership(
      TokenHandle: HANDLE,
      SidToCheck: PSID,
      IsMember: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlCheckTokenMembershipEx(
      TokenHandle: HANDLE,
      SidToCheck: PSID,
      Flags: ULONG,
      IsMember: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlQueryTokenHostIdAsUlong64(TokenHandle: HANDLE, HostId: PULONG64) -> NTSTATUS;
   pub fn RtlIsParentOfChildAppContainer(
      ParentAppContainerSid: PSID,
      ChildAppContainerSid: PSID,
   ) -> BOOLEAN;
   pub fn RtlIsApiSetImplemented(ApiSetName: PCSTR) -> NTSTATUS;
   pub fn RtlIsCapabilitySid(Sid: PSID) -> BOOLEAN;
   pub fn RtlIsPackageSid(Sid: PSID) -> BOOLEAN;
   pub fn RtlIsValidProcessTrustLabelSid(Sid: PSID) -> BOOLEAN;
   pub fn RtlGetAppContainerSidType(
      AppContainerSid: PSID,
      AppContainerSidType: PAPPCONTAINER_SID_TYPE,
   ) -> NTSTATUS;
   pub fn RtlFlsAlloc(Callback: PFLS_CALLBACK_FUNCTION, FlsIndex: PULONG) -> NTSTATUS;
   pub fn RtlFlsFree(FlsIndex: ULONG) -> NTSTATUS;
   pub fn RtlFlsGetValue(FlsIndex: ULONG, FlsData: *mut PVOID) -> NTSTATUS;
   pub fn RtlFlsSetValue(FlsIndex: ULONG, FlsData: PVOID) -> NTSTATUS;
   pub fn RtlIsStateSeparationEnabled() -> BOOLEAN;
   pub fn RtlGetPersistedStateLocation(
      SourceID: PCWSTR,
      CustomValue: PCWSTR,
      DefaultPath: PCWSTR,
      StateLocationType: STATE_LOCATION_TYPE,
      TargetPath: PWCHAR,
      BufferLengthIn: ULONG,
      BufferLengthOut: PULONG,
   ) -> NTSTATUS;
   pub fn RtlIsCloudFilesPlaceholder(FileAttributes: ULONG, ReparseTag: ULONG) -> BOOLEAN;
   pub fn RtlIsPartialPlaceholder(FileAttributes: ULONG, ReparseTag: ULONG) -> BOOLEAN;
   pub fn RtlIsPartialPlaceholderFileHandle(
      FileHandle: HANDLE,
      IsPartialPlaceholder: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlIsPartialPlaceholderFileInfo(
      InfoBuffer: PVOID,
      InfoClass: FILE_INFORMATION_CLASS,
      IsPartialPlaceholder: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlQueryThreadPlaceholderCompatibilityMode() -> CHAR;
   pub fn RtlSetThreadPlaceholderCompatibilityMode(Mode: CHAR) -> CHAR;
   pub fn RtlQueryProcessPlaceholderCompatibilityMode() -> CHAR;
   pub fn RtlSetProcessPlaceholderCompatibilityMode(Mode: CHAR) -> CHAR;
   pub fn RtlIsNonEmptyDirectoryReparsePointAllowed(ReparseTag: ULONG) -> BOOLEAN;
   pub fn RtlAppxIsFileOwnedByTrustedInstaller(
      FileHandle: HANDLE,
      IsFileOwnedByTrustedInstaller: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlQueryPackageClaims(
      TokenHandle: HANDLE,
      PackageFullName: PWSTR,
      PackageSize: PSIZE_T,
      AppId: PWSTR,
      AppIdSize: PSIZE_T,
      DynamicId: PGUID,
      PkgClaim: PPS_PKG_CLAIM,
      AttributesPresent: PULONG64,
   ) -> NTSTATUS;
   pub fn RtlQueryPackageIdentity(
      TokenHandle: HANDLE,
      PackageFullName: PWSTR,
      PackageSize: PSIZE_T,
      AppId: PWSTR,
      AppIdSize: PSIZE_T,
      Packaged: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlQueryPackageIdentityEx(
      TokenHandle: HANDLE,
      PackageFullName: PWSTR,
      PackageSize: PSIZE_T,
      AppId: PWSTR,
      AppIdSize: PSIZE_T,
      DynamicId: PGUID,
      Flags: PULONG64,
   ) -> NTSTATUS;
   pub fn RtlQueryProtectedPolicy(PolicyGuid: PGUID, PolicyValue: PULONG_PTR) -> NTSTATUS;
   pub fn RtlSetProtectedPolicy(
      PolicyGuid: PGUID,
      PolicyValue: ULONG_PTR,
      OldPolicyValue: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn RtlIsEnclaveFeaturePresent(FeatureMask: ULONG) -> BOOLEAN;
   pub fn RtlIsMultiSessionSku() -> BOOLEAN;
   pub fn RtlIsMultiUsersInSessionSku() -> BOOLEAN;
   pub fn RtlGetSessionProperties(SessionId: ULONG, SharedUserSessionId: PULONG) -> NTSTATUS;
   pub fn RtlCreateBootStatusDataFile() -> NTSTATUS;
   pub fn RtlLockBootStatusData(FileHandle: PHANDLE) -> NTSTATUS;
   pub fn RtlUnlockBootStatusData(FileHandle: HANDLE) -> NTSTATUS;
   pub fn RtlGetSetBootStatusData(
      FileHandle: HANDLE,
      Read: BOOLEAN,
      DataClass: RTL_BSD_ITEM_TYPE,
      Buffer: PVOID,
      BufferSize: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlCheckBootStatusIntegrity(FileHandle: HANDLE, Verified: PBOOLEAN) -> NTSTATUS;
   pub fn RtlRestoreBootStatusDefaults(FileHandle: HANDLE) -> NTSTATUS;
   pub fn RtlRestoreSystemBootStatusDefaults() -> NTSTATUS;
   pub fn RtlGetSystemBootStatus(
      BootStatusInformationClass: RTL_BSD_ITEM_TYPE,
      DataBuffer: PVOID,
      DataLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSetSystemBootStatus(
      BootStatusInformationClass: RTL_BSD_ITEM_TYPE,
      DataBuffer: PVOID,
      DataLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlCheckPortableOperatingSystem(IsPortable: PBOOLEAN) -> NTSTATUS;
   pub fn RtlSetPortableOperatingSystem(IsPortable: BOOLEAN) -> NTSTATUS;
   pub fn RtlSetProxiedProcessId(ProxiedProcessId: ULONG) -> ULONG;
   pub fn RtlFindClosestEncodableLength(
      SourceLength: ULONGLONG,
      TargetLength: PULONGLONG,
   ) -> NTSTATUS;
   pub fn RtlRegisterSecureMemoryCacheCallback(
      Callback: PRTL_SECURE_MEMORY_CACHE_CALLBACK,
   ) -> NTSTATUS;
   pub fn RtlDeregisterSecureMemoryCacheCallback(
      Callback: PRTL_SECURE_MEMORY_CACHE_CALLBACK,
   ) -> NTSTATUS;
   pub fn RtlFlushSecureMemoryCache(MemoryCache: PVOID, MemoryLength: SIZE_T) -> BOOLEAN;
   pub fn RtlNotifyFeatureUsage(FeatureUsageReport: PRTL_FEATURE_USAGE_REPORT) -> NTSTATUS;
   pub fn RtlQueryFeatureConfiguration(
      FeatureId: ULONG,
      FeatureType: RTL_FEATURE_CONFIGURATION_TYPE,
      ChangeStamp: PULONGLONG,
      FeatureConfiguration: PRTL_FEATURE_CONFIGURATION,
   ) -> NTSTATUS;
   pub fn RtlSetFeatureConfigurations(
      ChangeStamp: PULONGLONG,
      FeatureType: RTL_FEATURE_CONFIGURATION_TYPE,
      FeatureConfiguration: PRTL_FEATURE_CONFIGURATION,
      FeatureConfigurationCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlQueryAllFeatureConfigurations(
      FeatureType: RTL_FEATURE_CONFIGURATION_TYPE,
      ChangeStamp: PULONGLONG,
      FeatureConfigurations: PRTL_FEATURE_CONFIGURATION,
      FeatureConfigurationCount: PULONG,
   ) -> NTSTATUS;
   pub fn RtlQueryFeatureConfigurationChangeStamp() -> ULONGLONG;
   pub fn RtlQueryFeatureUsageNotificationSubscriptions(
      FeatureConfiguration: PRTL_FEATURE_CONFIGURATION,
      FeatureConfigurationCount: PULONG,
   ) -> NTSTATUS;
   pub fn RtlRegisterFeatureConfigurationChangeNotification(
      Callback: PRTL_FEATURE_CONFIGURATION_CHANGE_NOTIFICATION,
      Context: PVOID,
      ChangeStamp: PULONGLONG,
      NotificationHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn RtlUnregisterFeatureConfigurationChangeNotification(
      NotificationHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn RtlSubscribeForFeatureUsageNotification(
      FeatureConfiguration: PRTL_FEATURE_CONFIGURATION,
      FeatureConfigurationCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnsubscribeFromFeatureUsageNotifications(
      FeatureConfiguration: PRTL_FEATURE_CONFIGURATION,
      FeatureConfigurationCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlRunOnceInitialize(RunOnce: PRTL_RUN_ONCE);
   pub fn RtlRunOnceExecuteOnce(
      RunOnce: PRTL_RUN_ONCE,
      InitFn: PRTL_RUN_ONCE_INIT_FN,
      Parameter: PVOID,
      Context: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlRunOnceBeginInitialize(
      RunOnce: PRTL_RUN_ONCE,
      Flags: ULONG,
      Context: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlRunOnceComplete(RunOnce: PRTL_RUN_ONCE, Flags: ULONG, Context: PVOID) -> NTSTATUS;
   pub fn RtlEqualWnfChangeStamps(
      ChangeStamp1: WNF_CHANGE_STAMP,
      ChangeStamp2: WNF_CHANGE_STAMP,
   ) -> BOOLEAN;
   pub fn RtlQueryWnfStateData(
      ChangeStamp: PWNF_CHANGE_STAMP,
      StateName: WNF_STATE_NAME,
      Callback: PWNF_USER_CALLBACK,
      CallbackContext: PVOID,
      TypeId: PWNF_TYPE_ID,
   ) -> NTSTATUS;
   pub fn RtlPublishWnfStateData(
      StateName: WNF_STATE_NAME,
      TypeId: PCWNF_TYPE_ID,
      Buffer: *const cty::c_void,
      Length: ULONG,
      ExplicitScope: *const cty::c_void,
   ) -> NTSTATUS;
   pub fn RtlSubscribeWnfStateChangeNotification(
      SubscriptionHandle: *mut PVOID,
      StateName: WNF_STATE_NAME,
      ChangeStamp: WNF_CHANGE_STAMP,
      Callback: PWNF_USER_CALLBACK,
      CallbackContext: PVOID,
      TypeId: PCWNF_TYPE_ID,
      SerializationGroup: ULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnsubscribeWnfStateChangeNotification(Callback: PWNF_USER_CALLBACK) -> NTSTATUS;
   pub fn NtCopyFileChunk(
      SourceHandle: HANDLE,
      DestinationHandle: HANDLE,
      EventHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Length: ULONG,
      SourceOffset: PLARGE_INTEGER,
      DestOffset: PLARGE_INTEGER,
      SourceKey: PULONG,
      DestKey: PULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlQueryPropertyStore(Key: ULONG_PTR, Context: PULONG_PTR) -> NTSTATUS;
   pub fn RtlRemovePropertyStore(Key: ULONG_PTR, Context: PULONG_PTR) -> NTSTATUS;
   pub fn RtlCompareExchangePropertyStore(
      Key: ULONG_PTR,
      Comperand: PULONG_PTR,
      Exchange: PULONG_PTR,
      Context: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn RtlWow64ChangeThreadState(
      ThreadStateChangeHandle: HANDLE,
      ThreadHandle: HANDLE,
      StateChangeType: THREAD_STATE_CHANGE_TYPE,
      ExtendedInformation: PVOID,
      ExtendedInformationLength: SIZE_T,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn NtCreateToken(
      TokenHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Type: TOKEN_TYPE,
      AuthenticationId: PLUID,
      ExpirationTime: PLARGE_INTEGER,
      User: PTOKEN_USER,
      Groups: PTOKEN_GROUPS,
      Privileges: PTOKEN_PRIVILEGES,
      Owner: PTOKEN_OWNER,
      PrimaryGroup: PTOKEN_PRIMARY_GROUP,
      DefaultDacl: PTOKEN_DEFAULT_DACL,
      Source: PTOKEN_SOURCE,
   ) -> NTSTATUS;
   pub fn NtCreateLowBoxToken(
      TokenHandle: PHANDLE,
      ExistingTokenHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PackageSid: PSID,
      CapabilityCount: ULONG,
      Capabilities: PSID_AND_ATTRIBUTES,
      HandleCount: ULONG,
      Handles: *mut HANDLE,
   ) -> NTSTATUS;
   pub fn NtCreateTokenEx(
      TokenHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Type: TOKEN_TYPE,
      AuthenticationId: PLUID,
      ExpirationTime: PLARGE_INTEGER,
      User: PTOKEN_USER,
      Groups: PTOKEN_GROUPS,
      Privileges: PTOKEN_PRIVILEGES,
      UserAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceGroups: PTOKEN_GROUPS,
      MandatoryPolicy: PTOKEN_MANDATORY_POLICY,
      Owner: PTOKEN_OWNER,
      PrimaryGroup: PTOKEN_PRIMARY_GROUP,
      DefaultDacl: PTOKEN_DEFAULT_DACL,
      Source: PTOKEN_SOURCE,
   ) -> NTSTATUS;
   pub fn NtOpenProcessToken(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtOpenProcessTokenEx(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtOpenThreadToken(
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      OpenAsSelf: BOOLEAN,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtOpenThreadTokenEx(
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      OpenAsSelf: BOOLEAN,
      HandleAttributes: ULONG,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtDuplicateToken(
      ExistingTokenHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      EffectiveOnly: BOOLEAN,
      Type: TOKEN_TYPE,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtQueryInformationToken(
      TokenHandle: HANDLE,
      TokenInformationClass: TOKEN_INFORMATION_CLASS,
      TokenInformation: PVOID,
      TokenInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationToken(
      TokenHandle: HANDLE,
      TokenInformationClass: TOKEN_INFORMATION_CLASS,
      TokenInformation: PVOID,
      TokenInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtAdjustPrivilegesToken(
      TokenHandle: HANDLE,
      DisableAllPrivileges: BOOLEAN,
      NewState: PTOKEN_PRIVILEGES,
      BufferLength: ULONG,
      PreviousState: PTOKEN_PRIVILEGES,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAdjustGroupsToken(
      TokenHandle: HANDLE,
      ResetToDefault: BOOLEAN,
      NewState: PTOKEN_GROUPS,
      BufferLength: ULONG,
      PreviousState: PTOKEN_GROUPS,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAdjustTokenClaimsAndDeviceGroups(
      TokenHandle: HANDLE,
      UserResetToDefault: BOOLEAN,
      DeviceResetToDefault: BOOLEAN,
      DeviceGroupsResetToDefault: BOOLEAN,
      NewUserState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      NewDeviceState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      NewDeviceGroupsState: PTOKEN_GROUPS,
      UserBufferLength: ULONG,
      PreviousUserState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceBufferLength: ULONG,
      PreviousDeviceState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceGroupsBufferLength: ULONG,
      PreviousDeviceGroups: PTOKEN_GROUPS,
      UserReturnLength: PULONG,
      DeviceReturnLength: PULONG,
      DeviceGroupsReturnBufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtFilterToken(
      ExistingTokenHandle: HANDLE,
      Flags: ULONG,
      SidsToDisable: PTOKEN_GROUPS,
      PrivilegesToDelete: PTOKEN_PRIVILEGES,
      RestrictedSids: PTOKEN_GROUPS,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtFilterTokenEx(
      ExistingTokenHandle: HANDLE,
      Flags: ULONG,
      SidsToDisable: PTOKEN_GROUPS,
      PrivilegesToDelete: PTOKEN_PRIVILEGES,
      RestrictedSids: PTOKEN_GROUPS,
      DisableUserClaimsCount: ULONG,
      UserClaimsToDisable: PUNICODE_STRING,
      DisableDeviceClaimsCount: ULONG,
      DeviceClaimsToDisable: PUNICODE_STRING,
      DeviceGroupsToDisable: PTOKEN_GROUPS,
      RestrictedUserAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      RestrictedDeviceAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      RestrictedDeviceGroups: PTOKEN_GROUPS,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtCompareTokens(
      FirstTokenHandle: HANDLE,
      SecondTokenHandle: HANDLE,
      Equal: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtPrivilegeCheck(
      ClientToken: HANDLE,
      RequiredPrivileges: PPRIVILEGE_SET,
      Result: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtImpersonateAnonymousToken(ThreadHandle: HANDLE) -> NTSTATUS;
   pub fn NtQuerySecurityAttributesToken(
      TokenHandle: HANDLE,
      Attributes: PUNICODE_STRING,
      NumberOfAttributes: ULONG,
      Buffer: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAccessCheck(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn NtAccessCheckByType(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn NtAccessCheckByTypeResultList(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn NtSetCachedSigningLevel(
      Flags: ULONG,
      InputSigningLevel: SE_SIGNING_LEVEL,
      SourceFiles: PHANDLE,
      SourceFileCount: ULONG,
      TargetFile: HANDLE,
   ) -> NTSTATUS;
   pub fn NtGetCachedSigningLevel(
      File: HANDLE,
      Flags: PULONG,
      SigningLevel: PSE_SIGNING_LEVEL,
      Thumbprint: PUCHAR,
      ThumbprintSize: PULONG,
      ThumbprintAlgorithm: PULONG,
   ) -> NTSTATUS;
   pub fn NtCompareSigningLevels(
      FirstSigningLevel: SE_SIGNING_LEVEL,
      SecondSigningLevel: SE_SIGNING_LEVEL,
   ) -> NTSTATUS;
   pub fn NtAccessCheckAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      DesiredAccess: ACCESS_MASK,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtAccessCheckByTypeAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtAccessCheckByTypeResultListAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtAccessCheckByTypeResultListAndAuditAlarmByHandle(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ClientToken: HANDLE,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtOpenObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      GrantedAccess: ACCESS_MASK,
      Privileges: PPRIVILEGE_SET,
      ObjectCreation: BOOLEAN,
      AccessGranted: BOOLEAN,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtPrivilegeObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      Privileges: PPRIVILEGE_SET,
      AccessGranted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtCloseObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      GenerateOnClose: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtDeleteObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      GenerateOnClose: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtPrivilegedServiceAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      ServiceName: PUNICODE_STRING,
      ClientToken: HANDLE,
      Privileges: PPRIVILEGE_SET,
      AccessGranted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtCreateTransactionManager(
      TmHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LogFileName: PUNICODE_STRING,
      CreateOptions: ULONG,
      CommitStrength: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenTransactionManager(
      TmHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LogFileName: PUNICODE_STRING,
      TmIdentity: LPGUID,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn NtRenameTransactionManager(
      LogFileName: PUNICODE_STRING,
      ExistingTransactionManagerGuid: LPGUID,
   ) -> NTSTATUS;
   pub fn NtRollforwardTransactionManager(
      TransactionManagerHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtRecoverTransactionManager(TransactionManagerHandle: HANDLE) -> NTSTATUS;
   pub fn NtQueryInformationTransactionManager(
      TransactionManagerHandle: HANDLE,
      TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
      TransactionManagerInformation: PVOID,
      TransactionManagerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationTransactionManager(
      TmHandle: HANDLE,
      TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
      TransactionManagerInformation: PVOID,
      TransactionManagerInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtEnumerateTransactionObject(
      RootObjectHandle: HANDLE,
      QueryType: KTMOBJECT_TYPE,
      ObjectCursor: PKTMOBJECT_CURSOR,
      ObjectCursorLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreateTransaction(
      TransactionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Uow: LPGUID,
      TmHandle: HANDLE,
      CreateOptions: ULONG,
      IsolationLevel: ULONG,
      IsolationFlags: ULONG,
      Timeout: PLARGE_INTEGER,
      Description: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn NtOpenTransaction(
      TransactionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Uow: LPGUID,
      TmHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn NtQueryInformationTransaction(
      TransactionHandle: HANDLE,
      TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
      TransactionInformation: PVOID,
      TransactionInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationTransaction(
      TransactionHandle: HANDLE,
      TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
      TransactionInformation: PVOID,
      TransactionInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtCommitTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
   pub fn NtRollbackTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
   pub fn NtCreateEnlistment(
      EnlistmentHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ResourceManagerHandle: HANDLE,
      TransactionHandle: HANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CreateOptions: ULONG,
      NotificationMask: NOTIFICATION_MASK,
      EnlistmentKey: PVOID,
   ) -> NTSTATUS;
   pub fn NtOpenEnlistment(
      EnlistmentHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ResourceManagerHandle: HANDLE,
      EnlistmentGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtQueryInformationEnlistment(
      EnlistmentHandle: HANDLE,
      EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
      EnlistmentInformation: PVOID,
      EnlistmentInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationEnlistment(
      EnlistmentHandle: HANDLE,
      EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
      EnlistmentInformation: PVOID,
      EnlistmentInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtRecoverEnlistment(EnlistmentHandle: HANDLE, EnlistmentKey: PVOID) -> NTSTATUS;
   pub fn NtPrePrepareEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtPrepareEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
      -> NTSTATUS;
   pub fn NtCommitEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtRollbackEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtPrePrepareComplete(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtPrepareComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtCommitComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtReadOnlyEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtRollbackComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtSinglePhaseReject(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
      -> NTSTATUS;
   pub fn NtCreateResourceManager(
      ResourceManagerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      TmHandle: HANDLE,
      RmGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CreateOptions: ULONG,
      Description: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn NtOpenResourceManager(
      ResourceManagerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      TmHandle: HANDLE,
      ResourceManagerGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtRecoverResourceManager(ResourceManagerHandle: HANDLE) -> NTSTATUS;
   pub fn NtGetNotificationResourceManager(
      ResourceManagerHandle: HANDLE,
      TransactionNotification: PTRANSACTION_NOTIFICATION,
      NotificationLength: ULONG,
      Timeout: PLARGE_INTEGER,
      ReturnLength: PULONG,
      Asynchronous: ULONG,
      AsynchronousContext: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtQueryInformationResourceManager(
      ResourceManagerHandle: HANDLE,
      ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
      ResourceManagerInformation: PVOID,
      ResourceManagerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationResourceManager(
      ResourceManagerHandle: HANDLE,
      ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
      ResourceManagerInformation: PVOID,
      ResourceManagerInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtRegisterProtocolAddressInformation(
      ResourceManager: HANDLE,
      ProtocolId: PCRM_PROTOCOL_ID,
      ProtocolInformationSize: ULONG,
      ProtocolInformation: PVOID,
      CreateOptions: ULONG,
   ) -> NTSTATUS;
   pub fn NtPropagationComplete(
      ResourceManagerHandle: HANDLE,
      RequestCookie: ULONG,
      BufferLength: ULONG,
      Buffer: PVOID,
   ) -> NTSTATUS;
   pub fn NtPropagationFailed(
      ResourceManagerHandle: HANDLE,
      RequestCookie: ULONG,
      PropStatus: NTSTATUS,
   ) -> NTSTATUS;
   pub fn NtFreezeTransactions(
      FreezeTimeout: PLARGE_INTEGER,
      ThawTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtThawTransactions() -> NTSTATUS;
   pub fn TpAllocPool(PoolReturn: *mut PTP_POOL, Reserved: PVOID) -> NTSTATUS;
   pub fn TpReleasePool(Pool: PTP_POOL);
   pub fn TpSetPoolMaxThreads(Pool: PTP_POOL, MaxThreads: ULONG);
   pub fn TpSetPoolMinThreads(Pool: PTP_POOL, MinThreads: ULONG) -> NTSTATUS;
   pub fn TpQueryPoolStackInformation(
      Pool: PTP_POOL,
      PoolStackInformation: PTP_POOL_STACK_INFORMATION,
   ) -> NTSTATUS;
   pub fn TpSetPoolStackInformation(
      Pool: PTP_POOL,
      PoolStackInformation: PTP_POOL_STACK_INFORMATION,
   ) -> NTSTATUS;
   pub fn TpSetPoolThreadBasePriority(Pool: PTP_POOL, BasePriority: ULONG) -> NTSTATUS;
   pub fn TpAllocCleanupGroup(CleanupGroupReturn: *mut PTP_CLEANUP_GROUP) -> NTSTATUS;
   pub fn TpReleaseCleanupGroup(CleanupGroup: PTP_CLEANUP_GROUP);
   pub fn TpReleaseCleanupGroupMembers(
      CleanupGroup: PTP_CLEANUP_GROUP,
      CancelPendingCallbacks: LOGICAL,
      CleanupParameter: PVOID,
   );
   pub fn TpCallbackSetEventOnCompletion(Instance: PTP_CALLBACK_INSTANCE, Event: HANDLE);
   pub fn TpCallbackReleaseSemaphoreOnCompletion(
      Instance: PTP_CALLBACK_INSTANCE,
      Semaphore: HANDLE,
      ReleaseCount: ULONG,
   );
   pub fn TpCallbackReleaseMutexOnCompletion(Instance: PTP_CALLBACK_INSTANCE, Mutex: HANDLE);
   pub fn TpCallbackLeaveCriticalSectionOnCompletion(
      Instance: PTP_CALLBACK_INSTANCE,
      CriticalSection: PRTL_CRITICAL_SECTION,
   );
   pub fn TpCallbackUnloadDllOnCompletion(Instance: PTP_CALLBACK_INSTANCE, DllHandle: PVOID);
   pub fn TpCallbackMayRunLong(Instance: PTP_CALLBACK_INSTANCE) -> NTSTATUS;
   pub fn TpDisassociateCallback(Instance: PTP_CALLBACK_INSTANCE);
   pub fn TpSimpleTryPost(
      Callback: PTP_SIMPLE_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpAllocWork(
      WorkReturn: *mut PTP_WORK,
      Callback: PTP_WORK_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpReleaseWork(Work: PTP_WORK);
   pub fn TpPostWork(Work: PTP_WORK);
   pub fn TpWaitForWork(Work: PTP_WORK, CancelPendingCallbacks: LOGICAL);
   pub fn TpAllocTimer(
      Timer: *mut PTP_TIMER,
      Callback: PTP_TIMER_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpReleaseTimer(Timer: PTP_TIMER);
   pub fn TpSetTimer(Timer: PTP_TIMER, DueTime: PLARGE_INTEGER, Period: ULONG, WindowLength: ULONG);
   pub fn TpSetTimerEx(
      Timer: PTP_TIMER,
      DueTime: PLARGE_INTEGER,
      Period: ULONG,
      WindowLength: ULONG,
   ) -> NTSTATUS;
   pub fn TpIsTimerSet(Timer: PTP_TIMER) -> LOGICAL;
   pub fn TpWaitForTimer(Timer: PTP_TIMER, CancelPendingCallbacks: LOGICAL);
   pub fn TpAllocWait(
      WaitReturn: *mut PTP_WAIT,
      Callback: PTP_WAIT_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpReleaseWait(Wait: PTP_WAIT);
   pub fn TpSetWait(Wait: PTP_WAIT, Handle: HANDLE, Timeout: PLARGE_INTEGER);
   pub fn TpSetWaitEx(
      Wait: PTP_WAIT,
      Handle: HANDLE,
      Timeout: PLARGE_INTEGER,
      Reserved: PVOID,
   ) -> NTSTATUS;
   pub fn TpWaitForWait(Wait: PTP_WAIT, CancelPendingCallbacks: LOGICAL);
   pub fn TpAllocIoCompletion(
      IoReturn: *mut PTP_IO,
      File: HANDLE,
      Callback: PTP_IO_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpReleaseIoCompletion(Io: PTP_IO);
   pub fn TpStartAsyncIoOperation(Io: PTP_IO);
   pub fn TpCancelAsyncIoOperation(Io: PTP_IO);
   pub fn TpWaitForIoCompletion(Io: PTP_IO, CancelPendingCallbacks: LOGICAL);
   pub fn TpAllocAlpcCompletion(
      AlpcReturn: *mut PTP_ALPC,
      AlpcPort: HANDLE,
      Callback: PTP_ALPC_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpAllocAlpcCompletionEx(
      AlpcReturn: *mut PTP_ALPC,
      AlpcPort: HANDLE,
      Callback: PTP_ALPC_CALLBACK_EX,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpReleaseAlpcCompletion(Alpc: PTP_ALPC);
   pub fn TpWaitForAlpcCompletion(Alpc: PTP_ALPC);
   pub fn TpCaptureCaller(Type: TP_TRACE_TYPE);
   pub fn TpCheckTerminateWorker(Thread: HANDLE);
   pub fn RtlDispatchException(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
   ) -> BOOLEAN;
   pub fn RtlRaiseStatus(Status: NTSTATUS) -> !;
   pub fn RtlRaiseException(ExceptionRecord: PEXCEPTION_RECORD);
   pub fn RtlRaiseExceptionForReturnAddressHijack();
   pub fn RtlRaiseNoncontinuableException(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
   ) -> !;
   pub fn NtContinue(ContextRecord: PCONTEXT, TestAlert: BOOLEAN) -> NTSTATUS;
   pub fn NtContinueEx(ContextRecord: PCONTEXT, ContinueArgument: PVOID) -> NTSTATUS;
   pub fn NtRaiseException(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
      FirstChance: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAssert(
      VoidFailedAssertion: PVOID,
      VoidFileName: PVOID,
      LineNumber: ULONG,
      MutableMessage: PSTR,
   ) -> !;
   pub fn UStr32ToUStr(Destination: PUNICODE_STRING, Source: PUNICODE_STRING32);
   pub fn UStrToUStr32(Destination: PUNICODE_STRING32, Source: PUNICODE_STRING);
   pub fn Wow64CurrentGuestTeb() -> *mut TEB32;
   pub fn Wow64CurrentNativeTeb() -> *mut cty::c_void;
   pub fn SamFreeMemory(Buffer: PVOID) -> NTSTATUS;
   pub fn SamCloseHandle(SamHandle: SAM_HANDLE) -> NTSTATUS;
   pub fn SamSetSecurityObject(
      ObjectHandle: SAM_HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn SamQuerySecurityObject(
      ObjectHandle: SAM_HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn SamRidToSid(ObjectHandle: SAM_HANDLE, Rid: ULONG, Sid: *mut PSID) -> NTSTATUS;
   pub fn SamConnect(
      ServerName: PUNICODE_STRING,
      ServerHandle: PSAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn SamConnectWithCreds(
      ServerName: PUNICODE_STRING,
      ServerHandle: PSAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Creds: PRPC_AUTH_IDENTITY_HANDLE,
      Spn: PWCHAR,
      pfDstIsW2K: *mut BOOL,
   ) -> NTSTATUS;
   pub fn SamShutdownSamServer(ServerHandle: SAM_HANDLE) -> NTSTATUS;
   pub fn SamLookupDomainInSamServer(
      ServerHandle: SAM_HANDLE,
      Name: PUNICODE_STRING,
      DomainId: *mut PSID,
   ) -> NTSTATUS;
   pub fn SamEnumerateDomainsInSamServer(
      ServerHandle: SAM_HANDLE,
      EnumerationContext: PSAM_ENUMERATE_HANDLE,
      Buffer: *mut PVOID,
      PreferedMaximumLength: ULONG,
      CountReturned: PULONG,
   ) -> NTSTATUS;
   pub fn SamOpenDomain(
      ServerHandle: SAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      DomainId: PSID,
      DomainHandle: PSAM_HANDLE,
   ) -> NTSTATUS;
   pub fn SamQueryInformationDomain(
      DomainHandle: SAM_HANDLE,
      DomainInformationClass: DOMAIN_INFORMATION_CLASS,
      Buffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamSetInformationDomain(
      DomainHandle: SAM_HANDLE,
      DomainInformationClass: DOMAIN_INFORMATION_CLASS,
      DomainInformation: PVOID,
   ) -> NTSTATUS;
   pub fn SamLookupNamesInDomain(
      DomainHandle: SAM_HANDLE,
      Count: ULONG,
      Names: PUNICODE_STRING,
      RelativeIds: *mut PULONG,
      Use: *mut PSID_NAME_USE,
   ) -> NTSTATUS;
   pub fn SamLookupNamesInDomain2(
      DomainHandle: SAM_HANDLE,
      Count: ULONG,
      Names: PUNICODE_STRING,
      Sids: *mut PSID,
      Use: *mut PSID_NAME_USE,
   ) -> NTSTATUS;
   pub fn SamLookupIdsInDomain(
      DomainHandle: SAM_HANDLE,
      Count: ULONG,
      RelativeIds: PULONG,
      Names: *mut PUNICODE_STRING,
      Use: *mut PSID_NAME_USE,
   ) -> NTSTATUS;
   pub fn SamRemoveMemberFromForeignDomain(DomainHandle: SAM_HANDLE, MemberId: PSID) -> NTSTATUS;
   pub fn SamQueryLocalizableAccountsInDomain(
      Domain: SAM_HANDLE,
      Flags: ULONG,
      LanguageId: ULONG,
      Class: DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION,
      Buffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamEnumerateGroupsInDomain(
      DomainHandle: SAM_HANDLE,
      EnumerationContext: PSAM_ENUMERATE_HANDLE,
      Buffer: *mut PVOID,
      PreferedMaximumLength: ULONG,
      CountReturned: PULONG,
   ) -> NTSTATUS;
   pub fn SamCreateGroupInDomain(
      DomainHandle: SAM_HANDLE,
      AccountName: PUNICODE_STRING,
      DesiredAccess: ACCESS_MASK,
      GroupHandle: PSAM_HANDLE,
      RelativeId: PULONG,
   ) -> NTSTATUS;
   pub fn SamOpenGroup(
      DomainHandle: SAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      GroupId: ULONG,
      GroupHandle: PSAM_HANDLE,
   ) -> NTSTATUS;
   pub fn SamDeleteGroup(GroupHandle: SAM_HANDLE) -> NTSTATUS;
   pub fn SamQueryInformationGroup(
      GroupHandle: SAM_HANDLE,
      GroupInformationClass: GROUP_INFORMATION_CLASS,
      Buffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamSetInformationGroup(
      GroupHandle: SAM_HANDLE,
      GroupInformationClass: GROUP_INFORMATION_CLASS,
      Buffer: PVOID,
   ) -> NTSTATUS;
   pub fn SamAddMemberToGroup(
      GroupHandle: SAM_HANDLE,
      MemberId: ULONG,
      Attributes: ULONG,
   ) -> NTSTATUS;
   pub fn SamRemoveMemberFromGroup(GroupHandle: SAM_HANDLE, MemberId: ULONG) -> NTSTATUS;
   pub fn SamGetMembersInGroup(
      GroupHandle: SAM_HANDLE,
      MemberIds: *mut PULONG,
      Attributes: *mut PULONG,
      MemberCount: PULONG,
   ) -> NTSTATUS;
   pub fn SamSetMemberAttributesOfGroup(
      GroupHandle: SAM_HANDLE,
      MemberId: ULONG,
      Attributes: ULONG,
   ) -> NTSTATUS;
   pub fn SamEnumerateAliasesInDomain(
      DomainHandle: SAM_HANDLE,
      EnumerationContext: PSAM_ENUMERATE_HANDLE,
      Buffer: *mut PVOID,
      PreferedMaximumLength: ULONG,
      CountReturned: PULONG,
   ) -> NTSTATUS;
   pub fn SamCreateAliasInDomain(
      DomainHandle: SAM_HANDLE,
      AccountName: PUNICODE_STRING,
      DesiredAccess: ACCESS_MASK,
      AliasHandle: PSAM_HANDLE,
      RelativeId: PULONG,
   ) -> NTSTATUS;
   pub fn SamOpenAlias(
      DomainHandle: SAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      AliasId: ULONG,
      AliasHandle: PSAM_HANDLE,
   ) -> NTSTATUS;
   pub fn SamDeleteAlias(AliasHandle: SAM_HANDLE) -> NTSTATUS;
   pub fn SamQueryInformationAlias(
      AliasHandle: SAM_HANDLE,
      AliasInformationClass: ALIAS_INFORMATION_CLASS,
      Buffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamSetInformationAlias(
      AliasHandle: SAM_HANDLE,
      AliasInformationClass: ALIAS_INFORMATION_CLASS,
      Buffer: PVOID,
   ) -> NTSTATUS;
   pub fn SamAddMemberToAlias(AliasHandle: SAM_HANDLE, MemberId: PSID) -> NTSTATUS;
   pub fn SamAddMultipleMembersToAlias(
      AliasHandle: SAM_HANDLE,
      MemberIds: *mut PSID,
      MemberCount: ULONG,
   ) -> NTSTATUS;
   pub fn SamRemoveMemberFromAlias(AliasHandle: SAM_HANDLE, MemberId: PSID) -> NTSTATUS;
   pub fn SamRemoveMultipleMembersFromAlias(
      AliasHandle: SAM_HANDLE,
      MemberIds: *mut PSID,
      MemberCount: ULONG,
   ) -> NTSTATUS;
   pub fn SamGetMembersInAlias(
      AliasHandle: SAM_HANDLE,
      MemberIds: *mut *mut PSID,
      MemberCount: PULONG,
   ) -> NTSTATUS;
   pub fn SamGetAliasMembership(
      DomainHandle: SAM_HANDLE,
      PassedCount: ULONG,
      Sids: *mut PSID,
      MembershipCount: PULONG,
      Aliases: *mut PULONG,
   ) -> NTSTATUS;
   pub fn SamEnumerateUsersInDomain(
      DomainHandle: SAM_HANDLE,
      EnumerationContext: PSAM_ENUMERATE_HANDLE,
      UserAccountControl: ULONG,
      Buffer: *mut PVOID,
      PreferedMaximumLength: ULONG,
      CountReturned: PULONG,
   ) -> NTSTATUS;
   pub fn SamCreateUserInDomain(
      DomainHandle: SAM_HANDLE,
      AccountName: PUNICODE_STRING,
      DesiredAccess: ACCESS_MASK,
      UserHandle: PSAM_HANDLE,
      RelativeId: PULONG,
   ) -> NTSTATUS;
   pub fn SamCreateUser2InDomain(
      DomainHandle: SAM_HANDLE,
      AccountName: PUNICODE_STRING,
      AccountType: ULONG,
      DesiredAccess: ACCESS_MASK,
      UserHandle: PSAM_HANDLE,
      GrantedAccess: PULONG,
      RelativeId: PULONG,
   ) -> NTSTATUS;
   pub fn SamOpenUser(
      DomainHandle: SAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      UserId: ULONG,
      UserHandle: PSAM_HANDLE,
   ) -> NTSTATUS;
   pub fn SamDeleteUser(UserHandle: SAM_HANDLE) -> NTSTATUS;
   pub fn SamQueryInformationUser(
      UserHandle: SAM_HANDLE,
      UserInformationClass: USER_INFORMATION_CLASS,
      Buffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamSetInformationUser(
      UserHandle: SAM_HANDLE,
      UserInformationClass: USER_INFORMATION_CLASS,
      Buffer: PVOID,
   ) -> NTSTATUS;
   pub fn SamGetGroupsForUser(
      UserHandle: SAM_HANDLE,
      Groups: *mut PGROUP_MEMBERSHIP,
      MembershipCount: PULONG,
   ) -> NTSTATUS;
   pub fn SamChangePasswordUser(
      UserHandle: SAM_HANDLE,
      OldPassword: PUNICODE_STRING,
      NewPassword: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn SamChangePasswordUser2(
      ServerName: PUNICODE_STRING,
      UserName: PUNICODE_STRING,
      OldPassword: PUNICODE_STRING,
      NewPassword: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn SamChangePasswordUser3(
      ServerName: PUNICODE_STRING,
      UserName: PUNICODE_STRING,
      OldPassword: PUNICODE_STRING,
      NewPassword: PUNICODE_STRING,
      EffectivePasswordPolicy: *mut PDOMAIN_PASSWORD_INFORMATION,
      PasswordChangeFailureInfo: *mut PUSER_PWD_CHANGE_FAILURE_INFORMATION,
   ) -> NTSTATUS;
   pub fn SamQueryDisplayInformation(
      DomainHandle: SAM_HANDLE,
      DisplayInformation: DOMAIN_DISPLAY_INFORMATION,
      Index: ULONG,
      EntryCount: ULONG,
      PreferredMaximumLength: ULONG,
      TotalAvailable: PULONG,
      TotalReturned: PULONG,
      ReturnedEntryCount: PULONG,
      SortedBuffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamGetDisplayEnumerationIndex(
      DomainHandle: SAM_HANDLE,
      DisplayInformation: DOMAIN_DISPLAY_INFORMATION,
      Prefix: PUNICODE_STRING,
      Index: PULONG,
   ) -> NTSTATUS;
   pub fn SamRegisterObjectChangeNotification(
      ObjectType: SECURITY_DB_OBJECT_TYPE,
      NotificationEventHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn SamUnregisterObjectChangeNotification(
      ObjectType: SECURITY_DB_OBJECT_TYPE,
      NotificationEventHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn SamGetCompatibilityMode(ObjectHandle: SAM_HANDLE, Mode: *mut ULONG) -> NTSTATUS;
   pub fn SamValidatePassword(
      ServerName: PUNICODE_STRING,
      ValidationType: PASSWORD_POLICY_VALIDATION_TYPE,
      InputArg: PSAM_VALIDATE_INPUT_ARG,
      OutputArg: *mut PSAM_VALIDATE_OUTPUT_ARG,
   ) -> NTSTATUS;
   pub fn SamPerformGenericOperation(
      ServerName: PWSTR,
      OperationType: SAM_GENERIC_OPERATION_TYPE,
      OperationIn: PSAM_GENERIC_OPERATION_INPUT,
      OperationOut: *mut PSAM_GENERIC_OPERATION_OUTPUT,
   ) -> NTSTATUS;
   pub fn NtVdmControl(Service: VDMSERVICECLASS, ServiceData: PVOID) -> NTSTATUS;
   pub fn NtTraceEvent(
      TraceHandle: HANDLE,
      Flags: ULONG,
      FieldSize: ULONG,
      Fields: PVOID,
   ) -> NTSTATUS;
   pub fn NtTraceControl(
      TraceControlCode: ETWTRACECONTROLCODE,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn EtwSetMark(
      TraceHandle: TRACEHANDLE,
      MarkInfo: PETW_SET_MARK_INFORMATION,
      Size: ULONG,
   ) -> ULONG;
   pub fn EtwEventWriteFull(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      EventProperty: USHORT,
      ActivityId: LPCGUID,
      RelatedActivityId: LPCGUID,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventUnregister(RegHandle: REGHANDLE) -> ULONG;
   pub fn EtwEventSetInformation(
      RegHandle: REGHANDLE,
      InformationClass: EVENT_INFO_CLASS,
      EventInformation: PVOID,
      InformationLength: ULONG,
   ) -> ULONG;
   pub fn EtwRegisterSecurityProvider() -> ULONG;
   pub fn EtwEventProviderEnabled(
      RegHandle: REGHANDLE,
      Level: UCHAR,
      Keyword: ULONGLONG,
   ) -> BOOLEAN;
   pub fn EtwEventEnabled(RegHandle: REGHANDLE, EventDescriptor: PCEVENT_DESCRIPTOR) -> BOOLEAN;
   pub fn EtwEventWrite(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventWriteTransfer(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      ActivityId: LPCGUID,
      RelatedActivityId: LPCGUID,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventWriteString(
      RegHandle: REGHANDLE,
      Level: UCHAR,
      Keyword: ULONGLONG,
      String: PCWSTR,
   ) -> ULONG;
   pub fn EtwEventWriteEx(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      Filter: ULONG64,
      Flags: ULONG,
      ActivityId: LPCGUID,
      RelatedActivityId: LPCGUID,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventWriteStartScenario(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventWriteEndScenario(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwWriteUMSecurityEvent(
      EventDescriptor: PCEVENT_DESCRIPTOR,
      EventProperty: USHORT,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventWriteNoRegistration(
      ProviderId: LPCGUID,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventActivityIdControl(ControlCode: ULONG, ActivityId: LPGUID) -> ULONG;
   pub fn EtwNotificationRegister(
      Guid: LPCGUID,
      Type: ULONG,
      Callback: PETW_NOTIFICATION_CALLBACK,
      Context: PVOID,
      RegHandle: PREGHANDLE,
   ) -> ULONG;
   pub fn EtwNotificationUnregister(RegHandle: REGHANDLE, Context: *mut PVOID) -> ULONG;
   pub fn EtwSendNotification(
      DataBlock: PETW_NOTIFICATION_HEADER,
      ReceiveDataBlockSize: ULONG,
      ReceiveDataBlock: PVOID,
      ReplyReceived: PULONG,
      ReplySizeNeeded: PULONG,
   ) -> ULONG;
   pub fn EtwReplyNotification(Notification: PETW_NOTIFICATION_HEADER) -> ULONG;
   pub fn EtwEnumerateProcessRegGuids(
      OutBuffer: PVOID,
      OutBufferSize: ULONG,
      ReturnLength: PULONG,
   ) -> ULONG;
   pub fn EtwQueryRealtimeConsumer(
      TraceHandle: TRACEHANDLE,
      EventsLostCount: PULONG,
      BuffersLostCount: PULONG,
   ) -> ULONG;
   pub fn EtwCheckCoverage(CoveragePoint: PTELEMETRY_COVERAGE_POINT) -> BOOLEAN;
   pub fn ZwAcceptConnectPort(
      PortHandle: PHANDLE,
      PortContext: PVOID,
      ConnectionRequest: PPORT_MESSAGE,
      AcceptConnection: BOOLEAN,
      ServerView: PPORT_VIEW,
      ClientView: PREMOTE_PORT_VIEW,
   ) -> NTSTATUS;
   pub fn ZwAccessCheck(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      DesiredAccess: ACCESS_MASK,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckByType(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckByTypeAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckByTypeResultList(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckByTypeResultListAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckByTypeResultListAndAuditAlarmByHandle(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ClientToken: HANDLE,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAcquireCMFViewOwnership(
      TimeStamp: PULONGLONG,
      tokenTaken: PBOOLEAN,
      replaceExisting: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAddAtom(AtomName: PWSTR, Length: ULONG, Atom: PRTL_ATOM) -> NTSTATUS;
   pub fn ZwAddAtomEx(AtomName: PWSTR, Length: ULONG, Atom: PRTL_ATOM, Flags: ULONG) -> NTSTATUS;
   pub fn ZwAddBootEntry(BootEntry: PBOOT_ENTRY, Id: PULONG) -> NTSTATUS;
   pub fn ZwAddDriverEntry(DriverEntry: PEFI_DRIVER_ENTRY, Id: PULONG) -> NTSTATUS;
   pub fn ZwAdjustGroupsToken(
      TokenHandle: HANDLE,
      ResetToDefault: BOOLEAN,
      NewState: PTOKEN_GROUPS,
      BufferLength: ULONG,
      PreviousState: PTOKEN_GROUPS,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwAdjustPrivilegesToken(
      TokenHandle: HANDLE,
      DisableAllPrivileges: BOOLEAN,
      NewState: PTOKEN_PRIVILEGES,
      BufferLength: ULONG,
      PreviousState: PTOKEN_PRIVILEGES,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwAdjustTokenClaimsAndDeviceGroups(
      TokenHandle: HANDLE,
      UserResetToDefault: BOOLEAN,
      DeviceResetToDefault: BOOLEAN,
      DeviceGroupsResetToDefault: BOOLEAN,
      NewUserState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      NewDeviceState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      NewDeviceGroupsState: PTOKEN_GROUPS,
      UserBufferLength: ULONG,
      PreviousUserState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceBufferLength: ULONG,
      PreviousDeviceState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceGroupsBufferLength: ULONG,
      PreviousDeviceGroups: PTOKEN_GROUPS,
      UserReturnLength: PULONG,
      DeviceReturnLength: PULONG,
      DeviceGroupsReturnBufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwAlertResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   pub fn ZwAlertThread(ThreadHandle: HANDLE) -> NTSTATUS;
   pub fn ZwAlertThreadByThreadId(ThreadId: HANDLE) -> NTSTATUS;
   pub fn ZwAllocateLocallyUniqueId(Luid: PLUID) -> NTSTATUS;
   pub fn ZwAllocateReserveObject(
      MemoryReserveHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Type: MEMORY_RESERVE_TYPE,
   ) -> NTSTATUS;
   pub fn ZwAllocateUserPhysicalPages(
      ProcessHandle: HANDLE,
      NumberOfPages: PULONG_PTR,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwAllocateUserPhysicalPagesEx(
      ProcessHandle: HANDLE,
      NumberOfPages: PULONG_PTR,
      UserPfnArray: PULONG_PTR,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAllocateUuids(
      Time: PULARGE_INTEGER,
      Range: PULONG,
      Sequence: PULONG,
      Seed: PCHAR,
   ) -> NTSTATUS;
   pub fn ZwAllocateVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      RegionSize: PSIZE_T,
      AllocationType: ULONG,
      Protect: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAllocateVirtualMemoryEx(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      AllocationType: ULONG,
      PageProtection: ULONG,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAlpcAcceptConnectPort(
      PortHandle: PHANDLE,
      ConnectionPortHandle: HANDLE,
      Flags: ULONG,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      PortContext: PVOID,
      ConnectionRequest: PPORT_MESSAGE,
      ConnectionMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      AcceptConnection: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAlpcCancelMessage(
      PortHandle: HANDLE,
      Flags: ULONG,
      MessageContext: PALPC_CONTEXT_ATTR,
   ) -> NTSTATUS;
   pub fn ZwAlpcConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      Flags: ULONG,
      RequiredServerSid: PSID,
      ConnectionMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      OutMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      InMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwAlpcConnectPortEx(
      PortHandle: PHANDLE,
      ConnectionPortObjectAttributes: POBJECT_ATTRIBUTES,
      ClientPortObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      Flags: ULONG,
      ServerSecurityRequirements: PSECURITY_DESCRIPTOR,
      ConnectionMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      OutMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      InMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwAlpcCreatePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwAlpcCreatePortSection(
      PortHandle: HANDLE,
      Flags: ULONG,
      SectionHandle: HANDLE,
      SectionSize: SIZE_T,
      AlpcSectionHandle: PALPC_HANDLE,
      ActualSectionSize: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwAlpcCreateResourceReserve(
      PortHandle: HANDLE,
      Flags: ULONG,
      MessageSize: SIZE_T,
      ResourceId: PALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn ZwAlpcCreateSectionView(
      PortHandle: HANDLE,
      Flags: ULONG,
      ViewAttributes: PALPC_DATA_VIEW_ATTR,
   ) -> NTSTATUS;
   pub fn ZwAlpcCreateSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      SecurityAttribute: PALPC_SECURITY_ATTR,
   ) -> NTSTATUS;
   pub fn ZwAlpcDeletePortSection(
      PortHandle: HANDLE,
      Flags: ULONG,
      SectionHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn ZwAlpcDeleteResourceReserve(
      PortHandle: HANDLE,
      Flags: ULONG,
      ResourceId: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn ZwAlpcDeleteSectionView(PortHandle: HANDLE, Flags: ULONG, ViewBase: PVOID) -> NTSTATUS;
   pub fn ZwAlpcDeleteSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      ContextHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn ZwAlpcDisconnectPort(PortHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
   pub fn ZwAlpcImpersonateClientContainerOfPort(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAlpcImpersonateClientOfPort(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      Flags: PVOID,
   ) -> NTSTATUS;
   pub fn ZwAlpcOpenSenderProcess(
      ProcessHandle: PHANDLE,
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      Flags: ULONG,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwAlpcOpenSenderThread(
      ThreadHandle: PHANDLE,
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      Flags: ULONG,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwAlpcQueryInformation(
      PortHandle: HANDLE,
      PortInformationClass: ALPC_PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwAlpcQueryInformationMessage(
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      MessageInformationClass: ALPC_MESSAGE_INFORMATION_CLASS,
      MessageInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwAlpcRevokeSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      ContextHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn ZwAlpcSendWaitReceivePort(
      PortHandle: HANDLE,
      Flags: ULONG,
      SendMessageA: PPORT_MESSAGE,
      SendMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      ReceiveMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      ReceiveMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwAlpcSetInformation(
      PortHandle: HANDLE,
      PortInformationClass: ALPC_PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAreMappedFilesTheSame(
      File1MappedAsAnImage: PVOID,
      File2MappedAsFile: PVOID,
   ) -> NTSTATUS;
   pub fn ZwAssignProcessToJobObject(JobHandle: HANDLE, ProcessHandle: HANDLE) -> NTSTATUS;
   pub fn ZwAssociateWaitCompletionPacket(
      WaitCompletionPacketHandle: HANDLE,
      IoCompletionHandle: HANDLE,
      TargetObjectHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
      AlreadySignaled: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCallbackReturn(OutputBuffer: PVOID, OutputLength: ULONG, Status: NTSTATUS) -> NTSTATUS;
   pub fn ZwCallEnclave(
      Routine: PENCLAVE_ROUTINE,
      Reserved: PVOID,
      Flags: ULONG,
      RoutineParamReturn: *mut PVOID,
   ) -> NTSTATUS;
   pub fn ZwCancelIoFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
   pub fn ZwCancelIoFileEx(
      FileHandle: HANDLE,
      IoRequestToCancel: PIO_STATUS_BLOCK,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn ZwCancelSynchronousIoFile(
      ThreadHandle: HANDLE,
      IoRequestToCancel: PIO_STATUS_BLOCK,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn ZwCancelTimer(TimerHandle: HANDLE, CurrentState: PBOOLEAN) -> NTSTATUS;
   pub fn ZwCancelTimer2(TimerHandle: HANDLE, Parameters: PT2_CANCEL_PARAMETERS) -> NTSTATUS;
   pub fn ZwCancelWaitCompletionPacket(
      WaitCompletionPacketHandle: HANDLE,
      RemoveSignaledPacket: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwChangeProcessState(
      ProcessStateChangeHandle: HANDLE,
      ProcessHandle: HANDLE,
      StateChangeType: PROCESS_STATE_CHANGE_TYPE,
      ExtendedInformation: PVOID,
      ExtendedInformationLength: SIZE_T,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn ZwChangeThreadState(
      ThreadStateChangeHandle: HANDLE,
      ThreadHandle: HANDLE,
      StateChangeType: THREAD_STATE_CHANGE_TYPE,
      ExtendedInformation: PVOID,
      ExtendedInformationLength: SIZE_T,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn ZwClearEvent(EventHandle: HANDLE) -> NTSTATUS;
   pub fn ZwClose(Handle: HANDLE) -> NTSTATUS;
   pub fn ZwCloseObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      GenerateOnClose: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCommitComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwCommitEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwCommitTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
   pub fn ZwCompactKeys(Count: ULONG, KeyArray: *mut HANDLE) -> NTSTATUS;
   pub fn ZwCompareObjects(FirstObjectHandle: HANDLE, SecondObjectHandle: HANDLE) -> NTSTATUS;
   pub fn ZwCompareSigningLevels(
      FirstSigningLevel: SE_SIGNING_LEVEL,
      SecondSigningLevel: SE_SIGNING_LEVEL,
   ) -> NTSTATUS;
   pub fn ZwCompareTokens(
      FirstTokenHandle: HANDLE,
      SecondTokenHandle: HANDLE,
      Equal: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCompleteConnectPort(PortHandle: HANDLE) -> NTSTATUS;
   pub fn ZwCompressKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn ZwConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
      ClientView: PPORT_VIEW,
      ServerView: PREMOTE_PORT_VIEW,
      MaxMessageLength: PULONG,
      ConnectionInformation: PVOID,
      ConnectionInformationLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwContinue(ContextRecord: PCONTEXT, TestAlert: BOOLEAN) -> NTSTATUS;
   pub fn ZwContinueEx(ContextRecord: PCONTEXT, ContinueArgument: PVOID) -> NTSTATUS;
   pub fn ZwConvertBetweenAuxiliaryCounterAndPerformanceCounter(
      ConvertAuxiliaryToPerformanceCounter: BOOLEAN,
      PerformanceOrAuxiliaryCounterValue: PLARGE_INTEGER,
      ConvertedValue: PLARGE_INTEGER,
      ConversionError: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwCopyFileChunk(
      SourceHandle: HANDLE,
      DestinationHandle: HANDLE,
      EventHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Length: ULONG,
      SourceOffset: PLARGE_INTEGER,
      DestOffset: PLARGE_INTEGER,
      SourceKey: PULONG,
      DestKey: PULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateDebugObject(
      DebugObjectHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateDirectoryObject(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwCreateDirectoryObjectEx(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ShadowDirectoryHandle: HANDLE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      Size: SIZE_T,
      InitialCommitment: SIZE_T,
      EnclaveType: ULONG,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateEnlistment(
      EnlistmentHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ResourceManagerHandle: HANDLE,
      TransactionHandle: HANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CreateOptions: ULONG,
      NotificationMask: NOTIFICATION_MASK,
      EnlistmentKey: PVOID,
   ) -> NTSTATUS;
   pub fn ZwCreateEvent(
      EventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      EventType: EVENT_TYPE,
      InitialState: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCreateEventPair(
      EventPairHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwCreateFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      AllocationSize: PLARGE_INTEGER,
      FileAttributes: ULONG,
      ShareAccess: ULONG,
      CreateDisposition: ULONG,
      CreateOptions: ULONG,
      EaBuffer: PVOID,
      EaLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateIoCompletion(
      IoCompletionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Count: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateIoRing(
      IoRingHandle: PHANDLE,
      CreateParametersLength: ULONG,
      CreateParameters: PVOID,
      OutputParametersLength: ULONG,
      OutputParameters: PVOID,
   ) -> NTSTATUS;
   pub fn ZwCreateIRTimer(TimerHandle: PHANDLE, DesiredAccess: ACCESS_MASK) -> NTSTATUS;
   pub fn ZwCreateJobObject(
      JobHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwCreateJobSet(NumJob: ULONG, UserJobSet: PJOB_SET_ARRAY, Flags: ULONG) -> NTSTATUS;
   pub fn ZwCreateKey(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TitleIndex: ULONG,
      Class: PUNICODE_STRING,
      CreateOptions: ULONG,
      Disposition: PULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateKeyedEvent(
      KeyedEventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateKeyTransacted(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TitleIndex: ULONG,
      Class: PUNICODE_STRING,
      CreateOptions: ULONG,
      TransactionHandle: HANDLE,
      Disposition: PULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateLowBoxToken(
      TokenHandle: PHANDLE,
      ExistingTokenHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PackageSid: PSID,
      CapabilityCount: ULONG,
      Capabilities: PSID_AND_ATTRIBUTES,
      HandleCount: ULONG,
      Handles: *mut HANDLE,
   ) -> NTSTATUS;
   pub fn ZwCreateMailslotFile(
      FileHandle: PHANDLE,
      DesiredAccess: ULONG,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CreateOptions: ULONG,
      MailslotQuota: ULONG,
      MaximumMessageSize: ULONG,
      ReadTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwCreateMutant(
      MutantHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      InitialOwner: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCreateNamedPipeFile(
      FileHandle: PHANDLE,
      DesiredAccess: ULONG,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ShareAccess: ULONG,
      CreateDisposition: ULONG,
      CreateOptions: ULONG,
      NamedPipeType: ULONG,
      ReadMode: ULONG,
      CompletionMode: ULONG,
      MaximumInstances: ULONG,
      InboundQuota: ULONG,
      OutboundQuota: ULONG,
      DefaultTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwCreatePagingFile(
      PageFileName: PUNICODE_STRING,
      MinimumSize: PLARGE_INTEGER,
      MaximumSize: PLARGE_INTEGER,
      Priority: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreatePartition(
      ParentPartitionHandle: HANDLE,
      PartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PreferredNode: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreatePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaxConnectionInfoLength: ULONG,
      MaxMessageLength: ULONG,
      MaxPoolUsage: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreatePrivateNamespace(
      NamespaceHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      BoundaryDescriptor: POBJECT_BOUNDARY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn ZwCreateProcess(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ParentProcess: HANDLE,
      InheritObjectTable: BOOLEAN,
      SectionHandle: HANDLE,
      DebugPort: HANDLE,
      TokenHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwCreateProcessEx(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ParentProcess: HANDLE,
      Flags: ULONG,
      SectionHandle: HANDLE,
      DebugPort: HANDLE,
      TokenHandle: HANDLE,
      Reserved: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateProcessStateChange(
      ProcessStateChangeHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn ZwCreateProfile(
      ProfileHandle: PHANDLE,
      Process: HANDLE,
      ProfileBase: PVOID,
      ProfileSize: SIZE_T,
      BucketSize: ULONG,
      Buffer: PULONG,
      BufferSize: ULONG,
      ProfileSource: KPROFILE_SOURCE,
      Affinity: KAFFINITY,
   ) -> NTSTATUS;
   pub fn ZwCreateProfileEx(
      ProfileHandle: PHANDLE,
      Process: HANDLE,
      ProfileBase: PVOID,
      ProfileSize: SIZE_T,
      BucketSize: ULONG,
      Buffer: PULONG,
      BufferSize: ULONG,
      ProfileSource: KPROFILE_SOURCE,
      GroupCount: USHORT,
      GroupAffinity: PGROUP_AFFINITY,
   ) -> NTSTATUS;
   pub fn ZwCreateResourceManager(
      ResourceManagerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      TmHandle: HANDLE,
      RmGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CreateOptions: ULONG,
      Description: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn ZwCreateSection(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaximumSize: PLARGE_INTEGER,
      SectionPageProtection: ULONG,
      AllocationAttributes: ULONG,
      FileHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwCreateSectionEx(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaximumSize: PLARGE_INTEGER,
      SectionPageProtection: ULONG,
      AllocationAttributes: ULONG,
      FileHandle: HANDLE,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateSemaphore(
      SemaphoreHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      InitialCount: LONG,
      MaximumCount: LONG,
   ) -> NTSTATUS;
   pub fn ZwCreateSymbolicLinkObject(
      LinkHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LinkTarget: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn ZwCreateThread(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      ClientId: PCLIENT_ID,
      ThreadContext: PCONTEXT,
      InitialTeb: PINITIAL_TEB,
      CreateSuspended: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCreateThreadEx(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      StartRoutine: PUSER_THREAD_START_ROUTINE,
      Argument: PVOID,
      CreateFlags: ULONG,
      ZeroBits: SIZE_T,
      StackSize: SIZE_T,
      MaximumStackSize: SIZE_T,
      AttributeList: PPS_ATTRIBUTE_LIST,
   ) -> NTSTATUS;
   pub fn ZwCreateThreadStateChange(
      ThreadStateChangeHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ThreadHandle: HANDLE,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn ZwCreateTimer(
      TimerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TimerType: TIMER_TYPE,
   ) -> NTSTATUS;
   pub fn ZwCreateTimer2(
      TimerHandle: PHANDLE,
      Reserved1: PVOID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Attributes: ULONG,
      DesiredAccess: ACCESS_MASK,
   ) -> NTSTATUS;
   pub fn ZwCreateToken(
      TokenHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Type: TOKEN_TYPE,
      AuthenticationId: PLUID,
      ExpirationTime: PLARGE_INTEGER,
      User: PTOKEN_USER,
      Groups: PTOKEN_GROUPS,
      Privileges: PTOKEN_PRIVILEGES,
      Owner: PTOKEN_OWNER,
      PrimaryGroup: PTOKEN_PRIMARY_GROUP,
      DefaultDacl: PTOKEN_DEFAULT_DACL,
      Source: PTOKEN_SOURCE,
   ) -> NTSTATUS;
   pub fn ZwCreateTokenEx(
      TokenHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Type: TOKEN_TYPE,
      AuthenticationId: PLUID,
      ExpirationTime: PLARGE_INTEGER,
      User: PTOKEN_USER,
      Groups: PTOKEN_GROUPS,
      Privileges: PTOKEN_PRIVILEGES,
      UserAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceGroups: PTOKEN_GROUPS,
      MandatoryPolicy: PTOKEN_MANDATORY_POLICY,
      Owner: PTOKEN_OWNER,
      PrimaryGroup: PTOKEN_PRIMARY_GROUP,
      DefaultDacl: PTOKEN_DEFAULT_DACL,
      Source: PTOKEN_SOURCE,
   ) -> NTSTATUS;
   pub fn ZwCreateTransaction(
      TransactionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Uow: LPGUID,
      TmHandle: HANDLE,
      CreateOptions: ULONG,
      IsolationLevel: ULONG,
      IsolationFlags: ULONG,
      Timeout: PLARGE_INTEGER,
      Description: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn ZwCreateTransactionManager(
      TmHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LogFileName: PUNICODE_STRING,
      CreateOptions: ULONG,
      CommitStrength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateUserProcess(
      ProcessHandle: PHANDLE,
      ThreadHandle: PHANDLE,
      ProcessDesiredAccess: ACCESS_MASK,
      ThreadDesiredAccess: ACCESS_MASK,
      ProcessObjectAttributes: POBJECT_ATTRIBUTES,
      ThreadObjectAttributes: POBJECT_ATTRIBUTES,
      ProcessFlags: ULONG,
      ThreadFlags: ULONG,
      ProcessParameters: PVOID,
      CreateInfo: PPS_CREATE_INFO,
      AttributeList: PPS_ATTRIBUTE_LIST,
   ) -> NTSTATUS;
   pub fn ZwCreateWaitablePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaxConnectionInfoLength: ULONG,
      MaxMessageLength: ULONG,
      MaxPoolUsage: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateWaitCompletionPacket(
      WaitCompletionPacketHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwCreateWnfStateName(
      StateName: PWNF_STATE_NAME,
      NameLifetime: WNF_STATE_NAME_LIFETIME,
      DataScope: WNF_DATA_SCOPE,
      PersistData: BOOLEAN,
      TypeId: PCWNF_TYPE_ID,
      MaximumStateSize: ULONG,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn ZwCreateWorkerFactory(
      WorkerFactoryHandleReturn: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CompletionPortHandle: HANDLE,
      WorkerProcessHandle: HANDLE,
      StartRoutine: PVOID,
      StartParameter: PVOID,
      MaxThreadCount: ULONG,
      StackReserve: SIZE_T,
      StackCommit: SIZE_T,
   ) -> NTSTATUS;
   pub fn ZwDebugActiveProcess(ProcessHandle: HANDLE, DebugObjectHandle: HANDLE) -> NTSTATUS;
   pub fn ZwDebugContinue(
      DebugObjectHandle: HANDLE,
      ClientId: PCLIENT_ID,
      ContinueStatus: NTSTATUS,
   ) -> NTSTATUS;
   pub fn ZwDelayExecution(Alertable: BOOLEAN, DelayInterval: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwDeleteAtom(Atom: RTL_ATOM) -> NTSTATUS;
   pub fn ZwDeleteBootEntry(Id: ULONG) -> NTSTATUS;
   pub fn ZwDeleteDriverEntry(Id: ULONG) -> NTSTATUS;
   pub fn ZwDeleteFile(ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
   pub fn ZwDeleteKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn ZwDeleteObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      GenerateOnClose: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwDeletePrivateNamespace(NamespaceHandle: HANDLE) -> NTSTATUS;
   pub fn ZwDeleteValueKey(KeyHandle: HANDLE, ValueName: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwDeleteWnfStateData(
      StateName: PCWNF_STATE_NAME,
      ExplicitScope: *const cty::c_void,
   ) -> NTSTATUS;
   pub fn ZwDeleteWnfStateName(StateName: PCWNF_STATE_NAME) -> NTSTATUS;
   pub fn ZwDeviceIoControlFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      IoControlCode: ULONG,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwDisableLastKnownGood() -> NTSTATUS;
   pub fn ZwDisplayString(String: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwDrawText(Text: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwDuplicateObject(
      SourceProcessHandle: HANDLE,
      SourceHandle: HANDLE,
      TargetProcessHandle: HANDLE,
      TargetHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Options: ULONG,
   ) -> NTSTATUS;
   pub fn ZwDuplicateToken(
      ExistingTokenHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      EffectiveOnly: BOOLEAN,
      Type: TOKEN_TYPE,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwEnableLastKnownGood() -> NTSTATUS;
   pub fn ZwEnumerateBootEntries(Buffer: PVOID, BufferLength: PULONG) -> NTSTATUS;
   pub fn ZwEnumerateDriverEntries(Buffer: PVOID, BufferLength: PULONG) -> NTSTATUS;
   pub fn ZwEnumerateKey(
      KeyHandle: HANDLE,
      Index: ULONG,
      KeyInformationClass: KEY_INFORMATION_CLASS,
      KeyInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwEnumerateSystemEnvironmentValuesEx(
      InformationClass: ULONG,
      Buffer: PVOID,
      BufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwEnumerateTransactionObject(
      RootObjectHandle: HANDLE,
      QueryType: KTMOBJECT_TYPE,
      ObjectCursor: PKTMOBJECT_CURSOR,
      ObjectCursorLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwEnumerateValueKey(
      KeyHandle: HANDLE,
      Index: ULONG,
      KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
      KeyValueInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwExtendSection(SectionHandle: HANDLE, NewSectionSize: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwFilterBootOption(
      FilterOperation: FILTER_BOOT_OPTION_OPERATION,
      ObjectType: ULONG,
      ElementType: ULONG,
      Data: PVOID,
      DataSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwFilterToken(
      ExistingTokenHandle: HANDLE,
      Flags: ULONG,
      SidsToDisable: PTOKEN_GROUPS,
      PrivilegesToDelete: PTOKEN_PRIVILEGES,
      RestrictedSids: PTOKEN_GROUPS,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwFilterTokenEx(
      ExistingTokenHandle: HANDLE,
      Flags: ULONG,
      SidsToDisable: PTOKEN_GROUPS,
      PrivilegesToDelete: PTOKEN_PRIVILEGES,
      RestrictedSids: PTOKEN_GROUPS,
      DisableUserClaimsCount: ULONG,
      UserClaimsToDisable: PUNICODE_STRING,
      DisableDeviceClaimsCount: ULONG,
      DeviceClaimsToDisable: PUNICODE_STRING,
      DeviceGroupsToDisable: PTOKEN_GROUPS,
      RestrictedUserAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      RestrictedDeviceAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      RestrictedDeviceGroups: PTOKEN_GROUPS,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwFindAtom(AtomName: PWSTR, Length: ULONG, Atom: PRTL_ATOM) -> NTSTATUS;
   pub fn ZwFlushBuffersFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
   pub fn ZwFlushBuffersFileEx(
      FileHandle: HANDLE,
      Flags: ULONG,
      Parameters: PVOID,
      ParametersSize: ULONG,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn ZwFlushInstallUILanguage(InstallUILanguage: LANGID, SetComittedFlag: ULONG) -> NTSTATUS;
   pub fn ZwFlushInstructionCache(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Length: SIZE_T,
   ) -> NTSTATUS;
   pub fn ZwFlushKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn ZwFlushProcessWriteBuffers() -> NTSTATUS;
   pub fn ZwFlushVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      IoStatus: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn ZwFlushWriteBuffer() -> NTSTATUS;
   pub fn ZwFreeUserPhysicalPages(
      ProcessHandle: HANDLE,
      NumberOfPages: PULONG_PTR,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwFreeVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      FreeType: ULONG,
   ) -> NTSTATUS;
   pub fn ZwFreezeRegistry(TimeOutInSeconds: ULONG) -> NTSTATUS;
   pub fn ZwFreezeTransactions(
      FreezeTimeout: PLARGE_INTEGER,
      ThawTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwFsControlFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsControlCode: ULONG,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwGetCachedSigningLevel(
      File: HANDLE,
      Flags: PULONG,
      SigningLevel: PSE_SIGNING_LEVEL,
      Thumbprint: PUCHAR,
      ThumbprintSize: PULONG,
      ThumbprintAlgorithm: PULONG,
   ) -> NTSTATUS;
   pub fn ZwGetCompleteWnfStateSubscription(
      OldDescriptorStateName: PWNF_STATE_NAME,
      OldSubscriptionId: *mut ULONG64,
      OldDescriptorEventMask: ULONG,
      OldDescriptorStatus: ULONG,
      NewDeliveryDescriptor: PWNF_DELIVERY_DESCRIPTOR,
      DescriptorSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwGetContextThread(ThreadHandle: HANDLE, ThreadContext: PCONTEXT) -> NTSTATUS;
   pub fn ZwGetCurrentProcessorNumber() -> ULONG;
   pub fn ZwGetCurrentProcessorNumberEx(ProcessorNumber: PPROCESSOR_NUMBER) -> ULONG;
   pub fn ZwGetDevicePowerState(Device: HANDLE, State: PDEVICE_POWER_STATE) -> NTSTATUS;
   pub fn ZwGetMUIRegistryInfo(Flags: ULONG, DataSize: PULONG, Data: PVOID) -> NTSTATUS;
   pub fn ZwGetNextProcess(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Flags: ULONG,
      NewProcessHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwGetNextThread(
      ProcessHandle: HANDLE,
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Flags: ULONG,
      NewThreadHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwGetNlsSectionPtr(
      SectionType: ULONG,
      SectionData: ULONG,
      ContextData: PVOID,
      SectionPointer: *mut PVOID,
      SectionSize: PULONG,
   ) -> NTSTATUS;
   pub fn ZwGetNotificationResourceManager(
      ResourceManagerHandle: HANDLE,
      TransactionNotification: PTRANSACTION_NOTIFICATION,
      NotificationLength: ULONG,
      Timeout: PLARGE_INTEGER,
      ReturnLength: PULONG,
      Asynchronous: ULONG,
      AsynchronousContext: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwGetPlugPlayEvent(
      EventHandle: HANDLE,
      Context: PVOID,
      EventBlock: PPLUGPLAY_EVENT_BLOCK,
      EventBufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwGetWriteWatch(
      ProcessHandle: HANDLE,
      Flags: ULONG,
      BaseAddress: PVOID,
      RegionSize: SIZE_T,
      UserAddressArray: *mut PVOID,
      EntriesInUserAddressArray: PULONG_PTR,
      Granularity: PULONG,
   ) -> NTSTATUS;
   pub fn ZwImpersonateAnonymousToken(ThreadHandle: HANDLE) -> NTSTATUS;
   pub fn ZwImpersonateClientOfPort(PortHandle: HANDLE, Message: PPORT_MESSAGE) -> NTSTATUS;
   pub fn ZwImpersonateThread(
      ServerThreadHandle: HANDLE,
      ClientThreadHandle: HANDLE,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
   ) -> NTSTATUS;
   pub fn ZwInitializeEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn ZwInitializeNlsFiles(
      BaseAddress: *mut PVOID,
      DefaultLocaleId: PLCID,
      DefaultCasingTableSize: PLARGE_INTEGER,
      CurrentNLSVersion: PULONG,
   ) -> NTSTATUS;
   pub fn ZwInitializeRegistry(BootCondition: USHORT) -> NTSTATUS;
   pub fn ZwInitiatePowerAction(
      SystemAction: POWER_ACTION,
      LightestSystemState: SYSTEM_POWER_STATE,
      Flags: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwIsProcessInJob(ProcessHandle: HANDLE, JobHandle: HANDLE) -> NTSTATUS;
   pub fn ZwIsSystemResumeAutomatic() -> BOOLEAN;
   pub fn ZwIsUILanguageComitted() -> NTSTATUS;
   pub fn ZwListenPort(PortHandle: HANDLE, ConnectionRequest: PPORT_MESSAGE) -> NTSTATUS;
   pub fn ZwLoadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwLoadEnclaveData(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      Protect: ULONG,
      PageInformation: PVOID,
      PageInformationLength: ULONG,
      NumberOfBytesWritten: PSIZE_T,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn ZwLoadKey(TargetKey: POBJECT_ATTRIBUTES, SourceFile: POBJECT_ATTRIBUTES) -> NTSTATUS;
   pub fn ZwLoadKey2(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwLoadKey3(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
      ExtendedParameters: PCM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
      DesiredAccess: ACCESS_MASK,
      RootHandle: PHANDLE,
      Reserved: PVOID,
   ) -> NTSTATUS;
   pub fn ZwLoadKeyEx(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
      TrustClassKey: HANDLE,
      Event: HANDLE,
      DesiredAccess: ACCESS_MASK,
      RootHandle: PHANDLE,
      Reserved: PVOID,
   ) -> NTSTATUS;
   pub fn ZwLockFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ByteOffset: PLARGE_INTEGER,
      Length: PLARGE_INTEGER,
      Key: ULONG,
      FailImmediately: BOOLEAN,
      ExclusiveLock: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwLockProductActivationKeys(pPrivateVer: *mut ULONG, pSafeMode: *mut ULONG) -> NTSTATUS;
   pub fn ZwLockRegistryKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn ZwLockVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      MapType: ULONG,
   ) -> NTSTATUS;
   pub fn ZwMakePermanentObject(Handle: HANDLE) -> NTSTATUS;
   pub fn ZwMakeTemporaryObject(Handle: HANDLE) -> NTSTATUS;
   pub fn ZwManagePartition(
      TargetHandle: HANDLE,
      SourceHandle: HANDLE,
      PartitionInformationClass: PARTITION_INFORMATION_CLASS,
      PartitionInformation: PVOID,
      PartitionInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwMapCMFModule(
      What: ULONG,
      Index: ULONG,
      CacheIndexOut: PULONG,
      CacheFlagsOut: PULONG,
      ViewSizeOut: PULONG,
      BaseAddress: *mut PVOID,
   ) -> NTSTATUS;
   pub fn ZwMapUserPhysicalPages(
      VirtualAddress: PVOID,
      NumberOfPages: ULONG_PTR,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwMapUserPhysicalPagesScatter(
      VirtualAddresses: *mut PVOID,
      NumberOfPages: ULONG_PTR,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwMapViewOfSection(
      SectionHandle: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      CommitSize: SIZE_T,
      SectionOffset: PLARGE_INTEGER,
      ViewSize: PSIZE_T,
      InheritDisposition: SECTION_INHERIT,
      AllocationType: ULONG,
      Win32Protect: ULONG,
   ) -> NTSTATUS;
   pub fn ZwMapViewOfSectionEx(
      SectionHandle: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      SectionOffset: PLARGE_INTEGER,
      ViewSize: PSIZE_T,
      AllocationType: ULONG,
      Win32Protect: ULONG,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn ZwModifyBootEntry(BootEntry: PBOOT_ENTRY) -> NTSTATUS;
   pub fn ZwModifyDriverEntry(DriverEntry: PEFI_DRIVER_ENTRY) -> NTSTATUS;
   pub fn ZwNotifyChangeDirectoryFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwNotifyChangeDirectoryFileEx(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn ZwNotifyChangeKey(
      KeyHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      Buffer: PVOID,
      BufferSize: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwNotifyChangeMultipleKeys(
      MasterKeyHandle: HANDLE,
      Count: ULONG,
      SubordinateObjects: *mut OBJECT_ATTRIBUTES,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      Buffer: PVOID,
      BufferSize: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwNotifyChangeSession(
      SessionHandle: HANDLE,
      ChangeSequenceNumber: ULONG,
      ChangeTimeStamp: PLARGE_INTEGER,
      Event: IO_SESSION_EVENT,
      NewState: IO_SESSION_STATE,
      PreviousState: IO_SESSION_STATE,
      Payload: PVOID,
      PayloadSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwOpenDirectoryObject(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenEnlistment(
      EnlistmentHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ResourceManagerHandle: HANDLE,
      EnlistmentGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenEvent(
      EventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenEventPair(
      EventPairHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ShareAccess: ULONG,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn ZwOpenIoCompletion(
      IoCompletionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenJobObject(
      JobHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenKey(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenKeyedEvent(
      KeyedEventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenKeyEx(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn ZwOpenKeyTransacted(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TransactionHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenKeyTransactedEx(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      OpenOptions: ULONG,
      TransactionHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenMutant(
      MutantHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      GrantedAccess: ACCESS_MASK,
      Privileges: PPRIVILEGE_SET,
      ObjectCreation: BOOLEAN,
      AccessGranted: BOOLEAN,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwOpenPartition(
      PartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenPrivateNamespace(
      NamespaceHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      BoundaryDescriptor: POBJECT_BOUNDARY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn ZwOpenProcess(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ClientId: PCLIENT_ID,
   ) -> NTSTATUS;
   pub fn ZwOpenProcessToken(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenProcessTokenEx(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenResourceManager(
      ResourceManagerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      TmHandle: HANDLE,
      ResourceManagerGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenSection(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenSemaphore(
      SemaphoreHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenSession(
      SessionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenSymbolicLinkObject(
      LinkHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenThread(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ClientId: PCLIENT_ID,
   ) -> NTSTATUS;
   pub fn ZwOpenThreadToken(
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      OpenAsSelf: BOOLEAN,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenThreadTokenEx(
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      OpenAsSelf: BOOLEAN,
      HandleAttributes: ULONG,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenTimer(
      TimerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenTransaction(
      TransactionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Uow: LPGUID,
      TmHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenTransactionManager(
      TmHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LogFileName: PUNICODE_STRING,
      TmIdentity: LPGUID,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn ZwPlugPlayControl(
      PnPControlClass: PLUGPLAY_CONTROL_CLASS,
      PnPControlData: PVOID,
      PnPControlDataLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwPowerInformation(
      InformationLevel: POWER_INFORMATION_LEVEL,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwPrepareComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwPrepareEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
      -> NTSTATUS;
   pub fn ZwPrePrepareComplete(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwPrePrepareEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwPrivilegeCheck(
      ClientToken: HANDLE,
      RequiredPrivileges: PPRIVILEGE_SET,
      Result: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwPrivilegedServiceAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      ServiceName: PUNICODE_STRING,
      ClientToken: HANDLE,
      Privileges: PPRIVILEGE_SET,
      AccessGranted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwPrivilegeObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      Privileges: PPRIVILEGE_SET,
      AccessGranted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwPropagationComplete(
      ResourceManagerHandle: HANDLE,
      RequestCookie: ULONG,
      BufferLength: ULONG,
      Buffer: PVOID,
   ) -> NTSTATUS;
   pub fn ZwPropagationFailed(
      ResourceManagerHandle: HANDLE,
      RequestCookie: ULONG,
      PropStatus: NTSTATUS,
   ) -> NTSTATUS;
   pub fn ZwProtectVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      NewProtect: ULONG,
      OldProtect: PULONG,
   ) -> NTSTATUS;
   pub fn ZwPssCaptureVaSpaceBulk(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      BulkInformation: PNTPSS_MEMORY_BULK_INFORMATION,
      BulkInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwPulseEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   pub fn ZwQueryAttributesFile(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      FileInformation: PFILE_BASIC_INFORMATION,
   ) -> NTSTATUS;
   pub fn ZwQueryAuxiliaryCounterFrequency(AuxiliaryCounterFrequency: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwQueryBootEntryOrder(Ids: PULONG, Count: PULONG) -> NTSTATUS;
   pub fn ZwQueryBootOptions(BootOptions: PBOOT_OPTIONS, BootOptionsLength: PULONG) -> NTSTATUS;
   pub fn ZwQueryDebugFilterState(ComponentId: ULONG, Level: ULONG) -> NTSTATUS;
   pub fn ZwQueryDefaultLocale(UserProfile: BOOLEAN, DefaultLocaleId: PLCID) -> NTSTATUS;
   pub fn ZwQueryDefaultUILanguage(DefaultUILanguageId: *mut LANGID) -> NTSTATUS;
   pub fn ZwQueryDirectoryFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
      ReturnSingleEntry: BOOLEAN,
      FileName: PUNICODE_STRING,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwQueryDirectoryFileEx(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
      QueryFlags: ULONG,
      FileName: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn ZwQueryDirectoryObject(
      DirectoryHandle: HANDLE,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      RestartScan: BOOLEAN,
      Context: PULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryDriverEntryOrder(Ids: PULONG, Count: PULONG) -> NTSTATUS;
   pub fn ZwQueryEaFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      EaList: PVOID,
      EaListLength: ULONG,
      EaIndex: PULONG,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwQueryEvent(
      EventHandle: HANDLE,
      EventInformationClass: EVENT_INFORMATION_CLASS,
      EventInformation: PVOID,
      EventInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryFullAttributesFile(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      FileInformation: PFILE_NETWORK_OPEN_INFORMATION,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationAtom(
      Atom: RTL_ATOM,
      AtomInformationClass: ATOM_INFORMATION_CLASS,
      AtomInformation: PVOID,
      AtomInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationByName(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationEnlistment(
      EnlistmentHandle: HANDLE,
      EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
      EnlistmentInformation: PVOID,
      EnlistmentInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationJobObject(
      JobHandle: HANDLE,
      JobObjectInformationClass: JOBOBJECTINFOCLASS,
      JobObjectInformation: PVOID,
      JobObjectInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationPort(
      PortHandle: HANDLE,
      PortInformationClass: PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationProcess(
      ProcessHandle: HANDLE,
      ProcessInformationClass: PROCESSINFOCLASS,
      ProcessInformation: PVOID,
      ProcessInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationResourceManager(
      ResourceManagerHandle: HANDLE,
      ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
      ResourceManagerInformation: PVOID,
      ResourceManagerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationThread(
      ThreadHandle: HANDLE,
      ThreadInformationClass: THREADINFOCLASS,
      ThreadInformation: PVOID,
      ThreadInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationToken(
      TokenHandle: HANDLE,
      TokenInformationClass: TOKEN_INFORMATION_CLASS,
      TokenInformation: PVOID,
      TokenInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationTransaction(
      TransactionHandle: HANDLE,
      TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
      TransactionInformation: PVOID,
      TransactionInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationTransactionManager(
      TransactionManagerHandle: HANDLE,
      TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
      TransactionManagerInformation: PVOID,
      TransactionManagerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
      WorkerFactoryInformation: PVOID,
      WorkerFactoryInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInstallUILanguage(InstallUILanguageId: *mut LANGID) -> NTSTATUS;
   pub fn ZwQueryIntervalProfile(ProfileSource: KPROFILE_SOURCE, Interval: PULONG) -> NTSTATUS;
   pub fn ZwQueryIoCompletion(
      IoCompletionHandle: HANDLE,
      IoCompletionInformationClass: IO_COMPLETION_INFORMATION_CLASS,
      IoCompletionInformation: PVOID,
      IoCompletionInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryIoRingCapabilities(
      IoRingCapabilitiesLength: SIZE_T,
      IoRingCapabilities: PVOID,
   ) -> NTSTATUS;
   pub fn ZwQueryKey(
      KeyHandle: HANDLE,
      KeyInformationClass: KEY_INFORMATION_CLASS,
      KeyInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryLicenseValue(
      ValueName: PUNICODE_STRING,
      Type: PULONG,
      Data: PVOID,
      DataSize: ULONG,
      ResultDataSize: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryMultipleValueKey(
      KeyHandle: HANDLE,
      ValueEntries: PKEY_VALUE_ENTRY,
      EntryCount: ULONG,
      ValueBuffer: PVOID,
      BufferLength: PULONG,
      RequiredBufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryMutant(
      MutantHandle: HANDLE,
      MutantInformationClass: MUTANT_INFORMATION_CLASS,
      MutantInformation: PVOID,
      MutantInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryObject(
      Handle: HANDLE,
      ObjectInformationClass: OBJECT_INFORMATION_CLASS,
      ObjectInformation: PVOID,
      ObjectInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryOpenSubKeys(TargetKey: POBJECT_ATTRIBUTES, HandleCount: PULONG) -> NTSTATUS;
   pub fn ZwQueryOpenSubKeysEx(
      TargetKey: POBJECT_ATTRIBUTES,
      BufferLength: ULONG,
      Buffer: PVOID,
      RequiredSize: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryPerformanceCounter(
      PerformanceCounter: PLARGE_INTEGER,
      PerformanceFrequency: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwQueryPortInformationProcess() -> NTSTATUS;
   pub fn ZwQueryQuotaInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      SidList: PVOID,
      SidListLength: ULONG,
      StartSid: PSID,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwQuerySection(
      SectionHandle: HANDLE,
      SectionInformationClass: SECTION_INFORMATION_CLASS,
      SectionInformation: PVOID,
      SectionInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwQuerySecurityAttributesToken(
      TokenHandle: HANDLE,
      Attributes: PUNICODE_STRING,
      NumberOfAttributes: ULONG,
      Buffer: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySecurityObject(
      Handle: HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Length: ULONG,
      LengthNeeded: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySemaphore(
      SemaphoreHandle: HANDLE,
      SemaphoreInformationClass: SEMAPHORE_INFORMATION_CLASS,
      SemaphoreInformation: PVOID,
      SemaphoreInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySymbolicLinkObject(
      LinkHandle: HANDLE,
      LinkTarget: PUNICODE_STRING,
      ReturnedLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySystemEnvironmentValue(
      VariableName: PUNICODE_STRING,
      VariableValue: PWSTR,
      ValueLength: USHORT,
      ReturnLength: PUSHORT,
   ) -> NTSTATUS;
   pub fn ZwQuerySystemEnvironmentValueEx(
      VariableName: PUNICODE_STRING,
      VendorGuid: PCGUID,
      Value: PVOID,
      ValueLength: PULONG,
      Attributes: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySystemInformation(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySystemInformationEx(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySystemTime(SystemTime: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwQueryTimer(
      TimerHandle: HANDLE,
      TimerInformationClass: TIMER_INFORMATION_CLASS,
      TimerInformation: PVOID,
      TimerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryTimerResolution(
      MaximumTime: PULONG,
      MinimumTime: PULONG,
      CurrentTime: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryValueKey(
      KeyHandle: HANDLE,
      ValueName: PUNICODE_STRING,
      KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
      KeyValueInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      MemoryInformationClass: MEMORY_INFORMATION_CLASS,
      MemoryInformation: PVOID,
      MemoryInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwQueryVolumeInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsInformation: PVOID,
      Length: ULONG,
      FsInformationClass: FSINFOCLASS,
   ) -> NTSTATUS;
   pub fn ZwQueryWnfStateData(
      StateName: PCWNF_STATE_NAME,
      TypeId: PCWNF_TYPE_ID,
      ExplicitScope: *const cty::c_void,
      ChangeStamp: PWNF_CHANGE_STAMP,
      Buffer: PVOID,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryWnfStateNameInformation(
      StateName: PCWNF_STATE_NAME,
      NameInfoClass: WNF_STATE_NAME_INFORMATION,
      ExplicitScope: *const cty::c_void,
      InfoBuffer: PVOID,
      InfoBufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwQueueApcThread(
      ThreadHandle: HANDLE,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn ZwQueueApcThreadEx(
      ThreadHandle: HANDLE,
      ReserveHandle: HANDLE,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn ZwQueueApcThreadEx2(
      ThreadHandle: HANDLE,
      ReserveHandle: HANDLE,
      ApcFlags: ULONG,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn ZwRaiseException(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
      FirstChance: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwRaiseHardError(
      ErrorStatus: NTSTATUS,
      NumberOfParameters: ULONG,
      UnicodeStringParameterMask: ULONG,
      Parameters: PULONG_PTR,
      ValidResponseOptions: ULONG,
      Response: PULONG,
   ) -> NTSTATUS;
   pub fn ZwReadFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn ZwReadFileScatter(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      SegmentArray: PFILE_SEGMENT_ELEMENT,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn ZwReadOnlyEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwReadRequestData(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      DataEntryIndex: ULONG,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwReadVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwReadVirtualMemoryEx(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwRecoverEnlistment(EnlistmentHandle: HANDLE, EnlistmentKey: PVOID) -> NTSTATUS;
   pub fn ZwRecoverResourceManager(ResourceManagerHandle: HANDLE) -> NTSTATUS;
   pub fn ZwRecoverTransactionManager(TransactionManagerHandle: HANDLE) -> NTSTATUS;
   pub fn ZwRegisterProtocolAddressInformation(
      ResourceManager: HANDLE,
      ProtocolId: PCRM_PROTOCOL_ID,
      ProtocolInformationSize: ULONG,
      ProtocolInformation: PVOID,
      CreateOptions: ULONG,
   ) -> NTSTATUS;
   pub fn ZwRegisterThreadTerminatePort(PortHandle: HANDLE) -> NTSTATUS;
   pub fn ZwReleaseCMFViewOwnership() -> NTSTATUS;
   pub fn ZwReleaseKeyedEvent(
      KeyedEventHandle: HANDLE,
      KeyValue: PVOID,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwReleaseMutant(MutantHandle: HANDLE, PreviousCount: PLONG) -> NTSTATUS;
   pub fn ZwReleaseSemaphore(
      SemaphoreHandle: HANDLE,
      ReleaseCount: LONG,
      PreviousCount: PLONG,
   ) -> NTSTATUS;
   pub fn ZwReleaseWorkerFactoryWorker(WorkerFactoryHandle: HANDLE) -> NTSTATUS;
   pub fn ZwRemoveIoCompletion(
      IoCompletionHandle: HANDLE,
      KeyContext: *mut PVOID,
      ApcContext: *mut PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwRemoveIoCompletionEx(
      IoCompletionHandle: HANDLE,
      IoCompletionInformation: PFILE_IO_COMPLETION_INFORMATION,
      Count: ULONG,
      NumEntriesRemoved: PULONG,
      Timeout: PLARGE_INTEGER,
      Alertable: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwRemoveProcessDebug(ProcessHandle: HANDLE, DebugObjectHandle: HANDLE) -> NTSTATUS;
   pub fn ZwRenameKey(KeyHandle: HANDLE, NewName: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwRenameTransactionManager(
      LogFileName: PUNICODE_STRING,
      ExistingTransactionManagerGuid: LPGUID,
   ) -> NTSTATUS;
   pub fn ZwReplaceKey(
      NewFile: POBJECT_ATTRIBUTES,
      TargetHandle: HANDLE,
      OldFile: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwReplacePartitionUnit(
      TargetInstancePath: PUNICODE_STRING,
      SpareInstancePath: PUNICODE_STRING,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwReplyPort(PortHandle: HANDLE, ReplyMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn ZwReplyWaitReceivePort(
      PortHandle: HANDLE,
      PortContext: *mut PVOID,
      ReplyMessage: PPORT_MESSAGE,
      ReceiveMessage: PPORT_MESSAGE,
   ) -> NTSTATUS;
   pub fn ZwReplyWaitReceivePortEx(
      PortHandle: HANDLE,
      PortContext: *mut PVOID,
      ReplyMessage: PPORT_MESSAGE,
      ReceiveMessage: PPORT_MESSAGE,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwReplyWaitReplyPort(PortHandle: HANDLE, ReplyMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn ZwRequestPort(PortHandle: HANDLE, RequestMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn ZwRequestWaitReplyPort(
      PortHandle: HANDLE,
      RequestMessage: PPORT_MESSAGE,
      ReplyMessage: PPORT_MESSAGE,
   ) -> NTSTATUS;
   pub fn ZwRequestWakeupLatency(latency: LATENCY_TIME) -> NTSTATUS;
   pub fn ZwResetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   pub fn ZwResetWriteWatch(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      RegionSize: SIZE_T,
   ) -> NTSTATUS;
   pub fn ZwRestoreKey(KeyHandle: HANDLE, FileHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
   pub fn ZwResumeProcess(ProcessHandle: HANDLE) -> NTSTATUS;
   pub fn ZwResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   pub fn ZwRevertContainerImpersonation() -> NTSTATUS;
   pub fn ZwRollbackComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwRollbackEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwRollbackTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
   pub fn ZwRollforwardTransactionManager(
      TransactionManagerHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwSaveKey(KeyHandle: HANDLE, FileHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSaveKeyEx(KeyHandle: HANDLE, FileHandle: HANDLE, Format: ULONG) -> NTSTATUS;
   pub fn ZwSaveMergedKeys(
      HighPrecedenceKeyHandle: HANDLE,
      LowPrecedenceKeyHandle: HANDLE,
      FileHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwSecureConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
      ClientView: PPORT_VIEW,
      RequiredServerSid: PSID,
      ServerView: PREMOTE_PORT_VIEW,
      MaxMessageLength: PULONG,
      ConnectionInformation: PVOID,
      ConnectionInformationLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwSerializeBoot() -> NTSTATUS;
   pub fn ZwSetBootEntryOrder(Ids: PULONG, Count: ULONG) -> NTSTATUS;
   pub fn ZwSetBootOptions(BootOptions: PBOOT_OPTIONS, FieldsToChange: ULONG) -> NTSTATUS;
   pub fn ZwSetCachedSigningLevel(
      Flags: ULONG,
      InputSigningLevel: SE_SIGNING_LEVEL,
      SourceFiles: PHANDLE,
      SourceFileCount: ULONG,
      TargetFile: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwSetContextThread(ThreadHandle: HANDLE, ThreadContext: PCONTEXT) -> NTSTATUS;
   pub fn ZwSetDebugFilterState(ComponentId: ULONG, Level: ULONG, State: BOOLEAN) -> NTSTATUS;
   pub fn ZwSetDefaultHardErrorPort(DefaultHardErrorPort: HANDLE) -> NTSTATUS;
   pub fn ZwSetDefaultLocale(UserProfile: BOOLEAN, DefaultLocaleId: LCID) -> NTSTATUS;
   pub fn ZwSetDefaultUILanguage(DefaultUILanguageId: LANGID) -> NTSTATUS;
   pub fn ZwSetDriverEntryOrder(Ids: PULONG, Count: ULONG) -> NTSTATUS;
   pub fn ZwSetEaFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   pub fn ZwSetEventBoostPriority(EventHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSetHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSetHighWaitLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSetInformationDebugObject(
      DebugObjectHandle: HANDLE,
      DebugObjectInformationClass: DEBUGOBJECTINFOCLASS,
      DebugInformation: PVOID,
      DebugInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationEnlistment(
      EnlistmentHandle: HANDLE,
      EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
      EnlistmentInformation: PVOID,
      EnlistmentInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn ZwSetInformationIoRing(
      IoRingHandle: HANDLE,
      IoRingInformationClass: ULONG,
      IoRingInformationLength: ULONG,
      IoRingInformation: PVOID,
   ) -> NTSTATUS;
   pub fn ZwSetInformationJobObject(
      JobHandle: HANDLE,
      JobObjectInformationClass: JOBOBJECTINFOCLASS,
      JobObjectInformation: PVOID,
      JobObjectInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationKey(
      KeyHandle: HANDLE,
      KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
      KeySetInformation: PVOID,
      KeySetInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationObject(
      Handle: HANDLE,
      ObjectInformationClass: OBJECT_INFORMATION_CLASS,
      ObjectInformation: PVOID,
      ObjectInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationProcess(
      ProcessHandle: HANDLE,
      ProcessInformationClass: PROCESSINFOCLASS,
      ProcessInformation: PVOID,
      ProcessInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationResourceManager(
      ResourceManagerHandle: HANDLE,
      ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
      ResourceManagerInformation: PVOID,
      ResourceManagerInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationSymbolicLink(
      LinkHandle: HANDLE,
      SymbolicLinkInformationClass: SYMBOLIC_LINK_INFO_CLASS,
      SymbolicLinkInformation: PVOID,
      SymbolicLinkInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationThread(
      ThreadHandle: HANDLE,
      ThreadInformationClass: THREADINFOCLASS,
      ThreadInformation: PVOID,
      ThreadInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationToken(
      TokenHandle: HANDLE,
      TokenInformationClass: TOKEN_INFORMATION_CLASS,
      TokenInformation: PVOID,
      TokenInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationTransaction(
      TransactionHandle: HANDLE,
      TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
      TransactionInformation: PVOID,
      TransactionInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationTransactionManager(
      TmHandle: HANDLE,
      TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
      TransactionManagerInformation: PVOID,
      TransactionManagerInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationVirtualMemory(
      ProcessHandle: HANDLE,
      VmInformationClass: VIRTUAL_MEMORY_INFORMATION_CLASS,
      NumberOfEntries: ULONG_PTR,
      VirtualAddresses: PMEMORY_RANGE_ENTRY,
      VmInformation: PVOID,
      VmInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
      WorkerFactoryInformation: PVOID,
      WorkerFactoryInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetIntervalProfile(Interval: ULONG, Source: KPROFILE_SOURCE) -> NTSTATUS;
   pub fn ZwSetIoCompletion(
      IoCompletionHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwSetIoCompletionEx(
      IoCompletionHandle: HANDLE,
      IoCompletionPacketHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwSetIRTimer(TimerHandle: HANDLE, DueTime: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwSetLdtEntries(
      Selector0: ULONG,
      Entry0Low: ULONG,
      Entry0Hi: ULONG,
      Selector1: ULONG,
      Entry1Low: ULONG,
      Entry1Hi: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSetLowWaitHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSetQuotaInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetSecurityObject(
      Handle: HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn ZwSetSystemEnvironmentValue(
      VariableName: PUNICODE_STRING,
      VariableValue: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn ZwSetSystemEnvironmentValueEx(
      VariableName: PUNICODE_STRING,
      VendorGuid: PCGUID,
      Value: PVOID,
      ValueLength: ULONG,
      Attributes: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetSystemInformation(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetSystemPowerState(
      SystemAction: POWER_ACTION,
      LightestSystemState: SYSTEM_POWER_STATE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetSystemTime(SystemTime: PLARGE_INTEGER, PreviousTime: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwSetThreadExecutionState(
      NewFlags: EXECUTION_STATE,
      PreviousFlags: *mut EXECUTION_STATE,
   ) -> NTSTATUS;
   pub fn ZwSetTimer(
      TimerHandle: HANDLE,
      DueTime: PLARGE_INTEGER,
      TimerApcRoutine: PTIMER_APC_ROUTINE,
      TimerContext: PVOID,
      ResumeTimer: BOOLEAN,
      Period: LONG,
      PreviousState: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwSetTimer2(
      TimerHandle: HANDLE,
      DueTime: PLARGE_INTEGER,
      Period: PLARGE_INTEGER,
      Parameters: PT2_SET_PARAMETERS,
   ) -> NTSTATUS;
   pub fn ZwSetTimerEx(
      TimerHandle: HANDLE,
      TimerSetInformationClass: TIMER_SET_INFORMATION_CLASS,
      TimerSetInformation: PVOID,
      TimerSetInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetTimerResolution(
      DesiredTime: ULONG,
      SetResolution: BOOLEAN,
      ActualTime: PULONG,
   ) -> NTSTATUS;
   pub fn ZwSetUuidSeed(Seed: PCHAR) -> NTSTATUS;
   pub fn ZwSetValueKey(
      KeyHandle: HANDLE,
      ValueName: PUNICODE_STRING,
      TitleIndex: ULONG,
      Type: ULONG,
      Data: PVOID,
      DataSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetVolumeInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsInformation: PVOID,
      Length: ULONG,
      FsInformationClass: FSINFOCLASS,
   ) -> NTSTATUS;
   pub fn ZwSetWnfProcessNotificationEvent(NotificationEvent: HANDLE) -> NTSTATUS;
   pub fn ZwShutdownSystem(Action: SHUTDOWN_ACTION) -> NTSTATUS;
   pub fn ZwShutdownWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      PendingWorkerCount: *mut LONG,
   ) -> NTSTATUS;
   pub fn ZwSignalAndWaitForSingleObject(
      SignalHandle: HANDLE,
      WaitHandle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwSinglePhaseReject(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
      -> NTSTATUS;
   pub fn ZwStartProfile(ProfileHandle: HANDLE) -> NTSTATUS;
   pub fn ZwStopProfile(ProfileHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSubmitIoRing(
      IoRingHandle: HANDLE,
      Flags: ULONG,
      WaitOperations: ULONG,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwSubscribeWnfStateChange(
      StateName: PCWNF_STATE_NAME,
      ChangeStamp: WNF_CHANGE_STAMP,
      EventMask: ULONG,
      SubscriptionId: PULONG64,
   ) -> NTSTATUS;
   pub fn ZwSuspendProcess(ProcessHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSuspendThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   pub fn ZwSystemDebugControl(
      Command: SYSDBG_COMMAND,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwTerminateEnclave(BaseAddress: PVOID, Flags: ULONG) -> NTSTATUS;
   pub fn ZwTerminateJobObject(JobHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn ZwTerminateProcess(ProcessHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn ZwTerminateThread(ThreadHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn ZwTestAlert() -> NTSTATUS;
   pub fn ZwThawRegistry() -> NTSTATUS;
   pub fn ZwThawTransactions() -> NTSTATUS;
   pub fn ZwTraceControl(
      TraceControlCode: ETWTRACECONTROLCODE,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwTraceEvent(
      TraceHandle: HANDLE,
      Flags: ULONG,
      FieldSize: ULONG,
      Fields: PVOID,
   ) -> NTSTATUS;
   pub fn ZwTranslateFilePath(
      InputFilePath: PFILE_PATH,
      OutputType: ULONG,
      OutputFilePath: PFILE_PATH,
      OutputFilePathLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwUmsThreadYield(SchedulerParam: PVOID) -> NTSTATUS;
   pub fn ZwUnloadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwUnloadKey(TargetKey: POBJECT_ATTRIBUTES) -> NTSTATUS;
   pub fn ZwUnloadKey2(TargetKey: POBJECT_ATTRIBUTES, Flags: ULONG) -> NTSTATUS;
   pub fn ZwUnloadKeyEx(TargetKey: POBJECT_ATTRIBUTES, Event: HANDLE) -> NTSTATUS;
   pub fn ZwUnlockFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ByteOffset: PLARGE_INTEGER,
      Length: PLARGE_INTEGER,
      Key: ULONG,
   ) -> NTSTATUS;
   pub fn ZwUnlockVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      MapType: ULONG,
   ) -> NTSTATUS;
   pub fn ZwUnmapViewOfSection(ProcessHandle: HANDLE, BaseAddress: PVOID) -> NTSTATUS;
   pub fn ZwUnmapViewOfSectionEx(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwUnsubscribeWnfStateChange(StateName: PCWNF_STATE_NAME) -> NTSTATUS;
   pub fn ZwUpdateWnfStateData(
      StateName: PCWNF_STATE_NAME,
      Buffer: *const cty::c_void,
      Length: ULONG,
      TypeId: PCWNF_TYPE_ID,
      ExplicitScope: *const cty::c_void,
      MatchingChangeStamp: WNF_CHANGE_STAMP,
      CheckStamp: LOGICAL,
   ) -> NTSTATUS;
   pub fn ZwVdmControl(Service: VDMSERVICECLASS, ServiceData: PVOID) -> NTSTATUS;
   pub fn ZwWaitForAlertByThreadId(Address: PVOID, Timeout: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwWaitForDebugEvent(
      DebugObjectHandle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
      WaitStateChange: PDBGUI_WAIT_STATE_CHANGE,
   ) -> NTSTATUS;
   pub fn ZwWaitForKeyedEvent(
      KeyedEventHandle: HANDLE,
      KeyValue: PVOID,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwWaitForMultipleObjects(
      Count: ULONG,
      Handles: *mut HANDLE,
      WaitType: WAIT_TYPE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwWaitForMultipleObjects32(
      Count: ULONG,
      Handles: *mut LONG,
      WaitType: WAIT_TYPE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwWaitForSingleObject(
      Handle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwWaitForWorkViaWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      MiniPackets: PFILE_IO_COMPLETION_INFORMATION,
      Count: ULONG,
      PacketsReturned: PULONG,
      DeferredWork: PWORKER_FACTORY_DEFERRED_WORK,
   ) -> NTSTATUS;
   pub fn ZwWaitHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwWaitLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwWorkerFactoryWorkerReady(WorkerFactoryHandle: HANDLE) -> NTSTATUS;
   pub fn ZwWriteFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn ZwWriteFileGather(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      SegmentArray: PFILE_SEGMENT_ELEMENT,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn ZwWriteRequestData(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      DataEntryIndex: ULONG,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesWritten: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwWriteVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesWritten: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwYieldExecution() -> NTSTATUS;
}
